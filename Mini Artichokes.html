<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Branching Architecture Runner (Main/Proof/Solution + Whiteboard) ‚Äî v1.2</title>
	<script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
	<script>
		if (typeof pdfjsLib !== 'undefined') {
			pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.worker.min.js";
		}
	</script>
	<style>
		:root {
			--solver-grp: #ff4d8d;
			--red-grp: #ffb020;
			--mid-grp: #c084fc;
			--base: #93a4b5;
			--log-error: #fb7185;
			--log-success: #34d399;
			--status-success: #fbbf24;
			--status-running: #fb923c;
			--bg: #0b1020;
			--secondary-bg: #111a33;
			--border-light: #2a3558;
			--border-dark: #060914;
			--text-1: #e5e7eb;
			--text-2: #cbd5e1;
			--text-3: #94a3b8;
		}

		body {
			padding: 20px;
			display: flex;
			flex-direction: column;
			height: 100vh;
			box-sizing: border-box;
			overflow: hidden;
			font-family: "MS Sans Serif", Tahoma, sans-serif;
			background: radial-gradient(1200px 700px at 15% 15%, #16213a 0%, #070b18 60%, #050814 100%);
			color: var(--text-1);
		}

		.container {
			display: flex;
			gap: 20px;
			flex-grow: 1;
			overflow: hidden;
			min-height: 0;
		}

		.panel {
			background-color: var(--bg);
			border: 2px solid;
			border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
			padding: 15px;
			display: flex;
			flex-direction: column;
			min-height: 0;
		}

		.controls-panel {
			flex: 0 0 380px;
			overflow-y: auto;
			min-height: 0;
		}

		.comparison-panel {
			flex: 1;
			overflow: hidden;
			min-height: 0;
		}

		.form-group {
			margin-bottom: 15px;
		}

		.cs-input {
			width: 100%;
			box-sizing: border-box;
			border: 2px solid;
			border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
			padding: 4px;
			background: #0f172a;
			color: var(--text-1);
		}

		.cs-input::placeholder {
			color: var(--text-3);
		}

		textarea.cs-input {
			min-height: 80px;
			font-family: monospace;
			resize: vertical;
		}

		.button-group {
			display: flex;
			gap: 5px;
			margin-top: 10px;
			flex-wrap: wrap;
		}

		.cs-btn {
			flex-grow: 1;
			text-align: center;
			padding: 4px 8px;
			border: 2px solid;
			border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
			background: #16213a;
			color: var(--text-1);
			cursor: pointer;
		}

		.cs-btn:hover:not(:disabled) {
			filter: brightness(1.08);
		}

		.cs-btn:active {
			border-color: var(--border-dark) var(--border-light) var(--border-light) var(--border-dark);
			background: #0f172a;
		}

		.cs-btn:disabled {
			color: var(--text-3);
			cursor: default;
		}

		.arch-group {
			background: var(--secondary-bg);
			border: 1px solid var(--border-dark);
			padding: 8px;
			margin-bottom: 10px;
		}

		.arch-collapsible>summary {
			cursor: pointer;
			font-size: 12px;
			font-weight: bold;
			color: var(--text-2);
			list-style: none;
			user-select: none;
			padding: 2px 0;
		}

		.arch-collapsible>summary::-webkit-details-marker {
			display: none;
		}

		.arch-collapsible>summary::before {
			content: '‚ñ∏ ';
			color: var(--text-3);
		}

		.arch-collapsible[open]>summary::before {
			content: '‚ñæ ';
		}

		.arch-collapsible[open]>summary {
			margin-bottom: 6px;
			border-bottom: 1px solid var(--border-dark);
			padding-bottom: 4px;
		}

		.arch-group h3 {
			margin: 0 0 5px 0;
			font-size: 12px;
			text-transform: uppercase;
			border-bottom: 1px solid var(--border-dark);
			padding-bottom: 2px;
		}

		.arch-row {
			display: flex;
			align-items: center;
			font-size: 12px;
			margin-bottom: 4px;
		}

		.arch-row label {
			flex-grow: 1;
			cursor: pointer;
			margin-left: 5px;
		}

		.count-ctrl input {
			width: 30px;
			text-align: center;
			padding: 1px;
			background: #0f172a;
			color: var(--text-1);
			border: 1px solid var(--border-dark);
		}

		.arch-row input[type="checkbox"] {
			accent-color: var(--red-grp);
		}

		.comparison-results {
			flex-grow: 1;
			overflow-y: auto;
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
			gap: 15px;
			padding: 5px;
			padding-bottom: 24px;
			align-items: stretch;
			min-height: 0;
		}

		.architecture-result {
			background: var(--secondary-bg);
			padding: 10px;
			border: 2px solid;
			border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
			display: flex;
			flex-direction: column;
			height: auto !important;
			min-height: 250px;
			max-height: none !important;
			overflow: visible !important;
			position: relative;
		}

		.architecture-result[data-problem-qid] {
			border-left-width: 5px;
			border-left-style: solid;
			border-left-color: var(--problem-accent, var(--mid-grp));
		}

		.problem-badge {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			margin-bottom: 6px;
			padding: 2px 8px;
			font-size: 10px;
			font-weight: bold;
			letter-spacing: 0.4px;
			text-transform: uppercase;
			background: color-mix(in srgb, var(--problem-accent, var(--mid-grp)) 18%, #0b1228);
			color: var(--text-1);
			border: 1px solid color-mix(in srgb, var(--problem-accent, var(--mid-grp)) 45%, #243248);
			width: fit-content;
			max-width: 100%;
			overflow: hidden;
			text-overflow: ellipsis;
			white-space: nowrap;
		}

		.architecture-result,
		.architecture-result * {
			box-sizing: border-box;
		}

		.architecture-result textarea {
			padding: 6px;
			line-height: 1.35;
		}

		.architecture-result .agent-actions {
			margin-top: auto;
			padding-top: 8px;
			padding-bottom: 6px;
			flex-shrink: 0;
			justify-content: flex-end;
		}

		.architecture-result .agent-actions .cs-btn {
			flex: 0 0 auto;
		}

		.status-header {
			font-weight: bold;
			border-bottom: 2px solid;
			padding-bottom: 5px;
			margin-bottom: 5px;
			display: flex;
			justify-content: space-between;
			font-size: 13px;
		}

		.metrics {
			display: flex;
			justify-content: space-between;
			background: #0f172a;
			border: 1px solid var(--border-dark);
			padding: 5px;
			margin-bottom: 5px;
			font-size: 11px;
		}

		.agent-live-row {
			display: flex;
			gap: 10px;
			flex-wrap: wrap;
			align-items: baseline;
			background: #0b1228;
			border: 1px solid var(--border-dark);
			padding: 4px 6px;
			margin-bottom: 5px;
			font-family: monospace;
			font-size: 10px;
			color: var(--text-2);
		}

		.agent-live-row .lbl {
			color: var(--text-3);
		}

		.agent-live-row .val {
			font-weight: bold;
		}

		.metric-item span:first-child {
			color: var(--text-3);
			margin-right: 3px;
		}

		.metric-item span:last-child {
			font-weight: bold;
		}

		.log-mini {
			flex-grow: 1;
			overflow: auto;
			background: #0f172a;
			border: 1px solid var(--border-dark);
			font-family: monospace;
			font-size: 11px;
			white-space: pre-wrap;
			padding: 5px;
			word-break: break-all;
			max-height: 200px;
		}

		.benchmark-summary {
			margin-top: 6px;
			font-size: 11px;
			color: var(--text-2);
			line-height: 1.35;
			font-family: monospace;
			white-space: pre-wrap;
			word-break: break-word;
		}

		.benchmark-problem-editor {
			margin-top: 8px;
			padding: 6px;
			border: 1px solid var(--border-dark);
			background: #0f172a;
			max-height: 360px;
			overflow: auto;
		}

		.benchmark-problem-card {
			border: 1px solid var(--border-dark);
			background: #0b1228;
			border-radius: 6px;
			padding: 8px;
			margin-top: 8px;
		}

		.benchmark-problem-card summary {
			cursor: pointer;
			font-weight: 700;
		}

		.benchmark-problem-card .hint {
			margin-top: 4px;
			font-size: 11px;
			color: var(--text-3);
		}

		.benchmark-problem-card textarea {
			width: 100%;
			min-height: 70px;
			resize: vertical;
		}

		.retry-overlay {
			position: absolute;
			top: 34px;
			right: 5px;
			bottom: auto;
			background: rgba(255, 0, 0, 0.1);
			color: #fb7185;
			font-size: 10px;
			padding: 2px 5px;
			border-radius: 3px;
			z-index: 5;
			display: none;
		}

		#key-monitor-card {
			grid-column: 1 / -1;
		}

		.key-monitor-row {
			display: flex;
			gap: 6px;
			align-items: center;
			padding: 1px 0;
			margin: 0;
			line-height: 1.15;
			border-bottom: 1px dashed rgba(42, 53, 88, 0.35);
		}

		.key-monitor-row:last-child {
			border-bottom: none;
		}

		.key-monitor-dot {
			font-weight: bold;
			width: 10px;
			flex: 0 0 10px;
		}

		.key-monitor-col {
			font-family: monospace;
			font-size: 12px;
			line-height: 1.15;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.key-monitor-col.idx {
			width: 28px;
			text-align: right;
			color: var(--text-3);
		}

		.key-monitor-col.key {
			width: 90px;
		}

		.key-monitor-col.arch {
			width: 120px;
		}

		.key-monitor-col.tok {
			width: 85px;
			text-align: right;
		}

		.key-monitor-col.age {
			width: 80px;
			text-align: right;
		}

		.key-monitor-col.retry {
			width: 60px;
			text-align: right;
		}

		.key-monitor-col.status {
			flex: 1;
			min-width: 120px;
		}

		/* key monitor uses DOM rows; avoid pre-wrapping whitespace nodes */
		#key-monitor-output {
			white-space: normal;
			padding: 5px;
		}

		#main-recent-calls,
		#stats-telemetry-recent {
			white-space: pre;
			word-break: normal;
			overflow: auto;
			min-height: 0;
			line-height: 1.25;
			box-sizing: border-box;
			padding-bottom: 14px;
		}

		#jobList {
			white-space: normal;
		}

		.job-row {
			display: flex;
			gap: 8px;
			align-items: center;
			padding: 2px 0;
			border-bottom: 1px dashed rgba(42, 53, 88, 0.4);
		}

		.job-row:last-child {
			border-bottom: none;
		}

		.job-dot {
			width: 10px;
			flex: 0 0 10px;
			font-weight: bold;
		}

		.job-col {
			font-family: monospace;
			font-size: 11px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.job-col.id {
			width: 38px;
		}

		.job-col.status {
			width: 74px;
		}

		.job-col.progress {
			width: 72px;
			text-align: right;
		}

		.job-actions {
			display: flex;
			gap: 6px;
			flex: 0 0 auto;
		}

		.job-actions .cs-btn {
			font-size: 10px;
			padding: 2px 6px;
		}

		.modal-overlay {
			position: fixed;
			inset: 0;
			display: none;
			align-items: center;
			justify-content: center;
			background: rgba(0, 0, 0, 0.65);
			z-index: 9999;
		}

		.modal-window {
			width: min(1200px, 96vw);
			height: min(880px, 92vh);
			background: var(--bg);
			border: 2px solid;
			border-color: var(--border-light) var(--border-dark) var(--border-dark) var(--border-light);
			display: flex;
			flex-direction: column;
			min-height: 0;
		}

		.modal-header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px 10px;
			border-bottom: 1px solid var(--border-dark);
			background: var(--secondary-bg);
		}

		.modal-title {
			font-weight: bold;
			font-size: 13px;
		}

		.modal-tabs {
			display: flex;
			gap: 6px;
			padding: 6px 10px;
			border-bottom: 1px solid var(--border-dark);
		}

		.tab-btn {
			flex: 0 0 auto;
			padding: 4px 8px;
			border: 1px solid var(--border-dark);
			background: #0f172a;
			color: var(--text-1);
			cursor: pointer;
			font-size: 11px;
		}

		.tab-btn.active {
			border-color: var(--border-light);
			background: #16213a;
		}

		.modal-body {
			flex: 1;
			min-height: 0;
			overflow: hidden;
			padding: 10px;
		}

		.tab-panel {
			display: none;
			height: 100%;
			min-height: 0;
			overflow: hidden;
		}

		.tab-panel.active {
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.cs-table {
			width: 100%;
			border-collapse: collapse;
			font-size: 11px;
			font-family: monospace;
		}

		.cs-table th,
		.cs-table td {
			border: 1px solid var(--border-dark);
			padding: 3px 6px;
			white-space: nowrap;
		}

		.cs-table th {
			background: #0f172a;
			color: var(--text-2);
			position: sticky;
			top: 0;
			z-index: 1;
		}

		#progress-bar {
			background: var(--secondary-bg);
			padding: 8px;
			text-align: center;
			border: 1px solid var(--border-dark);
			margin-top: 10px;
			font-weight: bold;
			font-size: 12px;
			color: var(--text-2);
		}

		h1,
		h2 {
			color: var(--text-1);
		}

		.cs-input__label {
			color: var(--text-2);
		}
	</style>
</head>

<body>
	<header>
		<h1>Branching Architecture Runner (Main‚ÜíProof/Solution + Whiteboard) ‚Äî v1.2</h1>
	</header>

	<div class="container">
		<!-- CONTROLS -->
			<div class="panel controls-panel">
				<h2>Configuration</h2>
					<details id="archApiSettingsDetails" open class="form-group"
						style="margin-top:2px; background:var(--secondary-bg); border:1px solid var(--border-dark); padding:6px;">
						<summary class="cs-input__label" style="font-weight:bold; cursor:pointer;">Architecture API Settings</summary>
						<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
							Used only for architecture runs (`Run` agent execution, including benchmark mode).
						</div>

						<div class="form-group" style="margin-top:8px;">
							<label class="cs-input__label">API Keys (one per line)</label>
							<textarea id="apiKeyList" class="cs-input" placeholder="Enter keys&#10;one per line"></textarea>
						</div>
						<div class="form-group">
							<label class="cs-input__label">API URL</label>
							<input type="text" id="apiUrl" class="cs-input"
								value="https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent">
							<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
								Use `{model}` to auto-fill from the Model box. For OpenAI-compat:
								`.../v1beta/openai/chat/completions` (no `topK` support). For Cloudflare: `.../ai/v1/responses` or
								`.../ai/run/`.
							</div>
						</div>
						<div class="form-group">
							<label class="cs-input__label">Proxy URL (Cloudflare only, optional)</label>
							<input type="text" id="apiProxyUrl" class="cs-input"
								placeholder="https://your-proxy.example/forward or https://your-proxy.example/?url={url}">
							<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
								Use for CORS-blocked Cloudflare endpoints. If the URL includes `{url}`, requests are forwarded
								as-is; otherwise a JSON wrapper is sent.
							</div>
						</div>
						<div class="form-group">
							<label class="cs-input__label">Model</label>
							<input type="text" id="modelName" class="cs-input" value="gemma-3-27b-it">
						</div>

						<!-- New Options -->
						<div class="form-group">
							<label class="cs-input__label" style="cursor:pointer; display:flex; align-items:center;">
								<input type="checkbox" id="bypassSystemRole" style="margin-right:5px;">
								Bypass System Role (Merge into User)
							</label>
						</div>

						<div class="form-group">
							<label class="cs-input__label" style="cursor:pointer; display:flex; align-items:center;">
								<input type="checkbox" id="enableRateLimit" style="margin-right:5px;">
								Enable Per-Key Rate Limit
							</label>
							<div style="display:flex; gap:10px; margin-top:8px;">
								<div style="flex:1;">
									<label for="rpmLimit" class="cs-input__label">RPM (Calls/min)</label>
									<input type="number" id="rpmLimit" value="30" min="1" class="cs-input">
								</div>
								<div style="flex:1;">
									<label for="tpmLimit" class="cs-input__label">TPM (Tokens/min)</label>
									<input type="number" id="tpmLimit" value="15000" min="1" class="cs-input">
								</div>
							</div>
							<div style="margin-top:8px;">
								<label for="maxInflightPerKey" class="cs-input__label">Max inflight per key (optional)</label>
								<input type="number" id="maxInflightPerKey" min="1" class="cs-input" placeholder="auto">
								<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
									Leave blank for auto behavior. If set (e.g., 2), each key sends at most 2 concurrent requests;
									additional requests wait for a response.
								</div>
							</div>
						</div>

						<div class="form-group">
							<label class="cs-input__label" style="cursor:pointer; display:flex; align-items:center;">
								<input type="checkbox" id="expDiverseRt2Personas" style="margin-right:5px;">
								Experimental: Diverse RT2 personas (old consensus loop only)
							</label>
							<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
								Cycles intuitionist / logicist / formalist perspectives but still judges correctness, not style.
							</div>
						</div>
						<!-- End New Options -->
					</details>

			<div class="form-group">
				<label class="cs-input__label">Problems (Multi-problem runner)</label>
				<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
					Problem #1 runs in this window. Problem #2+ run in job windows when you click Run.
				</div>
				<textarea id="userQuery"
					class="cs-input">Prove that for all integers n, if n^2 is odd, then n is odd.</textarea>
				<div id="extraProblems" style="margin-top:8px;"></div>
				<div class="button-group" style="margin-top:6px;">
					<button id="addProblemBtn" class="cs-btn">‚ûï Add Problem</button>
					<button id="clearExtraProblemsBtn" class="cs-btn">üßπ Clear Extra Problems</button>
				</div>
			</div>

			<div class="form-group"
				style="margin-top:10px; background:var(--secondary-bg); border:1px solid var(--border-dark); padding:8px;">
				<label class="cs-input__label" style="font-weight:bold;">Mini Artichokes Benchmark Studio</label>
				<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
					Convert PDF/TXT/pasted text to benchmark format (API-only conversion), run benchmark batches, and grade.
					Parsing and grading use independent API settings below.
				</div>
				<div style="margin-top:8px;">
					<label class="cs-input__label" for="benchmarkSourceFile">Source file (.txt/.md/.pdf)</label>
					<input type="file" id="benchmarkSourceFile" class="cs-input"
						accept=".txt,.md,.pdf,text/plain,application/pdf" multiple>
				</div>
				<div style="margin-top:8px;">
					<label class="cs-input__label" for="benchmarkSourceText">Source text (optional)</label>
					<textarea id="benchmarkSourceText" class="cs-input"
						placeholder="Paste raw problem source text here."></textarea>
				</div>
				<div style="margin-top:8px; border:1px solid var(--border-dark); padding:8px; background:var(--bg);">
					<label class="cs-input__label" style="font-weight:bold;">Convert Chunking (delimiter)</label>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkConvertDelimiter">Chunk delimiter (optional)</label>
						<input type="text" id="benchmarkConvertDelimiter" class="cs-input" value="=\=\="
							placeholder="e.g. =\=\= or === (literal substring)">
					</div>
					<div style="margin-top:6px; font-size:11px; color:var(--text-3);">
						If provided, conversion splits on this exact substring. Token-based splitting is disabled for conversion.
					</div>
					<div style="margin-top:8px;">
						<label class="cs-input__label" for="benchmarkAnswerKeyText">Answer key (optional)</label>
						<textarea id="benchmarkAnswerKeyText" class="cs-input"
							placeholder="Paste an answer key here. This text will be appended to every conversion chunk."></textarea>
					</div>
				</div>
				<div style="margin-top:6px; font-size:11px; color:var(--text-3);">
					Conversion mode: API-only (local heuristic parsing disabled).
				</div>

				<div style="margin-top:8px; border:1px solid var(--border-dark); padding:8px; background:var(--bg);">
					<label class="cs-input__label" style="font-weight:bold;">Parsing API Settings (Benchmark Conversion)</label>
					<div style="margin-top:4px;">
						<label class="cs-input__label" for="benchmarkParseApiKeyList">API Keys (one per line)</label>
						<textarea id="benchmarkParseApiKeyList" class="cs-input" placeholder="Enter keys&#10;one per line"></textarea>
					</div>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkParseApiUrl">API URL</label>
						<input type="text" id="benchmarkParseApiUrl" class="cs-input"
							value="https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent">
					</div>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkParseApiProxyUrl">Proxy URL (optional)</label>
						<input type="text" id="benchmarkParseApiProxyUrl" class="cs-input"
							placeholder="https://your-proxy.example/forward or https://your-proxy.example/?url={url}">
					</div>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkParseModelName">Model</label>
						<input type="text" id="benchmarkParseModelName" class="cs-input" value="gemma-3-27b-it">
					</div>
					<div style="margin-top:6px; font-size:11px;">
						<label style="cursor:pointer; display:flex; align-items:center; gap:6px;">
							<input type="checkbox" id="benchmarkParseBypassSystemRole">
							Bypass System Role (merge into user)
						</label>
					</div>
					<div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; margin-top:8px;">
						<div>
							<label class="cs-input__label" for="benchmarkParseRpmLimit">RPM (parse)</label>
							<input type="number" id="benchmarkParseRpmLimit" class="cs-input" value="30" min="0" max="100000">
						</div>
						<div>
							<label class="cs-input__label" for="benchmarkParseTpmLimit">TPM (parse)</label>
							<input type="number" id="benchmarkParseTpmLimit" class="cs-input" value="15000" min="0" max="100000000">
						</div>
						<div>
							<label class="cs-input__label" for="benchmarkParseMaxInflightPerKey">Max inflight/key (parse)</label>
							<input type="number" id="benchmarkParseMaxInflightPerKey" class="cs-input" placeholder="auto" min="0" max="9999">
						</div>
					</div>
				</div>

					<div style="margin-top:8px; border:1px solid var(--border-dark); padding:8px; background:var(--bg);">
						<label class="cs-input__label" style="font-weight:bold;">Grading API Settings</label>
					<div style="margin-top:4px;">
						<label class="cs-input__label" for="benchmarkGradeApiKeyList">API Keys (one per line)</label>
						<textarea id="benchmarkGradeApiKeyList" class="cs-input" placeholder="Enter keys&#10;one per line"></textarea>
					</div>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkGradeApiUrl">API URL</label>
						<input type="text" id="benchmarkGradeApiUrl" class="cs-input"
							value="https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent">
					</div>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkGradeApiProxyUrl">Proxy URL (optional)</label>
						<input type="text" id="benchmarkGradeApiProxyUrl" class="cs-input"
							placeholder="https://your-proxy.example/forward or https://your-proxy.example/?url={url}">
					</div>
					<div style="margin-top:6px;">
						<label class="cs-input__label" for="benchmarkGradeModelName">Model</label>
						<input type="text" id="benchmarkGradeModelName" class="cs-input" value="gemma-3-27b-it">
					</div>
					<div style="margin-top:6px; font-size:11px;">
						<label style="cursor:pointer; display:flex; align-items:center; gap:6px;">
							<input type="checkbox" id="benchmarkGradeBypassSystemRole">
							Bypass System Role (merge into user)
							</label>
						</div>
						<div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:8px; margin-top:8px;">
							<div>
								<label class="cs-input__label" for="benchmarkGradeRpmLimit">RPM (grade)</label>
								<input type="number" id="benchmarkGradeRpmLimit" class="cs-input" value="30" min="0" max="100000">
							</div>
							<div>
								<label class="cs-input__label" for="benchmarkGradeTpmLimit">TPM (grade)</label>
								<input type="number" id="benchmarkGradeTpmLimit" class="cs-input" value="15000" min="0" max="100000000">
							</div>
							<div>
								<label class="cs-input__label" for="benchmarkGradeMaxInflightPerKey">Max inflight/key (grade)</label>
								<input type="number" id="benchmarkGradeMaxInflightPerKey" class="cs-input" placeholder="auto" min="0" max="9999">
							</div>
						</div>
					</div>
					<div style="margin-top:8px; border:1px solid var(--border-dark); padding:8px; background:var(--bg);">
						<label class="cs-input__label" style="font-weight:bold;">Token Budgets (gpt-tokenizer)</label>
						<div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-top:6px;">
							<div>
								<label class="cs-input__label" for="benchmarkParseSplitTokens">Convert split tokens (unused)</label>
								<input type="number" id="benchmarkParseSplitTokens" class="cs-input" value="12000" min="500" max="200000">
							</div>
								<div>
									<label class="cs-input__label" for="benchmarkParseMergeTokens">Convert merge tokens (unused)</label>
									<input type="number" id="benchmarkParseMergeTokens" class="cs-input" value="12000" min="500" max="200000">
								</div>
							<div>
								<label class="cs-input__label" for="benchmarkGradeSplitTokens">Grade split tokens</label>
								<input type="number" id="benchmarkGradeSplitTokens" class="cs-input" value="12000" min="500" max="200000">
							</div>
							<div>
								<label class="cs-input__label" for="benchmarkGradeMergeTokens">Grade merge tokens</label>
								<input type="number" id="benchmarkGradeMergeTokens" class="cs-input" value="12000" min="500" max="200000">
							</div>
						</div>
						<div style="margin-top:6px; font-size:11px; color:var(--text-3);">
							Convert splitting uses the delimiter above; token-based splitting is ignored for conversion.
							<br>
							Splitting and merge budgets are counted with <code>gpt-tokenizer (o200k_base)</code>. The tokenizer is lazy-loaded.
						</div>
					</div>
				<div id="benchmarkConvertApiCounter" class="benchmark-summary" style="margin-top:8px;">Convert API calls: total=0 | success=0 | error=0 | running=0</div>
				<div class="button-group" style="margin-top:6px;">
					<button id="benchmarkNewBtn" class="cs-btn">üÜï New Manual Benchmark</button>
					<button id="benchmarkConvertBtn" class="cs-btn">üß™ Convert Source ‚Üí Benchmark</button>
					<button id="benchmarkConvertStopBtn" class="cs-btn">‚èπ Stop Convert</button>
					<button id="benchmarkConvertResumeBtn" class="cs-btn">‚ñ∂ Resume Convert</button>
					<button id="benchmarkLoadJsonBtn" class="cs-btn">üìÇ Load Benchmark JSON/XML/Artifacts</button>
				<button id="benchmarkDownloadBtn" class="cs-btn">üíæ Download Benchmark JSON</button>
				<input type="file" id="benchmarkJsonInput" style="display:none" accept=".json,.xml,application/json,text/xml,application/xml">
			</div>
				<div style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
					<label for="benchmarkGradeMode" class="cs-input__label" style="margin:0;">Grading mode</label>
					<select id="benchmarkGradeMode" class="cs-input" style="width:250px;">
						<option value="answer_only">Answer only (official_answer)</option>
						<option value="answer_and_solution">Answer + solution (official_answer + official_explanation)</option>
					</select>
				</div>
					<div style="margin-top:6px; font-size:11px;">
						<label style="cursor:pointer; display:flex; align-items:center; gap:6px;">
							<input type="checkbox" id="benchmarkRunFilterEnabled">
							Run only problems matching filter
						</label>
						<div style="margin-top:4px; color:var(--text-3);">
							Use the ‚ÄúFilter by QID / text‚Äù box below. Supports text search and explicit numbers/ranges
							(e.g. <code>1</code>, <code>1,3-5</code>, <code>problem 8</code>).
						</div>
						<div style="margin-top:6px;">
							<button id="benchmarkRunFilteredBtn" class="cs-btn">‚ñ∂ Run Filtered Problems</button>
						</div>
					</div>
				<div style="margin-top:6px; font-size:11px; color:var(--text-3);">
					After <code>Apply Benchmark Problems</code>, use the main <code>Run</code> button. Benchmark runs use
					<code>Global count</code> and per-architecture counts from the architecture selector.
				</div>
				<div style="margin-top:6px; font-size:11px;">
					<label style="cursor:pointer; display:flex; align-items:center; gap:6px;">
						<input type="checkbox" id="benchmarkAutoGrade" checked>
						Auto-grade after each run
					</label>
				</div>
						<div id="benchmarkGradeApiCounter" class="benchmark-summary" style="margin-top:8px;">Grade API calls: total=0 | success=0 | error=0 | running=0</div>
							<div class="button-group" style="margin-top:6px;">
								<button id="benchmarkApplyBtn" class="cs-btn">üß© Apply Benchmark Problems</button>
								<button id="benchmarkGradeBtn" class="cs-btn">‚úÖ Grade Current Results</button>
								<button id="benchmarkRegradeBtn" class="cs-btn">‚ôªÔ∏è Regrade All</button>
								<button id="benchmarkGradeStopBtn" class="cs-btn">‚èπ Stop Grade</button>
								<button id="benchmarkGradeResumeBtn" class="cs-btn">‚ñ∂ Resume Grade</button>
								<button id="benchmarkGradeCopyBtn" class="cs-btn">üìã Copy Grade Report</button>
								<button id="benchmarkResultCopyBtn" class="cs-btn">üìã Copy Benchmark Results</button>
								<button id="benchmarkLogClearBtn" class="cs-btn">üßπ Clear Benchmark Log</button>
							</div>
						<div id="benchmarkSummary" class="benchmark-summary">No benchmark loaded.</div>
						<div style="margin-top:8px;">
								<label class="cs-input__label" style="font-weight:bold;">Benchmark Problems</label>
								<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
									Edits here are saved into the loaded benchmark dataset. Official answer/explanation are used for grading.
								</div>
									<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px;">
										<input type="text" id="benchmarkProblemFilter" class="cs-input" style="width:280px;"
											placeholder="Filter by text OR numbers/ranges (e.g., 8, 1,3-5, AMC12-2023-7, parabola)">
									<button id="benchmarkProblemAddBtn" class="cs-btn">‚ûï Add Problem</button>
									<button id="benchmarkProblemRefreshBtn" class="cs-btn">üîÑ Refresh</button>
									<button id="benchmarkProblemCollapseAllBtn" class="cs-btn">‚ñæ Collapse all</button>
									<button id="benchmarkProblemExpandAllBtn" class="cs-btn">‚ñ∏ Expand all</button>
								</div>
							<div id="benchmarkProblemEditor" class="benchmark-problem-editor">No benchmark loaded.</div>
						</div>
						<div id="benchmarkGradeOutput" class="log-mini" style="margin-top:8px; max-height:220px;">No grading results yet.</div>
					<div style="margin-top:8px;">
						<label class="cs-input__label" style="font-weight:bold;">Benchmark API Monitor</label>
						<div id="benchmarkProgress" class="benchmark-summary" style="margin-top:4px;">Idle</div>
						<div id="benchmarkLogOutput" class="log-mini" style="margin-top:6px; max-height:260px; white-space:pre-wrap;">No benchmark logs yet.</div>
					</div>
					<div style="margin-top:8px;">
						<label class="cs-input__label" style="font-weight:bold;">Benchmark Raw API I/O</label>
						<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:4px;">
							<select id="benchmarkIoCallSelect" class="cs-input" style="min-width:320px; max-width:100%;">
								<option value="">No API calls captured</option>
							</select>
							<button id="benchmarkIoRefreshBtn" class="cs-btn">üîÑ Refresh I/O View</button>
							<button id="benchmarkIoClearBtn" class="cs-btn">üßπ Clear Raw I/O</button>
							<button id="benchmarkArtifactsDownloadBtn" class="cs-btn">üì¶ Download Benchmark Artifacts</button>
						</div>
						<div style="margin-top:6px;">
							<label class="cs-input__label" for="benchmarkRawIoView">Request ‚Üí Response (sequential)</label>
							<textarea id="benchmarkRawIoView" class="cs-input" readonly
								placeholder="API request/response logs will appear here in call order."></textarea>
						</div>
					</div>
				</div>

			<div class="form-group">
				<label class="cs-input__label">Global count (per selected architecture)</label>
				<input type="number" id="globalArchCount" value="1" min="1" max="999" class="cs-input">
				<div style="margin-top:4px; font-size:11px; color:var(--text-3);">
					If an architecture's count is left at 1 (default), this value is used. Otherwise, the
					per-architecture count wins.
				</div>
			</div>

			<div id="archSelector"></div>

			<div class="form-group"
				style="margin-top:10px; background:var(--secondary-bg); border:1px solid var(--border-dark); padding:5px;">
				<input type="checkbox" id="mockModeChk">
				<label for="mockModeChk" style="cursor:pointer; font-weight:bold;">Enable Mock Mode (Dummy API)</label>
			</div>

			<div id="progress-bar">Ready</div>

			<div id="jobsPanel" class="form-group"
				style="margin-top:10px; background:var(--secondary-bg); border:1px solid var(--border-dark); padding:8px;">
				<div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
					<div style="font-weight:bold;">Jobs</div>
					<div id="jobsSummary" style="font-size:10px; color:var(--text-3); font-family:monospace;">0 running
						‚Ä¢ 0 queued</div>
				</div>
				<div style="margin-top:4px; font-size:10px; color:var(--text-3);">
					New Job opens in a separate window/tab. If nothing appears, allow popups and click "Open" in the
					list.
				</div>
					<div class="button-group" style="margin-top:6px;">
						<button id="jobRunNowBtn" class="cs-btn">ü™ü Open Job (Auto-start)</button>
						<button id="jobQueueBtn" class="cs-btn">‚è∏ Open Job (Paused)</button>
						<button id="jobBlankBenchmarkBtn" class="cs-btn">üß™ Open Blank Job (Benchmark)</button>
						<button id="jobQueueToggleBtn" class="cs-btn">‚ñ∂ Run Queue</button>
					</div>
				<div style="display:flex; gap:10px; align-items:center; margin-top:6px;">
					<label for="jobMaxConcurrent" style="font-size:11px; color:var(--text-3);">Max concurrent
						jobs</label>
					<input type="number" id="jobMaxConcurrent" value="1" min="1" class="cs-input" style="width:90px;">
				</div>
				<div class="log-mini" id="jobList" style="max-height:180px;"></div>
			</div>

			<div class="button-group">
				<button id="runBtn" class="cs-btn">Run / Resume</button>
				<button id="spawnMoreBtn" class="cs-btn" title="Create additional agents to match per-architecture counts (does not delete existing).">‚ûï Spawn More</button>
				<button id="stopBtn" class="cs-btn" disabled>Stop</button>
			</div>
			<div class="button-group">
				<button id="runAllBtn" class="cs-btn">Run / Resume (All windows)</button>
				<button id="stopAllBtn" class="cs-btn">Stop (All windows)</button>
			</div>

				<div class="button-group">
					<button id="exportBtn" class="cs-btn">üíæ Save State</button>
					<button id="importBtn" class="cs-btn">üìÇ Load State</button>
					<button id="importAsJobBtn" class="cs-btn">ü™ü Open State as Job</button>
					<button id="summaryBtn" class="cs-btn" onclick="showFinalSummary()">üìë View All Results</button>
					<button id="statsBtn" class="cs-btn">üìä Stats</button>
					<button id="logsBtn" class="cs-btn">üßæ Logs</button>
					<input type="file" id="fileInput" style="display:none" accept=".json,.xml,.bin,.chunk,.part,application/json,text/xml,application/xml,application/octet-stream" multiple>
					<input type="file" id="fileInputAsJob" style="display:none" accept=".json,.xml,application/json,text/xml,application/xml">
					<button id="keepSelectedBtn" class="cs-btn">üßπ Keep Selected</button>
					<button id="clearBtn" class="cs-btn">üóë Clear</button>
				</div>
		</div>

		<!-- RESULTS -->
		<div class="panel comparison-panel">
			<h2>Results</h2>
			<div class="comparison-results" id="resultsArea"></div>
		</div>
	</div>

	<script>
		// --- CONSTANTS & DEFINITIONS ---
		const ARCH_DEFINITIONS = [
			{ id: 'pass@1', group: 'Baseline', name: 'pass@1 (Single-shot answer; no verification)', who: 'solver', accRun: false, accCross: false, special: 'pass@1' },
			{
				id: 'system-1.2',
				group: 'System',
				name: 'system 1.2 (Checklist-based RT2 + validated artifacts + quorum memory + WM TTL)',
				who: 'mid',
				accRun: true,
				accCross: true,
				rtLogic: 'old',
				whiteboard: true,
				special: 'system-1.2',
			},
			{
				id: 'test37',
				group: 'Experimental',
				name: 'test37 (ICR Contextual Mode: main+iterative+memory agents)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test37',
			},
			{
				id: 'test43',
				group: 'Experimental',
				name: 'test43 (test41 variant; passStreak=3; redteam-budget 30; max 10 rounds)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43',
			},
			{
				id: 'test43-1',
				group: 'Experimental',
				name: 'test43-1 (test43 + graded eval + Good checkpoint)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-1',
			},
			{
				id: 'test43-2',
				group: 'Experimental',
				name: 'Mini Artichokes (test43-2: overlap diagnosis + flaw validation)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2',
			},
			// --- Round-capped Mini Artichokes baselines (per-round call cap; abort round and continue) ---
			{
				id: 'test43-2-rcap25',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; rcap25)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-rcap25',
			},
			{
				id: 'test43-2-rcap30',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; rcap30)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-rcap30',
			},
				{
					id: 'test43-2-rcap35',
					group: 'Mini Artichokes (Round-Capped)',
					name: 'Mini Artichokes',
					who: 'red',
					accRun: false,
					accCross: false,
					fullText: true,
					special: 'test43-2-rcap35',
				},
			{
				id: 'test43-2-rcap40',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; rcap40)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-rcap40',
			},
			{
				id: 'test43-2-rcap45',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; rcap45)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-rcap45',
			},
			{
				id: 'test43-2-rcap60',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; rcap60)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-rcap60',
			},
			{
				id: 'test43-2-cap200-rcap35',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; cap200; rcap35)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-cap200-rcap35',
			},
			{
				id: 'test43-2-cap200-rcap40',
				group: 'Mini Artichokes (Round-Capped)',
				name: 'Mini Artichokes (test43-2; cap200; rcap40)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-cap200-rcap40',
			},
			{
				id: 'adaptive-method3-overlap',
				group: 'Proposed',
				name: 'Adaptive-Method3-Overlap (route reading ‚Üí test37; else method3 + overlap + ans2)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'adaptive-method3-overlap',
			},
			{
				id: 'b-move',
				group: 'Proposed',
				name: 'B-MOVE (budgeted: route reading ‚Üí test37; else method3 + seed37 + anti-runaway caps)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'b-move',
			},
			// --- Experiment Pack („Ñ±): budgeted, general knobs (no per-problem hacks) ---
			{
				id: 'exp-g1-hg-lite',
				group: 'Experiment Pack („Ñ±)',
				name: 'HG-lite (test43-2hg; cap120; m4/r10; ps2/fs6; ih120; corr0)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-m4-r10-corr0-cap120-ps2-fs6-ih120',
			},
			{
				id: 'exp-g2-hg-std',
				group: 'Experiment Pack („Ñ±)',
				name: 'HG-std (test43-2hg; cap200; m6/r15; ps3/fs10; ih200; corr1; ans2+quietpass)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-m6-r15-corr1-cap200-ps3-fs10-ih200-ans2-quietpass',
			},
			{
				id: 'exp-g3-hg-nomem',
				group: 'Experiment Pack („Ñ±)',
				name: 'HG-nomem (test43-2hg; cap120; m4/r10; ps2/fs6; ih120; corr0; nomem)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-nomem-m4-r10-corr0-cap120-ps2-fs6-ih120',
			},
			{
				id: 'exp-g4-hg-sc3',
				group: 'Experiment Pack („Ñ±)',
				name: 'HG-sc3 (test43-2hg; cap160; m4/r10; ps2/fs6; ih200; corr0; sc3)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-sc3-m4-r10-corr0-cap160-ps2-fs6-ih200',
			},
			{
				id: 'exp-g5-hg-method3',
				group: 'Experiment Pack („Ñ±)',
				name: 'HG-method3 (test43-2hg; cap180; m4/r10; ps2/fs6; ih200; corr0; method3; ans2)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-method3-m4-r10-corr0-cap180-ps2-fs6-ih200-ans2',
			},
			{
				id: 'exp-g6-hg-method3-vsdiag',
				group: 'Experiment Pack („Ñ±)',
				name: 'HG-method3+vsdiag5 (test43-2hg; cap200; m4/r10; ps2/fs6; ih200; corr0; method3; vsdiag5; ans2)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-method3-vsdiag5-m4-r10-corr0-cap200-ps2-fs6-ih200-ans2',
			},
			{
				id: 'exp-g7-dehg-method3',
				group: 'Experiment Pack („Ñ±)',
				name: 'DEHG-method3 (test43-2dehg; cap200; m4/r10; ps2/fs6; ih200; corr0; method3; ans2)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dehg-method3-m4-r10-corr0-cap200-ps2-fs6-ih200-ans2',
			},
				{
					id: 'exp-g8-dehg-method3-vsdiag',
					group: 'Experiment Pack („Ñ±)',
					name: 'DEHG-method3+vsdiag5 (test43-2dehg; cap240; m4/r10; ps2/fs8; ih300; corr0; method3; vsdiag5; ans2)',
					who: 'red',
					accRun: false,
					accCross: false,
					fullText: true,
					special: 'test43-2dehg-method3-vsdiag5-m4-r10-corr0-cap240-ps2-fs8-ih300-ans2',
				},
				// --- Round-Capped Baselines: per-round call-cap baselines (rcap) ---
				{
					id: 'exp-r1-hg-std-rcap35',
					group: 'Round-Capped Baselines',
					name: 'HG-std + rcap35 (test43-2hg; cap5000; m20/r30; ps3/fs10; ih200; corr1; ans2+quietpass; rcap35)',
					who: 'red',
					accRun: false,
					accCross: false,
					fullText: true,
					special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35',
				},
				{
					id: 'exp-r2-hg-sc3-rcap35',
					group: 'Round-Capped Baselines',
					name: 'HG-sc3 + rcap35 (test43-2hg; sc3; cap5000; m20/r30; ps2/fs6; ih200; corr0; ans2; rcap35)',
					who: 'red',
					accRun: false,
					accCross: false,
					fullText: true,
					special: 'test43-2hg-sc3-m20-r30-corr0-cap5000-ps2-fs6-ih200-ans2-rcap35',
				},
					{
						id: 'exp-r3-dehg-method3-vsdiag-rcap45',
						group: 'Round-Capped Baselines',
						name: 'DEHG-method3+vsdiag5 + rcap45 (test43-2dehg; method3; vsdiag5; cap5000; m20/r30; ps2/fs8; ih300; corr0; ans2; rcap45)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45',
					},
					// --- Round-Capped Lab: combine stability + escape + truncation knobs ---
					{
						id: 'lab-r1-hg-std-pass2',
						group: 'Round-Capped Lab',
						name: 'HG-std + pass2 (rcap35; pass2; cap5000; m20/r30; ps3/fs10; ih200; corr1; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-rcap35-pass2',
					},
					{
						id: 'lab-r2-hg-std-autoban',
						group: 'Round-Capped Lab',
						name: 'HG-std + autoban3+coolban2 (rcap35; autoban3; coolban2; cap5000; m20/r30; ps3/fs10; ih200; corr1; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-rcap35-autoban3-coolban2',
					},
					{
						id: 'lab-r3-hg-std-pass2-autoban-bugcaps',
						group: 'Round-Capped Lab',
						name: 'HG-std + pass2 + autoban3 (rcap35; pass2; autoban3; coolban2; bugcap2500; memcap2500; cap5000; m20/r30; ps3/fs10; ih200; corr1; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-rcap35-pass2-autoban3-coolban2-bugcap2500-memcap2500',
					},
					{
						id: 'lab-r4-hg-sc3-pass2-autoban-bugcaps',
						group: 'Round-Capped Lab',
						name: 'HG-sc3 + pass2 + autoban3 (rcap35; pass2; autoban3; coolban2; bugcap2500; memcap2500; cap5000; m20/r30; ps2/fs6; ih200; corr0; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2hg-sc3-m20-r30-corr0-cap5000-ps2-fs6-ih200-ans2-rcap35-pass2-autoban3-coolban2-bugcap2500-memcap2500',
					},
					{
						id: 'lab-r5-dehg-method3-vsdiag-pass2-autoban-bugcaps',
						group: 'Round-Capped Lab',
						name: 'DEHG-method3+vsdiag5 + pass2 + autoban3 (rcap45; pass2; autoban3; coolban2; bugcap2500; memcap2500; cap5000; m20/r30; ps2/fs8; ih300; corr0; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-pass2-autoban3-coolban2-bugcap2500-memcap2500',
					},
					{
						id: 'lab-r6-dehg-method3-vsdiag-pass2-autoban-bugcaps-tcap',
						group: 'Round-Capped Lab',
						name: 'DEHG-method3+vsdiag5 + pass2 + autoban3 + tcap250000 (rcap45; tcap250000; pass2; autoban3; coolban2; bugcap2500; memcap2500; cap5000; m30/r30; ps2/fs8; ih300; corr0; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2dehg-method3-vsdiag5-m30-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-tcap250000-pass2-autoban3-coolban2-bugcap2500-memcap2500',
					},
					{
						id: 'lab-r7-hg-std-pass2-tcap',
						group: 'Round-Capped Lab',
						name: 'HG-std + pass2 + tcap250000 (rcap35; tcap250000; pass2; bugcap2500; memcap2500; cap5000; m30/r30; ps3/fs10; ih200; corr1; ans2)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43-2hg-m30-r30-corr1-cap5000-ps3-fs10-ih200-ans2-rcap35-tcap250000-pass2-bugcap2500-memcap2500',
					},
						{
							id: 'lab-r8-hg-sc3-pass2-tcap',
							group: 'Round-Capped Lab',
							name: 'HG-sc3 + pass2 + tcap250000 (rcap35; tcap250000; pass2; bugcap2500; memcap2500; cap5000; m30/r30; ps2/fs6; ih200; corr0; ans2)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-sc3-m30-r30-corr0-cap5000-ps2-fs6-ih200-ans2-rcap35-tcap250000-pass2-bugcap2500-memcap2500',
						},
						// --- Combo Lab (v1): systematic sweeps on top of 43-2 (goal: general, not per-problem hacks) ---
						// Baseline for this grid is exp-r1-hg-std-rcap35; we sweep rcap/tcap and add one idea at a time.
						{
							id: 'combo-v1-hg-std-rcap25',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 (baseline sweep; cap5000; m20/r30; ps3/fs10; ih200; corr1; ans2+quietpass; rcap25)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25',
						},
						{
							id: 'combo-v1-hg-std-rcap25-tcap150k',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + tcap150000 (adds per-round token cap)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-tcap150000',
						},
						{
							id: 'combo-v1-hg-std-rcap25-pass2',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + pass2 (double-check verifier on success)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-pass2',
						},
						{
							id: 'combo-v1-hg-std-rcap25-autoban',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + autoban3+coolban2 (escape repeated wrong answers)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-autoban3-coolban2',
						},
						{
							id: 'combo-v1-hg-std-rcap25-bugcaps',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + bugcap2500+memcap2500 (keep prompts small during correction)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-bugcap2500-memcap2500',
						},
						{
							id: 'combo-v1-hg-std-rcap25-vsdiag5',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + vsdiag5 (Verbalized Sampling overlap diagnoses k=5)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-vsdiag5',
						},
						{
							id: 'combo-v1-hg-std-rcap25-method3',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + method3 (multi-method init; tail sampling)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-method3',
						},
						{
							id: 'combo-v1-hg-std-rcap25-sc3',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + sc3 (self-consistency init k=3)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-sc3',
						},
						{
							id: 'combo-v1-hg-std-rcap25-pacore4',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + pacore4 (parallel init trajectories k=4)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-pacore4',
						},
						{
							id: 'combo-v1-hg-std-rcap25-vsdiag5-method3',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + vsdiag5 + method3 (2-idea combo)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-vsdiag5-method3',
						},
						{
							id: 'combo-v1-hg-std-rcap25-vsdiag5-method3-autoban',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 + vsdiag5 + method3 + autoban3 (escape + diversity)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap25-vsdiag5-method3-autoban3-coolban2',
						},
						{
							id: 'combo-v1-hg-std-rcap25-kitchensink-lite',
							group: 'Combo Lab (v1)',
							name: 'HG-std + rcap25 (vsdiag5+method3+sc3+pacore4+autoban3+pass2+tcap150k+bugcaps)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2hg-m30-r30-corr1-cap5000-ps2-fs6-ih200-ans2-quietpass-rcap25-tcap150000-pass2-autoban3-coolban2-bugcap2500-memcap2500-vsdiag5-method3-sc3-pacore4',
						},
						// DEHG family (harder problems): start from method3+vsdiag5 baseline and add caps/escape.
						{
							id: 'combo-v1-dehg-m3-vsdiag-rcap35',
							group: 'Combo Lab (v1)',
							name: 'DEHG method3+vsdiag5 + rcap35 (cap5000; m20/r30; ps2/fs8; ih300; corr0; ans2)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap35',
						},
						{
							id: 'combo-v1-dehg-m3-vsdiag-rcap35-pass2-autoban-bugcaps-tcap',
							group: 'Combo Lab (v1)',
							name: 'DEHG method3+vsdiag5 + rcap35 (pass2+autoban3+bugcaps+tcap200k)',
							who: 'red',
							accRun: false,
							accCross: false,
							fullText: true,
							special: 'test43-2dehg-method3-vsdiag5-m30-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap35-tcap200000-pass2-autoban3-coolban2-bugcap2500-memcap2500',
						},
							{
								id: 'combo-v1-dehg-m3-vsdiag-rcap35-pacore4',
								group: 'Combo Lab (v1)',
								name: 'DEHG method3+vsdiag5 + rcap35 + pacore4 (parallel init)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap35-pacore4',
							},
							// --- SoT/VS Lab (v1): Society-of-Thought + Verbalized Sampling sweeps ---
							{
								id: 'sotvs-v1-hg-baseline',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std baseline (exp-r1; rcap35; ans2+quietpass)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35',
							},
							{
								id: 'sotvs-v1-hg-baseline-markers',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + markers (discourse markers: Wait/But self-check)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-markers',
							},
							{
								id: 'sotvs-v1-hg-baseline-optgrid',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + optgrid (optimization guard: endpoints/critical points/proof)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-optgrid',
							},
							{
								id: 'sotvs-v1-hg-baseline-refute3',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + refute3 (success refutation gate; validate critiques)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-refute3',
							},
							{
								id: 'sotvs-v1-hg-baseline-refute3-vstune20',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + refute3 + vstune20 (tail critiques encouraged)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-refute3-vstune20',
							},
							{
								id: 'sotvs-v1-hg-baseline-refute3-vstune20hard',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + refute3 + vstune20hard (hard tail critiques)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-refute3-vstune20-vstunehard',
							},
							{
								id: 'sotvs-v1-hg-vssc5-vstune20-vsdiv',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + vssc5 + vstune20 + vsdiv (VS init candidates; diversity pick)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-vssc5-vstune20-vsdiv',
							},
							{
								id: 'sotvs-v1-hg-mcts5-vstune20',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + mcts5 + vstune20 (verifier-vote init; tuned sampling)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-mcts5-vstune20',
							},
							{
								id: 'sotvs-v1-hg-valuepick5-vstune20',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + valuepick5 + vstune20 (value-net pick among VS candidates)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-valuepick5-vstune20',
							},
							{
								id: 'sotvs-v1-hg-method3-vstune20',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + method3 + vstune20 (tail methodologies encouraged)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-method3-vstune20',
							},
							{
								id: 'sotvs-v1-hg-method3-vstune20-vsdiv',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + method3 + vstune20 + vsdiv (diversity pick within winning token)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-method3-vstune20-vsdiv',
							},
							{
								id: 'sotvs-v1-hg-method3-vstune20-refute3',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + method3 + vstune20 + refute3 (init diversity + success refute)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-method3-vstune20-refute3',
							},
							{
								id: 'sotvs-v1-hg-sot3',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 (SoT council init k=3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3',
							},
							{
								id: 'sotvs-v1-hg-sot3-lite',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 + sotlite (shorter SoT drafts)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3-sotlite',
							},
							{
								id: 'sotvs-v1-hg-sot3-crit',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 + sotcrit (SoT conflict audit)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3-sotcrit',
							},
							{
								id: 'sotvs-v1-hg-sot3-markers',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 + markers (SoT + discourse markers)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3-markers',
							},
							{
								id: 'sotvs-v1-hg-sot3-method3-vstune20',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 + method3 + vstune20 (SoT uses top methodology as hint)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3-method3-vstune20',
							},
							{
								id: 'sotvs-v1-hg-sot3-sotcorr',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 + sotcorr (SoT correction instead of ICR correct)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3-sotcorr',
							},
							{
								id: 'sotvs-v1-hg-sot3-sotcorr-markers',
								group: 'SoT/VS Lab (v1)',
								name: 'HG-std + sot3 + sotcorr + markers (SoT correction + discourse markers)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-sot3-sotcorr-markers',
							},
							{
								id: 'sotvs-v1-dehg-baseline',
								group: 'SoT/VS Lab (v1)',
								name: 'DEHG baseline (exp-r3; method3+vsdiag5; rcap45)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45',
							},
							{
								id: 'sotvs-v1-dehg-baseline-sot3',
								group: 'SoT/VS Lab (v1)',
								name: 'DEHG + sot3 (SoT init on hard setting)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-sot3',
							},
							{
								id: 'sotvs-v1-dehg-baseline-sot3-markers',
								group: 'SoT/VS Lab (v1)',
								name: 'DEHG + sot3 + markers (SoT + discourse markers)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-sot3-markers',
							},
							{
								id: 'sotvs-v1-dehg-baseline-sot3-sotcorr',
								group: 'SoT/VS Lab (v1)',
								name: 'DEHG + sot3 + sotcorr (SoT correction on hard setting)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-sot3-sotcorr',
							},
							{
								id: 'sotvs-v1-dehg-method3-vstune20-vsdiv',
								group: 'SoT/VS Lab (v1)',
								name: 'DEHG + method3 + vstune20 + vsdiv (diversity pick; tuned methodologies)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-vstune20-vsdiv',
							},
							// --- RSA Lab (v1): Recursive Self-Aggregation sweeps ---
							{
								id: 'rsa-v1-hg-n8k3t3',
								group: 'RSA Lab (v1)',
								name: 'HG-std + RSA (N=8,K=3,T=3; method3+vstune20+vsdiv; pass2+refute3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-method3-vstune20-vsdiv-pass2-refute3-rsaN8-rsaK3-rsaT3',
							},
							{
								id: 'rsa-v1-hg-n12k4t3',
								group: 'RSA Lab (v1)',
								name: 'HG-std + RSA (N=12,K=4,T=3; method3+vstune20+vsdiv; pass2+refute3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-method3-vstune20-vsdiv-pass2-refute3-rsaN12-rsaK4-rsaT3',
							},
							{
								id: 'rsa-v1-hg-n8k2t5',
								group: 'RSA Lab (v1)',
								name: 'HG-std + RSA (N=8,K=2,T=5; method3+vstune20+vsdiv; pass2+refute3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-method3-vstune20-vsdiv-pass2-refute3-rsaN8-rsaK2-rsaT5',
							},
							{
								id: 'rsa-v1-dehg-n8k3t3',
								group: 'RSA Lab (v1)',
								name: 'DEHG + RSA (N=8,K=3,T=3; vstune20+vsdiv; pass2+refute3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-vstune20-vsdiv-pass2-refute3-rsaN8-rsaK3-rsaT3',
							},
							{
								id: 'rsa-v1-dehg-n12k4t3',
								group: 'RSA Lab (v1)',
								name: 'DEHG + RSA (N=12,K=4,T=3; vstune20+vsdiv; pass2+refute3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-vstune20-vsdiv-pass2-refute3-rsaN12-rsaK4-rsaT3',
							},
							{
								id: 'rsa-v1-dehg-n8k2t5',
								group: 'RSA Lab (v1)',
								name: 'DEHG + RSA (N=8,K=2,T=5; vstune20+vsdiv; pass2+refute3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-vstune20-vsdiv-pass2-refute3-rsaN8-rsaK2-rsaT5',
							},
							// --- Prompt Repetition Lab (v1): repeat the prompt in prefill ---
							{
								id: 'prepeat-v1-t432-baseline',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 baseline',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2',
							},
							{
								id: 'prepeat-v1-t432-ppad2',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + ppad2 (padding control; length‚âàrepeat√ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-ppad2',
							},
							{
								id: 'prepeat-v1-t432-ppad3',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + ppad3 (padding control; length‚âàrepeat√ó3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-ppad3',
							},
							{
								id: 'prepeat-v1-t432-prepeat2',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + prepeat2 (repeat prompt √ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-prepeat2',
							},
							{
								id: 'prepeat-v1-t432-prepeat2v',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + prepeat2 + prepeatv (verbose repeat √ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-prepeat2-prepeatv',
							},
							{
								id: 'prepeat-v1-t432-prepeat3',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + prepeat3 (repeat prompt √ó3)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-prepeat3',
							},
							{
								id: 'prepeat-v1-t432-prepeat3v',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + prepeat3 + prepeatv (repeat √ó3; verbose)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-prepeat3-prepeatv',
							},
							{
								id: 'prepeat-v1-t432-prepeat2-full',
								group: 'Prompt Repetition Lab (v1)',
								name: 'test43-2 + prepeat2 + prepeatfull (repeat full prompt)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-prepeat2-prepeatfull',
							},
							{
								id: 'prepeat-v1-hg-baseline',
								group: 'Prompt Repetition Lab (v1)',
								name: 'HG-std baseline (exp-r1; rcap35; ans2+quietpass)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35',
							},
							{
								id: 'prepeat-v1-hg-prepeat2',
								group: 'Prompt Repetition Lab (v1)',
								name: 'HG-std + prepeat2 (repeat prompt √ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-prepeat2',
							},
							{
								id: 'prepeat-v1-hg-prepeat2v',
								group: 'Prompt Repetition Lab (v1)',
								name: 'HG-std + prepeat2 + prepeatv (verbose repeat √ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-prepeat2-prepeatv',
							},
							{
								id: 'prepeat-v1-hg-prepeat3v',
								group: 'Prompt Repetition Lab (v1)',
								name: 'HG-std + prepeat3 + prepeatv (repeat √ó3; verbose)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-prepeat3-prepeatv',
							},
							{
								id: 'prepeat-v1-dehg-baseline',
								group: 'Prompt Repetition Lab (v1)',
								name: 'DEHG baseline (exp-r3; method3+vsdiag5; rcap45)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45',
							},
							{
								id: 'prepeat-v1-dehg-prepeat2',
								group: 'Prompt Repetition Lab (v1)',
								name: 'DEHG + prepeat2 (repeat prompt √ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-prepeat2',
							},
							{
								id: 'prepeat-v1-dehg-prepeat2v',
								group: 'Prompt Repetition Lab (v1)',
								name: 'DEHG + prepeat2 + prepeatv (verbose repeat √ó2)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-prepeat2-prepeatv',
							},
							{
								id: 'prepeat-v1-dehg-prepeat3v',
								group: 'Prompt Repetition Lab (v1)',
								name: 'DEHG + prepeat3 + prepeatv (repeat √ó3; verbose)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-prepeat3-prepeatv',
							},
							// --- Prompt Structure Lab (v1): prompt order / formatting invariances ---
							{
								id: 'pstruct-v1-t432-baseline',
								group: 'Prompt Structure Lab (v1)',
								name: 'test43-2 baseline',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2',
							},
							{
								id: 'pstruct-v1-t432-optfirst',
								group: 'Prompt Structure Lab (v1)',
								name: 'test43-2 + optfirst (move options before question)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-optfirst',
							},
							{
								id: 'pstruct-v1-t432-optmix',
								group: 'Prompt Structure Lab (v1)',
								name: 'test43-2 + optmix (append options-first copy)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-optmix',
							},
							{
								id: 'pstruct-v1-t432-optmix-prepeat2',
								group: 'Prompt Structure Lab (v1)',
								name: 'test43-2 + optmix + prepeat2 (order-mix + repetition)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-optmix-prepeat2',
							},
							{
								id: 'pstruct-v1-t432-optfirst-prepeat2',
								group: 'Prompt Structure Lab (v1)',
								name: 'test43-2 + optfirst + prepeat2 (options-first + repetition)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-optfirst-prepeat2',
							},
							{
								id: 'pstruct-v1-hg-baseline',
								group: 'Prompt Structure Lab (v1)',
								name: 'HG-std baseline (exp-r1; rcap35; ans2+quietpass)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35',
							},
							{
								id: 'pstruct-v1-hg-optfirst',
								group: 'Prompt Structure Lab (v1)',
								name: 'HG-std + optfirst (move options before question)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-optfirst',
							},
							{
								id: 'pstruct-v1-hg-optmix',
								group: 'Prompt Structure Lab (v1)',
								name: 'HG-std + optmix (append options-first copy)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-optmix',
							},
							{
								id: 'pstruct-v1-hg-optmix-prepeat2',
								group: 'Prompt Structure Lab (v1)',
								name: 'HG-std + optmix + prepeat2 (order-mix + repetition)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-optmix-prepeat2',
							},
							{
								id: 'pstruct-v1-dehg-baseline',
								group: 'Prompt Structure Lab (v1)',
								name: 'DEHG baseline (exp-r3; method3+vsdiag5; rcap45)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45',
							},
							{
								id: 'pstruct-v1-dehg-optfirst',
								group: 'Prompt Structure Lab (v1)',
								name: 'DEHG + optfirst (move options before question)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-optfirst',
							},
							{
								id: 'pstruct-v1-dehg-optmix',
								group: 'Prompt Structure Lab (v1)',
								name: 'DEHG + optmix (append options-first copy)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-optmix',
							},
							{
								id: 'pstruct-v1-dehg-optmix-prepeat2',
								group: 'Prompt Structure Lab (v1)',
								name: 'DEHG + optmix + prepeat2 (order-mix + repetition)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-optmix-prepeat2',
							},
							// --- Anti-Persuasion Lab (v1): mitigate "persuaded verifier" failures ---
							{
								id: 'antipers-v1-t432-baseline',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'test43-2 baseline',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2',
							},
							{
								id: 'antipers-v1-t432-blindans3',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'test43-2 + blindans3 (answer-only majority gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-blindans3',
							},
							{
								id: 'antipers-v1-t432-blindans5',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'test43-2 + blindans5 (stronger answer-only gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-blindans5',
							},
							{
								id: 'antipers-v1-t432-blindans3-raw',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'test43-2 + blindans3 + blindraw (gate uses raw query)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-blindans3-blindraw',
							},
							{
								id: 'antipers-v1-t432-blindans3-pass2',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'test43-2 + blindans3 + pass2 (double-check verifier + blind gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-pass2-blindans3',
							},
							{
								id: 'antipers-v1-t432-blindans3-pass2-refute3',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'test43-2 + blindans3 + pass2 + refute3 (stacked anti-false-pass gates)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2-pass2-refute3-blindans3',
							},
							{
								id: 'antipers-v1-hg-baseline',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'HG-std baseline (exp-r1; rcap35; ans2+quietpass)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35',
							},
							{
								id: 'antipers-v1-hg-blindans3',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'HG-std + blindans3 (answer-only majority gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-blindans3',
							},
							{
								id: 'antipers-v1-hg-blindans3-pass2',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'HG-std + blindans3 + pass2 (double-check verifier + blind gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-pass2-blindans3',
							},
							{
								id: 'antipers-v1-hg-blindans3-pass2-refute3',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'HG-std + blindans3 + pass2 + refute3 (stacked anti-false-pass gates)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2hg-m20-r30-corr1-cap5000-ps3-fs10-ih200-ans2-quietpass-rcap35-pass2-refute3-blindans3',
							},
							{
								id: 'antipers-v1-dehg-baseline',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'DEHG baseline (exp-r3; method3+vsdiag5; rcap45)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45',
							},
							{
								id: 'antipers-v1-dehg-blindans3',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'DEHG + blindans3 (answer-only majority gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-blindans3',
							},
							{
								id: 'antipers-v1-dehg-blindans3-pass2',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'DEHG + blindans3 + pass2 (double-check verifier + blind gate)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-pass2-blindans3',
							},
							{
								id: 'antipers-v1-dehg-blindans3-pass2-refute3',
								group: 'Anti-Persuasion Lab (v1)',
								name: 'DEHG + blindans3 + pass2 + refute3 (stacked anti-false-pass gates)',
								who: 'red',
								accRun: false,
								accCross: false,
								fullText: true,
								special: 'test43-2dehg-method3-vsdiag5-m20-r30-corr0-cap5000-ps2-fs8-ih300-ans2-rcap45-pass2-refute3-blindans3',
							},
							// --- test48: 43-2 Modular Experiments (no combinatorial grid) ---
							// Idea ‚Üí Architecture mapping (keep these as separate archIds for attribution):
							// - Verbalized Sampling overlap diagnoses: test48-vsdiag5
							// - No strict output format (freeform ‚Üí coerce to <solution>): test48-nlinit, test48-nlfull
			// - Memory off (ablation): test48-nomem
			// - MuZero-style state abstraction (hidden state summary): test48-hstate
			// - Hierarchical goal stack / sustained objectives: test48-goalstack
			// - Obscuro belief sets: test48-belief3 (+ unanimity gate: test48-belief3agree)
			// - Self-consistency init: test48-sc3 (+ unanimity gate: test48-sc3agree)
			// - Verbalized self-consistency init: test48-vssc5
			// - Value-network selection among candidates: test48-valuepick5
			// - MCTS-ish visit-count init using verifier votes: test48-mcts5
			// - Multi-method init: test48-method3 (+ unanimity gate: test48-method3agree)
			// - ToT-style branching corrections: test48-totcorr3
			// - Verbalized Sampling redteam notes: test48-vsred5
			// - Process supervision (earliest failing step bug report): test48-procsup
			// - Bug-report delta compression (short actionable fixes): test48-deltasum
			// - Quiet-position stability filter (one more step): test48-quietpass
			// - Answer stability gate before accept (2 solves): test48-ans2
			// - Backprop of failure via banned answer tokens: test48-banans
			// - Reason-agreement vote (k) for gating: test48-samek3
			// - Hybrid (kitchen sink; not for attribution): test48-hybrid
			{
				id: 'test48-vsdiag5',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-vsdiag5 (test43-2 + Verbalized Sampling diagnoses k=5)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-vsdiag5',
			},
			{
				id: 'test48-nlinit',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-nlinit (test43-2 + freeform initial solve ‚Üí coerce to <solution> for verify)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-nlinit',
			},
			{
				id: 'test48-nlfull',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-nlfull (test43-2 + freeform solve/correct ‚Üí coerce to <solution> for verify)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-nlfull',
			},
			{
				id: 'test48-nomem',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-nomem (test43-2 + disable solver memory)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-nomem',
			},
			{
				id: 'test48-hstate',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-hstate (test43-2 + MuZero-style hidden state summary)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-hstate',
			},
			{
				id: 'test48-goalstack',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-goalstack (test43-2 + hierarchical goal stack instructions)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-goalstack',
			},
			{
				id: 'test48-belief3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-belief3 (test43-2 + Obscuro belief sets k=3 for init)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-belief3',
			},
			{
				id: 'test48-belief3agree',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-belief3agree (test43-2 + belief3 + unanimity gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-belief3-initagree',
			},
			{
				id: 'test48-sc3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-sc3 (test43-2 + self-consistency init k=3)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-sc3',
			},
			{
				id: 'test48-sc3agree',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-sc3agree (test43-2 + sc3 + unanimity gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-sc3-initagree',
			},
			{
				id: 'test48-vssc5',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-vssc5 (test43-2 + Verbalized self-consistency init k=5)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-vssc5',
			},
			{
				id: 'test48-valuepick5',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-valuepick5 (test43-2 + value-network pick among k=5 VS solutions)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-valuepick5',
			},
			{
				id: 'test48-mcts5',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-mcts5 (test43-2 + MCTS visit-count init k=5 using verifier)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-mcts5',
			},
			{
				id: 'test48-method3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-method3 (test43-2 + 3 diverse methodologies for init)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-method3',
			},
			{
				id: 'test48-method3agree',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-method3agree (test43-2 + method3 + unanimity gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-method3-initagree',
			},
			{
				id: 'test48-totcorr3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-totcorr3 (test43-2 + ToT-style branching corrections k=3)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-totcorr3',
			},
			{
				id: 'test48-vsred5',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-vsred5 (test43-2 + Verbalized Sampling redteam notes k=5)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-vsred5',
			},
			{
				id: 'test48-procsup',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-procsup (test43-2 + process supervision bug report)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-procsup',
			},
			{
				id: 'test48-deltasum',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-deltasum (test43-2 + bug-report delta compression)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-deltasum',
			},
			{
				id: 'test48-quietpass',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-quietpass (test43-2 + quiet-position check before accept)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-quietpass',
			},
			{
				id: 'test48-ans2',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-ans2 (test43-2 + answer-stability gate before accept)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-ans2',
			},
			{
				id: 'test48-banans',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-banans (test43-2 + backprop ban failed answer tokens)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-banans',
			},
			{
				id: 'test48-samek3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-samek3 (test43-2 + reason-agreement vote k=3)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-samek3',
			},
			{
				id: 'test48-hybrid',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-hybrid (test43-2 + hstate+belief3+vsdiag5+vsred5+totcorr3+quietpass+banans+deltasum+samek3+valuepick5)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-hstate-belief3-vsdiag5-vsred5-totcorr3-quietpass-banans-deltasum-samek3-valuepick5',
			},
			// --- SciIdea: Scientific Ideation Architecture (Survey Paper) ---
			{
				id: 'sciidea',
				group: 'Experimental (SciIdea)',
				name: 'SciIdea (Survey-based: CoI + Persona3 + Debate loop)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'sciidea',
			},
			{
				id: 'sciidea-lite',
				group: 'Experimental (SciIdea)',
				name: 'SciIdea-Lite (CoI context + 3-persona rotation only)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'sciidea-lite',
			},
			// --- test43-2 with SciIdea modular flags ---
			{
				id: 'test48-sciidea',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-sciidea (test43-2 + CoI + persona3 + debate3)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-coi-persona3-debate3',
			},
			{
				id: 'test48-coi',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-coi (test43-2 + Chain-of-Ideas context augmentation)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-coi',
			},
			{
				id: 'test48-persona3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-persona3 (test43-2 + 3-persona rotation)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-persona3',
			},
			{
				id: 'test48-debate3',
				group: 'Experimental (43-2 Modular)',
				name: 'test48-debate3 (test43-2 + Generator-Discriminator debate k=3)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-debate3',
			},
			{
				id: 'test43-2a',
				group: 'Experimental',
				name: 'test43-2a (test43-2 + overlap must agree with verifier)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2a',
			},
			{
				id: 'test43-2b',
				group: 'Experimental',
				name: 'test43-2b (test43-2 + skip correction if overlap missing)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2b',
			},
			{
				id: 'test43-2c',
				group: 'Experimental',
				name: 'test43-2c (test43-2 + cap 1 correction per round)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2c',
			},
			{
				id: 'test43-2d',
				group: 'Experimental',
				name: 'test43-2d (test43-2 + reset on repeated same failure)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2d',
			},
			{
				id: 'test43-2e',
				group: 'Experimental',
				name: 'test43-2e (test43-2 + require same failure twice before correction)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2e',
			},
			{
				id: 'test43-2f',
				group: 'Experimental',
				name: 'test43-2f (test43-2 + weak overlap => regenerate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2f',
			},
			{
				id: 'test43-2g',
				group: 'Experimental',
				name: 'test43-2g (test43-2 + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2g',
			},
			{
				id: 'test43-2h',
				group: 'Experimental',
				name: 'test43-2h (test43-2 + double-verify gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2h',
			},
			{
				id: 'test43-2de',
				group: 'Experimental',
				name: 'test43-2de (test43-2 + reset-on-repeat + require-same-failure-twice)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2de',
			},
			{
				id: 'test43-2dh',
				group: 'Experimental',
				name: 'test43-2dh (test43-2 + reset-on-repeat + double-verify gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dh',
			},
			{
				id: 'test43-2dg',
				group: 'Experimental',
				name: 'test43-2dg (test43-2 + reset-on-repeat + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dg',
			},
			{
				id: 'test43-2eh',
				group: 'Experimental',
				name: 'test43-2eh (test43-2 + require-same-failure-twice + double-verify gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2eh',
			},
			{
				id: 'test43-2eg',
				group: 'Experimental',
				name: 'test43-2eg (test43-2 + require-same-failure-twice + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2eg',
			},
			{
				id: 'test43-2hg',
				group: 'Experimental',
				name: 'test43-2hg (test43-2 + double-verify gate + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg',
			},
			{
				id: 'test43-2deh',
				group: 'Experimental',
				name: 'test43-2deh (test43-2 + reset-on-repeat + require-same-failure-twice + double-verify gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2deh',
			},
			{
				id: 'test43-2deg',
				group: 'Experimental',
				name: 'test43-2deg (test43-2 + reset-on-repeat + require-same-failure-twice + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2deg',
			},
			{
				id: 'test43-2dhg',
				group: 'Experimental',
				name: 'test43-2dhg (test43-2 + reset-on-repeat + double-verify gate + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dhg',
			},
			{
				id: 'test43-2ehg',
				group: 'Experimental',
				name: 'test43-2ehg (test43-2 + require-same-failure-twice + double-verify gate + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2ehg',
			},
			{
				id: 'test43-2dehg',
				group: 'Experimental',
				name: 'test43-2dehg (test43-2 + reset-on-repeat + require-same-failure-twice + double-verify gate + adaptive solver temperature)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dehg',
			},
			{
				id: 'test43-2hg-r10',
				group: 'Experimental',
				name: 'test43-2hg-r10 (test43-2hg + redteam budget r10)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-r10',
			},
			{
				id: 'test43-2hg-r15',
				group: 'Experimental',
				name: 'test43-2hg-r15 (test43-2hg + redteam budget r15)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-r15',
			},
			{
				id: 'test43-2hg-r20',
				group: 'Experimental',
				name: 'test43-2hg-r20 (test43-2hg + redteam budget r20)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-r20',
			},
			{
				id: 'test43-2hg-r15-it1',
				group: 'Experimental',
				name: 'test43-2hg-r15-it1 (test43-2hg + r15 + it1)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-r15-it1',
			},
			{
				id: 'test43-2hg-r15-init3-corr1',
				group: 'Experimental',
				name: 'test43-2hg-r15-init3-corr1 (test43-2hg + r15 + init it3 + corr it1)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-r15-init3-corr1',
			},
			{
				id: 'test43-2hg-seed37',
				group: 'Experimental',
				name: 'test43-2hg-seed37 (test43-2hg + seed37 draft)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-seed37',
			},
			{
				id: 'test43-2hg-seed37-r15-init3-corr1',
				group: 'Experimental',
				name: 'test43-2hg-seed37-r15-init3-corr1 (test43-2hg + seed37 + r15 + init it3 + corr it1)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2hg-seed37-r15-init3-corr1',
			},
			{
				id: 'test43-2dehg-r10',
				group: 'Experimental',
				name: 'test43-2dehg-r10 (test43-2dehg + redteam budget r10)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dehg-r10',
			},
			{
				id: 'test43-2dehg-r15',
				group: 'Experimental',
				name: 'test43-2dehg-r15 (test43-2dehg + redteam budget r15)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dehg-r15',
			},
			{
				id: 'test43-2dehg-r20',
				group: 'Experimental',
				name: 'test43-2dehg-r20 (test43-2dehg + redteam budget r20)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dehg-r20',
			},
			{
				id: 'test43-2dehg-r15-init3-corr1',
				group: 'Experimental',
				name: 'test43-2dehg-r15-init3-corr1 (test43-2dehg + r15 + init it3 + corr it1)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2dehg-r15-init3-corr1',
			},
			{
				id: 'test43-3',
				group: 'Experimental',
				name: 'test43-3 (test43 + outlier insight memory)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-3',
			},
			{
				id: 'test43-1-2',
				group: 'Experimental',
				name: 'test43-1,2 (graded eval + checkpoint + overlap diagnosis)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-1-2',
			},
			{
				id: 'test43-1-3',
				group: 'Experimental',
				name: 'test43-1,3 (graded eval + checkpoint + outlier memory)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-1-3',
			},
			{
				id: 'test43-2-3',
				group: 'Experimental',
				name: 'test43-2,3 (overlap diagnosis + outlier memory)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-3',
			},
			{
				id: 'test43-1-2-3',
				group: 'Experimental',
				name: 'test43-1,2,3 (graded eval + overlap diagnosis + outlier memory)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-1-2-3',
			},
			{
				id: 'test47-1',
				group: 'Experimental',
				name: 'test47-1 (Routing: lite-gate heuristic)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-1',
			},
			{
				id: 'test47-2',
				group: 'Experimental',
				name: 'test47-2 (Routing: test37 then graded gate)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-2',
			},
			{
				id: 'test47-3',
				group: 'Experimental',
				name: 'test47-3 (Routing: signal-based tiers)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-3',
			},
			{
				id: 'test47-4',
				group: 'Experimental',
				name: 'test47-4 (Routing: budget-adaptive)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-4',
			},
			{
				id: 'test47-5',
				group: 'Experimental',
				name: 'test47-5 (Routing: test37 x2 answer-consistency ‚Üí test43-2 fallback)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-5',
			},
			{
				id: 'test47-6',
				group: 'Experimental',
				name: 'test47-6 (Routing: test37 + lite redteam gate ‚Üí test43-2 fallback)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-6',
			},
			{
				id: 'test47-7',
				group: 'Experimental',
				name: 'test47-7 (Routing: test37 + 1 retry gate ‚Üí test43-2 fallback)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test47-7',
			},
			// === PaCoRe: Parallel Coordinated Reasoning (StepFun) ===
			{
				id: 'pacore',
				group: 'Proposed',
				name: 'PaCoRe (Parallel Coordinated Reasoning: 4 parallel trajectories ‚Üí message compaction ‚Üí synthesis)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'pacore',
			},
			{
				id: 'test43-2-pacore',
				group: 'Experimental (43-2 Modular)',
				name: 'test43-2-pacore (test43-2 + PaCoRe parallel init with 4 trajectories)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-pacore4',
			},
			// === AgeMem: Agentic Memory (Unified LTM/STM Management) ===
			{
				id: 'agemem',
				group: 'AgeMem',
				name: 'AgeMem (Unified LTM/STM memory management with tool-based actions)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'agemem',
			},
			{
				id: 'test43-2-agemem',
				group: 'AgeMem',
				name: 'test43-2-agemem (test43-2 + AgeMem unified memory management)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-agemem',
			},
			// === Focus: Active Context Compression (Slime Mold inspiration) ===
			{
				id: 'focus',
				group: 'Focus',
				name: 'Focus (Active Context Compression with Knowledge Block)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'focus',
			},
			{
				id: 'test43-2-focus',
				group: 'Focus',
				name: 'test43-2-focus (test43-2 + Focus context compression)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-focus',
			},
			// === SimpleMem: Efficient Lifelong Memory (Semantic Compression) ===
			{
				id: 'simplemem',
				group: 'SimpleMem',
				name: 'SimpleMem (Semantic Structured Compression + Adaptive Retrieval)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'simplemem',
			},
			{
				id: 'test43-2-simplemem',
				group: 'SimpleMem',
				name: 'test43-2-simplemem (test43-2 + SimpleMem memory management)',
				who: 'red',
				accRun: false,
				accCross: false,
				fullText: true,
				special: 'test43-2-simplemem',
			},
		];

		// --- Import architectures from `general.html` (paper checkpoint parity) ---
		// Keep the original IDs (e.g., `test2`) because they are referenced in the paper appendix/tables.
		(() => {
			try {
				const existingIds = new Set((ARCH_DEFINITIONS || []).map(d => d?.id).filter(Boolean));
				const addMissing = (defs) => {
					(defs || []).forEach((def) => {
						const id = def && def.id ? `${def.id}` : '';
						if (!id || existingIds.has(id)) return;
						ARCH_DEFINITIONS.push(def);
						existingIds.add(id);
					});
				};

				// From `general.html` (baseline + summaries + clue variants + RT profiles)
				const __GENERAL_BASE_ARCH_DEFS = [
					{ id: 'pass@1', group: 'Baseline', name: 'pass@1 (Single-shot answer; no verification)', who: 'solver', accRun: false, accCross: false, special: 'pass@1' },
					{ id: 'A11', group: 'Baseline', name: 'Baseline (Full Text)', who: 'red', accRun: false, accCross: false, fullText: true },
					// Solver
					{ id: 'S-XX', group: 'Solver Summary', name: 'Run(X) Cross(X)', who: 'solver', accRun: false, accCross: false },
					{ id: 'S-OX', group: 'Solver Summary', name: 'Run(O) Cross(X)', who: 'solver', accRun: true, accCross: false },
					{ id: 'S-XO', group: 'Solver Summary', name: 'Run(X) Cross(O)', who: 'solver', accRun: false, accCross: true },
					{ id: 'S-OO', group: 'Solver Summary', name: 'Run(O) Cross(O)', who: 'solver', accRun: true, accCross: true },
					// Red Team
					{ id: 'R-XX', group: 'RedTeam Summary', name: 'Run(X) Cross(X)', who: 'red', accRun: false, accCross: false },
					{ id: 'R-OX', group: 'RedTeam Summary', name: 'Run(O) Cross(X)', who: 'red', accRun: true, accCross: false },
					{ id: 'R-XO', group: 'RedTeam Summary', name: 'Run(X) Cross(O)', who: 'red', accRun: false, accCross: true },
					{ id: 'R-OO', group: 'RedTeam Summary', name: 'Run(O) Cross(O)', who: 'red', accRun: true, accCross: true },
					// Intermediary
					{ id: 'I-XX', group: 'Intermediary Summary', name: 'Run(X) Cross(X)', who: 'mid', accRun: false, accCross: false },
					{ id: 'I-OX', group: 'Intermediary Summary', name: 'Run(O) Cross(X)', who: 'mid', accRun: true, accCross: false },
					{ id: 'I-XO', group: 'Intermediary Summary', name: 'Run(X) Cross(O)', who: 'mid', accRun: false, accCross: true },
					{ id: 'I-OO', group: 'Intermediary Summary', name: 'Run(O) Cross(O)', who: 'mid', accRun: true, accCross: true },
					// Clue Variants
					{ id: 'A11-CLUE', group: 'Baseline+Clue', name: 'Baseline + Clue', who: 'red', accRun: false, accCross: false, fullText: true, clueEnabled: true },
					{ id: 'S-XX-CLUE', group: 'Solver+Clue', name: 'S-XX + Clue', who: 'solver', accRun: false, accCross: false, clueEnabled: true },
					{ id: 'R-XO-CLUE', group: 'RedTeam+Clue', name: 'R-XO + Clue', who: 'red', accRun: false, accCross: true, clueEnabled: true },
					{ id: 'I-OO-CLUE', group: 'Intermediary+Clue', name: 'I-OO + Clue', who: 'mid', accRun: true, accCross: true, clueEnabled: true },
					// Red Team Variations (New)
					{ id: 'RT1-T1', group: 'RT:CritError', name: 'T1 (Streak 5)', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V1', rtTrigger: 'T1' },
					{ id: 'RT1-T2', group: 'RT:CritError', name: 'T2 (Streak 3)', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V1', rtTrigger: 'T2' },
					{ id: 'RT1-T3', group: 'RT:CritError', name: 'T3 (Always)', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V1', rtTrigger: 'T3' },
					{ id: 'RT2-T1', group: 'RT:OrigEval', name: 'T1 (Streak 5)', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V2', rtTrigger: 'T1' },
					{ id: 'RT2-T2', group: 'RT:OrigEval', name: 'T2 (Streak 3)', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V2', rtTrigger: 'T2' },
					{ id: 'RT2-T3', group: 'RT:OrigEval', name: 'T3 (Always)', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V2', rtTrigger: 'T3' },
				];
				addMissing(__GENERAL_BASE_ARCH_DEFS);

				// Red Team Variations (OLD: test 1.2 logic)
				const __GENERAL_RT_OLD_DEFS = [
					{ id: 'RT1-T1-old', group: 'RT:CritError (old)', name: 'T1 (Streak 5) - old', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V1', rtTrigger: 'T1', rtLogic: 'old' },
					{ id: 'RT1-T2-old', group: 'RT:CritError (old)', name: 'T2 (Streak 3) - old', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V1', rtTrigger: 'T2', rtLogic: 'old' },
					{ id: 'RT1-T3-old', group: 'RT:CritError (old)', name: 'T3 (Always) - old', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V1', rtTrigger: 'T3', rtLogic: 'old' },
					{ id: 'RT2-T1-old', group: 'RT:OrigEval (old)', name: 'T1 (Streak 5) - old', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V2', rtTrigger: 'T1', rtLogic: 'old' },
					{ id: 'RT2-T2-old', group: 'RT:OrigEval (old)', name: 'T2 (Streak 3) - old', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V2', rtTrigger: 'T2', rtLogic: 'old' },
					{ id: 'RT2-T3-old', group: 'RT:OrigEval (old)', name: 'T3 (Always) - old', who: 'red', accRun: false, accCross: false, fullText: true, rtType: 'V2', rtTrigger: 'T3', rtLogic: 'old' },
				];
				addMissing(__GENERAL_RT_OLD_DEFS);

				// Composed Architectures: MainLoop + RedTeam (custom assemblies), restricted to the `general.html` base set.
				const __isGeneralRedTeamProfile = (def) => !!def?.rtType && !!def?.rtTrigger;
				const __GENERAL_MAINLOOP_ARCHES = __GENERAL_BASE_ARCH_DEFS.filter(d => !__isGeneralRedTeamProfile(d));
				const __GENERAL_RT_PROFILES = [...__GENERAL_BASE_ARCH_DEFS, ...__GENERAL_RT_OLD_DEFS].filter(__isGeneralRedTeamProfile);
				const __GENERAL_COMPOSED_ARCH_DEFS = [];
				__GENERAL_MAINLOOP_ARCHES.forEach(main => {
					__GENERAL_RT_PROFILES.forEach(rt => {
						__GENERAL_COMPOSED_ARCH_DEFS.push({
							...main,
							id: `${main.id}-${rt.id}`,
							group: 'Composed (Main + RedTeam)',
							name: `${main.id} + ${rt.id}`,
							rtType: rt.rtType,
							rtTrigger: rt.rtTrigger,
							rtLogic: rt.rtLogic || 'new',
						});
					});
				});
				addMissing(__GENERAL_COMPOSED_ARCH_DEFS);

				// System Architectures (standalone; not composed)
				addMissing([
					{
						id: 'system-1.0',
						group: 'System',
						name: 'system 1.0 (Main‚ÜíProof/Solution; method vote + memory gate)',
						who: 'mid',
						accRun: true,
						accCross: true,
						rtLogic: 'old',
						whiteboard: true,
						special: 'system-1.0'
					},
					{
						id: 'system-1.1',
						group: 'System',
						name: 'system 1.1 (Working memory + per-run methodology + trial + router loop)',
						who: 'mid',
						accRun: true,
						accCross: true,
						rtLogic: 'old',
						whiteboard: true,
						special: 'system-1.1'
					},
					{
						id: 'system-1.2',
						group: 'System',
						name: 'system 1.2 (Checklist-based RT2 + validated artifacts + quorum memory + WM TTL)',
						who: 'mid',
						accRun: true,
						accCross: true,
						rtLogic: 'old',
						whiteboard: true,
						special: 'system-1.2'
					},
				]);

				// Experimental Architectures (System 1.2 feature ablations on Baseline)
				addMissing([
					{
						id: 'test1',
						group: 'Experimental',
						name: 'test1 (Baseline + step rationale; step-logic Red Team)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { solverPrompt: 'v12', verifierMode: 'step_logic' },
					},
					{
						id: 'test2',
						group: 'Experimental',
						name: 'test2 (Baseline + Methodology Vote/Selection)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { methodologyVote: true, methodologyInjection: 'mandatory' },
					},
					{
						id: 'test3',
						group: 'Experimental',
						name: 'test3 (Baseline + final Trial verification)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { postPass: { trialV12: true } },
					},
					{
						id: 'test4',
						group: 'Experimental',
						name: 'test4 (Baseline + RT criteria generation pass@1 ‚Üí checklist Red Team)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { verifierMode: 'rt2_checklist', checklistGen: 'pass@1' },
					},
					{
						id: 'test5',
						group: 'Experimental',
						name: 'test5 (Baseline + RT criteria generation (loop-validated) ‚Üí checklist Red Team)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { verifierMode: 'rt2_checklist', checklistGen: 'validated' },
					},
					{
						id: 'test6',
						group: 'Experimental',
						name: 'test6 (Baseline + 3-solver sampling + Red Team best-of selection loop)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test6',
					},
					{
						id: 'test7',
						group: 'Experimental',
						name: 'test7 (Baseline + System 1.2 working memory only)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { workingMemoryV12: true },
					},
					{
						id: 'test8',
						group: 'Experimental',
						name: 'test8 (I-OO + RT2-T2-old + mediator summary + verbatim RT feedback)',
						who: 'mid',
						accRun: true,
						accCross: true,
						rtType: 'V2',
						rtTrigger: 'T2',
						rtLogic: 'old',
						exp: { intermediaryIncludeVerbatimVerifierFeedback: true },
					},
					{
						id: 'test9',
						group: 'Experimental',
						name: 'test9 (3-branch Baseline; prune on 3 fails; regrow to 3)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test9',
					},
					{
						id: 'test10',
						group: 'Experimental',
						name: 'test10 (Baseline+Clue: show original problem; clue branch solves clue; reject placeholder/peripheral clues)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						clueEnabled: true,
						exp: { clueV2: true },
					},
					{
						id: 'test11',
						group: 'Experimental',
						name: 'test11 (Baseline + step-basis; Red Team rejects any contradiction)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { solverPrompt: 'v12_basis', verifierMode: 'step_contradiction_strict' },
					},
					{
						id: 'test12',
						group: 'Experimental',
						name: 'test12 (Baseline + post-pass counterexample specialist)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { postPass: { counterexamplePersona: true } },
					},
					{
						id: 'test13a',
						group: 'Experimental',
						name: 'test13a (Baseline + post-pass counterexample branch: 1 run; allow ‚Äúnone found‚Äù)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { postPass: { counterexampleBranch: { runs: 1, maxRunsIfInconclusive: 3, allowConcludeNone: true } } },
					},
					{
						id: 'test13b',
						group: 'Experimental',
						name: 'test13b (Baseline + post-pass counterexample branch: 3 runs; allow ‚Äúnone found‚Äù)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { postPass: { counterexampleBranch: { runs: 3, maxRunsIfInconclusive: 3, allowConcludeNone: true } } },
					},
					{
						id: 'test14',
						group: 'Experimental',
						name: 'test14 (Baseline + post-pass counterexample branch: 3 runs; RT refuses ‚Äúnone found‚Äù)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { postPass: { counterexampleBranch: { runs: 3, maxRunsIfInconclusive: 3, allowConcludeNone: false, forbidVerifierConcludeNone: true } } },
					},
					{
						id: 'test15',
						group: 'Experimental',
						name: 'test15 (Baseline + post-pass counterexample branch: 3 runs; Solver+RT refuse ‚Äúnone found‚Äù)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { postPass: { counterexampleBranch: { runs: 3, maxRunsIfInconclusive: 3, allowConcludeNone: false, forbidSolverConcludeNone: true, forbidVerifierConcludeNone: true } } },
					},
					{
						id: 'test16',
						group: 'Experimental',
						name: 'test16 (Baseline; Red Team verifier personas round-robin: Formalist‚ÜíLogicist‚ÜíIntuitionist)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { rrVerifier: true },
					},
					{
						id: 'test17',
						group: 'Experimental',
						name: 'test17 (Baseline + RT2-T2-old; RT2 personas round-robin: Formalist‚ÜíLogicist‚ÜíIntuitionist)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						rtType: 'V2',
						rtTrigger: 'T2',
						rtLogic: 'old',
						exp: { rrRt2T2Old: true },
					},
					{
						id: 'test18',
						group: 'Experimental',
						name: 'test18 (Baseline; Solver personas round-robin: Formalist‚ÜíLogicist‚ÜíIntuitionist)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { rrSolver: true },
					},
					{
						id: 'test19',
						group: 'Experimental',
						name: 'test19 (Baseline; Solver + Red Team verifier personas round-robin: 3 each)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						exp: { rrSolver: true, rrVerifier: true },
					},
					{
						id: 'test20',
						group: 'Experimental',
						name: 'test20 (agent.py-equivalent: self-improve ‚Üí verify‚Üí yes/no gate ‚Üí correct; pass-streak 5)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test20',
					},
					{
						id: 'test21',
						group: 'Experimental',
						name: 'test21 (ÎàÑ2 Arch9 port; XML-gated agent.py; round = fail-streak 10 OR redteam-budget 10; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test21',
					},
					{
						id: 'test22',
						group: 'Experimental',
						name: 'test22 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch9: Advanced Verification Pipeline)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test22',
					},
					{
						id: 'test23',
						group: 'Experimental',
						name: 'test23 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch11: Agent Pipeline)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test23',
					},
					{
						id: 'test24',
						group: 'Experimental',
						name: 'test24 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch12: Agent Pipeline w/ Full History)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test24',
					},
					{
						id: 'test25',
						group: 'Experimental',
						name: 'test25 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch13: Arch12 + Loop SI)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test25',
					},
					{
						id: 'test26',
						group: 'Experimental',
						name: 'test26 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch14: Arch12 + History has Solutions)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test26',
					},
					{
						id: 'test27',
						group: 'Experimental',
						name: 'test27 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch15: Arch14 + Verifier History)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test27',
					},
					{
						id: 'test28',
						group: 'Experimental',
						name: 'test28 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch16: Arch12 + Verifier History (Simple))',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test28',
					},
					{
						id: 'test29',
						group: 'Experimental',
						name: 'test29 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch17: Cognitive Synergy)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test29',
					},
					{
						id: 'test30',
						group: 'Experimental',
						name: 'test30 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 Arch19: Arch15 (Loop SI) w/o History in SI)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test30',
					},
					{
						id: 'test31',
						group: 'Experimental',
						name: 'test31 (ÎÇ¥ÏïÑÌÇ§ ÎßàÏßÄÎßâ Arch4: Graded Evaluation & Flaw-Resolution Loop)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test31',
					},
					{
						id: 'test32',
						group: 'Experimental',
						name: 'test32 (ICR Refine Mode: iterative refine + feature + bugfix)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test32',
					},
					{
						id: 'test33',
						group: 'Experimental',
						name: 'test33 (ICR React Mode: orchestrator + parallel workers + validation)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test33',
					},
					{
						id: 'test34',
						group: 'Experimental',
						name: 'test34 (ICR Deepthink Mode: multi-strategy ‚Üí critique ‚Üí judge)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test34',
					},
					{
						id: 'test35',
						group: 'Experimental',
						name: 'test35 (ICR Adaptive Deepthink Mode: tool-like staged reasoning)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test35',
					},
					{
						id: 'test36',
						group: 'Experimental',
						name: 'test36 (ICR Agentic Mode: iterative draft + memory compression)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test36',
					},
					{
						id: 'test37',
						group: 'Experimental',
						name: 'test37 (ICR Contextual Mode: main+iterative+memory agents)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test37',
					},
					{
						id: 'test38',
						group: 'Experimental',
						name: 'test38 (ICR Generative UI Mode: UI plan ‚Üí HTML ‚Üí eval ‚Üí refine)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test38',
					},
					{
						id: 'test39',
						group: 'Experimental',
						name: 'test39 (ÌôîÏù¥Ìä∏Î≥¥Îìú ÌïòÏù¥Î∏åÎ¶¨Îìú: Hybrid Whiteboard-Pipeline)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						whiteboard: true,
						special: 'test39',
					},
					{
						id: 'test40',
						group: 'Experimental',
						name: 'test40 (test21 + test37 solver; redteam-budget 10; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test40',
					},
					{
						id: 'test41',
						group: 'Experimental',
						name: 'test41 (test40 variant; redteam-budget 30; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test41',
					},
					{
						id: 'test42',
						group: 'Experimental',
						name: 'test42 (test40-lite; solver ITERATIONS=1; redteam-budget 10; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test42',
					},
					{
						id: 'test43',
						group: 'Experimental',
						name: 'test43 (test41 variant; passStreak=3; redteam-budget 30; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test43',
					},
					{
						id: 'test44',
						group: 'Experimental',
						name: 'test44 (test43 + ICR redteam verdict; passStreak=3; redteam-budget 30; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test44',
					},
					{
						id: 'test45',
						group: 'Experimental',
						name: 'test45 (test42 + ICR redteam verdict; passStreak=5; redteam-budget 10; max 10 rounds)',
						who: 'red',
						accRun: false,
						accCross: false,
						fullText: true,
						special: 'test45',
					},
				]);
			} catch (e) {
				console.warn('[general.html architectures] Failed to import:', e);
			}
		})();

		let agents = [];
		let isRunning = false;
		let GLOBAL_EMERGENCY_STOP = false;

		const __keepAlive = (() => {
			let wakeLock = null;
			let worker = null;
			let workerUrl = null;
			let active = false;

			const supportsWakeLock = !!(navigator && navigator.wakeLock && navigator.wakeLock.request);

			const startWorker = () => {
				if (worker) return;
				const code = `
let timer = null;
const ping = () => { try { postMessage({ t: Date.now() }); } catch {} };
self.onmessage = (e) => {
  const msg = e && e.data ? e.data : {};
  if (msg.type === 'start') {
    if (timer) return;
    timer = setInterval(ping, 20000);
    ping();
    return;
  }
  if (msg.type === 'stop') {
    if (timer) clearInterval(timer);
    timer = null;
  }
};
`;
				try {
					const blob = new Blob([code], { type: 'text/javascript' });
					workerUrl = URL.createObjectURL(blob);
					worker = new Worker(workerUrl);
					worker.postMessage({ type: 'start' });
				} catch {
					worker = null;
				}
			};

			const stopWorker = () => {
				if (!worker) return;
				try { worker.postMessage({ type: 'stop' }); } catch { }
				try { worker.terminate(); } catch { }
				worker = null;
				if (workerUrl) {
					try { URL.revokeObjectURL(workerUrl); } catch { }
					workerUrl = null;
				}
			};

			const requestWakeLock = async () => {
				if (!supportsWakeLock) return;
				if (document.visibilityState !== 'visible') return;
				try {
					wakeLock = await navigator.wakeLock.request('screen');
					wakeLock.addEventListener('release', () => { wakeLock = null; });
				} catch { }
			};

			const releaseWakeLock = async () => {
				if (!wakeLock) return;
				try { await wakeLock.release(); } catch { }
				wakeLock = null;
			};

			const sync = (running) => {
				active = !!running;
				if (active) {
					startWorker();
					requestWakeLock();
				} else {
					releaseWakeLock();
					stopWorker();
				}
			};

			document.addEventListener('visibilitychange', () => {
				if (!active) return;
				if (document.visibilityState === 'visible') requestWakeLock();
			});

			return { sync };
		})();

		// URL params (Jobs: separate windows)
		const __urlParams = (() => {
			try { return new URL(window.location.href).searchParams; } catch { }
			try { return new URLSearchParams(window.location.search || ''); } catch { return new URLSearchParams(); }
		})();
			const __jobLaunchId = __urlParams.get('jobLaunch');
			const __jobSessionId = __urlParams.get('jobSession') || __jobLaunchId || null;
				const __isJobLaunchWindow = !!__jobLaunchId;
				const __isJobWindow = !!__jobSessionId;
				const __dbSnapshotKey = __jobSessionId ? `job:${__jobSessionId}` : 'latest';
				const __sessionId = (__jobSessionId ? __jobSessionId.toString() : 'latest');
				try {
					if (((__urlParams.get('detached') || '').toString() === '1')) window.__JOB_DETACHED = true;
				} catch { }

			function __bindProxyHostForJobWindowRef(w) {
				try {
					if (!w || w.closed) return false;
					w.__JOB_PROXY_PARENT = window;
					return true;
				} catch {
					return false;
				}
			}

			// Global HTML-escape fallback (some render paths reference __esc directly).
			function __esc(v) {
			const s = (v ?? '').toString();
			return s.replace(/[&<>"']/g, (ch) => {
				if (ch === '&') return '&amp;';
				if (ch === '<') return '&lt;';
				if (ch === '>') return '&gt;';
				if (ch === '"') return '&quot;';
				return '&#39;';
			});
		}

		// === JOB QUEUE / MULTI-PROBLEM RUNNER ===
		const __jobManager = (() => {
			const state = {
				version: 1,
				nextNum: 1,
				jobs: [], // { id, createdAt, startedAt, endedAt, status, query, selection:[{archId,count}], agents:[], agentUniqueIds:[], promise:null, headerId }
				queueRunning: false,
				maxConcurrentJobs: 1,
				ui: { scheduled: false },
				timerId: null,
			};

			const __now = () => Date.now();

			const __esc = (v) => {
				const s = (v ?? '').toString();
				return s.replace(/[&<>"']/g, (ch) => {
					if (ch === '&') return '&amp;';
					if (ch === '<') return '&lt;';
					if (ch === '>') return '&gt;';
					if (ch === '"') return '&quot;';
					return '&#39;';
				});
			};

			const __firstLine = (text) => {
				const s = (text ?? '').toString();
				const first = s.split(/\r?\n/).find(l => l.trim()) || s;
				return first.trim();
			};

			const __short = (text, maxLen = 80) => {
				const s = (text ?? '').toString().replace(/\s+/g, ' ').trim();
				if (s.length <= maxLen) return s;
				return s.slice(0, Math.max(0, maxLen - 1)) + '‚Ä¶';
			};

			const __safeInt = (v, fallback, min = 1, max = 9999) => {
				const n = parseInt(v, 10);
				if (!Number.isFinite(n)) return fallback;
				return Math.min(max, Math.max(min, n));
			};

			const __sumPlannedAgents = (selection) => {
				let total = 0;
				for (const s of (selection || [])) total += __safeInt(s?.count, 0, 0, 9999);
				return total;
			};

			const __getJobsUi = () => {
				return {
					list: document.getElementById('jobList'),
					summary: document.getElementById('jobsSummary'),
					toggleBtn: document.getElementById('jobQueueToggleBtn'),
					maxConcurrent: document.getElementById('jobMaxConcurrent'),
				};
			};

			const __scheduleRender = () => {
				if (state.ui.scheduled) return;
				state.ui.scheduled = true;
				const kick = () => {
					state.ui.scheduled = false;
					try { render(); } catch { }
				};
				try { (window.requestAnimationFrame || window.setTimeout)(kick, 0); } catch { try { setTimeout(kick, 0); } catch { } }
			};

			const __syncKeysFromInput = ({ required = false } = {}) => {
				const providedKeys = getApiKeyListFromInput();
				apiKeyManager.setKeys(providedKeys);
				if (!providedKeys.length && !document.getElementById('mockModeChk')?.checked) {
					if (required) alert("Enter at least one API key (one per line).");
					return !required;
				}
				return true;
			};

			const __collectSelectionFromUi = () => {
				const selection = [];
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
					if (!chk?.checked) return;
					const id = (chk.id || '').replace('chk-', '');
					const count = __getEffectiveArchCount(id);
					const def = ARCH_DEFINITIONS.find(d => d && d.id === id);
					if (!def) return;
					selection.push({ archId: id, count });
				});
				return selection;
			};

			const __ensureJobHeader = (job) => {
				if (!job?.id) return;
				const existing = document.getElementById(`job-header-${job.id}`);
				if (existing) return;
				const resArea = document.getElementById('resultsArea');
				if (!resArea) return;

				const card = document.createElement('div');
				card.className = 'architecture-result';
				card.id = `job-header-${job.id}`;
				card.style.minHeight = 'auto';

				const selectionText = (job.selection || [])
					.map(s => `${s.archId}√ó${__safeInt(s.count, 0, 0, 9999)}`)
					.join(', ');

				card.innerHTML = `
	                    <div class="status-header" style="color:var(--base); border-color:var(--base)">
	                        <span>JOB ${__esc(job.id)} ‚Ä¢ ${__esc(__short(__firstLine(job.query), 70))}</span>
	                        <span id="job-status-${__esc(job.id)}">${__esc(job.status || '')}</span>
	                    </div>
	                    <div style="font-size:11px; color:var(--text-3); font-family:monospace; margin-top:6px;">
	                        ${__esc(selectionText || '‚Äî')}
	                    </div>
	                `;

				const keyCard = document.getElementById('key-monitor-card');
				if (keyCard && keyCard.parentElement === resArea) {
					resArea.insertBefore(card, keyCard.nextSibling);
				} else {
					resArea.insertBefore(card, resArea.firstChild || null);
				}
			};

			const __setJobStatusText = (job) => {
				if (!job?.id) return;
				const el = document.getElementById(`job-status-${job.id}`);
				if (!el) return;
				el.textContent = job.status || '';
				if (job.status === 'running') el.style.color = 'var(--log-success)';
				else if (job.status === 'queued') el.style.color = 'var(--text-3)';
				else if (job.status === 'paused') el.style.color = 'orange';
				else if (job.status === 'done') el.style.color = 'var(--text-2)';
				else el.style.color = 'var(--text-2)';
			};

			const __recomputeJobStatus = (job) => {
				if (!job) return;
				if (job.status === 'queued') return;
				// Don't override while the job is actively running.
				if (job.status === 'running' && job.promise) return;
				const agentsArr = Array.isArray(job.agents) ? job.agents : [];
				if (!agentsArr.length) { job.status = 'done'; return; }
				const unfinished = agentsArr.some(a => {
					const st = a?.state?.status || '';
					return !(st === 'Success' || st === 'Failed');
				});
				job.status = unfinished ? 'paused' : 'done';
			};

			const __startJob = (job) => {
				if (!job || !job.id) return;
				if (job.status === 'running') return;
				if (job.status === 'done') return;
				if (!__syncKeysFromInput({ required: true })) return;

				__ensureJobHeader(job);

				if (!Array.isArray(job.agents) || job.agents.length === 0) {
					job.agents = [];
					for (const sel of (job.selection || [])) {
						const def = ARCH_DEFINITIONS.find(d => d && d.id === sel.archId);
						if (!def) continue;
						const count = __safeInt(sel.count, 0, 0, 999);
						for (let i = 0; i < count; i++) {
							createAgentUI(def, `${job.id}-${i + 1}`);
							const agent = agents[agents.length - 1];
							if (agent) {
								agent.jobId = job.id;
								agent.jobQuery = job.query;
								job.agents.push(agent);
							}
						}
					}

					try { updateAnalysisGroupOptions(); } catch { }
					try { updateAnalysisArchOptions(); } catch { }
				}

				// (Re)attach queries to agents (in case of restored state)
				for (const a of (job.agents || [])) {
					if (!a) continue;
					a.jobId = job.id;
					a.jobQuery = job.query;
				}

				job.startedAt = job.startedAt || __now();
				job.endedAt = null;
				job.status = 'running';

				const p = Promise.all((job.agents || []).map(a => a?.run ? a.run(job.query) : Promise.resolve()));
				job.promise = p;
				__scheduleRender();

				p.then(() => {
					job.endedAt = __now();
					job.promise = null;
					__recomputeJobStatus(job);
				}).catch(() => {
					job.endedAt = __now();
					job.promise = null;
					__recomputeJobStatus(job);
				}).finally(() => {
					__scheduleRender();
					tick();
				});
			};

			const addJobFromUi = ({ startNow = false } = {}) => {
				const query = document.getElementById('userQuery')?.value || '';
				const selection = __collectSelectionFromUi();
				if (!query.trim()) {
					alert('Enter a Problem Statement.');
					return null;
				}
				if (!selection.length) {
					alert('Select architectures first.');
					return null;
				}

				// Allow queueing even without keys; but starting requires keys.
				if (startNow && !__syncKeysFromInput({ required: true })) return null;

				const id = `J${state.nextNum++}`;
				const job = {
					id,
					createdAt: __now(),
					startedAt: null,
					endedAt: null,
					status: startNow ? 'running' : 'queued',
					query,
					selection,
					agents: [],
					agentUniqueIds: [],
					promise: null,
				};
				state.jobs.push(job);
				__scheduleRender();
				if (startNow) __startJob(job);
				else tick();
				return job;
			};

			const removeJob = (jobId) => {
				const idx = state.jobs.findIndex(j => j && j.id === jobId);
				if (idx < 0) return;
				const job = state.jobs[idx];
				if (job?.status === 'running') {
					if (!confirm(`Stop + remove this running job?\n\nJob: ${jobId}\n\nThis stops and deletes all agents in this job and will not be restored.`)) return;
					try {
						const uids = (job?.agents || []).map(a => (a?.uniqueId || '').toString()).filter(Boolean);
						for (const uid of uids) {
							try { __deleteAgentRunByUniqueId(uid, { persist: false }); } catch { }
						}
					} catch { }
				}
				state.jobs.splice(idx, 1);
				try { document.getElementById(`job-header-${jobId}`)?.remove(); } catch { }
				__scheduleRender();
				try { saveToLocalStorage(); } catch { }
			};

			const setQueueRunning = (enabled) => {
				state.queueRunning = !!enabled;
				__scheduleRender();
				tick();
			};

			const toggleQueue = () => setQueueRunning(!state.queueRunning);

			const setMaxConcurrentJobs = (n) => {
				state.maxConcurrentJobs = __safeInt(n, 1, 1, 99);
				__scheduleRender();
				tick();
			};

			const tick = () => {
				if (!state.queueRunning) return;
				const maxConc = (() => {
					const ui = __getJobsUi();
					const v = __safeInt(ui.maxConcurrent?.value, state.maxConcurrentJobs, 1, 99);
					state.maxConcurrentJobs = v;
					return v;
				})();

				let running = state.jobs.filter(j => j && j.status === 'running').length;
				if (running >= maxConc) return;

				for (const job of state.jobs) {
					if (running >= maxConc) break;
					if (!job || job.status !== 'queued') continue;
					__startJob(job);
					running++;
				}
			};

			const resumeAllIncomplete = () => {
				if (!__syncKeysFromInput({ required: true })) return;

				// Resume paused jobs first (keeps their original query).
				let resumedAny = false;
				for (const job of state.jobs) {
					if (!job) continue;
					if (job.status === 'paused') {
						__startJob(job);
						resumedAny = true;
					}
				}

				// Resume imported/standalone agents not in a job.
				const q = document.getElementById('userQuery')?.value || '';
				const standalones = (agents || []).filter(a => a && !a.jobId && a?.state?.status !== 'Success' && a?.state?.status !== 'Failed');
				if (standalones.length) {
					resumedAny = true;
					standalones.forEach(a => { if (!a.jobQuery && q.trim()) a.jobQuery = q; });
					Promise.all(standalones.map(a => a.run(a.jobQuery || q))).finally(() => __scheduleRender());
				}

				// If nothing to resume, start a new job from current UI.
				if (!resumedAny) addJobFromUi({ startNow: true });
				__scheduleRender();
			};

			const clear = () => {
				state.jobs = [];
				state.nextNum = 1;
				state.queueRunning = false;
				state.maxConcurrentJobs = 1;
				__scheduleRender();
			};

			const exportState = () => {
				return {
					version: state.version,
					nextNum: state.nextNum,
					queueRunning: state.queueRunning,
					maxConcurrentJobs: state.maxConcurrentJobs,
					jobs: (state.jobs || []).map(j => ({
						id: j?.id,
						createdAt: j?.createdAt,
						startedAt: j?.startedAt,
						endedAt: j?.endedAt,
						status: j?.status,
						query: j?.query,
						selection: j?.selection,
						agentUniqueIds: (j?.agents || []).map(a => a?.uniqueId).filter(Boolean),
					})),
				};
			};

			const importState = (obj) => {
				if (!obj || typeof obj !== 'object') return;
				const incomingJobs = Array.isArray(obj.jobs) ? obj.jobs : [];
				state.nextNum = Number.isFinite(obj.nextNum) ? obj.nextNum : state.nextNum;
				state.queueRunning = false; // always paused on restore (user resumes explicitly)
				state.maxConcurrentJobs = __safeInt(obj.maxConcurrentJobs, state.maxConcurrentJobs, 1, 99);

				state.jobs = incomingJobs.map(j => ({
					id: (j?.id || '').toString(),
					createdAt: Number.isFinite(j?.createdAt) ? j.createdAt : null,
					startedAt: Number.isFinite(j?.startedAt) ? j.startedAt : null,
					endedAt: Number.isFinite(j?.endedAt) ? j.endedAt : null,
					status: (j?.status || 'queued').toString(),
					query: (j?.query || '').toString(),
					selection: Array.isArray(j?.selection) ? j.selection : [],
					agentUniqueIds: Array.isArray(j?.agentUniqueIds) ? j.agentUniqueIds : [],
					agents: [],
					promise: null,
				})).filter(j => j.id);

				// Normalize statuses on restore (nothing is actively running).
				for (const j of state.jobs) {
					if (j.status === 'running') j.status = 'paused';
				}

				// Ensure nextNum keeps growing.
				const maxNum = state.jobs.reduce((m, j) => {
					const mm = (j.id || '').match(/^J(\d+)$/i);
					const n = mm ? parseInt(mm[1], 10) : null;
					return Number.isFinite(n) ? Math.max(m, n) : m;
				}, 0);
				state.nextNum = Math.max(state.nextNum, maxNum + 1);

				__scheduleRender();
			};

			const attachAgents = () => {
				const byUid = new Map((agents || []).map(a => [a?.uniqueId, a]).filter(([k, v]) => !!k && !!v));
				for (const job of state.jobs) {
					if (!job) continue;
					const ids = Array.isArray(job.agentUniqueIds) ? job.agentUniqueIds : [];
					job.agents = [];
					for (const uid of ids) {
						const a = byUid.get(uid);
						if (!a) continue;
						a.jobId = job.id;
						a.jobQuery = job.query;
						job.agents.push(a);
					}
					if (job.agents.length) __ensureJobHeader(job);
					__recomputeJobStatus(job);
				}
				__scheduleRender();
			};

			const render = () => {
				const { list, summary, toggleBtn, maxConcurrent } = __getJobsUi();

				const runningJobs = state.jobs.filter(j => j?.status === 'running').length;
				const queuedJobs = state.jobs.filter(j => j?.status === 'queued').length;
				const pausedJobs = state.jobs.filter(j => j?.status === 'paused').length;
				const runningAgents = (agents || []).filter(a => !!a?._activeRun).length;
				const anyRunning = runningJobs > 0 || runningAgents > 0;
				const canStop = anyRunning || (state.queueRunning && queuedJobs > 0);

				// If this is a job window, publish its live status to the shared Jobs list.
				try {
					if (!window.__JOB_DETACHED && __isJobWindow && __jobSessionId) {
						const reg = __ensureJobWindowsRegistry();
						const id = __jobSessionId.toString();
						const ban = (() => { try { return __ensureJobWindowsBanList(); } catch { return null; } })();
						if (!ban || !ban[id]) {
							const now = __now();
							const prev = reg[id] || {};
							const nextStatus = runningAgents > 0 ? 'running' : 'ready';
							reg[id] = {
								...prev,
								id,
								createdAt: Number.isFinite(prev.createdAt) ? prev.createdAt : now,
								startedAt: Number.isFinite(prev.startedAt) ? prev.startedAt : now,
								closedAt: null,
								status: nextStatus,
								title: (prev.title || document.title || id).toString().slice(0, 140),
								windowName: prev.windowName || `_job_${id}`,
								url: window.location.href,
								lastSeenAt: now,
							};
						}
					}
				} catch { }

				const jobWins = (() => {
					try {
						const reg = __shared?.jobWindows;
						if (!reg || typeof reg !== 'object') return [];
						return Object.values(reg).filter(Boolean);
					} catch { return []; }
				})();
				jobWins.sort((a, b) => ((b?.createdAt || 0) - (a?.createdAt || 0)));
				const winCounts = jobWins.reduce((acc, j) => {
					const s = (j?.status || '').toString();
					acc.total += 1;
					if (s === 'running') acc.running += 1;
					else if (s === 'ready') acc.ready += 1;
					else if (s === 'opening') acc.opening += 1;
					else if (s === 'blocked') acc.blocked += 1;
					else if (s === 'closed') acc.closed += 1;
					else acc.other += 1;
					return acc;
				}, { total: 0, running: 0, ready: 0, opening: 0, blocked: 0, closed: 0, other: 0 });

				if (summary) {
					summary.textContent =
						`This:${runningAgents} running ‚Ä¢ Jobs:${winCounts.running} run/${winCounts.total} total` +
						(winCounts.ready ? ` ‚Ä¢ ${winCounts.ready} ready` : '') +
						(winCounts.blocked ? ` ‚Ä¢ ${winCounts.blocked} blocked` : '');
				}
				if (toggleBtn) {
					toggleBtn.textContent = 'Queue disabled';
					toggleBtn.disabled = true;
					toggleBtn.title = 'Each job runs in its own window/tab.';
				}
				if (maxConcurrent) {
					maxConcurrent.value = '1';
					maxConcurrent.disabled = true;
					maxConcurrent.title = 'Disabled (Jobs run in separate windows).';
				}

				// Update progress bar + global run state
				isRunning = anyRunning;
				try { __keepAlive.sync(isRunning); } catch { }
				const pb = document.getElementById('progress-bar');
				if (pb) pb.innerText = `This window: ${runningAgents}/${(agents || []).length} running ‚Ä¢ Job windows: ${winCounts.running} running (${winCounts.total} total)`;

				const stopBtn = document.getElementById('stopBtn');
				if (stopBtn) stopBtn.disabled = !canStop;
				const runBtn = document.getElementById('runBtn');
				if (runBtn) runBtn.disabled = anyRunning;

				// Update job headers
				for (const job of state.jobs) __setJobStatusText(job);

				if (!list) return;
				const rootStyle = getComputedStyle(document.documentElement);
				const colSuccess = (rootStyle.getPropertyValue('--log-success') || '#34d399').trim();
				const colFail = (rootStyle.getPropertyValue('--log-error') || '#fb7185').trim();
				const colWarn = 'orange';
				const colMuted = (rootStyle.getPropertyValue('--text-3') || '#94a3b8').trim();
				const colOpen = (rootStyle.getPropertyValue('--status-success') || '#fbbf24').trim(); // yellow

				const rows = [];
				const now = __now();

				if (!jobWins.length && !state.jobs.length) {
					list.innerHTML = `<div style="color:var(--text-3); font-family:monospace; font-size:11px;">No job windows yet. Click ‚ÄúRun New Job‚Äù.</div>`;
					return;
				}

				if (jobWins.length) {
					rows.push(`<div style="color:var(--text-3); font-family:monospace; font-size:10px; margin:2px 0 4px;">Job windows</div>`);
					for (let i = 0; i < jobWins.length; i++) {
						const j = jobWins[i];
						const id = (j?.id || '').toString();
						if (!id) continue;
						const statusRaw = (j?.status || 'opening').toString();
						const status = statusRaw.toUpperCase();
						const dotColor = status === 'RUNNING' ? colSuccess
							: (status === 'BLOCKED' ? colFail
								: (status === 'CLOSED' ? colMuted : colOpen));
						const createdAt = Number.isFinite(j?.createdAt) ? j.createdAt : null;
						const ageSec = Number.isFinite(createdAt) ? Math.max(0, (now - createdAt) / 1000) : null;
						const progress = ageSec == null ? '-' : `${ageSec.toFixed(0)}s`;
						const title = __short((j?.title || id), 62);
						const windowName = (j?.windowName || `_job_${id}`).toString();
						const url = (j?.url || '').toString();
						const canClose = (() => {
							try {
								const ref = __jobWindowRefs.get(id);
								return !!ref && !ref.closed;
							} catch { return false; }
						})();

						rows.push(`
		                            <div class="job-row" data-jobwin-id="${__esc(id)}" data-jobwin-name="${__esc(windowName)}" data-jobwin-url="${__esc(url)}" title="${__esc(j?.title || id)}">
		                                <div class="job-dot" style="color:${dotColor};">‚óè</div>
		                                <div class="job-col id">${__esc(`W${i + 1}`)}</div>
		                                <div class="job-col status">${__esc(status)}</div>
		                                <div class="job-col progress">${__esc(progress)}</div>
		                                <div class="job-col" style="flex:1;">${__esc(title)}</div>
			                                <div class="job-actions">
			                                    <button class="cs-btn" data-action="openwin">Open</button>
			                                    <button class="cs-btn" data-action="closewin" title="Close + remove from list + delete autosave snapshot">Close</button>
			                                </div>
		                            </div>
		                        `);
					}
				}

				if (state.jobs.length) {
					if (jobWins.length) rows.push(`<div style="border-top:1px dashed rgba(42,53,88,0.6); margin:6px 0;"></div>`);
					rows.push(`<div style="color:var(--text-3); font-family:monospace; font-size:10px; margin:2px 0 4px;">Legacy local queue</div>`);
					for (const job of state.jobs) {
						if (!job) continue;
						const planned = __sumPlannedAgents(job.selection);
						const total = (job.agents && job.agents.length) ? job.agents.length : planned;
						const done = (job.agents || []).filter(a => {
							const st = a?.state?.status || '';
							return st === 'Success' || st === 'Failed';
						}).length;
						const progress = total ? `${done}/${total}` : '-';

						const dotColor = job.status === 'running' ? colSuccess
							: (job.status === 'queued' ? colMuted
								: (job.status === 'paused' ? colWarn
									: (job.status === 'done' ? 'var(--text-2)' : colFail)));

						const title = __short(__firstLine(job.query), 62);

						const actions = (() => {
							if (job.status === 'queued') {
								return `
		                                    <div class="job-actions">
		                                        <button class="cs-btn" data-action="start">Start</button>
		                                        <button class="cs-btn" data-action="remove">Remove</button>
		                                    </div>`;
							}
							if (job.status === 'paused') {
								return `
		                                    <div class="job-actions">
		                                        <button class="cs-btn" data-action="resume">Resume</button>
		                                        <button class="cs-btn" data-action="remove">Remove</button>
		                                    </div>`;
							}
							if (job.status === 'running') {
								return `
		                                    <div class="job-actions">
		                                        <button class="cs-btn" data-action="remove" title="Stop + remove this job (deletes its agents)">Stop+Remove</button>
		                                    </div>`;
							}
							return `
		                                <div class="job-actions">
		                                    <button class="cs-btn" data-action="remove">Remove</button>
		                                </div>`;
						})();

						rows.push(`
		                            <div class="job-row" data-job-id="${__esc(job.id)}" title="${__esc(job.query)}">
		                                <div class="job-dot" style="color:${dotColor};">‚óè</div>
		                                <div class="job-col id">${__esc(job.id)}</div>
		                                <div class="job-col status">${__esc(job.status)}</div>
		                                <div class="job-col progress">${__esc(progress)}</div>
		                                <div class="job-col" style="flex:1;">${__esc(title)}</div>
		                                ${actions}
		                            </div>
		                        `);
					}
				}

				list.innerHTML = rows.join('');
			};

			const onJobListClick = (e) => {
				const btn = e?.target?.closest?.('button[data-action]');
				if (!btn) return;
				const row = btn.closest('.job-row');
				const jobWinId = row?.dataset?.jobwinId;
				const jobId = row?.dataset?.jobId;
				const action = btn.dataset.action;
				if (jobWinId) {
					const name = row?.dataset?.jobwinName;
					const url = row?.dataset?.jobwinUrl;
						if (action === 'openwin') {
							try {
								const ref = __jobWindowRefs.get(jobWinId);
								if (ref && !ref.closed) {
									try { __bindProxyHostForJobWindowRef(ref); } catch { }
									try { ref.focus(); } catch { }
									return;
								}
							} catch { }
						try {
							const w = __openJobWindow(jobWinId, { id: jobWinId, windowName: name || `_job_${jobWinId}` }, { autoRestore: true });
							if (w) return;
						} catch { }
						try {
							const w2 = window.open(url || window.location.href, name || '_blank');
							try { if (w2) __jobWindowRefs.set(jobWinId, w2); } catch { }
							try { w2?.focus?.(); } catch { }
						} catch { }
					} else if (action === 'closewin' || action === 'purgewin') {
						const id = (jobWinId || '').toString();
						if (!id) return;
						if (!confirm(`Close this job window AND remove it from the Jobs list?\n\nJob: ${id}\n\nThis deletes its autosave snapshot and cannot be undone.`)) return;

						const reg = (() => { try { return __shared?.jobWindows; } catch { return null; } })();
						const meta = (() => {
							try { return (reg && reg[id] && typeof reg[id] === 'object') ? reg[id] : {}; } catch { return {}; }
						})();
						const windowName = (name || meta?.windowName || `_job_${id}`).toString();
						const status = (meta?.status || '').toString();
						const lastSeenAt = Number.isFinite(meta?.lastSeenAt) ? meta.lastSeenAt : null;

						let ref = null;
						try { ref = __jobWindowRefs.get(id); } catch { ref = null; }

						// Prevent re-registration while we purge (job windows publish status every second).
						try {
							const ban = __ensureJobWindowsBanList();
							if (ban) ban[id] = Date.now();
						} catch { }
						try { if (reg && reg[id]) delete reg[id]; } catch { }
						try { __jobWindowRefs.delete(id); } catch { }
						__scheduleRender();

						(async () => {
							// Try to close the job window if it's still alive.
							let w = null;
							try { if (ref && !ref.closed) w = ref; } catch { w = null; }
							if (!w && lastSeenAt && (Date.now() - lastSeenAt < 15000) && status !== 'closed') {
								try {
									const maybe = window.open('', windowName);
									if (maybe && !maybe.closed) w = maybe;
								} catch { }
							}
							if (w && !w.closed) {
								try { __jobWindowRefs.set(id, w); } catch { }
								try { w.postMessage({ type: 'BRANCHING_V12_JOB_CONTROL', cmd: 'clear_and_close' }, '*'); } catch { }
								try { w.close(); } catch { }
							}

							// Delete payload + snapshot so it can't restore later.
							try { localStorage.removeItem(`${__JOB_PAYLOAD_LS_PREFIX}${id}`); } catch { }
							try { await __idbDeleteSnapshot(`job:${id}`); } catch { }

							// Persist updated main snapshot so the removed job doesn't resurrect on restore.
							try { await performSave(); } catch { }

							__scheduleRender();
						})();
					}
					__scheduleRender();
					return;
				}
				if (!jobId) return;
				const job = state.jobs.find(j => j && j.id === jobId);
				if (!job) return;

				if (action === 'start') __startJob(job);
				else if (action === 'resume') __startJob(job);
				else if (action === 'remove') removeJob(jobId);
				__scheduleRender();
			};

			const bindUiOnce = () => {
				const { list, maxConcurrent } = __getJobsUi();
				if (list && !list.dataset.bound) {
					list.dataset.bound = '1';
					list.addEventListener('click', onJobListClick);
				}
				if (maxConcurrent && !maxConcurrent.dataset.bound) {
					maxConcurrent.dataset.bound = '1';
					maxConcurrent.addEventListener('change', () => setMaxConcurrentJobs(maxConcurrent.value));
				}
			};

			const onInit = () => {
				bindUiOnce();
				if (!state.timerId) {
					state.timerId = setInterval(() => {
						try {
							const hasJobWins = (() => {
								try { return __shared?.jobWindows && Object.keys(__shared.jobWindows).length > 0; } catch { return false; }
							})();
							if (state.jobs.some(j => j?.status === 'running') || hasJobWins) __scheduleRender();
						} catch { }
					}, 1000);
				}
				__scheduleRender();
			};

			return {
				onInit,
				addJobFromUi,
				startJob: __startJob,
				resumeAllIncomplete,
				removeJob,
				toggleQueue,
				setQueueRunning,
				setMaxConcurrentJobs,
				tick,
				clear,
				exportState,
				importState,
				attachAgents,
				getState: () => state,
			};
		})();

		window.__jobManager = __jobManager;

		// --- API KEY ROLLER ---
		const apiKeyManager = {
			keys: [],
			idx: 0,
			setKeys(list) {
				this.keys = Array.isArray(list) ? list : [];
				this.idx = 0;
			},
			hasKeys() { return this.keys.length > 0; },
			nextKey() {
				if (!this.keys.length) throw new Error("No API keys configured");
				const key = this.keys[this.idx];
				this.idx = (this.idx + 1) % this.keys.length;
				return key;
			}
		};

		function getApiKeyListFromInput() {
			const raw = document.getElementById('apiKeyList').value || '';
			return __parseApiKeyList(raw);
		}

		function __parseApiKeyList(raw) {
			// Keep API keys byte-for-byte except surrounding whitespace.
			// Do not split by comma or strip trailing punctuation: some providers
			// may issue keys containing punctuation (e.g. ending with comma).
			return (raw || '')
				.toString()
				.split(/\r?\n/g)
				.map((k) => k.trim())
				.filter(Boolean);
		}

		function __coerceApiKeyListTextareaValue(raw) {
			if (Array.isArray(raw)) {
				return raw
					.map((k) => (k ?? '').toString().trim())
					.filter(Boolean)
					.join('\n');
			}
			if (raw && typeof raw === 'object') {
				const keys = Array.isArray(raw.keys) ? raw.keys : null;
				if (keys) {
					return keys
						.map((k) => (k ?? '').toString().trim())
						.filter(Boolean)
						.join('\n');
				}
			}
			if (raw == null) return '';
			return raw.toString();
		}

		function maskKey(key) {
			if (!key) return '';
			return key.length <= 8 ? key : `${key.slice(0, 4)}...${key.slice(-4)}`;
		}

		async function __pickApiKeyWithBackoff(agent, meta = {}) {
			if (!apiKeyManager.hasKeys()) {
				apiKeyManager.setKeys(getApiKeyListFromInput());
			}
			try { __apiKeyLive.syncFromInput(); } catch { }
			const estTokens = Number.isFinite(meta?.estTokens) ? Math.max(0, meta.estTokens) : 0;
			const __MAX_KEY_WAIT_MS = 10 * 60 * 1000;
			const hardWaitStart = Date.now();
			while (true) {
				const keys = Array.isArray(apiKeyManager.keys) ? apiKeyManager.keys : [];
				if (!keys.length) throw new Error("No API keys configured");

				if (agent?.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped by User");
				const now = Date.now();
				let bestReadyAt = Infinity;
				let bestKeyIdx = -1;
				let chosenKey = null;
				let chosenKeyIdx = -1;
				const candidates = [];
				const startIdx = Number.isFinite(apiKeyManager.idx) ? (apiKeyManager.idx % keys.length) : 0;
				const rateEnabled = !!document.getElementById('enableRateLimit')?.checked;
				const rpmLimit = __normalizeRateLimit(document.getElementById('rpmLimit')?.value);
				const tpmLimit = __normalizeRateLimit(document.getElementById('tpmLimit')?.value);
				const paceMs = rpmLimit > 0 ? Math.ceil(60000 / rpmLimit) : 0;
				const gapMs = Math.max(3000, paceMs); // UI gap; effective may be smaller

				for (let off = 0; off < keys.length; off++) {
					const idx = (startIdx + off) % keys.length;
					const k = keys[idx];
					const cooldownUntil = (() => {
						try { return __apiKeyLive.getCooldownUntil?.(k); } catch { return null; }
					})();
					const cooldownReadyAt = (Number.isFinite(cooldownUntil) && cooldownUntil > now) ? cooldownUntil : now;
					const cooldownWaitMs = Math.max(0, cooldownReadyAt - now);

					let rateReadyAt = now;
					let rateGapWaitMs = 0;
					let rateBucketWaitMs = 0;
					let hitRpm = false;
					let hitTpm = false;
					let rpm = null;
					let tpm = null;
					let windowStart = null;
					let lastSentAt = null;
					let effRpmLimit = rpmLimit;
					let effTpmLimit = tpmLimit;
					let effGapMs = gapMs;
					let isTpmOversize = rateEnabled && effTpmLimit > 0 && estTokens > effTpmLimit;
					if (rateEnabled) {
						try {
							const key = k || '__NO_KEY__';
							const state = __applySharedRateLimitsForKey(key, { rpmLimitUi: rpmLimit, tpmLimitUi: tpmLimit });
							__recoverRateStateIfStale(state, now);
							effRpmLimit = Number.isFinite(state?.rpmLimit) ? state.rpmLimit : rpmLimit;
							effTpmLimit = Number.isFinite(state?.tpmLimit) ? state.tpmLimit : tpmLimit;
							const effPaceMs = effRpmLimit > 0 ? Math.ceil(60000 / effRpmLimit) : 0;
							effGapMs = Math.max(3000, effPaceMs);
							isTpmOversize = effTpmLimit > 0 && estTokens > effTpmLimit;

							// (1) Per-key pacing (min gap)
							const ls = Number.isFinite(state?.lastSentAt) ? state.lastSentAt : 0;
							lastSentAt = ls || null;
							const nextByGap = ls ? (ls + effGapMs) : 0;
							if (nextByGap && now < nextByGap) {
								rateGapWaitMs = Math.max(0, nextByGap - now);
								rateReadyAt = Math.max(rateReadyAt, nextByGap);
							}

							// (2) Minute RPM/TPM bucket (predict next availability)
							windowStart = Number.isFinite(state?.windowStart) ? state.windowStart : __minuteStart(now);
							rpm = Number.isFinite(state?.rpm) ? state.rpm : 0;
							tpm = Number.isFinite(state?.tpm) ? state.tpm : 0;
							const win = __minuteStart(now);
							if (win !== windowStart) {
								windowStart = win;
								rpm = 0;
								tpm = 0;
							}

							hitRpm = effRpmLimit > 0 && (rpm + 1 > effRpmLimit);
							hitTpm = effTpmLimit > 0 && (isTpmOversize ? (tpm >= effTpmLimit) : (tpm + estTokens > effTpmLimit));
							if (hitRpm || hitTpm) {
								const nextWin = windowStart + 60000 + 25;
								rateBucketWaitMs = Math.max(0, nextWin - now);
								rateReadyAt = Math.max(rateReadyAt, nextWin);
							}
						} catch { }
					}

					const readyAt = Math.max(cooldownReadyAt, rateReadyAt);
					candidates.push({
						idx,
						key: maskKey(k),
						cooldownWaitMs,
						rateGapWaitMs,
						rateBucketWaitMs,
						readyInMs: Math.max(0, readyAt - now),
						rpmLimit: effRpmLimit,
						tpmLimit: effTpmLimit,
						gapMs: effGapMs,
						hitRpm,
						hitTpm,
						rpm,
						tpm,
						windowStart,
						lastSentAt,
						isTpmOversize,
					});
					if (!chosenKey && readyAt <= now) {
						chosenKey = k;
						chosenKeyIdx = idx;
					}
					if (readyAt < bestReadyAt) {
						bestReadyAt = readyAt;
						bestKeyIdx = idx;
					}
				}

				if (chosenKey) {
					try {
						__keySchedulerLog.add({
							type: 'pick',
							ts: now,
							uniqueId: agent?.uniqueId,
							archId: agent?.config?.id,
							instanceId: agent?.instanceId,
							estTokens,
							rateEnabled,
							rpmLimit,
							tpmLimit,
							gapMs,
							startIdx,
							chosenIdx: chosenKeyIdx,
							chosenKey: maskKey(chosenKey),
							candidates,
						});
					} catch { }
					apiKeyManager.idx = (chosenKeyIdx + 1) % keys.length;
					return chosenKey;
				}

				if (bestReadyAt !== Infinity) {
					const waitMs = Math.max(0, bestReadyAt - now);
					if ((Date.now() - hardWaitStart) > __MAX_KEY_WAIT_MS) {
						const bestKey = (bestKeyIdx >= 0 && keys[bestKeyIdx]) ? maskKey(keys[bestKeyIdx]) : '(unknown)';
						throw new Error(`Key wait exceeded ${Math.round(__MAX_KEY_WAIT_MS / 1000)}s (best=${bestKey}, wait=${Math.round(waitMs / 1000)}s)`);
					}
					try {
						__keySchedulerLog.add({
							type: 'wait',
							ts: now,
							uniqueId: agent?.uniqueId,
							archId: agent?.config?.id,
							instanceId: agent?.instanceId,
							estTokens,
							rateEnabled,
							rpmLimit,
							tpmLimit,
							gapMs,
							startIdx,
							bestKeyIdx,
							bestKey: (bestKeyIdx >= 0 && keys[bestKeyIdx]) ? maskKey(keys[bestKeyIdx]) : null,
							waitMs,
							candidates,
						});
					} catch { }
					await agent.sleepInterruptible(waitMs);
					continue;
				}

				// Fallback: if cooldown state is missing for some reason.
				return apiKeyManager.nextKey();
			}
		}

		// === API TELEMETRY (GLOBAL) ===
		const __apiTelemetry = (() => {
			const DEFAULT_MAX_ENTRIES = 20000;
			const state = {
				version: 1,
				enabled: true,
				maxEntries: DEFAULT_MAX_ENTRIES,
				nextId: 1,
				entries: [],
				byId: new Map(), // id -> entry
				inflight: new Map(), // id -> entry
				ui: { scheduled: false }
			};

			const __now = () => Date.now();
			const __iso = (ms) => {
				try { return new Date(ms).toISOString(); } catch { return ''; }
			};

			const __clip = (val, maxLen = 400) => {
				const s = (val ?? '').toString();
				if (s.length <= maxLen) return s;
				return s.slice(0, maxLen - 1) + '‚Ä¶';
			};

			const __sanitizeUrlForLog = (u) => {
				const raw = (u || '').toString();
				if (!raw) return '';
				try {
					const parsed = new URL(raw);
					parsed.searchParams.delete('key');
					parsed.searchParams.delete('api_key');
					parsed.searchParams.delete('apikey');
					return parsed.toString();
				} catch {
					return raw.replace(/([?&](?:key|api_key|apikey)=)[^&]+/ig, '$1***');
				}
			};

			const __trim = () => {
				if (!Number.isFinite(state.maxEntries) || state.maxEntries <= 0) return;
				if (state.entries.length <= state.maxEntries) return;
				// Prefer trimming only completed entries; never drop inflight.
				while (state.entries.length > state.maxEntries) {
					const idx = state.entries.findIndex(e => e && e.done);
					if (idx < 0) break;
					const [removed] = state.entries.splice(idx, 1);
					if (removed?.id) {
						state.inflight.delete(removed.id);
						state.byId.delete(removed.id);
					}
				}
			};

			const __scheduleUiUpdate = () => {
				if (state.ui.scheduled) return;
				state.ui.scheduled = true;
				const kick = () => {
					state.ui.scheduled = false;
					try { window.updateApiTelemetryPanel?.(); } catch { }
					try { window.updateMainRecentCalls?.(); } catch { }
				};
				try {
					(window.requestAnimationFrame || window.setTimeout)(kick, 0);
				} catch {
					try { setTimeout(kick, 0); } catch { }
				}
			};

			const start = (meta = {}) => {
				if (!state.enabled) return null;
				const id = state.nextId++;
				const t0 = __now();
				const entry = {
					id,
					t0,
					iso0: __iso(t0),
					seq: Number.isFinite(meta.seq) ? meta.seq : null,
					archId: meta.archId || '',
					archName: meta.archName || '',
					instanceId: meta.instanceId || '',
					uniqueId: meta.uniqueId || '',
					apiMode: meta.apiMode || '',
					model: meta.model || '',
					url: __sanitizeUrlForLog(meta.url),
					key: meta.key || '',
					estTokens: Number.isFinite(meta.estTokens) ? meta.estTokens : null,
					rateWaitMs: null,
					sentAt: null,
					respAt: null,
					latencyMs: null,
					totalMs: null,
					ok: null,
					httpStatus: null,
					errorType: null,
					errorMessage: null,
					errorBody: null,
					validationPassed: null,
					validationReason: null,
					done: false
				};
				state.entries.push(entry);
				state.byId.set(id, entry);
				state.inflight.set(id, entry);
				__trim();
				__scheduleUiUpdate();
				return id;
			};

			const __get = (id) => {
				if (!id) return null;
				return state.byId.get(id) || null;
			};

			const markRateWait = (id, waitMs) => {
				const e = __get(id);
				if (!e) return;
				e.rateWaitMs = Number.isFinite(waitMs) ? Math.max(0, Math.round(waitMs)) : null;
				__scheduleUiUpdate();
			};

			const markSent = (id, extra = {}) => {
				const e = __get(id);
				if (!e) return;
				const t = __now();
				e.sentAt = t;
				if (extra?.url) e.url = __sanitizeUrlForLog(extra.url);
				__scheduleUiUpdate();
			};

			const markResponse = (id, res = {}) => {
				const e = __get(id);
				if (!e) return;
				const t = __now();
				e.respAt = t;
				e.ok = typeof res.ok === 'boolean' ? res.ok : e.ok;
				e.httpStatus = Number.isFinite(res.httpStatus) ? res.httpStatus : (Number.isFinite(res.status) ? res.status : e.httpStatus);
				e.errorType = res.errorType ? __clip(res.errorType, 40) : e.errorType;
				e.errorMessage = res.errorMessage ? __clip(res.errorMessage, 240) : e.errorMessage;
				e.errorBody = res.errorBody ? __clip(res.errorBody, 400) : e.errorBody;
				e.latencyMs = Number.isFinite(res.latencyMs) ? Math.max(0, Math.round(res.latencyMs)) : e.latencyMs;
				e.totalMs = Number.isFinite(res.totalMs) ? Math.max(0, Math.round(res.totalMs)) : (t - (e.t0 || t));
				e.done = true;
				state.inflight.delete(id);
				__trim();
				__scheduleUiUpdate();
			};

			const markValidation = (id, v = {}) => {
				const e = __get(id);
				if (!e) return;
				if (typeof v.passed === 'boolean') e.validationPassed = v.passed;
				if (v.reason != null) e.validationReason = __clip(v.reason, 200);
				__scheduleUiUpdate();
			};

			const clear = () => {
				state.entries = [];
				state.byId = new Map();
				state.inflight = new Map();
				state.nextId = 1;
				__scheduleUiUpdate();
			};

			const exportState = () => {
				return {
					version: state.version,
					enabled: state.enabled,
					maxEntries: state.maxEntries,
					nextId: state.nextId,
					entries: state.entries
				};
			};

			const importState = (obj) => {
				if (!obj || typeof obj !== 'object') return;
				const hadNextId = Number.isFinite(obj.nextId);
				const incoming = Array.isArray(obj.entries) ? obj.entries : [];
				state.enabled = typeof obj.enabled === 'boolean' ? obj.enabled : state.enabled;
				state.maxEntries = Number.isFinite(obj.maxEntries) ? obj.maxEntries : state.maxEntries;
				state.nextId = hadNextId ? obj.nextId : state.nextId;
				state.entries = incoming.map((e) => {
					const safe = { ...(e || {}) };
					safe.errorBody = __clip(safe.errorBody, 400);
					safe.errorMessage = __clip(safe.errorMessage, 240);
					safe.validationReason = __clip(safe.validationReason, 200);
					safe.done = !!safe.done;
					return safe;
				});
				state.byId = new Map();
				let maxId = 0;
				for (const e of state.entries) {
					if (e && Number.isFinite(e.id)) {
						state.byId.set(e.id, e);
						if (e.id > maxId) maxId = e.id;
					}
				}
				if (!hadNextId) state.nextId = maxId + 1;
				else state.nextId = Math.max(state.nextId, maxId + 1);
				state.inflight = new Map();
				// No inflight restore (treat as completed/unknown)
				__trim();
				__scheduleUiUpdate();
			};

			const setEnabled = (enabled) => {
				state.enabled = !!enabled;
				__scheduleUiUpdate();
			};

			const setMaxEntries = (n) => {
				const v = Number(n);
				if (!Number.isFinite(v) || v <= 0) return;
				state.maxEntries = Math.round(v);
				__trim();
				__scheduleUiUpdate();
			};

			const getState = () => state;

			return { start, markRateWait, markSent, markResponse, markValidation, clear, exportState, importState, setEnabled, setMaxEntries, getState, __sanitizeUrlForLog };
		})();

		window.__apiTelemetry = __apiTelemetry;

		// === KEY SCHEDULER LOG (GLOBAL) ===
		const __keySchedulerLog = (() => {
			const DEFAULT_MAX_ENTRIES = 5000;
			const state = {
				version: 1,
				enabled: true,
				maxEntries: DEFAULT_MAX_ENTRIES,
				nextId: 1,
				entries: [],
			};

			const __now = () => Date.now();

			const __trim = () => {
				const max = Number.isFinite(state.maxEntries) ? state.maxEntries : DEFAULT_MAX_ENTRIES;
				if (state.entries.length <= max) return;
				state.entries.splice(0, state.entries.length - max);
			};

			const add = (entry) => {
				if (!state.enabled) return null;
				const e = { ...(entry || {}) };
				e.id = state.nextId++;
				e.ts = Number.isFinite(e.ts) ? e.ts : __now();
				state.entries.push(e);
				__trim();
				return e.id;
			};

			const clear = () => {
				state.entries = [];
				state.nextId = 1;
			};

			const exportState = () => ({
				version: state.version,
				enabled: state.enabled,
				maxEntries: state.maxEntries,
				nextId: state.nextId,
				entries: Array.isArray(state.entries) ? state.entries : [],
			});

			const importState = (obj) => {
				if (!obj || typeof obj !== 'object') return;
				state.enabled = typeof obj.enabled === 'boolean' ? obj.enabled : state.enabled;
				state.maxEntries = Number.isFinite(obj.maxEntries) ? obj.maxEntries : state.maxEntries;
				state.nextId = Number.isFinite(obj.nextId) ? obj.nextId : state.nextId;
				state.entries = Array.isArray(obj.entries) ? obj.entries : [];
				__trim();
			};

			const setEnabled = (enabled) => { state.enabled = !!enabled; };
			const setMaxEntries = (n) => {
				const v = Number(n);
				if (!Number.isFinite(v) || v <= 0) return;
				state.maxEntries = Math.round(v);
				__trim();
			};

			const getState = () => state;

			return { add, clear, exportState, importState, setEnabled, setMaxEntries, getState };
		})();

		window.__keySchedulerLog = __keySchedulerLog;

		// === LIVE API-KEY MONITOR (Always visible) ===
		const __apiKeyLive = (() => {
			const state = {
				byKey: new Map(), // rawKey -> { masked, phase, archLabel, estTokens, sentAt, lastHttpStatus, lastMsg, retryUntil, retryHttpStatus }
				order: [],
				ui: { scheduled: false },
				timerId: null,
			};

			const __now = () => Date.now();

			const ensure = (rawKey) => {
				if (!rawKey) return null;
				if (!state.byKey.has(rawKey)) {
					state.byKey.set(rawKey, {
						rawKey,
						masked: maskKey(rawKey),
						phase: 'idle', // idle | waiting_rate | inflight
						archLabel: '',
						lastUniqueId: '',
						estTokens: null,
						sentAt: null,
						lastSentAt: null,
						ageFrozenSec: null,
						pendingCount: 0,
						inflightCount: 0,
						lastHttpStatus: null,
						lastMsg: '',
						retryUntil: null,
						retryHttpStatus: null,
						retryCount: 0,
						updatedAt: __now(),
					});
				}
				const s = state.byKey.get(rawKey);
				if (s) s.masked = maskKey(rawKey);
				return s;
			};

			const syncFromInput = () => {
				const keys = getApiKeyListFromInput();
				const seen = new Set(keys);
				// remove deleted
				for (const k of state.byKey.keys()) {
					if (!seen.has(k)) state.byKey.delete(k);
				}
				state.order = keys;
				for (const k of keys) ensure(k);
				return keys;
			};

			const __scheduleRender = () => {
				if (state.ui.scheduled) return;
				state.ui.scheduled = true;
				const kick = () => {
					state.ui.scheduled = false;
					try { render(); } catch { }
				};
				try { (window.requestAnimationFrame || window.setTimeout)(kick, 0); } catch { try { setTimeout(kick, 0); } catch { } }
			};

			const __isRetrying = (s, now) => {
				if (!s) return false;
				if (!Number.isFinite(s.retryUntil)) return false;
				return now < s.retryUntil;
			};

			const render = () => {
				const outEl = document.getElementById('key-monitor-output');
				if (!outEl) return;

				syncFromInput();
				const now = __now();
				const esc = (v) => {
					const s = (v ?? '').toString();
					return s.replace(/[&<>"']/g, (ch) => {
						if (ch === '&') return '&amp;';
						if (ch === '<') return '&lt;';
						if (ch === '>') return '&gt;';
						if (ch === '"') return '&quot;';
						return '&#39;';
					});
				};
				const keys = state.order.length ? state.order : [...state.byKey.keys()];
				if (!keys.length) {
					outEl.innerHTML = `<div style="color:var(--text-3); font-family:monospace; font-size:11px;">No API keys configured.</div>`;
					return;
				}

				const rows = [];
				for (let i = 0; i < keys.length; i++) {
					const rawKey = keys[i];
					const s = ensure(rawKey);
					if (!s) continue;
					const retrying = __isRetrying(s, now);
					const inflightN = Number.isFinite(s.inflightCount) ? s.inflightCount : 0;
					const hasInflight = inflightN > 0;
					const hasPending = Number.isFinite(s.pendingCount) && s.pendingCount > 0;
					const inflightLabel = hasInflight ? (inflightN > 1 ? `INFLIGHT x${inflightN}` : 'INFLIGHT') : '';
					const dotColor = retrying
						? 'var(--log-error)'
						: (hasInflight || s.phase === 'inflight'
							? 'var(--status-success)'
							: ((hasPending || s.phase === 'waiting_rate') ? 'var(--log-error)' : 'var(--log-success)'));

					const estTok = Number.isFinite(s.estTokens) ? s.estTokens.toString() : '-';
					let age = '-';
					if (Number.isFinite(s.lastSentAt)) {
						const ageSec = Number.isFinite(s.ageFrozenSec)
							? s.ageFrozenSec
							: ((now - s.lastSentAt) / 1000);
						age = `${Math.max(0, ageSec).toFixed(1)}s`;
					}
					const retryCount = (Number.isFinite(s.retryCount) && s.retryCount > 0) ? s.retryCount : 0;
					let retryCol = retryCount > 0 ? `x${retryCount}` : '-';
					if (retrying) {
						const left = Math.max(0, Math.ceil((s.retryUntil - now) / 1000));
						retryCol = Number.isFinite(s.retryHttpStatus)
							? `${s.retryHttpStatus} ${left}s x${retryCount}`
							: `cool ${left}s x${retryCount}`;
					}

					let statusText = '';
					if (hasInflight || s.phase === 'inflight') {
						statusText = inflightLabel || 'INFLIGHT';
					} else if (hasPending || s.phase === 'waiting_rate') {
						const n = Number.isFinite(s.pendingCount) ? s.pendingCount : 0;
						statusText = n > 1 ? `WAIT_RATE x${n} (RPM/TPM waiting)` : 'WAIT_RATE (RPM/TPM saturated)';
					} else if (retrying) {
						statusText = 'COOLDOWN';
					} else if (Number.isFinite(s.lastHttpStatus)) {
						statusText = `HTTP ${s.lastHttpStatus}`;
					} else {
						statusText = 'IDLE';
					}

					const msg = (s.lastMsg || '').toString();
					const msgEsc = esc(msg);
					const archEsc = esc(s.archLabel || '-');

					rows.push(
						`<div class="key-monitor-row" title="${msgEsc}">` +
						`<div class="key-monitor-dot" style="color:${dotColor};">‚óè</div>` +
						`<div class="key-monitor-col idx">${i + 1}</div>` +
						`<div class="key-monitor-col key">${esc(s.masked)}</div>` +
						`<div class="key-monitor-col arch">${archEsc}</div>` +
						`<div class="key-monitor-col tok">${esc(estTok)}</div>` +
						`<div class="key-monitor-col age">${esc(age)}</div>` +
						`<div class="key-monitor-col retry">${esc(retryCol)}</div>` +
						`<div class="key-monitor-col status">${esc(statusText)}${msg ? ` ‚Äî ${msgEsc}` : ''}</div>` +
						`</div>`
					);
				}

				outEl.innerHTML = rows.join('');
			};

			const __archLabel = (meta) => {
				const archId = meta?.archId || '';
				const inst = meta?.instanceId || '';
				const label = `${archId}${inst ? `#${inst}` : ''}`.trim();
				return label || '';
			};

			const onPrepare = (rawKey, meta = {}) => {
				const s = ensure(rawKey);
				if (!s) return;
				s.phase = 'waiting_rate';
				s.pendingCount = Math.max(0, (Number.isFinite(s.pendingCount) ? s.pendingCount : 0) + 1);
				s.archLabel = __archLabel(meta);
				s.lastUniqueId = meta?.uniqueId ? meta.uniqueId : s.lastUniqueId;
				s.ageFrozenSec = null;
				s.estTokens = Number.isFinite(meta.estTokens) ? meta.estTokens : s.estTokens;
				s.sentAt = null;
				s.updatedAt = __now();
				// Keep retry flag while countdown is active (429), but clear stale values.
				if (Number.isFinite(s.retryUntil) && __now() >= s.retryUntil) {
					s.retryUntil = null;
					s.retryHttpStatus = null;
				}
				__scheduleRender();
			};

			const onSent = (rawKey, meta = {}) => {
				const s = ensure(rawKey);
				if (!s) return;
				if (Number.isFinite(s.pendingCount) && s.pendingCount > 0) s.pendingCount -= 1;
				s.inflightCount = Math.max(0, (Number.isFinite(s.inflightCount) ? s.inflightCount : 0) + 1);
				s.phase = 'inflight';
				s.archLabel = __archLabel(meta);
				s.lastUniqueId = meta?.uniqueId ? meta.uniqueId : s.lastUniqueId;
				s.ageFrozenSec = null;
				s.estTokens = Number.isFinite(meta.estTokens) ? meta.estTokens : s.estTokens;
				s.sentAt = __now();
				s.lastSentAt = s.sentAt;
				s.updatedAt = __now();
				__scheduleRender();
			};

			const onDone = (rawKey, meta = {}) => {
				const s = ensure(rawKey);
				if (!s) return;
				const doneAt = __now();
				s.inflightCount = Math.max(0, (Number.isFinite(s.inflightCount) ? s.inflightCount : 0) - 1);
				if (Number.isFinite(s.pendingCount) && s.pendingCount > 0) s.phase = 'waiting_rate';
				else s.phase = 'idle';
				s.sentAt = null;
				s.lastUniqueId = meta?.uniqueId ? meta.uniqueId : s.lastUniqueId;
				if (Number.isFinite(meta.httpStatus)) s.lastHttpStatus = meta.httpStatus;
				if (meta.message != null) s.lastMsg = (meta.message || '').toString().slice(0, 220);
				const doneMsg = (meta?.message ?? '').toString();
				if (!Number.isFinite(s.ageFrozenSec) && Number.isFinite(s.lastSentAt) && /\bstopped\b/i.test(doneMsg)) {
					s.ageFrozenSec = Math.max(0, (doneAt - s.lastSentAt) / 1000);
				}
				const okMsg = /^ok$/i.test((doneMsg || '').trim());
				const isHttpOk = Number.isFinite(meta.httpStatus) && meta.httpStatus >= 200 && meta.httpStatus < 400;
				if (isHttpOk || okMsg || meta?.ok === true) {
					s.retryCount = 0;
					s.retryUntil = null;
					s.retryHttpStatus = null;
					try {
						const rs = __rateState?.get?.(rawKey || '__NO_KEY__');
						if (rs) {
							rs.cooldownUntil = null;
							rs.cooldownRetryCount = 0;
						}
					} catch { }
				}
				s.updatedAt = doneAt;
				__scheduleRender();
			};

			const onRetry = (rawKey, meta = {}) => {
				const s = ensure(rawKey);
				if (!s) return { delayMs: 0, retryCount: 0, retryUntil: null };
				const status = Number.isFinite(meta.httpStatus) ? meta.httpStatus : null;
				s.retryCount = (Number.isFinite(s.retryCount) ? s.retryCount : 0) + 1;
				const streak = s.retryCount;

				const __computeBackoffMs = (n, httpStatus) => {
					// Key-level backoff: 3s -> 10s -> 30s -> 60s -> (cap at 60s)
					let baseDelay;
					if (n <= 1) baseDelay = 3000;
					else if (n === 2) baseDelay = 10000;
					else if (n === 3) baseDelay = 30000;
					else baseDelay = 60000;

					return Math.min(baseDelay, 60000);
				};

				const delayMs = Number.isFinite(meta.delayMs)
					? Math.max(0, meta.delayMs)
					: __computeBackoffMs(streak, status);

				if (delayMs > 0) {
					const now = __now();
					s.retryHttpStatus = status;
					const until = now + delayMs;
					s.retryUntil = Number.isFinite(s.retryUntil) ? Math.max(s.retryUntil, until) : until;
				}
				try {
					const rs = __ensureRateStateForKey(rawKey);
					if (Number.isFinite(s.retryUntil)) {
						rs.cooldownUntil = Number.isFinite(rs.cooldownUntil) ? Math.max(rs.cooldownUntil, s.retryUntil) : s.retryUntil;
					}
					rs.cooldownRetryCount = Number.isFinite(rs.cooldownRetryCount) ? Math.max(rs.cooldownRetryCount, streak) : streak;
				} catch { }
				s.updatedAt = __now();
				__scheduleRender();
				return { delayMs, retryCount: streak, retryUntil: s.retryUntil, httpStatus: status };
			};

			const getCooldownUntil = (rawKey) => {
				const s = ensure(rawKey);
				if (!s) return null;
				let until = Number.isFinite(s.retryUntil) ? s.retryUntil : null;
				try {
					const rs = __rateState?.get?.(rawKey || '__NO_KEY__');
					const globalUntil = rs?.cooldownUntil;
					if (Number.isFinite(globalUntil)) {
						until = Number.isFinite(until) ? Math.max(until, globalUntil) : globalUntil;
					}
				} catch { }
				return Number.isFinite(until) ? until : null;
			};

			const clear = () => {
				state.byKey.clear();
				state.order = [];
				__scheduleRender();
			};

			const freezeAgeByUniqueId = (uniqueId) => {
				const uid = (uniqueId || '').toString();
				if (!uid) return;
				const now = __now();
				for (const s of state.byKey.values()) {
					if (!s) continue;
					if ((s.lastUniqueId || '') !== uid) continue;
					if (!Number.isFinite(s.lastSentAt)) continue;
					if (Number.isFinite(s.ageFrozenSec)) continue;
					s.ageFrozenSec = Math.max(0, (now - s.lastSentAt) / 1000);
					s.updatedAt = now;
				}
				__scheduleRender();
			};

			const startLoop = () => {
				if (state.timerId) return;
				state.timerId = setInterval(() => __scheduleRender(), 250);
			};

			startLoop();

			return { syncFromInput, onPrepare, onSent, onDone, onRetry, freezeAgeByUniqueId, getCooldownUntil, clear, getState: () => state };
		})();

		window.__apiKeyLive = __apiKeyLive;

		// Refresh per-agent key/retry countdowns (lightweight UI loop)
		let __agentLiveTimerId = null;
		function __startAgentLiveLoop() {
			if (__agentLiveTimerId) return;
			__agentLiveTimerId = setInterval(() => {
				for (const a of (agents || [])) {
					try { a?.refreshLiveRequestInfoUI?.(); } catch { }
				}
			}, 250);
		}

		let __globalCallStatsTimerId = null;
		function __startGlobalCallStatsLoop() {
			if (__globalCallStatsTimerId) return;
			__globalCallStatsTimerId = setInterval(() => {
				try { updateGlobalCallStatsUI(); } catch { }
			}, 1000);
		}

		function setupKeyMonitorCard() {
			if (__isJobWindow) return;
			const resArea = document.getElementById('resultsArea');
			if (!resArea) return;
			if (document.getElementById('key-monitor-card')) return;

			const card = document.createElement('div');
			card.className = 'architecture-result';
			card.id = 'key-monitor-card';

			card.innerHTML = `
		                <div class="status-header" style="color:var(--base); border-color:var(--base)">
		                    <span>API Key Live Monitor</span>
		                    <span style="font-size:11px; color:var(--text-3);">green=idle, yellow=inflight, red=wait_rate/retry ‚Ä¢ tokens=est ‚Ä¢ age=since sent</span>
		                </div>
			                <div style="display:flex; gap:10px; flex-wrap:wrap;">
			                    <div style="flex:1; min-width:360px; min-height:0; display:flex; flex-direction:column;">
			                        <div style="display:flex; gap:10px; font-size:11px; color:var(--text-3); font-family:monospace; padding:4px 0;">
			                            <div style="width:10px;"></div>
		                            <div style="width:28px; text-align:right;">#</div>
		                            <div style="width:90px;">Key</div>
		                            <div style="width:120px;">Arch</div>
		                            <div style="width:85px; text-align:right;">estTok</div>
		                            <div style="width:80px; text-align:right;">age</div>
		                            <div style="width:60px; text-align:right;">retry</div>
		                            <div style="flex:1;">status</div>
		                        </div>
		                        <div class="log-mini" id="key-monitor-output" style="max-height:360px; font-size:12px;"></div>
		                    </div>
			                    <div style="flex:1; min-width:360px; min-height:0; display:flex; flex-direction:column;">
			                        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
			                            <div style="font-size:11px; font-weight:bold; margin:2px 0;">Recent Calls (50)</div>
			                            <div id="main-global-totals" style="font-size:10px; font-family:monospace; color:var(--text-3);">calls 0 ‚Ä¢ ok 0 ‚Ä¢ reject 0 ‚Ä¢ fail 0</div>
			                        </div>
			                        <div class="log-mini" id="main-recent-calls" style="max-height:360px; font-size:12px; white-space:pre;"></div>
			                    </div>
		                </div>
		            `;

			resArea.insertBefore(card, resArea.firstChild || null);
			try { __apiKeyLive.syncFromInput(); } catch { }
			try { updateMainRecentCalls(); } catch { }
			try { updateGlobalCallStatsUI(); } catch { }
		}

		// === STATS MODAL (shown only when requested) ===
		function setupStatsModal() {
			if (document.getElementById('stats-modal')) return;
			const modal = document.createElement('div');
			modal.id = 'stats-modal';
			modal.className = 'modal-overlay';
			modal.innerHTML = `
	                <div class="modal-window" role="dialog" aria-modal="true">
	                    <div class="modal-header">
	                        <div class="modal-title">Statistics</div>
	                        <div class="button-group" style="margin:0;">
	                            <button id="stats-close-btn" class="cs-btn" style="flex:0 0 auto;">Close</button>
	                        </div>
		                    </div>
		                    <div class="modal-tabs">
		                        <button id="tab-telemetry" class="tab-btn active">API Telemetry</button>
		                        <button id="tab-key-scheduler" class="tab-btn">Key Scheduler</button>
		                        <button id="tab-raw" class="tab-btn">Raw Output</button>
		                    </div>
		                    <div class="modal-body">
		                        <div id="panel-telemetry" class="tab-panel active">
	                            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
	                                <div class="form-group" style="margin:0; min-width:170px;">
	                                    <label class="cs-input__label" style="font-size:11px;">Group</label>
	                                    <select id="stats-telemetry-group" class="cs-input" style="font-size:11px;padding:2px 4px;"></select>
	                                </div>
	                                <div class="form-group" style="margin:0; min-width:160px;">
	                                    <label class="cs-input__label" style="font-size:11px;">Architecture</label>
	                                    <select id="stats-telemetry-arch" class="cs-input" style="font-size:11px;padding:2px 4px;"></select>
	                                </div>
	                                <div class="form-group" style="margin:0; width:140px;">
		                                    <label class="cs-input__label" style="font-size:11px;">Scale</label>
		                                    <select id="stats-telemetry-scale" class="cs-input" style="font-size:11px;padding:2px 4px;">
		                                        <option value="minute" selected>Minute</option>
		                                        <option value="hour">Hour</option>
		                                        <option value="day">Day</option>
		                                    </select>
		                                </div>
	                                <div class="form-group" style="margin:0; width:140px;">
	                                    <label class="cs-input__label" style="font-size:11px;">Range</label>
	                                    <select id="stats-telemetry-range" class="cs-input" style="font-size:11px;padding:2px 4px;"></select>
	                                </div>
	                                <div class="form-group" style="margin:0; width:120px;">
	                                    <label class="cs-input__label" style="font-size:11px;">Recent</label>
	                                    <select id="stats-telemetry-recent-limit" class="cs-input" style="font-size:11px;padding:2px 4px;">
	                                        <option value="50">50</option>
	                                        <option value="100" selected>100</option>
	                                        <option value="200">200</option>
	                                        <option value="500">500</option>
	                                    </select>
	                                </div>
	                                <div class="form-group" style="margin:0; width:110px;">
	                                    <label class="cs-input__label" style="font-size:11px;">Max logs</label>
	                                    <input id="stats-telemetry-max" class="cs-input" type="number" min="1000" step="1000" value="20000" style="font-size:11px;padding:2px 4px;">
	                                </div>
	                                <div class="form-group" style="margin:0; width:90px;">
	                                    <label class="cs-input__label" style="font-size:11px;">Enabled</label>
	                                    <input id="stats-telemetry-enabled" type="checkbox" checked style="transform:scale(1.05);">
	                                </div>
	                            </div>
	
		                            <div class="button-group" style="margin-top:6px;">
		                                <button id="statsTelemetryRefreshBtn" class="cs-btn">Refresh</button>
		                                <button id="statsTelemetryClearBtn" class="cs-btn">Clear</button>
		                                <button id="statsTelemetryDownloadCsvBtn" class="cs-btn">Download CSV</button>
		                                <button id="statsTelemetryDownloadJsonlBtn" class="cs-btn">Download JSONL</button>
		                            </div>

		                            <div style="margin-top:6px; padding:6px; border:1px solid var(--border-dark); background:#0f172a;">
		                                <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
		                                    <div style="font-size:11px; font-weight:bold;">Global Counters (unlimited)</div>
		                                    <div style="font-size:10px; color:var(--text-3); font-family:monospace;">calls=sent ‚Ä¢ ok=validation passed</div>
		                                </div>
		                                <div class="metrics" style="margin-top:4px;">
		                                    <div class="metric-item"><span>All calls:</span><span id="gs-all-calls">0</span></div>
		                                    <div class="metric-item"><span>All ok:</span><span id="gs-all-success">0</span></div>
		                                    <div class="metric-item"><span>All reject:</span><span id="gs-all-reject">0</span></div>
		                                    <div class="metric-item"><span>All fail:</span><span id="gs-all-fail">0</span></div>
		                                </div>
		                                <div class="metrics" style="margin-top:4px;">
		                                    <div class="metric-item"><span>1h calls:</span><span id="gs-1h-calls">0</span></div>
		                                    <div class="metric-item"><span>1h ok:</span><span id="gs-1h-success">0</span></div>
		                                    <div class="metric-item"><span>1h reject:</span><span id="gs-1h-reject">0</span></div>
		                                    <div class="metric-item"><span>1h fail:</span><span id="gs-1h-fail">0</span></div>
		                                </div>
		                                <div class="metrics" style="margin-top:4px;">
		                                    <div class="metric-item"><span>24h calls:</span><span id="gs-24h-calls">0</span></div>
		                                    <div class="metric-item"><span>24h ok:</span><span id="gs-24h-success">0</span></div>
		                                    <div class="metric-item"><span>24h reject:</span><span id="gs-24h-reject">0</span></div>
		                                    <div class="metric-item"><span>24h fail:</span><span id="gs-24h-fail">0</span></div>
		                                </div>
		                                <div style="display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap; margin-top:4px;">
		                                    <div class="form-group" style="margin:0; width:110px;">
		                                        <label class="cs-input__label" style="font-size:11px;">Custom days</label>
		                                        <input id="gs-custom-days" class="cs-input" type="number" min="0" step="1" value="7" style="font-size:11px;padding:2px 4px;">
		                                    </div>
		                                    <div class="form-group" style="margin:0; width:110px;">
		                                        <label class="cs-input__label" style="font-size:11px;">Custom hours</label>
		                                        <input id="gs-custom-hours" class="cs-input" type="number" min="0" step="1" value="0" style="font-size:11px;padding:2px 4px;">
		                                    </div>
		                                    <button id="gs-custom-apply" class="cs-btn" style="flex:0 0 auto;">Apply</button>
		                                </div>
		                                <div class="metrics" style="margin-top:4px;">
		                                    <div class="metric-item"><span>Custom calls:</span><span id="gs-custom-calls">0</span></div>
		                                    <div class="metric-item"><span>Custom ok:</span><span id="gs-custom-success">0</span></div>
		                                    <div class="metric-item"><span>Custom reject:</span><span id="gs-custom-reject">0</span></div>
		                                    <div class="metric-item"><span>Custom fail:</span><span id="gs-custom-fail">0</span></div>
		                                </div>
		                            </div>
		
		                            <div class="metrics" style="margin-top:6px;">
		                                <div class="metric-item"><span>Total:</span><span id="stats-telemetry-total">0</span></div>
		                                <div class="metric-item"><span>Success:</span><span id="stats-telemetry-success">0</span></div>
	                                <div class="metric-item"><span>Fail:</span><span id="stats-telemetry-fail">0</span></div>
	                                <div class="metric-item"><span>Reject:</span><span id="stats-telemetry-reject">0</span></div>
	                                <div class="metric-item"><span>In-flight:</span><span id="stats-telemetry-inflight">0</span></div>
	                                <div class="metric-item"><span>Avg wait:</span><span id="stats-telemetry-avgwait">-</span></div>
	                                <div class="metric-item"><span>Avg lat:</span><span id="stats-telemetry-avglat">-</span></div>
	                            </div>
	
	                            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:6px; min-height:0; flex:1;">
	                                <div style="flex:1; min-width:420px; min-height:0; display:flex; flex-direction:column;">
	                                    <div style="font-size:11px; font-weight:bold; margin-bottom:2px;">Recent Calls (sent/wait/resp)</div>
	                                    <div class="log-mini" id="stats-telemetry-recent" style="max-height:220px; white-space:pre;"></div>
	                                </div>
	                                <div style="flex:1; min-width:520px; min-height:0; display:flex; flex-direction:column;">
	                                    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
	                                        <div style="font-size:11px; font-weight:bold;">Buckets</div>
	                                        <div style="display:flex; gap:10px; font-size:10px; font-family:monospace; color:var(--text-3);">
	                                            <span><span style="color:var(--log-success);">‚ñ†</span> success</span>
	                                            <span><span style="color:var(--red-grp);">‚ñ†</span> reject</span>
	                                            <span><span style="color:var(--log-error);">‚ñ†</span> fail</span>
	                                            <span><span style="color:var(--text-3);">‚ñ†</span> inflight</span>
	                                        </div>
	                                    </div>
	                                    <canvas id="stats-telemetry-chart" width="900" height="220" style="width:100%; height:170px; border:1px solid var(--border-dark); background:#0f172a;"></canvas>
	                                    <div style="flex:1; min-height:0; overflow:auto; border:1px solid var(--border-dark); background:#0f172a; margin-top:6px;">
	                                        <table class="cs-table">
	                                            <thead>
	                                                <tr>
	                                                    <th>Bucket</th><th>Total</th><th>Success</th><th>Reject</th><th>Fail</th><th>In-flight</th><th>Fail%</th>
	                                                </tr>
	                                            </thead>
	                                            <tbody id="stats-telemetry-buckets-body"></tbody>
	                                        </table>
	                                    </div>
	                                </div>
		                            </div>
		                        </div>

		                        <div id="panel-key-scheduler" class="tab-panel">
		                            <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end;">
		                                <div class="form-group" style="margin:0; width:120px;">
		                                    <label class="cs-input__label" style="font-size:11px;">Recent</label>
		                                    <select id="stats-key-sched-recent-limit" class="cs-input" style="font-size:11px;padding:2px 4px;">
		                                        <option value="50">50</option>
		                                        <option value="100" selected>100</option>
		                                        <option value="200">200</option>
		                                        <option value="500">500</option>
		                                        <option value="1000">1000</option>
		                                    </select>
		                                </div>
		                                <div class="form-group" style="margin:0; width:90px;">
		                                    <label class="cs-input__label" style="font-size:11px;">Enabled</label>
		                                    <input id="stats-key-sched-enabled" type="checkbox" checked style="transform:scale(1.05);">
		                                </div>
		                                <div class="form-group" style="margin:0; width:140px;">
		                                    <label class="cs-input__label" style="font-size:11px;">Max entries</label>
		                                    <input id="stats-key-sched-max" class="cs-input" type="number" min="100" step="100" value="5000" style="font-size:11px;padding:2px 4px;">
		                                </div>
		                            </div>

		                            <div class="button-group" style="margin-top:6px;">
		                                <button id="statsKeySchedRefreshBtn" class="cs-btn">Refresh</button>
		                                <button id="statsKeySchedClearBtn" class="cs-btn">Clear</button>
		                                <button id="statsKeySchedDownloadJsonlBtn" class="cs-btn">Download JSONL</button>
		                            </div>

		                            <div class="log-mini" id="stats-key-sched-output" style="max-height:60vh; white-space:pre;"></div>
		                        </div>
		
		                        <div id="panel-raw" class="tab-panel">
		                            <div id="stats-raw-root" style="flex:1; min-height:0; overflow:auto;"></div>
		                        </div>
	                    </div>
	                </div>
	            `;
			document.body.appendChild(modal);

			const close = () => closeStatsModal();
			document.getElementById('stats-close-btn').addEventListener('click', close);
			modal.addEventListener('click', (e) => { if (e.target === modal) close(); });
			window.addEventListener('keydown', (e) => { if (e.key === 'Escape') close(); });

			const setTab = (tab) => {
				const btnT = document.getElementById('tab-telemetry');
				const btnK = document.getElementById('tab-key-scheduler');
				const btnR = document.getElementById('tab-raw');
				const pT = document.getElementById('panel-telemetry');
				const pK = document.getElementById('panel-key-scheduler');
				const pR = document.getElementById('panel-raw');
				const isT = tab === 'telemetry';
				const isK = tab === 'key-scheduler';
				const isR = tab === 'raw';
				btnT.classList.toggle('active', isT);
				btnK.classList.toggle('active', isK);
				btnR.classList.toggle('active', isR);
				pT.classList.toggle('active', isT);
				pK.classList.toggle('active', isK);
				pR.classList.toggle('active', isR);
				if (isR) {
					// Lazy mount analysis UI when opening Raw tab
					try { setupAnalysisCard('stats-raw-root'); } catch { }
					try { if (typeof updateAnalysisGroupOptions === 'function') updateAnalysisGroupOptions(); } catch { }
					try { if (typeof updateAnalysisArchOptions === 'function') updateAnalysisArchOptions(); } catch { }
					try { if (typeof updateAnalysisPanel === 'function') updateAnalysisPanel(); } catch { }
				} else if (isT) {
					try { if (typeof updateApiTelemetryPanel === 'function') updateApiTelemetryPanel(); } catch { }
				} else if (isK) {
					try { if (typeof updateKeySchedulerPanel === 'function') updateKeySchedulerPanel(); } catch { }
				}
			};
			document.getElementById('tab-telemetry').addEventListener('click', () => setTab('telemetry'));
			document.getElementById('tab-key-scheduler').addEventListener('click', () => setTab('key-scheduler'));
			document.getElementById('tab-raw').addEventListener('click', () => setTab('raw'));

			// Wire telemetry controls
			document.getElementById('statsTelemetryRefreshBtn').addEventListener('click', updateApiTelemetryPanel);
			document.getElementById('statsTelemetryClearBtn').addEventListener('click', () => {
				if (confirm('Clear API telemetry logs?')) __apiTelemetry.clear();
			});
			document.getElementById('statsTelemetryDownloadCsvBtn').addEventListener('click', () => downloadApiTelemetry('csv'));
			document.getElementById('statsTelemetryDownloadJsonlBtn').addEventListener('click', () => downloadApiTelemetry('jsonl'));

			document.getElementById('stats-telemetry-scale').addEventListener('change', () => {
				setupTelemetryRangeOptions();
				updateApiTelemetryPanel();
			});
			document.getElementById('stats-telemetry-range').addEventListener('change', updateApiTelemetryPanel);
			document.getElementById('stats-telemetry-group').addEventListener('change', () => {
				updateTelemetryArchOptions();
				updateApiTelemetryPanel();
			});
			document.getElementById('stats-telemetry-arch').addEventListener('change', updateApiTelemetryPanel);
			document.getElementById('stats-telemetry-recent-limit').addEventListener('change', updateApiTelemetryPanel);
			document.getElementById('stats-telemetry-enabled').addEventListener('change', (e) => {
				__apiTelemetry.setEnabled(!!e.target.checked);
				updateApiTelemetryPanel();
			});
			document.getElementById('stats-telemetry-max').addEventListener('change', (e) => {
				__apiTelemetry.setMaxEntries(e.target.value);
				updateApiTelemetryPanel();
			});

			// Wire global counters controls
			document.getElementById('gs-custom-apply')?.addEventListener('click', updateGlobalCallStatsUI);
			document.getElementById('gs-custom-days')?.addEventListener('change', updateGlobalCallStatsUI);
			document.getElementById('gs-custom-hours')?.addEventListener('change', updateGlobalCallStatsUI);

			// Wire key scheduler controls
			document.getElementById('statsKeySchedRefreshBtn').addEventListener('click', updateKeySchedulerPanel);
			document.getElementById('statsKeySchedClearBtn').addEventListener('click', () => {
				if (confirm('Clear key scheduler logs?')) __keySchedulerLog.clear();
			});
			document.getElementById('statsKeySchedDownloadJsonlBtn').addEventListener('click', () => downloadKeySchedulerLog('jsonl'));
			document.getElementById('stats-key-sched-recent-limit').addEventListener('change', updateKeySchedulerPanel);
			document.getElementById('stats-key-sched-enabled').addEventListener('change', (e) => {
				__keySchedulerLog.setEnabled(!!e.target.checked);
				updateKeySchedulerPanel();
			});
			document.getElementById('stats-key-sched-max').addEventListener('change', (e) => {
				__keySchedulerLog.setMaxEntries(e.target.value);
				updateKeySchedulerPanel();
			});

			setupTelemetryGroupOptions();
			updateTelemetryArchOptions();
			setupTelemetryRangeOptions();
		}

		function openStatsModal() {
			setupStatsModal();
			const modal = document.getElementById('stats-modal');
			if (!modal) return;
			modal.style.display = 'flex';
			setupTelemetryGroupOptions();
			updateTelemetryArchOptions();
			setupTelemetryRangeOptions();
			updateApiTelemetryPanel();
			try { updateGlobalCallStatsUI(); } catch { }
		}

		function closeStatsModal() {
			const modal = document.getElementById('stats-modal');
			if (!modal) return;
			modal.style.display = 'none';
		}

		// === LOGS MODAL (on-demand full log viewer) ===
		let __logsLiveTimerId = null;

		function __logsRowsFromSession(session) {
			const out = [];
			if (Array.isArray(session?.rows)) out.push(...session.rows);
			if (Array.isArray(session?.input_rows)) out.push(...session.input_rows);
			if (Array.isArray(session?.output_rows)) out.push(...session.output_rows);
			return out;
		}

		function __logsFilterRowsByArch(rows, archId) {
			const target = __benchmarkTrim(archId || '');
			const list = Array.isArray(rows) ? rows : [];
			if (!target) return list.slice();
			return list.filter(r => __benchmarkTrim(r?.archId || '') === target);
		}

		function __logsCountSessionRows(session) {
			return __logsRowsFromSession(session).length;
		}

		function __logsCollectArchitectureIds() {
			const seen = new Set();
			const add = (v) => {
				const id = __benchmarkTrim(v || '');
				if (id) seen.add(id);
			};

			(agents || []).forEach(a => add(a?.config?.id));
			(__benchmarkStudio?.lastRunRows || []).forEach(r => add(r?.archId));

			let artifacts = null;
			try { artifacts = __benchmarkEnsureArtifacts(); } catch { artifacts = null; }
			const runSessions = Array.isArray(artifacts?.runSessions) ? artifacts.runSessions : [];
			const gradeSessions = Array.isArray(artifacts?.gradeSessions) ? artifacts.gradeSessions : [];

			for (const sess of runSessions) {
				const rows = __logsRowsFromSession(sess);
				rows.forEach(r => add(r?.archId));
			}
			for (const sess of gradeSessions) {
				const rows = __logsRowsFromSession(sess);
				rows.forEach(r => add(r?.archId));
			}
			return [...seen].sort((a, b) => a.localeCompare(b));
		}

		function __logsRenderArchFilterOptions() {
			const sel = document.getElementById('logs-arch-filter');
			if (!sel) return;
			const prev = __benchmarkTrim(sel.value || 'all') || 'all';
			sel.innerHTML = '';

			const mk = (value, text) => {
				const o = document.createElement('option');
				o.value = value;
				o.textContent = text;
				sel.appendChild(o);
			};
			mk('all', 'All (Benchmark + Architectures)');
			mk('benchmark', 'Benchmark only');

			const ids = __logsCollectArchitectureIds();
			ids.forEach(id => mk(id, `Architecture: ${id}`));
			if ([...sel.options].some(o => o.value === prev)) sel.value = prev;
			else sel.value = 'all';
		}

		function __logsBuildBenchmarkText({ archFilter = 'all', includeApiCalls = true, includeLineStream = true } = {}) {
			const lines = [];
			const targetArch = __benchmarkTrim(archFilter || '');
			const artifacts = (() => {
				try { return __benchmarkEnsureArtifacts(); } catch { return null; }
			})();
			const benchmarkLines = Array.isArray(__benchmarkStudio?.logLines) ? __benchmarkStudio.logLines : [];
			const runSessions = Array.isArray(artifacts?.runSessions) ? artifacts.runSessions : [];
			const gradeSessions = Array.isArray(artifacts?.gradeSessions) ? artifacts.gradeSessions : [];
			const apiCalls = Array.isArray(artifacts?.apiCalls) ? artifacts.apiCalls : [];

			lines.push('===== BENCHMARK LOGS =====');
			if (includeLineStream) {
				lines.push('--- Stream log lines ---');
				if (benchmarkLines.length) lines.push(benchmarkLines.join('\n'));
				else lines.push('(empty)');
				lines.push('');
			}

			const appendSessions = (title, sessions) => {
				lines.push(`--- ${title} ---`);
				let appended = 0;
				for (const sess of sessions) {
					const copy = __benchmarkSafeClone(sess) || {};
					if (targetArch && targetArch !== 'all' && targetArch !== 'benchmark') {
						if (Array.isArray(copy.rows)) copy.rows = __logsFilterRowsByArch(copy.rows, targetArch);
						if (Array.isArray(copy.input_rows)) copy.input_rows = __logsFilterRowsByArch(copy.input_rows, targetArch);
						if (Array.isArray(copy.output_rows)) copy.output_rows = __logsFilterRowsByArch(copy.output_rows, targetArch);
						if (__logsCountSessionRows(copy) === 0) continue;
					}
					lines.push(JSON.stringify(copy, null, 2));
					lines.push('');
					appended += 1;
				}
				if (!appended) lines.push('(empty)\n');
			};

			appendSessions('Run sessions', runSessions);
			appendSessions('Grade sessions', gradeSessions);

			if (includeApiCalls) {
				lines.push('--- API request/response timeline ---');
				if (apiCalls.length) lines.push(__benchmarkBuildApiCallsTimelineText(apiCalls));
				else lines.push('(empty)');
				lines.push('');
			}

			return lines.join('\n').trim();
		}

		function __logsBuildAgentText({ archFilter = 'all' } = {}) {
			const lines = [];
			const targetArch = __benchmarkTrim(archFilter || '');
			const list = (agents || []).filter(a => {
				if (!a) return false;
				if (!targetArch || targetArch === 'all' || targetArch === 'benchmark') return true;
				return __benchmarkTrim(a?.config?.id || '') === targetArch;
			});

			lines.push('===== AGENT LOGS =====');
			if (!list.length) {
				lines.push('(no matching agents in current window)');
				return lines.join('\n');
			}

			list.forEach((a, idx) => {
				const logs = Array.isArray(a?.state?.logs) ? a.state.logs : [];
				lines.push(`--- Agent ${idx + 1}/${list.length}: ${a?.config?.id || '?'} #${a?.instanceId || '?'} (${a?.uniqueId || '-'}) ---`);
				lines.push(`status=${a?.state?.status || ''} | calls=${a?.state?.metrics?.calls || 0} | tokens=${a?.state?.metrics?.tokens || 0}`);
				if (logs.length) lines.push(logs.join('\n'));
				else lines.push('(empty)');
				lines.push('');
			});
			return lines.join('\n').trim();
		}

		function __logsBuildCombinedText({ archFilter = 'all', includeApiCalls = true } = {}) {
			const target = __benchmarkTrim(archFilter || 'all') || 'all';
			if (target === 'benchmark') {
				return __logsBuildBenchmarkText({ archFilter: 'benchmark', includeApiCalls, includeLineStream: true });
			}
			if (target !== 'all') {
				const bm = __logsBuildBenchmarkText({ archFilter: target, includeApiCalls: false, includeLineStream: false });
				const ag = __logsBuildAgentText({ archFilter: target });
				return `${ag}\n\n\n${bm}`.trim();
			}
			const bm = __logsBuildBenchmarkText({ archFilter: 'all', includeApiCalls, includeLineStream: true });
			const ag = __logsBuildAgentText({ archFilter: 'all' });
			return `${bm}\n\n\n${ag}`.trim();
		}

		function __logsRenderPanel({ refreshOptions = true } = {}) {
			if (refreshOptions) __logsRenderArchFilterOptions();
			const outEl = document.getElementById('logs-output');
			const metaEl = document.getElementById('logs-meta');
			const archSel = document.getElementById('logs-arch-filter');
			const includeApi = !!document.getElementById('logs-include-api')?.checked;
			if (!outEl || !metaEl || !archSel) return;

			const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
			const archFilter = __benchmarkTrim(archSel.value || 'all') || 'all';
			const text = __logsBuildCombinedText({ archFilter, includeApiCalls: includeApi });
			outEl.value = text || '(no logs)';
			try { outEl.scrollTop = 0; } catch { }
			const t1 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
			metaEl.innerText = `Filter=${archFilter} | chars=${outEl.value.length} | render=${Math.max(0, Math.round(t1 - t0))}ms`;
		}

		function __logsDownloadCurrent() {
			const outEl = document.getElementById('logs-output');
			if (!outEl) return;
			const txt = __benchmarkString(outEl.value || '');
			if (!txt.trim()) { alert('No logs to download.'); return; }
			const arch = __benchmarkTrim(document.getElementById('logs-arch-filter')?.value || 'all') || 'all';
			const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `mini-artichokes-logs-${sanitizeForFilename(arch, 30)}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
			a.click();
		}

		function __logsCopyCurrent(btn) {
			const outEl = document.getElementById('logs-output');
			if (!outEl) return;
			const txt = __benchmarkString(outEl.value || '');
			if (!txt.trim()) { alert('No logs to copy.'); return; }
			copyToClipboard(txt, btn || null, 'Copy');
		}

		function __logsStartLiveUpdates() {
			if (__logsLiveTimerId) return;
			__logsLiveTimerId = setInterval(() => {
				const modal = document.getElementById('logs-modal');
				if (!modal || modal.style.display === 'none') return;
				try { __logsRenderPanel({ refreshOptions: true }); } catch { }
			}, 1500);
		}

		function __logsStopLiveUpdates() {
			if (!__logsLiveTimerId) return;
			clearInterval(__logsLiveTimerId);
			__logsLiveTimerId = null;
		}

		function setupLogsModal() {
			if (document.getElementById('logs-modal')) return;
			const modal = document.createElement('div');
			modal.id = 'logs-modal';
			modal.className = 'modal-overlay';
			modal.style.display = 'none';
			modal.innerHTML = `
				<div class="modal-window" role="dialog" aria-modal="true">
					<div class="modal-header">
						<div class="modal-title">Execution Logs</div>
						<div class="button-group" style="margin:0;">
							<button id="logs-close-btn" class="cs-btn" style="flex:0 0 auto;">Close</button>
						</div>
					</div>
					<div class="modal-body" style="display:flex; flex-direction:column; min-height:0; gap:8px;">
						<div style="display:flex; gap:8px; flex-wrap:wrap; align-items:flex-end;">
							<div class="form-group" style="margin:0; min-width:260px;">
								<label class="cs-input__label" style="font-size:11px;">Filter</label>
								<select id="logs-arch-filter" class="cs-input" style="font-size:11px; padding:2px 4px;">
									<option value="all">All (Benchmark + Architectures)</option>
									<option value="benchmark">Benchmark only</option>
								</select>
							</div>
							<div class="form-group" style="margin:0; min-width:150px;">
								<label class="cs-input__label" style="font-size:11px;">Benchmark API timeline</label>
								<label style="display:flex; align-items:center; gap:6px; font-size:12px; cursor:pointer;">
									<input id="logs-include-api" type="checkbox" checked>
									Include
								</label>
							</div>
							<div class="button-group" style="margin:0;">
								<button id="logs-refresh-btn" class="cs-btn">Refresh</button>
								<button id="logs-copy-btn" class="cs-btn">Copy</button>
								<button id="logs-download-btn" class="cs-btn">Download</button>
							</div>
						</div>
						<div id="logs-meta" style="font-size:11px; color:var(--text-3);">Idle</div>
						<textarea id="logs-output" class="cs-input" readonly style="min-height:360px;" placeholder="Logs will appear here..."></textarea>
					</div>
				</div>
			`;
			document.body.appendChild(modal);

			const close = () => closeLogsModal();
			document.getElementById('logs-close-btn')?.addEventListener('click', close);
			modal.addEventListener('click', (e) => { if (e.target === modal) close(); });
			window.addEventListener('keydown', (e) => {
				if (e.key !== 'Escape') return;
				const m = document.getElementById('logs-modal');
				if (m && m.style.display !== 'none') close();
			});

			document.getElementById('logs-arch-filter')?.addEventListener('change', () => __logsRenderPanel({ refreshOptions: false }));
			document.getElementById('logs-include-api')?.addEventListener('change', () => __logsRenderPanel({ refreshOptions: false }));
			document.getElementById('logs-refresh-btn')?.addEventListener('click', () => __logsRenderPanel({ refreshOptions: true }));
			document.getElementById('logs-copy-btn')?.addEventListener('click', (e) => __logsCopyCurrent(e?.currentTarget));
			document.getElementById('logs-download-btn')?.addEventListener('click', () => __logsDownloadCurrent());
		}

		function openLogsModal() {
			setupLogsModal();
			const modal = document.getElementById('logs-modal');
			if (!modal) return;
			modal.style.display = 'flex';
			__logsRenderPanel({ refreshOptions: true });
			__logsStartLiveUpdates();
		}

		function closeLogsModal() {
			const modal = document.getElementById('logs-modal');
			if (modal) modal.style.display = 'none';
			__logsStopLiveUpdates();
		}

		// --- INDEXED DB SETUP ---
		const DB_NAME = 'ExpBackupDB_Final';
		const STORE_NAME = 'snapshots';
		let dbInstance = null;

		const initDB = () => new Promise((resolve, reject) => {
			const req = indexedDB.open(DB_NAME, 1);
			req.onupgradeneeded = (e) => e.target.result.createObjectStore(STORE_NAME);
			req.onsuccess = (e) => { dbInstance = e.target.result; resolve(dbInstance); };
			req.onerror = (e) => reject(e);
		});

		async function __idbGetSnapshot(key) {
			if (!key) return null;
			if (!dbInstance) await initDB();
			return await new Promise((resolve) => {
				try {
					const tx = dbInstance.transaction(STORE_NAME, 'readonly');
					const req = tx.objectStore(STORE_NAME).get(key);
					req.onsuccess = (e) => resolve(e?.target?.result ?? null);
					req.onerror = () => resolve(null);
				} catch {
					resolve(null);
				}
			});
		}

		async function __idbPutSnapshot(key, value) {
			if (!key) return false;
			if (!dbInstance) await initDB();
			return await new Promise((resolve) => {
				try {
					const tx = dbInstance.transaction(STORE_NAME, 'readwrite');
					const req = tx.objectStore(STORE_NAME).put(value, key);
					req.onsuccess = () => resolve(true);
					req.onerror = () => resolve(false);
				} catch {
					resolve(false);
				}
			});
		}

		async function __idbDeleteSnapshot(key) {
			if (!key) return false;
			if (!dbInstance) await initDB();
			return await new Promise((resolve) => {
				try {
					const tx = dbInstance.transaction(STORE_NAME, 'readwrite');
					const req = tx.objectStore(STORE_NAME).delete(key);
					req.onsuccess = () => resolve(true);
					req.onerror = () => resolve(false);
				} catch {
					resolve(false);
				}
			});
		}

		async function __idbDeleteSnapshotsByPrefix(prefix) {
			const p = (prefix ?? '').toString();
			if (!p) return 0;
			let keys = [];
			try { keys = await __idbListSnapshotKeys(); } catch { keys = []; }
			const targets = (keys || [])
				.map(k => (k ?? '').toString())
				.filter(k => k && k.startsWith(p));
			for (const k of targets) {
				try { await __idbDeleteSnapshot(k); } catch { }
			}
			return targets.length;
		}

		async function __idbListSnapshotKeys() {
			if (!dbInstance) await initDB();
			return await new Promise((resolve) => {
				try {
					const tx = dbInstance.transaction(STORE_NAME, 'readonly');
					const store = tx.objectStore(STORE_NAME);
					const req = store.getAllKeys ? store.getAllKeys() : null;
					if (req) {
						req.onsuccess = (e) => resolve(Array.isArray(e?.target?.result) ? e.target.result : []);
						req.onerror = () => resolve([]);
						return;
					}
					const keys = [];
					const cursorReq = store.openCursor();
					cursorReq.onsuccess = (e) => {
						const cursor = e?.target?.result;
						if (!cursor) { resolve(keys); return; }
						keys.push(cursor.key);
						cursor.continue();
					};
					cursorReq.onerror = () => resolve(keys);
				} catch {
					resolve([]);
				}
			});
		}

		async function performSave() {
			if (!dbInstance) await initDB();
			try {
				const tx = dbInstance.transaction(STORE_NAME, 'readwrite');
				const state = getAppState();
				tx.objectStore(STORE_NAME).put(state, __dbSnapshotKey);
				const ts = new Date().toTimeString().split(' ')[0];
				console.log(`[AutoSave] Data saved to IndexedDB at ${ts}`);
			} catch (e) {
				console.warn("DB Save Error:", e);
			}
		}

			function saveToLocalStorage() {
				performSave();
			}

			// Autosave:
			// - Frequent periodic save regardless of `isRunning` (reduces crash-loss window).
			// - Extra save when tab is backgrounded (reduces loss on crashes/reloads).
			setInterval(() => {
				saveToLocalStorage();
			}, 30 * 1000);
			document.addEventListener('visibilitychange', () => {
				if (document.visibilityState === 'hidden') saveToLocalStorage();
			});

		// --- Architecture count helpers (global default + per-arch overrides) ---
		function __getGlobalArchCount() {
			const el = document.getElementById('globalArchCount');
			const n = parseInt(el?.value || '1', 10);
			if (!Number.isFinite(n) || n < 1) return 1;
			return Math.min(999, n);
		}

		function __getEffectiveArchCount(archId) {
			const defaultCount = 1;
			const cntEl = document.getElementById(`cnt-${archId}`);
			const per = parseInt(cntEl?.value || `${defaultCount}`, 10);
			const perCount = Number.isFinite(per) ? Math.min(999, Math.max(1, per)) : defaultCount;
			if (perCount !== defaultCount) return perCount;
			return __getGlobalArchCount();
		}

		// --- UI GENERATION ---
			const __PRIMARY_ARCH_IDS = ['test43-2-rcap35', 'pass@1'];

		function __getArchGroupColor(groupName) {
			const g = (groupName || '').toString();
			if (g.includes('Solver')) return 'var(--solver-grp)';
			if (g.includes('Red')) return 'var(--red-grp)';
			if (g.includes('Intermediary')) return 'var(--mid-grp)';
			return 'var(--base)';
		}

		function __createArchRow(archDef) {
			const row = document.createElement('div');
			row.className = 'arch-row';
			row.innerHTML = `
            <input type="checkbox" id="chk-${archDef.id}">
            <label for="chk-${archDef.id}">${archDef.name}</label>
            <div class="count-ctrl">
                <input type="number" id="cnt-${archDef.id}" value="1" min="1" max="5">
            </div>
        `;
			return row;
		}

		function __createArchGroup(groupName, archDefs) {
			const grpDiv = document.createElement('div');
			grpDiv.className = 'arch-group';
			grpDiv.innerHTML = `<h3 style="color:${__getArchGroupColor(groupName)}">${groupName}</h3>`;
			(archDefs || []).forEach(def => grpDiv.appendChild(__createArchRow(def)));
			return grpDiv;
		}

		function renderArchitectureSelector() {
			const selectorDiv = document.getElementById('archSelector');
			if (!selectorDiv) return;
			selectorDiv.innerHTML = '';

			const byId = new Map((ARCH_DEFINITIONS || []).map(def => [def.id, def]));
			const primaryDefs = __PRIMARY_ARCH_IDS
				.map(id => byId.get(id))
				.filter(Boolean);
			const primarySet = new Set(primaryDefs.map(d => d.id));

			if (primaryDefs.length) {
				const core = document.createElement('div');
				core.className = 'arch-group';
				core.innerHTML = `<h3 style="color:var(--status-success)">Core (Mini Artichokes)</h3>`;
				primaryDefs.forEach(def => core.appendChild(__createArchRow(def)));
				selectorDiv.appendChild(core);
			}

			const others = (ARCH_DEFINITIONS || []).filter(def => !primarySet.has(def.id));
			if (!others.length) return;

			const grouped = {};
			others.forEach(def => {
				if (!grouped[def.group]) grouped[def.group] = [];
				grouped[def.group].push(def);
			});

			const collapsible = document.createElement('details');
			collapsible.className = 'arch-collapsible arch-group';
			collapsible.innerHTML = `<summary>More Architectures (${others.length})</summary>`;

			const container = document.createElement('div');
			for (const [grpName, archDefs] of Object.entries(grouped)) {
				container.appendChild(__createArchGroup(grpName, archDefs));
			}
			collapsible.appendChild(container);
			selectorDiv.appendChild(collapsible);
		}

		renderArchitectureSelector();

		// ===== System-role bypass + Per-key rate limiter (GLOBAL) =====
		// Shared across windows (Jobs open in separate windows).
		const __sharedRoot = (() => {
			try {
				if (window.opener && !window.opener.closed && window.opener.__BRANCHING_SHARED_V12) return window.opener;
			} catch { }
			try {
				if (window.opener && !window.opener.closed) return window.opener;
			} catch { }
			return window;
		})();

		const __shared = (() => {
			try {
				if (!__sharedRoot.__BRANCHING_SHARED_V12) __sharedRoot.__BRANCHING_SHARED_V12 = {};
				const shared = __sharedRoot.__BRANCHING_SHARED_V12;
				try { window.__BRANCHING_SHARED_V12 = shared; } catch { }
				return shared;
			} catch {
				if (!window.__BRANCHING_SHARED_V12) window.__BRANCHING_SHARED_V12 = {};
				return window.__BRANCHING_SHARED_V12;
			}
		})();

		// ===== GLOBAL CALL COUNTERS (unlimited totals; bucketed windows) =====
		const __globalCallStats = (() => {
			const STORAGE_KEY = 'BRANCHING_V12_GLOBAL_CALL_STATS_V1';
			const IDB_KEY = 'BRANCHING_V12_GLOBAL_CALL_STATS_IDB_V1';
			const DEFAULT_MINUTE_KEEP_MS = 48 * 60 * 60 * 1000; // 48h
			const DEFAULT_HOUR_KEEP_MS = 365 * 24 * 60 * 60 * 1000; // 365d

			if (!__shared.globalCallStats) {
				__shared.globalCallStats = {
					version: 1,
					loaded: false,
					updatedAt: 0,
					lastGcAt: 0,
					totals: { calls: 0, success: 0, reject: 0, fail: 0 },
					minute: {}, // minuteStartMs -> { calls, success, reject, fail }
					hour: {},   // hourStartMs -> { calls, success, reject, fail }
				};
			}
			const state = __shared.globalCallStats;
			let saveTimerId = null;
			let uiTimerId = null;
			if (typeof state.idbLoaded !== 'boolean') state.idbLoaded = false;
			if (typeof state.idbLoading !== 'boolean') state.idbLoading = false;

			const __now = () => Date.now();
			const __minStart = (ts) => ts - (ts % 60000);
			const __hourStart = (ts) => ts - (ts % 3600000);
			const __safeInt = (v) => (Number.isFinite(v) ? Math.trunc(v) : 0);

			const __mergeBuckets = (target, incoming) => {
				if (!incoming || typeof incoming !== 'object') return;
				for (const [k, v] of Object.entries(incoming)) {
					if (!k) continue;
					const bk = `${parseInt(k, 10) || 0}`;
					const cur = target[bk] || { calls: 0, success: 0, reject: 0, fail: 0 };
					const add = v || {};
					target[bk] = {
						calls: Math.max(__safeInt(cur.calls), __safeInt(add.calls)),
						success: Math.max(__safeInt(cur.success), __safeInt(add.success)),
						reject: Math.max(__safeInt(cur.reject), __safeInt(add.reject)),
						fail: Math.max(__safeInt(cur.fail), __safeInt(add.fail)),
					};
				}
			};

			const __mergeSnapshot = (obj) => {
				if (!obj || typeof obj !== 'object') return;
				const t = obj.totals || {};
				state.totals.calls = Math.max(__safeInt(state.totals.calls), __safeInt(t.calls));
				state.totals.success = Math.max(__safeInt(state.totals.success), __safeInt(t.success));
				state.totals.reject = Math.max(__safeInt(state.totals.reject), __safeInt(t.reject));
				state.totals.fail = Math.max(__safeInt(state.totals.fail), __safeInt(t.fail));
				__mergeBuckets(state.minute, obj.minute);
				__mergeBuckets(state.hour, obj.hour);
				if (Number.isFinite(obj.updatedAt)) state.updatedAt = Math.max(__safeInt(state.updatedAt), __safeInt(obj.updatedAt));
			};

			const __idbGet = (key) => new Promise((resolve) => {
				try {
					const p = dbInstance ? Promise.resolve(dbInstance) : initDB();
					p.then(() => {
						try {
							const tx = dbInstance.transaction(STORE_NAME, 'readonly');
							const req = tx.objectStore(STORE_NAME).get(key);
							req.onsuccess = (e) => resolve(e?.target?.result || null);
							req.onerror = () => resolve(null);
						} catch { resolve(null); }
					}).catch(() => resolve(null));
				} catch { resolve(null); }
			});

			const __idbPut = (key, value) => new Promise((resolve) => {
				try {
					const p = dbInstance ? Promise.resolve(dbInstance) : initDB();
					p.then(() => {
						try {
							const tx = dbInstance.transaction(STORE_NAME, 'readwrite');
							const req = tx.objectStore(STORE_NAME).put(value, key);
							req.onsuccess = () => resolve(true);
							req.onerror = () => resolve(false);
						} catch { resolve(false); }
					}).catch(() => resolve(false));
				} catch { resolve(false); }
			});

			const __loadFromIdbOnce = () => {
				if (state.idbLoaded || state.idbLoading) return;
				state.idbLoading = true;
				__idbGet(IDB_KEY).then((obj) => {
					state.idbLoading = false;
					state.idbLoaded = true;
					try { __mergeSnapshot(obj); } catch { }
					try { __gc(); } catch { }
					__scheduleUi();
				});
			};

			const __loadIfNeeded = () => {
				if (state.loaded) return;
				state.loaded = true;
				try { __loadFromIdbOnce(); } catch { }
				try {
					const raw = localStorage.getItem(STORAGE_KEY);
					if (!raw) return;
					const obj = JSON.parse(raw);
					if (!obj || typeof obj !== 'object') return;
					__mergeSnapshot(obj);
				} catch { }
			};

			const __toJson = () => ({
				version: state.version,
				updatedAt: state.updatedAt,
				totals: state.totals,
				minute: state.minute,
				hour: state.hour,
			});

			const __scheduleSave = () => {
				try {
					if (saveTimerId) return;
					saveTimerId = setTimeout(() => {
						saveTimerId = null;
						const snapshot = __toJson();
						try { localStorage.setItem(STORAGE_KEY, JSON.stringify(snapshot)); } catch { }
						try { __idbPut(IDB_KEY, snapshot); } catch { }
					}, 750);
				} catch { }
			};

			const __scheduleUi = () => {
				if (uiTimerId) return;
				uiTimerId = setTimeout(() => {
					uiTimerId = null;
					try { window.updateGlobalCallStatsUI?.(); } catch { }
				}, 0);
			};

			const __gc = () => {
				const now = __now();
				if (Number.isFinite(state.lastGcAt) && now - state.lastGcAt < 60000) return;
				state.lastGcAt = now;
				const minCut = now - DEFAULT_MINUTE_KEEP_MS;
				const hourCut = now - DEFAULT_HOUR_KEEP_MS;
				try {
					for (const k of Object.keys(state.minute || {})) {
						const ts = parseInt(k, 10) || 0;
						if (ts && ts < minCut) delete state.minute[k];
					}
					for (const k of Object.keys(state.hour || {})) {
						const ts = parseInt(k, 10) || 0;
						if (ts && ts < hourCut) delete state.hour[k];
					}
				} catch { }
			};

			const __incBucket = (container, ts, field) => {
				const k = `${ts}`;
				if (!container[k]) container[k] = { calls: 0, success: 0, reject: 0, fail: 0 };
				container[k][field] = __safeInt(container[k][field]) + 1;
			};

			const onSent = (meta = {}) => {
				__loadIfNeeded();
				const ts = Number.isFinite(meta?.ts) ? meta.ts : __now();
				state.totals.calls = __safeInt(state.totals.calls) + 1;
				__incBucket(state.minute, __minStart(ts), 'calls');
				__incBucket(state.hour, __hourStart(ts), 'calls');
				state.updatedAt = __now();
				__gc();
				__scheduleSave();
				__scheduleUi();
			};

			const onFinal = (kind, meta = {}) => {
				__loadIfNeeded();
				const ts = Number.isFinite(meta?.ts) ? meta.ts : __now();
				const k = (kind || '').toString().toLowerCase();
				if (k !== 'success' && k !== 'reject' && k !== 'fail') return;
				state.totals[k] = __safeInt(state.totals[k]) + 1;
				__incBucket(state.minute, __minStart(ts), k);
				__incBucket(state.hour, __hourStart(ts), k);
				state.updatedAt = __now();
				__gc();
				__scheduleSave();
				__scheduleUi();
			};

			const getTotals = () => {
				__loadIfNeeded();
				return {
					calls: __safeInt(state.totals.calls),
					success: __safeInt(state.totals.success),
					reject: __safeInt(state.totals.reject),
					fail: __safeInt(state.totals.fail),
				};
			};

			const __sumInRange = (src, startTs) => {
				const out = { calls: 0, success: 0, reject: 0, fail: 0 };
				for (const [k, v] of Object.entries(src || {})) {
					const ts = parseInt(k, 10) || 0;
					if (!ts || ts < startTs) continue;
					const b = v || {};
					out.calls += __safeInt(b.calls);
					out.success += __safeInt(b.success);
					out.reject += __safeInt(b.reject);
					out.fail += __safeInt(b.fail);
				}
				return out;
			};

			const getWindow = (ms) => {
				__loadIfNeeded();
				const span = Math.max(0, Number(ms) || 0);
				const now = __now();
				const start = now - span;
				const useMinute = span <= DEFAULT_MINUTE_KEEP_MS;
				return __sumInRange(useMinute ? state.minute : state.hour, useMinute ? __minStart(start) : __hourStart(start));
			};

			// Start an async load early (localStorage can be unreliable on file://).
			try { __loadFromIdbOnce(); } catch { }

			return { onSent, onFinal, getTotals, getWindow, getState: () => state };
		})();

		if (!__shared.rateState) __shared.rateState = new Map();
		const __rateState = __shared.rateState; // apiKey -> { windowStart, rpm, tpm, lastSentAt, chain, rpmLimit, tpmLimit }

		function __minuteStart(ts) { return ts - (ts % 60000); }

		function __normalizeRateLimit(v) {
			const n = parseInt(v, 10);
			if (!Number.isFinite(n) || n <= 0) return 0;
			return n;
		}

		function __mergeRateLimit(existing, incoming) {
			const e = __normalizeRateLimit(existing);
			const n = __normalizeRateLimit(incoming);
			// UI/config should be able to both decrease AND increase limits.
			// Keep existing only when incoming is unset/invalid (0).
			if (n > 0) return n;
			return e;
		}

		function __normalizeInflightLimit(v) {
			const n = parseInt(v, 10);
			if (!Number.isFinite(n) || n <= 0) return 0;
			return Math.min(9999, n);
		}

		function __getMaxInflightPerKeyLimit() {
			try {
				const raw = (document.getElementById('maxInflightPerKey')?.value || '').toString().trim();
				if (!raw) return 0;
				return __normalizeInflightLimit(raw);
			} catch {
				return 0;
			}
		}

		// Optional hard cap: max concurrent in-flight requests per API key (applies to all direct + proxy requests in this window).
		const __perKeyInflightGate = (() => {
			// Reservation gate to prevent per-key concurrency spikes.
			// Uses live inflight count (+ short-lived reservations) so turning the limit on mid-run applies immediately.
			const reserved = new Map(); // rawKey -> reservations (until caller marks "sent")
			const __getReserved = (k) => (Number.isFinite(reserved.get(k)) ? reserved.get(k) : 0);
			const __getLiveInflight = (k) => {
				try {
					const live = __apiKeyLive?.getState?.().byKey?.get?.(k) || null;
					const n = Number.isFinite(live?.inflightCount) ? live.inflightCount : 0;
					return Math.max(0, n);
				} catch {
					return 0;
				}
			};

			const acquire = async (arch, rawKey) => {
				const key = (rawKey || '').toString();
				if (!key) return { release: () => { } };
				const __MAX_GATE_WAIT_MS = 10 * 60 * 1000;
				const hardWaitStart = Date.now();

				while (true) {
					if (arch?.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped by User");

					const limit = __getMaxInflightPerKeyLimit();
					if (!limit) return { release: () => { } }; // auto/unlimited

					const liveInflight = __getLiveInflight(key);
					const curReserved = __getReserved(key);
					if ((liveInflight + curReserved) < limit) {
						reserved.set(key, curReserved + 1);
						let released = false;
						const release = () => {
							if (released) return;
							released = true;
							const v = __getReserved(key);
							const next = Math.max(0, v - 1);
							if (next <= 0) reserved.delete(key);
							else reserved.set(key, next);
						};
						return { release };
					}

					if ((Date.now() - hardWaitStart) > __MAX_GATE_WAIT_MS) {
						throw new Error(`Per-key inflight gate wait exceeded ${Math.round(__MAX_GATE_WAIT_MS / 1000)}s (key=${maskKey(key)}, inflight=${liveInflight}, reserved=${curReserved}, limit=${limit})`);
					}

					const waitMs = 120;
					if (arch && typeof arch.sleepInterruptible === 'function') await arch.sleepInterruptible(waitMs);
					else await new Promise(res => setTimeout(res, waitMs));
				}
			};

			const clear = () => { try { reserved.clear(); } catch { } };
			return { acquire, clear, getState: () => reserved };
		})();

		// Cross-window (multi-root) best-effort rate limiter via localStorage.
		// This complements the in-memory `__shared.rateState` (which only shares across an opener chain).
		const __rateLsLimiter = (() => {
			const STATE_PREFIX = 'BRANCHING_V12_RATE_LS_V1:state:';
			const LOCK_PREFIX = 'BRANCHING_V12_RATE_LS_V1:lock:';
			const LOCK_TTL_MS = 8000;
			const MIN_SLEEP_MS = 25;
			const MAX_SLEEP_MS = 2000;

			let availability = null;
			let seq = 0;
			const windowId = (() => {
				try {
					if (window.__BRANCHING_V12_WINDOW_ID) return window.__BRANCHING_V12_WINDOW_ID;
					const id = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
					window.__BRANCHING_V12_WINDOW_ID = id;
					return id;
				} catch {
					return `${Date.now()}_${Math.random().toString(36).slice(2)}`;
				}
			})();

			const __hash32 = (str) => {
				const s = (str ?? '').toString();
				let h = 0x811c9dc5;
				for (let i = 0; i < s.length; i++) {
					h ^= s.charCodeAt(i);
					h = (h + (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24)) >>> 0;
				}
				return h.toString(16).padStart(8, '0');
			};

			const __stateKey = (rawKey) => `${STATE_PREFIX}${__hash32(rawKey || '__NO_KEY__')}`;
			const __lockKey = (rawKey) => `${LOCK_PREFIX}${__hash32(rawKey || '__NO_KEY__')}`;

			const __jsonParse = (raw) => {
				if (!raw) return null;
				try { return JSON.parse(raw); } catch { return null; }
			};

			const __lsGetObj = (k) => {
				try { return __jsonParse(localStorage.getItem(k)); } catch { return null; }
			};

			const __lsSetObj = (k, obj) => {
				try { localStorage.setItem(k, JSON.stringify(obj || {})); return true; } catch { return false; }
			};

			const __sleep = async (arch, ms) => {
				const n = Math.max(0, Number(ms) || 0);
				if (arch?.sleepInterruptible) { await arch.sleepInterruptible(n); return; }
				await new Promise(res => setTimeout(res, n));
			};

			const __isAvailable = () => {
				if (availability === false) return false;
				if (availability === true) return true;
				try {
					const k = `${STATE_PREFIX}__test__`;
					localStorage.setItem(k, '1');
					localStorage.removeItem(k);
					availability = true;
					return true;
				} catch {
					availability = false;
					return false;
				}
			};

			const __withLock = async (rawKey, arch, fn) => {
				if (!__isAvailable()) return null;
				const lk = __lockKey(rawKey);
				const owner = `${windowId}:${++seq}:${Math.random().toString(36).slice(2)}`;
				while (true) {
					if (arch?.stopFlag || GLOBAL_EMERGENCY_STOP) return null;
					const now = Date.now();
					const cur = __lsGetObj(lk);
					const curExp = Number.isFinite(cur?.expiresAt) ? cur.expiresAt : 0;
					const curOwner = (cur?.owner || '').toString();
					if (curExp && curExp > now && curOwner && curOwner !== owner) {
						const waitMs = Math.min(MAX_SLEEP_MS, Math.max(MIN_SLEEP_MS, (curExp - now) + 5));
						await __sleep(arch, waitMs);
						continue;
					}
					if (!__lsSetObj(lk, { owner, expiresAt: now + LOCK_TTL_MS })) { availability = false; return null; }
					const ver = __lsGetObj(lk);
					if ((ver?.owner || '') === owner) break;
					await __sleep(arch, MIN_SLEEP_MS);
				}

				try {
					return await fn();
				} finally {
					try {
						const ver = __lsGetObj(lk);
						if ((ver?.owner || '') === owner) localStorage.removeItem(lk);
					} catch { }
				}
			};

			const acquire = async (arch, rawKey, {
				rpmLimit,
				tpmLimit,
				tokensForBucket,
				isTpmOversize,
			} = {}) => {
				if (!__isAvailable()) return null;
				const key = rawKey || '__NO_KEY__';

				const __isRateEnabled = () => {
					try { return !!document.getElementById('enableRateLimit')?.checked; } catch { return true; }
				};

				const __evalMaybeFn = (v) => {
					if (typeof v === 'function') {
						try { return v(); } catch { return 0; }
					}
					return v;
				};

				const bucketTokens = Number.isFinite(tokensForBucket) ? Math.max(0, tokensForBucket) : 0;

				while (true) {
					if (arch?.stopFlag || GLOBAL_EMERGENCY_STOP) return null;
					if (!__isRateEnabled()) return { ok: true, state: null };

					const incomingRpm = __normalizeRateLimit(__evalMaybeFn(rpmLimit));
					const incomingTpm = __normalizeRateLimit(__evalMaybeFn(tpmLimit));
					const decision = await __withLock(key, arch, async () => {
						const now = Date.now();
						const stKey = __stateKey(key);
						const st0 = __lsGetObj(stKey) || {};

						let windowStart = Number.isFinite(st0.windowStart) ? st0.windowStart : __minuteStart(now);
						const winNow = __minuteStart(now);
						const staleWin = Math.abs(windowStart - winNow) >= 60000 && Math.abs(now - windowStart) > 120000;
						const futureWin = windowStart > now + 60000;
						if (staleWin || futureWin || windowStart !== winNow) windowStart = winNow;

						let rpm = Number.isFinite(st0.rpm) ? st0.rpm : 0;
						let tpm = Number.isFinite(st0.tpm) ? st0.tpm : 0;
						let lastSentAt = Number.isFinite(st0.lastSentAt) ? st0.lastSentAt : 0;
						if (lastSentAt && lastSentAt > now + 60000) lastSentAt = 0;
						if (windowStart !== Number(st0.windowStart)) { rpm = 0; tpm = 0; }

						const effRpm = __mergeRateLimit(st0.rpmLimit, incomingRpm);
						const effTpm = __mergeRateLimit(st0.tpmLimit, incomingTpm);
						const oversize = effTpm > 0 && bucketTokens > effTpm;
						const paceMs = effRpm > 0 ? Math.ceil(60000 / effRpm) : 0;
						const gapMs = Math.max(3000, paceMs);

						const nextByGap = lastSentAt ? (lastSentAt + gapMs) : 0;
						let waitMs = 0;
						if (nextByGap && now < nextByGap) waitMs = Math.max(waitMs, (nextByGap - now) + 5);

						if (winNow !== windowStart) {
							windowStart = winNow;
							rpm = 0;
							tpm = 0;
						}

						const hitRpm = effRpm > 0 && (rpm + 1 > effRpm);
						const hitTpm = effTpm > 0 && (oversize ? (tpm >= effTpm) : (tpm + bucketTokens > effTpm));
						if (hitRpm || hitTpm) {
							const bucketWait = (windowStart + 60000) - now + 25;
							waitMs = Math.max(waitMs, bucketWait);
						}

						if (waitMs <= 0 && !hitRpm && !hitTpm && (!nextByGap || now >= nextByGap)) {
							rpm += 1;
							if (effTpm > 0) {
								if (oversize) tpm = Math.max(tpm, effTpm);
								else tpm += bucketTokens;
							}
							lastSentAt = now;
							const st1 = {
								windowStart,
								rpm,
								tpm,
								lastSentAt,
								rpmLimit: effRpm,
								tpmLimit: effTpm,
								updatedAt: now,
								v: 1,
							};
							__lsSetObj(stKey, st1);
							return { ok: true, state: st1 };
						}

						const st1 = {
							windowStart,
							rpm,
							tpm,
							lastSentAt,
							rpmLimit: effRpm,
							tpmLimit: effTpm,
							updatedAt: now,
							v: 1,
						};
						__lsSetObj(stKey, st1);
						return { ok: false, waitMs: Math.max(MIN_SLEEP_MS, Math.min(MAX_SLEEP_MS, waitMs || MIN_SLEEP_MS)), state: st1 };
					});

					if (!decision) return null;
					if (decision.ok) return decision;
					await __sleep(arch, decision.waitMs);
				}
			};

			return { acquire };
		})();

		function __ensureRateStateForKey(rawKey) {
			const key = rawKey || '__NO_KEY__';
			if (!__rateState.has(key)) {
				__rateState.set(key, {
					windowStart: __minuteStart(Date.now()),
					rpm: 0,
					tpm: 0,
					lastSentAt: 0,
					chain: Promise.resolve(),
					chainLockedAt: 0,
					chainOwner: null,
					chainCreatedAt: 0,
					rpmLimit: 0,
					tpmLimit: 0,
					cooldownUntil: null,
					cooldownRetryCount: 0,
				});
			}
			return __rateState.get(key);
		}

		function __resetRateChainIfStale(state, now, maxStaleMs = 120000) {
			if (!state) return false;
			const lockedAt = Number.isFinite(state.chainLockedAt) ? state.chainLockedAt : 0;
			const createdAt = Number.isFinite(state.chainCreatedAt) ? state.chainCreatedAt : 0;
			const refAt = lockedAt || createdAt;
			if (!refAt) return false;
			if (now - refAt <= maxStaleMs) return false;
			state.chain = Promise.resolve();
			state.chainLockedAt = 0;
			state.chainOwner = null;
			state.chainCreatedAt = 0;
			return true;
		}

		function __recoverRateStateIfStale(state, now, maxStaleMs = 120000) {
			if (!state) return false;
			const win = __minuteStart(now);
			let changed = false;
			const ws = Number.isFinite(state.windowStart) ? state.windowStart : win;
			const staleWin = Math.abs(ws - win) >= 60000 && Math.abs(now - ws) > maxStaleMs;
			const futureWin = ws > now + 60000;
			if (staleWin || futureWin) {
				state.windowStart = win;
				state.rpm = 0;
				state.tpm = 0;
				changed = true;
			}
			let lastSentAt = Number.isFinite(state.lastSentAt) ? state.lastSentAt : 0;
			if (lastSentAt && lastSentAt > now + 60000) {
				// Clock skew / corrupted state can pin the scheduler for hours; treat future timestamps as invalid.
				state.lastSentAt = 0;
				lastSentAt = 0;
				changed = true;
			}
			if (!changed && lastSentAt && (now - lastSentAt > maxStaleMs) && (state.rpm > 0 || state.tpm > 0)) {
				state.rpm = 0;
				state.tpm = 0;
				changed = true;
			}
			return changed;
		}

		function __applySharedRateLimitsForKey(rawKey, { rpmLimitUi, tpmLimitUi } = {}) {
			const state = __ensureRateStateForKey(rawKey);
			state.rpmLimit = __mergeRateLimit(state.rpmLimit, rpmLimitUi);
			state.tpmLimit = __mergeRateLimit(state.tpmLimit, tpmLimitUi);
			return state;
		}

		// ===== Jobs: open each job in its own window =====
		const __JOB_PAYLOAD_LS_PREFIX = 'BRANCHING_V12_JOB_PAYLOAD_V1:';

		function __storeJobPayloadToLocalStorage(jobId, payload) {
			if (!jobId) return;
			try { localStorage.setItem(`${__JOB_PAYLOAD_LS_PREFIX}${jobId}`, JSON.stringify(payload)); } catch { }
		}

		function __takeJobPayloadFromLocalStorage(jobId) {
			if (!jobId) return null;
			try {
				const k = `${__JOB_PAYLOAD_LS_PREFIX}${jobId}`;
				const raw = localStorage.getItem(k);
				if (!raw) return null;
				localStorage.removeItem(k);
				return JSON.parse(raw);
			} catch { return null; }
		}

		const __jobWindowRefs = new Map(); // jobId -> Window
		window.__jobWindowRefs = __jobWindowRefs;

		function __jobFirstLine(text) {
			const s = (text ?? '').toString();
			const first = s.split(/\r?\n/).find(l => l.trim()) || s;
			return first.trim();
		}

		function __precreateAgentsForPayload(payload) {
			try {
				if (!payload || typeof payload !== 'object') return;
				if ((agents || []).length > 0) return;

				const query = (payload.query || '').toString();
				const selection = Array.isArray(payload.selection) ? payload.selection : [];
				for (const sel of selection) {
					const archId = sel?.archId;
					const count = Math.max(1, parseInt(sel?.count || '1', 10) || 1);
					const def = ARCH_DEFINITIONS.find(d => d && d.id === archId);
					if (!def) continue;
					for (let i = 0; i < count; i++) {
						createAgentUI(def, i + 1);
						const a = agents[agents.length - 1];
						if (a) {
							a.jobQuery = query;
							a.jobSession = payload.jobId || __jobSessionId || null;
							a.sessionId = (payload.jobId || __sessionId).toString();
						}
					}
				}
				try { updateAnalysisGroupOptions(); } catch { }
				try { updateAnalysisArchOptions(); } catch { }
			} catch { }
		}

		function __ensureJobWindowsRegistry() {
			if (!__shared.jobWindows || typeof __shared.jobWindows !== 'object') __shared.jobWindows = {};
			return __shared.jobWindows;
		}

		function __ensureJobWindowsBanList() {
			if (!__shared.jobWindowsBan || typeof __shared.jobWindowsBan !== 'object') __shared.jobWindowsBan = {};
			return __shared.jobWindowsBan;
		}

		function __registerJobWindowSelf(status = 'running') {
			// For reopened job windows (jobSession only, no jobLaunch payload).
			if (window.__JOB_DETACHED) return;
			if (!__isJobWindow || !__jobSessionId) return;
			if (__jobLaunchId) return; // payload flow registers itself
			if (window.__JOB_SELF_REG_STARTED) return;
			window.__JOB_SELF_REG_STARTED = true;

			try {
				const id = (__jobSessionId || '').toString();
				if (!id) return;
				try {
					const ban = __ensureJobWindowsBanList();
					if (ban && ban[id]) return;
				} catch { }
				const now = Date.now();
				const reg = __ensureJobWindowsRegistry();
				const prev = reg[id] || {};
				reg[id] = {
					...prev,
					id,
					createdAt: Number.isFinite(prev.createdAt) ? prev.createdAt : now,
					startedAt: Number.isFinite(prev.startedAt) ? prev.startedAt : now,
					closedAt: null,
					status: (status || prev.status || 'running').toString(),
					title: (prev.title || document.title || id).toString().slice(0, 140),
					windowName: prev.windowName || `_job_${id}`,
					url: window.location.href,
					lastSeenAt: now,
				};

				const beatId = setInterval(() => {
					try {
						const r = __ensureJobWindowsRegistry()?.[id];
						if (!r || r.status === 'closed') { clearInterval(beatId); return; }
						r.lastSeenAt = Date.now();
					} catch { }
				}, 1000);

				window.addEventListener('beforeunload', () => {
					try {
						const r = __ensureJobWindowsRegistry()?.[id];
						if (r) {
							r.status = 'closed';
							r.closedAt = Date.now();
							r.lastSeenAt = Date.now();
						}
					} catch { }
					try { clearInterval(beatId); } catch { }
				}, { once: true });
			} catch { }
		}

		function __installJobPayloadMessageBridge() {
			if (window.__JOB_PAYLOAD_BRIDGE_INSTALLED) return;
			window.__JOB_PAYLOAD_BRIDGE_INSTALLED = true;
			window.addEventListener('message', (e) => {
				const d = e?.data;
				if (!d || typeof d !== 'object') return;
				if (d.type === 'BRANCHING_V12_JOB_REQUEST_PAYLOAD') {
					const jobId = (d.jobId || '').toString();
					if (!jobId) return;
					let payload = null;
					try { payload = __shared?.jobLaunchPayloads?.[jobId] || null; } catch { payload = null; }
					if (!payload) payload = __takeJobPayloadFromLocalStorage(jobId);
					try { e.source?.postMessage({ type: 'BRANCHING_V12_JOB_DELIVER_PAYLOAD', jobId, payload }, '*'); } catch { }
					return;
				}
			});
		}

		function __installJobControlMessageBridge() {
			if (window.__JOB_CONTROL_BRIDGE_INSTALLED) return;
			window.__JOB_CONTROL_BRIDGE_INSTALLED = true;
			window.addEventListener('message', (e) => {
				const d = e?.data;
				if (!d || typeof d !== 'object') return;
				if (d.type !== 'BRANCHING_V12_JOB_CONTROL') return;
				const cmd = (d.cmd || '').toString();
				if (!cmd) return;

				// Only job windows respond; main window is the controller.
				if (!__isJobWindow) return;

					// Best-effort: accept only from opener (if accessible).
					try {
						if (window.opener && !window.opener.closed && e.source && e.source !== window.opener) return;
					} catch { }
					try {
						if (e?.source && !window.__JOB_DETACHED && !window.__JOB_LOCAL_API) {
							window.__JOB_PROXY_PARENT = e.source;
						}
					} catch { }

				if (cmd === 'clear_and_close') {
					(async () => {
						try { window.__JOB_DETACHED = true; } catch { }
						try {
							const id = (__jobSessionId || '').toString();
							const reg = __ensureJobWindowsRegistry();
							if (id && reg && reg[id]) delete reg[id];
						} catch { }
						try { stopComparison(); } catch { }
						try { clearAll(false); } catch { }
						try { await __idbDeleteSnapshot(__dbSnapshotKey); } catch { }
						try {
							const id = (__jobSessionId || '').toString();
							if (id) await __idbDeleteSnapshot(`job:${id}`);
						} catch { }
						try { window.close(); } catch { }
					})();
					return;
				}

				if (cmd === 'stop') {
					try { stopComparison(); } catch { }
					return;
				}

				if (cmd === 'resume') {
					try { startComparison(); } catch { try { document.getElementById('runBtn')?.click?.(); } catch { } }
					return;
				}
			});
		}
		try { __installJobControlMessageBridge(); } catch { }

		function __getMainPinnedQueryText() {
			// Used to restore the main UI after temporarily editing the Problem Statement to launch a job.
			try {
				const v = (__shared?.mainPinnedQuery || '').toString();
				if (v.trim()) return v;
			} catch { }
			try {
				const a = (agents || []).find(x => x && typeof x.jobQuery === 'string' && x.jobQuery.trim());
				if (a && a.jobQuery) return a.jobQuery.toString();
			} catch { }
			return '';
		}

		function __clearExtraProblemsUi() {
			try {
				const box = document.getElementById('extraProblems');
				if (box) box.innerHTML = '';
			} catch { }
		}

		function __addExtraProblemSlot(initialText = '') {
			const box = document.getElementById('extraProblems');
			if (!box) return;
			const idx = (box.querySelectorAll('.problem-slot').length || 0) + 2;
			const slot = document.createElement('div');
			slot.className = 'problem-slot';
			slot.dataset.problemIndex = String(idx);
			slot.style.marginTop = '8px';
			slot.innerHTML = `
			                <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
			                    <div data-role="problem-label" style="font-size:11px; color:var(--text-2); font-weight:bold;">Problem #${idx} (Job window)</div>
			                    <button class="cs-btn" data-action="remove-problem" style="font-size:10px; padding:2px 6px;">Remove</button>
			                </div>
			                <textarea class="cs-input extra-problem" data-problem-index="${idx}" placeholder="Paste another problem statement here..."></textarea>
			            `;
			box.appendChild(slot);
			const ta = slot.querySelector('textarea.extra-problem');
			if (ta) {
				ta.value = (initialText ?? '').toString();
				try { ta.focus(); } catch { }
			}
		}

		function __renumberExtraProblemsUi() {
			const box = document.getElementById('extraProblems');
			if (!box) return;
			const slots = Array.from(box.querySelectorAll('.problem-slot'));
			slots.forEach((slot, i) => {
				const idx = i + 2;
				try { slot.dataset.problemIndex = String(idx); } catch { }
				try {
					const lbl = slot.querySelector('[data-role="problem-label"]');
					if (lbl) lbl.textContent = `Problem #${idx} (Job window)`;
				} catch { }
				try {
					const ta = slot.querySelector('textarea.extra-problem');
					if (ta) ta.dataset.problemIndex = String(idx);
				} catch { }
			});
		}

		function __getProblemQueriesFromUi({ includeEmpty = false } = {}) {
			const out = [];
			try { out.push((document.getElementById('userQuery')?.value || '').toString()); } catch { out.push(''); }
			try {
				const extras = Array.from(document.querySelectorAll('#extraProblems textarea.extra-problem'));
				for (const ta of extras) out.push((ta?.value || '').toString());
			} catch { }

			if (!includeEmpty) {
				while (out.length > 1 && !out[out.length - 1].trim()) out.pop();
			}
			return out;
		}

		function __setProblemQueriesInUi(queries) {
			const list = Array.isArray(queries) ? queries : [];
			const q1 = (list[0] ?? '').toString();
			try { document.getElementById('userQuery').value = q1; } catch { }
			__clearExtraProblemsUi();
			for (let i = 1; i < list.length; i++) {
				const q = (list[i] ?? '').toString();
				__addExtraProblemSlot(q);
			}
			__renumberExtraProblemsUi();
		}

		// --- Mini Artichokes Benchmark Studio ---
		const __BENCHMARK_SCHEMA_VERSION = 'mini-artichokes-benchmark-v1';

		function __benchmarkCreateApiCountersState() {
			return {
				parse: { total: 0, success: 0, error: 0, running: 0 },
				grade: { total: 0, success: 0, error: 0, running: 0 },
			};
		}

			const __benchmarkStudio = {
				dataset: null,
				lastRunRows: [],
				lastGradeMode: 'answer_only',
				manualSpawnMode: false,
				pendingSpawnUniqueIds: [],
				isRunning: false,
				parseTaskRunning: false,
				gradeTaskRunning: false,
			parseStopRequested: false,
			gradeStopRequested: false,
			parseCheckpoint: null,
			gradeCheckpoint: null,
			apiKeyCursor: { parse: 0, grade: 0 },
			logLines: [],
			artifacts: null,
			apiCounters: __benchmarkCreateApiCountersState(),
			appliedToUi: false,
			runCheckpoint: null,
			taskRateState: {
				parse: new Map(),
				grade: new Map(),
			},
			taskInflightState: {
				parse: new Map(),
				grade: new Map(),
			},
		};

		let __benchmarkApiAgent = null;
		let __benchmarkTokenizerScriptPromise = null;
		let __benchmarkTokenizerLoaded = false;
		let __benchmarkPersistTimer = null;

		function __benchmarkCreateArtifactsState() {
			return {
				version: 1,
				created_at: Date.now(),
				updated_at: Date.now(),
				counters: { id: 0 },
				apiCalls: [],
				convertSessions: [],
				runSessions: [],
				gradeSessions: [],
				selectedApiCallId: '',
				latestRawInput: '',
				latestRawOutput: '',
			};
		}

		function __benchmarkNormalizeArtifactsState(raw) {
			const base = __benchmarkCreateArtifactsState();
			if (!raw || typeof raw !== 'object') return base;
			const out = { ...base, ...raw };
			out.counters = (raw.counters && typeof raw.counters === 'object') ? { ...raw.counters } : { id: 0 };
			if (!Number.isFinite(out.counters.id)) out.counters.id = 0;
			out.apiCalls = Array.isArray(raw.apiCalls) ? raw.apiCalls.slice() : [];
			out.convertSessions = Array.isArray(raw.convertSessions) ? raw.convertSessions.slice() : [];
			out.runSessions = Array.isArray(raw.runSessions) ? raw.runSessions.slice() : [];
			out.gradeSessions = Array.isArray(raw.gradeSessions) ? raw.gradeSessions.slice() : [];
			out.selectedApiCallId = __benchmarkTrim(raw.selectedApiCallId || '');
			out.latestRawInput = __benchmarkString(raw.latestRawInput || '');
			out.latestRawOutput = __benchmarkString(raw.latestRawOutput || '');
			out.updated_at = Date.now();
			return out;
		}

		function __benchmarkEnsureArtifacts() {
			if (!__benchmarkStudio.artifacts || typeof __benchmarkStudio.artifacts !== 'object') {
				__benchmarkStudio.artifacts = __benchmarkCreateArtifactsState();
			}
			return __benchmarkStudio.artifacts;
		}

		function __benchmarkTouchArtifacts() {
			const artifacts = __benchmarkEnsureArtifacts();
			artifacts.updated_at = Date.now();
			__benchmarkSchedulePersist(1200);
			return artifacts;
		}

		function __benchmarkSchedulePersist(delayMs = 1200) {
			if (__benchmarkPersistTimer) return;
			const wait = Number.isFinite(delayMs) ? Math.max(50, delayMs) : 1200;
			__benchmarkPersistTimer = setTimeout(async () => {
				__benchmarkPersistTimer = null;
				try { await performSave(); } catch { }
			}, wait);
		}

		function __benchmarkNormalizeSelectionForSignature(selection) {
			const list = Array.isArray(selection) ? selection : [];
			const out = [];
			for (const item of list) {
				const archId = __benchmarkTrim(item?.archId || item?.id || '');
				if (!archId) continue;
				const rawCount = parseInt(item?.count ?? item?.cnt ?? '1', 10);
				const count = Number.isFinite(rawCount) ? Math.min(999, Math.max(1, rawCount)) : 1;
				out.push({ archId, count });
			}
			out.sort((a, b) => {
				if (a.archId === b.archId) return a.count - b.count;
				return a.archId.localeCompare(b.archId);
			});
			return out;
		}

		function __benchmarkDatasetSignature(dataset) {
			const ds = dataset || {};
			const probs = Array.isArray(ds?.problems) ? ds.problems : [];
			const qids = probs.map((p, idx) => {
				const qid = __benchmarkTrim(p?.qid || '');
				return qid || `Q${idx + 1}`;
			});
			const name = __benchmarkTrim(ds?.name || '');
			return `${name}::${probs.length}::${qids.join('|')}`;
		}

		function __benchmarkHash32(value) {
			const str = String(value ?? '');
			let h = 2166136261;
			for (let i = 0; i < str.length; i++) {
				h ^= str.charCodeAt(i);
				h = Math.imul(h, 16777619);
			}
			return (h >>> 0).toString(16);
		}

			function __benchmarkParseExplicitProblemIndices(filterRaw, totalCount) {
				const raw = __benchmarkTrim(filterRaw || '');
				if (!raw) return null;
				const total = __benchmarkClampInt(totalCount, { min: 0, max: 1000000, fallback: 0 });
				if (total <= 0) return [];
				const normalized = raw
					.toLowerCase()
					.replace(/\bproblems?\b/g, '')
					.replace(/\bindices?\b/g, '')
					.replace(/\bidx\b/g, '')
					.replace(/#/g, '')
					.replace(/\bq\b/g, '')
					.replace(/\bp\b/g, '')
					.replace(/\s+/g, '');
				if (!normalized) return null;
				if (!/^[0-9,\-]+$/.test(normalized)) return null;
				const tokens = normalized.split(',').map((t) => __benchmarkTrim(t)).filter(Boolean);
				if (!tokens.length) return null;

				const out = new Set();
				for (const token of tokens) {
					const range = token.match(/^(\d+)-(\d+)$/);
					if (range) {
						let a = __benchmarkClampInt(range[1], { min: 1, max: 1000000, fallback: -1 });
						let b = __benchmarkClampInt(range[2], { min: 1, max: 1000000, fallback: -1 });
						if (a <= 0 || b <= 0) return null;
						if (a > b) { const t = a; a = b; b = t; }
						for (let n = a; n <= b; n++) {
							if (n >= 1 && n <= total) out.add(n - 1);
						}
						continue;
					}
					if (/^\d+$/.test(token)) {
						const n = __benchmarkClampInt(token, { min: 1, max: 1000000, fallback: -1 });
						if (n >= 1 && n <= total) out.add(n - 1);
						continue;
					}
					return null;
				}
				return Array.from(out).sort((a, b) => a - b);
			}

			function __benchmarkProblemMatchesTextFilter(problem, filterLower, problemIndex = -1) {
				const filter = __benchmarkTrim(filterLower || '').toLowerCase();
				if (!filter) return true;
				const p = problem || {};
				const qid = __benchmarkTrim(p.qid || '');
				const q = __benchmarkTrim((p.question_text || '').toString());
				const choices = __benchmarkTrim((p.answer_choices || '').toString());
				const ans = __benchmarkTrim((p.official_answer || '').toString());
				const expl = __benchmarkTrim((p.official_explanation || '').toString());
				const idx = __benchmarkClampInt(problemIndex, { min: 0, max: 1000000, fallback: -1 });
				const oneBased = idx >= 0 ? `${idx + 1}` : '';
				const indexHints = oneBased
					? `\nproblem ${oneBased}\n#${oneBased}\nq${oneBased}\np${oneBased}`
					: '';
				const hay = `${qid}\n${q}\n${choices}\n${ans}\n${expl}${indexHints}`.toLowerCase();
				if (!filter.includes('|')) return hay.includes(filter);
				const terms = filter
					.split('|')
					.map((t) => __benchmarkTrim(t))
					.filter(Boolean);
				if (!terms.length) return true;
				return terms.some((t) => hay.includes(t));
			}

		function __benchmarkBuildRunSignature(dataset, selection, mode, autoGrade, extra = {}) {
			const dsSig = __benchmarkDatasetSignature(dataset);
			const sel = __benchmarkNormalizeSelectionForSignature(selection)
				.map((s) => `${s.archId}:${s.count}`)
				.join('|');
			const gradeMode = __benchmarkTrim(mode || 'answer_only') || 'answer_only';
			const ag = autoGrade ? '1' : '0';
			const subsetSig = __benchmarkTrim(extra?.subsetSig || '');
			const subsetPart = subsetSig ? `::subset=${subsetSig}` : '';
			return `${dsSig}::${sel}::${gradeMode}::${ag}${subsetPart}`;
		}

		function __benchmarkBuildConvertSourceSignature(textChunks, chunkCfg = {}) {
			const chunks = Array.isArray(textChunks) ? textChunks : [];
			const split = __benchmarkClampInt(chunkCfg?.parseSplitTokens, { min: 500, max: 200000, fallback: 12000 });
			const merge = __benchmarkClampInt(chunkCfg?.parseMergeTokens, { min: 500, max: 200000, fallback: 12000 });
			const digest = chunks.map((item, idx) => {
				const txt = __benchmarkTrim(item?.text || '');
				const hints = __benchmarkUniqueTextList(item?.qidHints || []).join(',');
				const tok = __benchmarkEstimateTokens(txt);
				const head = txt.slice(0, 48).replace(/\s+/g, ' ');
				return `${idx}:${tok}:${hints}:${head}`;
			}).join('|');
			return `v1|chunks=${chunks.length}|split=${split}|merge=${merge}|${digest}`;
		}

		function __benchmarkNormalizeRunCheckpoint(raw) {
			if (!raw || typeof raw !== 'object') return null;
			const rows = Array.isArray(raw.rows) ? raw.rows.slice() : [];
			const totalProblems = __benchmarkClampInt(raw.total_problems, { min: 0, max: 1000000, fallback: 0 });
			const nextProblemIndex = __benchmarkClampInt(raw.next_problem_index, {
				min: 0,
				max: Math.max(0, totalProblems || 1000000),
				fallback: 0,
			});
			return {
				version: 1,
				status: __benchmarkTrim(raw.status || 'running') || 'running',
				created_at: Number.isFinite(raw.created_at) ? raw.created_at : Date.now(),
				updated_at: Number.isFinite(raw.updated_at) ? raw.updated_at : Date.now(),
				signature: __benchmarkTrim(raw.signature || ''),
				dataset_signature: __benchmarkTrim(raw.dataset_signature || ''),
				mode: __benchmarkTrim(raw.mode || 'answer_only') || 'answer_only',
				auto_grade: !!raw.auto_grade,
				total_problems: totalProblems,
				next_problem_index: nextProblemIndex,
				rows,
				run_session_id: __benchmarkTrim(raw.run_session_id || ''),
				selected: __benchmarkNormalizeSelectionForSignature(raw.selected),
				note: __benchmarkTrim(raw.note || ''),
			};
		}

		function __benchmarkNormalizeParseCheckpoint(raw) {
			if (!raw || typeof raw !== 'object') return null;
			const textChunks = Array.isArray(raw.text_chunks)
				? raw.text_chunks.map((c) => ({
					text: __benchmarkTrim(c?.text || ''),
					qidHints: __benchmarkUniqueTextList(c?.qidHints || []),
				})).filter((c) => !!c.text)
				: [];
			const partialDatasets = Array.isArray(raw.partial_datasets)
				? raw.partial_datasets
					.map((ds, idx) => __benchmarkNormalizeDataset(ds || {}, __benchmarkTrim(ds?.name || `API-Converted chunk ${idx + 1}`)))
					.filter((ds) => Array.isArray(ds?.problems) && ds.problems.length > 0)
				: [];
			const split = __benchmarkClampInt(raw?.chunk_cfg?.parseSplitTokens, { min: 500, max: 200000, fallback: 12000 });
			const merge = __benchmarkClampInt(raw?.chunk_cfg?.parseMergeTokens, { min: 500, max: 200000, fallback: 12000 });
			const nextChunkIndex = __benchmarkClampInt(raw.next_chunk_index, {
				min: 0,
				max: Math.max(0, textChunks.length),
				fallback: 0,
			});
			return {
				version: 1,
				status: __benchmarkTrim(raw.status || 'paused') || 'paused',
				created_at: Number.isFinite(raw.created_at) ? raw.created_at : Date.now(),
				updated_at: Number.isFinite(raw.updated_at) ? raw.updated_at : Date.now(),
				source_signature: __benchmarkTrim(raw.source_signature || ''),
				source_label: __benchmarkTrim(raw.source_label || ''),
				chunk_cfg: { parseSplitTokens: split, parseMergeTokens: merge },
				total_input_tokens: __benchmarkClampInt(raw.total_input_tokens, { min: 0, max: 1000000000, fallback: 0 }),
				text_chunks: textChunks,
				next_chunk_index: nextChunkIndex,
				partial_datasets: partialDatasets,
				note: __benchmarkTrim(raw.note || ''),
			};
		}

		function __benchmarkNormalizeGradeCheckpoint(raw) {
			if (!raw || typeof raw !== 'object') return null;
			const rows = Array.isArray(raw.rows) ? raw.rows.slice() : [];
			return {
				version: 1,
				status: __benchmarkTrim(raw.status || 'paused') || 'paused',
				created_at: Number.isFinite(raw.created_at) ? raw.created_at : Date.now(),
				updated_at: Number.isFinite(raw.updated_at) ? raw.updated_at : Date.now(),
				mode: __benchmarkTrim(raw.mode || 'answer_only') || 'answer_only',
				dataset_signature: __benchmarkTrim(raw.dataset_signature || ''),
				rows,
				note: __benchmarkTrim(raw.note || ''),
			};
		}

		function __benchmarkSafeClone(value) {
			try { return JSON.parse(JSON.stringify(value)); } catch { }
			try { return __benchmarkString(value); } catch { }
			return null;
		}

		function __benchmarkNextArtifactId(prefix = 'evt') {
			const artifacts = __benchmarkEnsureArtifacts();
			const next = (__benchmarkClampInt(artifacts?.counters?.id, { min: 0, max: 1000000000, fallback: 0 }) + 1);
			if (!artifacts.counters || typeof artifacts.counters !== 'object') artifacts.counters = {};
			artifacts.counters.id = next;
			return `${prefix}-${next}`;
		}

		function __benchmarkMessageContentToText(content) {
			if (typeof content === 'string') return content;
			if (Array.isArray(content)) {
				return content.map(part => {
					if (typeof part === 'string') return part;
					if (part && typeof part === 'object') {
						if (typeof part.text === 'string') return part.text;
						try { return JSON.stringify(part); } catch { return ''; }
					}
					return __benchmarkString(part);
				}).filter(Boolean).join('\n');
			}
			if (content && typeof content === 'object') {
				if (typeof content.text === 'string') return content.text;
				try { return JSON.stringify(content, null, 2); } catch { }
			}
			return __benchmarkString(content);
		}

		function __benchmarkMessagesToRawText(messages) {
			return __benchmarkToArray(messages).map((m, idx) => {
				const role = __benchmarkTrim(m?.role || `message-${idx + 1}`) || `message-${idx + 1}`;
				const body = __benchmarkMessageContentToText(m?.content);
				return `[${role}]\n${body}`;
			}).join('\n\n-----\n\n');
		}

		function __benchmarkRecordApiCallStart(meta = {}) {
			const artifacts = __benchmarkEnsureArtifacts();
			const rec = {
				id: __benchmarkNextArtifactId('api'),
				started_at: Date.now(),
				finished_at: null,
				status: 'running',
				kind: __benchmarkTrim(meta.kind || ''),
				context: __benchmarkTrim(meta.context || ''),
				model: __benchmarkTrim(meta.model || ''),
				mode: __benchmarkTrim(meta.mode || ''),
				attempt: __benchmarkTrim(meta.attempt || ''),
				key_slot: __benchmarkTrim(meta.key_slot || ''),
				request: __benchmarkSafeClone(meta.request || {}),
				response: null,
				error: null,
			};
			rec.__counterFinalized = false;
			artifacts.apiCalls.push(rec);
			artifacts.selectedApiCallId = rec.id;
			const counters = __benchmarkEnsureApiCounters();
			const kind = (__benchmarkTrim(rec.kind || '').toLowerCase() === 'grade') ? 'grade' : 'parse';
			counters[kind].total += 1;
			counters[kind].running += 1;
			__benchmarkRenderApiCounters();
			__benchmarkTouchArtifacts();
			__benchmarkRenderRawIoViewer(false);
			return rec;
		}

		function __benchmarkRecordApiCallFinish(record, patch = {}) {
			if (!record || typeof record !== 'object') return;
			const artifacts = __benchmarkEnsureArtifacts();
			const alreadyFinalized = !!record.__counterFinalized;
			record.finished_at = Date.now();
			record.status = __benchmarkTrim(patch.status || record.status || 'done') || 'done';
			if (patch.request && typeof patch.request === 'object') record.request = __benchmarkSafeClone(patch.request);
			if (patch.response && typeof patch.response === 'object') record.response = __benchmarkSafeClone(patch.response);
			if (patch.error && typeof patch.error === 'object') record.error = __benchmarkSafeClone(patch.error);
			if (!alreadyFinalized) {
				const counters = __benchmarkEnsureApiCounters();
				const kind = (__benchmarkTrim(record.kind || '').toLowerCase() === 'grade') ? 'grade' : 'parse';
				const row = counters[kind] || (counters[kind] = { total: 0, success: 0, error: 0, running: 0 });
				row.running = Math.max(0, __benchmarkClampInt(row.running, { min: 0, max: 1000000000, fallback: 0 }) - 1);
				const status = __benchmarkTrim(record.status || '').toLowerCase();
				if (status === 'error' || status === 'failed' || status === 'fail') row.error += 1;
				else row.success += 1;
				record.__counterFinalized = true;
				__benchmarkRenderApiCounters();
			}
			artifacts.selectedApiCallId = record.id;
			const latestInput = __benchmarkBuildApiCallInputText(record);
			const latestOutput = __benchmarkBuildApiCallOutputText(record);
			artifacts.latestRawInput = latestInput;
			artifacts.latestRawOutput = latestOutput;
			__benchmarkTouchArtifacts();
			__benchmarkRenderRawIoViewer(false);
		}

		function __benchmarkFindApiCallById(id) {
			const key = __benchmarkTrim(id || '');
			if (!key) return null;
			const artifacts = __benchmarkEnsureArtifacts();
			const list = Array.isArray(artifacts.apiCalls) ? artifacts.apiCalls : [];
			for (let i = 0; i < list.length; i++) {
				if (__benchmarkTrim(list[i]?.id || '') === key) return list[i];
			}
			return null;
		}

		function __benchmarkBuildApiCallInputText(rec) {
			const call = rec || {};
			const req = (call.request && typeof call.request === 'object') ? call.request : {};
			const lines = [];
			if (__benchmarkTrim(call.context)) lines.push(`Context: ${call.context}`);
			if (__benchmarkTrim(call.kind)) lines.push(`Kind: ${call.kind}`);
			if (__benchmarkTrim(call.mode)) lines.push(`Mode: ${call.mode}`);
			if (__benchmarkTrim(call.model)) lines.push(`Model: ${call.model}`);
			if (__benchmarkTrim(call.attempt)) lines.push(`Attempt: ${call.attempt}`);
			if (__benchmarkTrim(req.endpoint)) lines.push(`Endpoint: ${req.endpoint}`);
			if (__benchmarkTrim(req.proxy)) lines.push(`Proxy: ${req.proxy}`);
			if (Number.isFinite(req.est_in_tokens)) lines.push(`Estimated input tokens: ${req.est_in_tokens}`);
			lines.push('');
			lines.push('Messages (raw):');
			lines.push(__benchmarkString(req.messages_text || ''));
			lines.push('');
			lines.push('Request body (JSON):');
			lines.push(JSON.stringify(req.body || {}, null, 2));
			return lines.join('\n').trim();
		}

		function __benchmarkBuildApiCallOutputText(rec) {
			const call = rec || {};
			const lines = [];
			lines.push(`Status: ${__benchmarkTrim(call.status || 'unknown')}`);
			if (Number.isFinite(call?.response?.elapsed_ms)) lines.push(`Elapsed ms: ${call.response.elapsed_ms}`);
			if (Number.isFinite(call?.response?.usage_tokens)) lines.push(`Usage tokens: ${call.response.usage_tokens}`);
			if (__benchmarkTrim(call?.error?.message)) lines.push(`Error: ${call.error.message}`);
			if (Number.isFinite(call?.error?.http_status)) lines.push(`HTTP status: ${call.error.http_status}`);
			lines.push('');
			if (__benchmarkTrim(call?.response?.raw_text)) {
				lines.push('Raw model output:');
				lines.push(__benchmarkString(call.response.raw_text));
			} else if (__benchmarkTrim(call?.error?.body)) {
				lines.push('Raw error body:');
				lines.push(__benchmarkString(call.error.body));
			} else {
				lines.push('Raw model output:');
				lines.push('');
			}
			return lines.join('\n').trim();
		}

		function __benchmarkBuildApiCallSequenceText(rec) {
			const call = rec || {};
			const lines = [];
			lines.push('===== API CALL =====');
			lines.push(`Call ID: ${__benchmarkTrim(call?.id || '-')}`);
			if (Number.isFinite(call?.started_at)) lines.push(`Started: ${new Date(call.started_at).toISOString()}`);
			if (Number.isFinite(call?.finished_at)) lines.push(`Finished: ${new Date(call.finished_at).toISOString()}`);
			lines.push('');
			lines.push('[INPUT]');
			lines.push(__benchmarkBuildApiCallInputText(call));
			lines.push('');
			lines.push('[OUTPUT]');
			lines.push(__benchmarkBuildApiCallOutputText(call));
			return lines.join('\n').trim();
		}

		function __benchmarkBuildApiCallsTimelineText(calls) {
			const list = Array.isArray(calls) ? calls.slice() : [];
			if (!list.length) return '';
			const sorted = list.slice().sort((a, b) => {
				const ta = Number.isFinite(a?.started_at) ? a.started_at : 0;
				const tb = Number.isFinite(b?.started_at) ? b.started_at : 0;
				if (ta !== tb) return ta - tb;
				const ida = __benchmarkTrim(a?.id || '');
				const idb = __benchmarkTrim(b?.id || '');
				return ida.localeCompare(idb);
			});
			return sorted.map((rec) => __benchmarkBuildApiCallSequenceText(rec)).join('\n\n\n');
		}

		function __benchmarkClearRawIoArtifacts(options = {}) {
			const opts = (options && typeof options === 'object') ? options : {};
			const artifacts = __benchmarkEnsureArtifacts();
			artifacts.apiCalls = [];
			artifacts.selectedApiCallId = '';
			artifacts.latestRawInput = '';
			artifacts.latestRawOutput = '';
			__benchmarkTouchArtifacts();
			__benchmarkRenderRawIoViewer(true);
			if (!opts.silent) {
				__benchmarkLog('INFO', 'BenchmarkArtifacts', 'Cleared raw API I/O artifacts.');
			}
			if (!opts.noSave) {
				try { saveToLocalStorage(); } catch { }
			}
		}

		function __benchmarkRenderRawIoViewer(forceRebuildSelect = false) {
			const artifacts = __benchmarkEnsureArtifacts();
			const selectEl = document.getElementById('benchmarkIoCallSelect');
			const ioEl = document.getElementById('benchmarkRawIoView');
			if (!selectEl || !ioEl) return;

			const calls = Array.isArray(artifacts.apiCalls) ? artifacts.apiCalls : [];
			const prev = __benchmarkTrim(selectEl.value || artifacts.selectedApiCallId || '');
			selectEl.innerHTML = '';
			const emptyOpt = document.createElement('option');
			emptyOpt.value = '';
			emptyOpt.textContent = calls.length ? 'All captured API calls (in order)' : 'No API calls captured';
			selectEl.appendChild(emptyOpt);
			for (const rec of calls) {
				const opt = document.createElement('option');
				opt.value = __benchmarkTrim(rec?.id || '');
				const ts = Number.isFinite(rec?.started_at) ? new Date(rec.started_at).toLocaleTimeString() : '--:--:--';
				const ctx = __benchmarkTrim(rec?.context || 'API');
				const status = __benchmarkTrim(rec?.status || 'unknown');
				const model = __benchmarkTrim(rec?.model || '');
				const attempt = __benchmarkTrim(rec?.attempt || '');
				opt.textContent = `${ts} | ${ctx} | ${model || 'model?'} | ${status}${attempt ? ` | ${attempt}` : ''}`;
				selectEl.appendChild(opt);
			}

			let selectedId = prev;
			if (!selectedId || !calls.some((rec) => __benchmarkTrim(rec?.id || '') === selectedId)) {
				selectedId = '';
			}
			selectEl.value = selectedId;
			artifacts.selectedApiCallId = __benchmarkTrim(selectEl.value || '');

			const selectedCall = __benchmarkFindApiCallById(artifacts.selectedApiCallId) || null;
			const timeline = selectedCall
				? __benchmarkBuildApiCallSequenceText(selectedCall)
				: __benchmarkBuildApiCallsTimelineText(calls);
			const fallback = __benchmarkTrim(artifacts.latestRawInput || '') || __benchmarkTrim(artifacts.latestRawOutput || '');
			ioEl.value = __benchmarkTrim(timeline || fallback);
			try { ioEl.scrollTop = 0; } catch { }
		}

		function __benchmarkRecordConvertSessionStart(meta = {}) {
			const artifacts = __benchmarkEnsureArtifacts();
			const session = {
				id: __benchmarkNextArtifactId('convert'),
				started_at: Date.now(),
				finished_at: null,
				status: 'running',
				meta: __benchmarkSafeClone(meta || {}),
				prepared_chunks: [],
				chunk_results: [],
				partial_datasets: [],
				final_dataset: null,
				error: '',
			};
			artifacts.convertSessions.push(session);
			__benchmarkTouchArtifacts();
			return session;
		}

		function __benchmarkRecordConvertSessionFinish(session, patch = {}) {
			if (!session || typeof session !== 'object') return;
			session.finished_at = Date.now();
			session.status = __benchmarkTrim(patch.status || session.status || 'done') || 'done';
			if (patch.error != null) session.error = __benchmarkString(patch.error || '');
			if (patch.final_dataset) session.final_dataset = __benchmarkSafeClone(patch.final_dataset);
			__benchmarkTouchArtifacts();
		}

		function __benchmarkRecordRunSession(meta = {}) {
			const artifacts = __benchmarkEnsureArtifacts();
			const entry = {
				id: __benchmarkNextArtifactId('run'),
				created_at: Date.now(),
				...__benchmarkSafeClone(meta || {}),
			};
			artifacts.runSessions.push(entry);
			__benchmarkTouchArtifacts();
			return entry;
		}

		function __benchmarkRecordGradeSession(meta = {}) {
			const artifacts = __benchmarkEnsureArtifacts();
			const entry = {
				id: __benchmarkNextArtifactId('grade'),
				created_at: Date.now(),
				...__benchmarkSafeClone(meta || {}),
			};
			artifacts.gradeSessions.push(entry);
			__benchmarkTouchArtifacts();
			return entry;
		}

		function __benchmarkDownloadArtifactsJson() {
			const benchmarkState = __benchmarkExportState();
			try {
				if (benchmarkState?.ui) {
					if (benchmarkState.ui.parseApiKeyList) benchmarkState.ui.parseApiKeyList = '[REDACTED]';
					if (benchmarkState.ui.gradeApiKeyList) benchmarkState.ui.gradeApiKeyList = '[REDACTED]';
				}
			} catch { }
			const state = {
				version: 'mini-artichokes-artifacts-v1',
				exported_at: Date.now(),
				benchmark: benchmarkState,
			};
			__benchmarkDownloadJson('mini-artichokes-benchmark-artifacts.json', state);
			__benchmarkLog('INFO', 'BenchmarkArtifacts', 'Downloaded benchmark artifacts JSON.');
		}

		function __benchmarkToArray(v) {
			if (Array.isArray(v)) return v.slice();
			if (v == null) return [];
			return [v];
		}

		function __benchmarkString(v) {
			return (v == null) ? '' : String(v);
		}

		function __benchmarkTrim(v) {
			return __benchmarkString(v).replace(/\r\n/g, '\n').trim();
		}

		function __benchmarkClampInt(v, { min = 0, max = 999999999, fallback = 0 } = {}) {
			const n = parseInt(v, 10);
			if (!Number.isFinite(n)) return fallback;
			if (n < min) return min;
			if (n > max) return max;
			return n;
		}

		function __benchmarkTaskKindLabel(kind) {
			return (kind === 'grade') ? 'Grade' : 'Convert';
		}

		function __benchmarkGetTaskCheckpoint(kind) {
			return (kind === 'grade') ? (__benchmarkStudio.gradeCheckpoint || null) : (__benchmarkStudio.parseCheckpoint || null);
		}

		function __benchmarkSetTaskCheckpoint(kind, checkpoint) {
			if (kind === 'grade') {
				__benchmarkStudio.gradeCheckpoint = checkpoint ? __benchmarkNormalizeGradeCheckpoint(checkpoint) : null;
			} else {
				__benchmarkStudio.parseCheckpoint = checkpoint ? __benchmarkNormalizeParseCheckpoint(checkpoint) : null;
			}
			__benchmarkSyncTaskButtons();
		}

		function __benchmarkIsTaskRunning(kind) {
			return (kind === 'grade') ? !!__benchmarkStudio.gradeTaskRunning : !!__benchmarkStudio.parseTaskRunning;
		}

		function __benchmarkSetTaskRunning(kind, running) {
			if (kind === 'grade') __benchmarkStudio.gradeTaskRunning = !!running;
			else __benchmarkStudio.parseTaskRunning = !!running;
			__benchmarkSyncTaskButtons();
		}

		function __benchmarkIsTaskStopRequested(kind) {
			return (kind === 'grade') ? !!__benchmarkStudio.gradeStopRequested : !!__benchmarkStudio.parseStopRequested;
		}

		function __benchmarkSetTaskStopRequested(kind, requested) {
			if (kind === 'grade') __benchmarkStudio.gradeStopRequested = !!requested;
			else __benchmarkStudio.parseStopRequested = !!requested;
			__benchmarkSyncTaskButtons();
		}

		function __benchmarkMakeTaskStopError(kind) {
			const e = new Error(`${__benchmarkTaskKindLabel(kind)} stopped by user.`);
			e.__benchmarkTaskStopped = true;
			e.__benchmarkTaskKind = kind;
			return e;
		}

		function __benchmarkIsTaskStopError(err, kind = '') {
			if (!err || !err.__benchmarkTaskStopped) return false;
			if (!kind) return true;
			return __benchmarkTrim(err.__benchmarkTaskKind || '') === __benchmarkTrim(kind);
		}

		function __benchmarkThrowIfTaskStopped(kind) {
			if (__benchmarkIsTaskStopRequested(kind)) throw __benchmarkMakeTaskStopError(kind);
		}

		async function __benchmarkSleepInterruptible(kind, ms) {
			const waitMs = Math.max(0, Number(ms) || 0);
			if (!waitMs) return;
			const end = Date.now() + waitMs;
			while (Date.now() < end) {
				__benchmarkThrowIfTaskStopped(kind);
				const slice = Math.min(200, end - Date.now());
				await new Promise((res) => setTimeout(res, Math.max(1, slice)));
			}
		}

		function __benchmarkGetTaskRateMap(kind) {
			const pack = (__benchmarkStudio.taskRateState && typeof __benchmarkStudio.taskRateState === 'object')
				? __benchmarkStudio.taskRateState
				: null;
			if (!pack) return new Map();
			if (!pack[kind]) pack[kind] = new Map();
			return pack[kind];
		}

		function __benchmarkGetTaskInflightMap(kind) {
			const pack = (__benchmarkStudio.taskInflightState && typeof __benchmarkStudio.taskInflightState === 'object')
				? __benchmarkStudio.taskInflightState
				: null;
			if (!pack) return new Map();
			if (!pack[kind]) pack[kind] = new Map();
			return pack[kind];
		}

		async function __benchmarkAcquireTaskRateSlot(kind, cfg, rawKey, estTokens, contextLabel) {
			const rpmLimit = __normalizeRateLimit(cfg?.rpmLimit);
			const tpmLimit = __normalizeRateLimit(cfg?.tpmLimit);
			const inflightLimit = __normalizeInflightLimit(cfg?.maxInflightPerKey);
			if (!rpmLimit && !tpmLimit && !inflightLimit) return () => { };

			const key = __benchmarkTrim(rawKey || '__NO_KEY__') || '__NO_KEY__';
			const rateMap = __benchmarkGetTaskRateMap(kind);
			const inflightMap = __benchmarkGetTaskInflightMap(kind);
			const tokens = Number.isFinite(estTokens) ? Math.max(0, estTokens) : 0;
			const oversizeTpm = tpmLimit > 0 && tokens > tpmLimit;
			let lastLogAt = 0;
			const __MAX_RATE_WAIT_MS = 10 * 60 * 1000;
			const hardWaitStart = Date.now();

			while (true) {
				__benchmarkThrowIfTaskStopped(kind);
				const now = Date.now();
				let st = rateMap.get(key);
				if (!st || typeof st !== 'object') {
					st = {
						windowStart: __minuteStart(now),
						rpm: 0,
						tpm: 0,
						lastSentAt: 0,
					};
				}
				const win = __minuteStart(now);
				if (st.windowStart !== win) {
					st.windowStart = win;
					st.rpm = 0;
					st.tpm = 0;
				}

				const inflight = Math.max(0, Number(inflightMap.get(key) || 0));
				const hitInflight = inflightLimit > 0 && inflight >= inflightLimit;
				const hitRpm = rpmLimit > 0 && (st.rpm + 1 > rpmLimit);
				const hitTpm = tpmLimit > 0 && (oversizeTpm ? (st.tpm >= tpmLimit) : (st.tpm + tokens > tpmLimit));

				if (!hitInflight && !hitRpm && !hitTpm) {
					st.rpm += 1;
					if (tpmLimit > 0) {
						if (oversizeTpm) st.tpm = Math.max(st.tpm, tpmLimit);
						else st.tpm += tokens;
					}
					st.lastSentAt = now;
					rateMap.set(key, st);
					inflightMap.set(key, inflight + 1);
					return () => {
						const cur = Math.max(0, Number(inflightMap.get(key) || 0));
						const next = Math.max(0, cur - 1);
						if (next <= 0) inflightMap.delete(key);
						else inflightMap.set(key, next);
					};
				}

				let waitMs = 120;
				if (hitRpm || hitTpm) {
					waitMs = Math.max(waitMs, (st.windowStart + 60000) - now + 25);
				}
				if (hitInflight) {
					waitMs = Math.max(waitMs, 150);
				}
				waitMs = Math.max(60, Math.min(5000, waitMs));

				if ((Date.now() - hardWaitStart) > __MAX_RATE_WAIT_MS) {
					const err = new Error(
						`Rate wait exceeded ${Math.round(__MAX_RATE_WAIT_MS / 1000)}s (${kind}): ` +
						`key=${maskKey(key)}, rpm=${st.rpm}/${rpmLimit || '‚àû'}, tpm=${st.tpm}/${tpmLimit || '‚àû'}, ` +
						`inflight=${inflight}/${inflightLimit || '‚àû'}`
					);
					try {
						err.__benchmarkNoRetry = true;
						err.__benchmarkRateWaitTimeout = true;
					} catch { }
					throw err;
				}

				if (!lastLogAt || (now - lastLogAt) > 1500) {
					lastLogAt = now;
					__benchmarkLog(
						'INFO',
						contextLabel,
						`Rate wait (${kind}): key=${maskKey(key)}, rpm=${st.rpm}/${rpmLimit || '‚àû'}, tpm=${st.tpm}/${tpmLimit || '‚àû'}, inflight=${inflight}/${inflightLimit || '‚àû'}, wait=${waitMs}ms`
					);
				}
				await __benchmarkSleepInterruptible(kind, waitMs);
			}
		}

		function __benchmarkSyncTaskButtons() {
			const parseRunning = !!__benchmarkStudio.parseTaskRunning;
			const gradeRunning = !!__benchmarkStudio.gradeTaskRunning;
			const parsePaused = __benchmarkTrim(__benchmarkStudio?.parseCheckpoint?.status || '') === 'paused';
			const gradeCp = __benchmarkNormalizeGradeCheckpoint(__benchmarkStudio?.gradeCheckpoint || null);
			const gradeCpStatus = __benchmarkTrim(gradeCp?.status || '');
			const gradeResumable = (
				gradeCpStatus === 'paused' ||
				(gradeCpStatus === 'running' && !gradeRunning && Array.isArray(gradeCp?.rows) && gradeCp.rows.length > 0)
			);
			try {
				const el = document.getElementById('benchmarkConvertStopBtn');
				if (el) el.disabled = !parseRunning;
			} catch { }
			try {
				const el = document.getElementById('benchmarkConvertResumeBtn');
				if (el) el.disabled = parseRunning || !parsePaused;
			} catch { }
			try {
				const el = document.getElementById('benchmarkGradeStopBtn');
				if (el) el.disabled = !gradeRunning;
			} catch { }
			try {
				const el = document.getElementById('benchmarkGradeResumeBtn');
				if (el) el.disabled = gradeRunning || !gradeResumable;
			} catch { }
			try {
				const el = document.getElementById('benchmarkGradeBtn');
				if (el && !gradeRunning) {
					el.textContent = gradeResumable ? '‚úÖ Grade / Resume Current Results' : '‚úÖ Grade Current Results';
				}
			} catch { }
		}

		function __benchmarkGetChunkingConfig() {
			return {
				convertDelimiter: __benchmarkTrim(document.getElementById('benchmarkConvertDelimiter')?.value || ''),
				answerKeyProvided: !!__benchmarkTrim(document.getElementById('benchmarkAnswerKeyText')?.value || ''),
				parseSplitTokens: __benchmarkClampInt(document.getElementById('benchmarkParseSplitTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
				parseMergeTokens: __benchmarkClampInt(document.getElementById('benchmarkParseMergeTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
				gradeSplitTokens: __benchmarkClampInt(document.getElementById('benchmarkGradeSplitTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
				gradeMergeTokens: __benchmarkClampInt(document.getElementById('benchmarkGradeMergeTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
			};
		}

		function __benchmarkResolveResumableGradeCheckpoint() {
			const cp = __benchmarkNormalizeGradeCheckpoint(__benchmarkGetTaskCheckpoint('grade') || null);
			if (!cp || !Array.isArray(cp?.rows) || !cp.rows.length) return null;
			const status = __benchmarkTrim(cp?.status || '');
			if (status === 'paused') return cp;
			if (status === 'running' && !__benchmarkIsTaskRunning('grade')) {
				cp.status = 'paused';
				cp.updated_at = Date.now();
				cp.note = __benchmarkTrim(cp?.note || '') || 'auto-paused-stale-running-checkpoint';
				__benchmarkSetTaskCheckpoint('grade', cp);
				__benchmarkSchedulePersist(20);
				__benchmarkLog('WARN', 'Grade', 'Recovered stale running grading checkpoint; switched to paused for resume.');
				return cp;
			}
			return null;
		}

		function __benchmarkSetProgress(text) {
			const el = document.getElementById('benchmarkProgress');
			if (!el) return;
			el.innerText = __benchmarkTrim(text) || 'Idle';
		}

		function __benchmarkNormalizeApiCounters(raw) {
			const base = __benchmarkCreateApiCountersState();
			const src = (raw && typeof raw === 'object') ? raw : {};
			const kinds = ['parse', 'grade'];
			for (const kind of kinds) {
				const item = (src[kind] && typeof src[kind] === 'object') ? src[kind] : {};
				base[kind] = {
					total: __benchmarkClampInt(item.total, { min: 0, max: 1000000000, fallback: 0 }),
					success: __benchmarkClampInt(item.success, { min: 0, max: 1000000000, fallback: 0 }),
					error: __benchmarkClampInt(item.error, { min: 0, max: 1000000000, fallback: 0 }),
					running: __benchmarkClampInt(item.running, { min: 0, max: 1000000000, fallback: 0 }),
				};
			}
			return base;
		}

		function __benchmarkEnsureApiCounters() {
			__benchmarkStudio.apiCounters = __benchmarkNormalizeApiCounters(__benchmarkStudio.apiCounters || {});
			return __benchmarkStudio.apiCounters;
		}

		function __benchmarkResetApiCounters(kind = '') {
			const counters = __benchmarkEnsureApiCounters();
			const k = __benchmarkTrim(kind || '').toLowerCase();
			if (k === 'parse' || k === 'grade') {
				counters[k] = { total: 0, success: 0, error: 0, running: 0 };
			} else {
				__benchmarkStudio.apiCounters = __benchmarkCreateApiCountersState();
			}
			__benchmarkRenderApiCounters();
		}

		function __benchmarkRebuildApiCountersFromArtifacts() {
			const counters = __benchmarkCreateApiCountersState();
			const calls = __benchmarkToArray(__benchmarkEnsureArtifacts()?.apiCalls || []);
			for (const rec of calls) {
				const kind = __benchmarkTrim(rec?.kind || '').toLowerCase() === 'grade' ? 'grade' : 'parse';
				const status = __benchmarkTrim(rec?.status || '').toLowerCase();
				counters[kind].total += 1;
				if (status === 'running') counters[kind].running += 1;
				else if (status === 'error' || status === 'failed' || status === 'fail') counters[kind].error += 1;
				else counters[kind].success += 1;
			}
			__benchmarkStudio.apiCounters = counters;
			__benchmarkRenderApiCounters();
		}

		function __benchmarkRenderApiCounters() {
			const counters = __benchmarkEnsureApiCounters();
			const renderOne = (kind, elId, label) => {
				const el = document.getElementById(elId);
				if (!el) return;
				const row = counters[kind] || { total: 0, success: 0, error: 0, running: 0 };
				el.textContent = `${label} API calls: total=${row.total} | success=${row.success} | error=${row.error} | running=${row.running}`;
			};
			renderOne('parse', 'benchmarkConvertApiCounter', 'Convert');
			renderOne('grade', 'benchmarkGradeApiCounter', 'Grade');
		}

		function __benchmarkRenderLog() {
			const outEl = document.getElementById('benchmarkLogOutput');
			if (!outEl) return;
			const lines = Array.isArray(__benchmarkStudio.logLines) ? __benchmarkStudio.logLines : [];
			if (!lines.length) {
				outEl.innerText = 'No benchmark logs yet.';
				return;
			}
			outEl.innerText = lines.join('\n');
			try { outEl.scrollTop = outEl.scrollHeight; } catch { }
		}

			function __benchmarkLog(level, context, message) {
				const lvl = __benchmarkTrim(level || 'INFO').toUpperCase();
				const ctx = __benchmarkTrim(context || 'Benchmark');
				const msg = __benchmarkTrim(message || '');
				const ts = new Date();
				const hh = `${ts.getHours()}`.padStart(2, '0');
				const mm = `${ts.getMinutes()}`.padStart(2, '0');
				const ss = `${ts.getSeconds()}`.padStart(2, '0');
				if (!Array.isArray(__benchmarkStudio.logLines)) __benchmarkStudio.logLines = [];
				const sig = `${lvl}|${ctx}|${msg}`;
				if (__benchmarkStudio.__lastLogSig === sig && __benchmarkStudio.logLines.length) {
					const nextCount = (Number.isFinite(__benchmarkStudio.__lastLogRepeatCount) ? __benchmarkStudio.__lastLogRepeatCount : 1) + 1;
					__benchmarkStudio.__lastLogRepeatCount = nextCount;
					const line = `[${hh}:${mm}:${ss}] [${lvl}] [${ctx}] ${msg}${nextCount > 1 ? ` (x${nextCount})` : ''}`;
					__benchmarkStudio.logLines[__benchmarkStudio.logLines.length - 1] = line;
				} else {
					__benchmarkStudio.__lastLogSig = sig;
					__benchmarkStudio.__lastLogRepeatCount = 1;
					const line = `[${hh}:${mm}:${ss}] [${lvl}] [${ctx}] ${msg}`;
					__benchmarkStudio.logLines.push(line);
				}
				const maxLines = 200000;
				if (__benchmarkStudio.logLines.length > maxLines) __benchmarkStudio.logLines = __benchmarkStudio.logLines.slice(-maxLines);
				__benchmarkRenderLog();
				__benchmarkSchedulePersist(1200);
			}

		function __benchmarkClearLog() {
			__benchmarkStudio.logLines = [];
			__benchmarkRenderLog();
			__benchmarkSetProgress('Idle');
		}

		async function __benchmarkEnsureGptTokenizer() {
			try {
				const tok = (typeof window !== 'undefined')
					? (window.o200k_base || window.GPTTokenizer_o200k_base || null)
					: null;
				if (tok && typeof tok.encode === 'function') {
					__benchmarkTokenizerLoaded = true;
					return tok;
				}
			} catch { }
			if (!__benchmarkTokenizerScriptPromise) {
				__benchmarkTokenizerScriptPromise = new Promise((resolve, reject) => {
					try {
						const existing = document.querySelector('script[data-gpt-tokenizer="1"]');
						if (existing) {
							if (existing.dataset.loaded === '1') { __benchmarkTokenizerLoaded = true; return resolve(); }
							try {
								const tok = window.o200k_base || window.GPTTokenizer_o200k_base || null;
								if (tok && typeof tok.encode === 'function') { __benchmarkTokenizerLoaded = true; return resolve(); }
							} catch { }
							existing.addEventListener('load', () => { __benchmarkTokenizerLoaded = true; resolve(); }, { once: true });
							existing.addEventListener('error', () => reject(new Error('Failed to load gpt-tokenizer')), { once: true });
							return;
						}
						const s = document.createElement('script');
						s.dataset.gptTokenizer = '1';
						s.src = 'https://cdn.jsdelivr.net/npm/gpt-tokenizer@3.4.0/dist/o200k_base.min.js';
						s.async = true;
						s.onload = () => { try { s.dataset.loaded = '1'; __benchmarkTokenizerLoaded = true; } catch { } resolve(); };
						s.onerror = () => reject(new Error('Failed to load gpt-tokenizer'));
						document.head.appendChild(s);
					} catch (e) {
						reject(e);
					}
				});
			}
			await __benchmarkTokenizerScriptPromise;
			try {
				const tok = window.o200k_base || window.GPTTokenizer_o200k_base || null;
				if (tok && typeof tok.encode === 'function') { __benchmarkTokenizerLoaded = true; return tok; }
			} catch { }
			return null;
		}

		function __benchmarkEstimateTokens(text) {
			try {
				const s = __benchmarkString(text);
				const tok = (typeof window !== 'undefined')
					? (window.o200k_base || window.GPTTokenizer_o200k_base || null)
					: null;
				if (tok && typeof tok.encode === 'function') return tok.encode(s).length;
				return Math.max(1, Math.ceil(s.length / 4));
			} catch {
				return Math.max(1, Math.ceil(__benchmarkString(text).length / 4));
			}
		}

		async function __benchmarkCountTokensAsync(text) {
			try {
				const tok = await __benchmarkEnsureGptTokenizer();
				if (tok && typeof tok.encode === 'function') {
					return tok.encode(__benchmarkString(text)).length;
				}
			} catch { }
			return __benchmarkEstimateTokens(text);
		}

		function __benchmarkSplitAtomicTextByBudget(text, budget) {
			const raw = __benchmarkString(text).trim();
			const b = __benchmarkClampInt(budget, { min: 500, max: 200000, fallback: 12000 });
			if (!raw) return [];
			if (__benchmarkEstimateTokens(raw) <= b) return [raw];

			const tryPack = (parts, joiner = ' ') => {
				const arr = (Array.isArray(parts) ? parts : []).map(x => __benchmarkString(x).trim()).filter(Boolean);
				if (!arr.length) return [];
				const out = [];
				let cur = [];
				let curTok = 0;
				for (const p of arr) {
					const pt = __benchmarkEstimateTokens(p);
					if (pt > b) {
						const words = p.split(/\s+/).map(w => w.trim()).filter(Boolean);
						if (!words.length) continue;
						if (cur.length) {
							out.push(cur.join(joiner).trim());
							cur = [];
							curTok = 0;
						}
						let wCur = [];
						let wTok = 0;
						for (const w of words) {
							const wt = __benchmarkEstimateTokens(w);
							if (wCur.length && (wTok + wt > b)) {
								out.push(wCur.join(' ').trim());
								wCur = [w];
								wTok = wt;
							} else {
								wCur.push(w);
								wTok += wt;
							}
						}
						if (wCur.length) out.push(wCur.join(' ').trim());
						continue;
					}
					if (cur.length && (curTok + pt > b)) {
						out.push(cur.join(joiner).trim());
						cur = [p];
						curTok = pt;
					} else {
						cur.push(p);
						curTok += pt;
					}
				}
				if (cur.length) out.push(cur.join(joiner).trim());
				return out.filter(Boolean);
			};

			const lines = raw.split(/\n+/).map(s => s.trim()).filter(Boolean);
			if (lines.length > 1) return tryPack(lines, '\n');
			const sentences = raw.split(/(?<=[\.\?\!\n])\s+/g).map(s => s.trim()).filter(Boolean);
			if (sentences.length > 1) return tryPack(sentences, ' ');
			return tryPack(raw.split(/\s+/g), ' ');
		}

		function __benchmarkBuildBalancedCuts(tokenList, chunkCount, budget) {
			const toks = Array.isArray(tokenList) ? tokenList.map(v => Math.max(1, __benchmarkClampInt(v, { min: 1, max: 2000000, fallback: 1 }))) : [];
			const n = toks.length;
			const k = Math.max(1, __benchmarkClampInt(chunkCount, { min: 1, max: 200000, fallback: 1 }));
			const b = Math.max(1, __benchmarkClampInt(budget, { min: 1, max: 2000000, fallback: 1 }));
			if (!n || k <= 1) return [];

			const prefix = [0];
			for (let i = 0; i < n; i++) prefix.push(prefix[prefix.length - 1] + toks[i]);
			const total = prefix[n];
			const cuts = [];
			let last = 0;

			for (let cutIdx = 1; cutIdx <= k - 1; cutIdx++) {
				const remainingCuts = (k - 1) - cutIdx;
				const minI = last + 1;
				const maxI = n - (remainingCuts + 1);
				if (minI > maxI) break;

				const desired = Math.round((total * cutIdx) / k);
				let bestI = -1;
				let bestDiff = Number.POSITIVE_INFINITY;

				for (let i = minI; i <= maxI; i++) {
					const leftTok = prefix[i] - prefix[last];
					if (leftTok > b) break;
					const remTok = total - prefix[i];
					const remChunks = (k - cutIdx);
					if (remTok > remChunks * b) continue;
					const diff = Math.abs(prefix[i] - desired);
					if (diff < bestDiff) {
						bestDiff = diff;
						bestI = i;
					}
				}

				if (bestI < 0) {
					for (let i = maxI; i >= minI; i--) {
						const leftTok = prefix[i] - prefix[last];
						if (leftTok <= b) {
							bestI = i;
							break;
						}
					}
				}
				if (bestI < 0) bestI = minI;
				cuts.push(bestI);
				last = bestI;
			}
			return cuts;
		}

		function __benchmarkSplitTextByTokens(rawText, maxTokens) {
			const txt = __benchmarkString(rawText).trim();
			const budget = __benchmarkClampInt(maxTokens, { min: 500, max: 200000, fallback: 12000 });
			if (!txt) return [];

			const totalTok = __benchmarkEstimateTokens(txt);
			if (totalTok <= budget) return [txt];
			const targetChunks = Math.max(1, Math.ceil(totalTok / budget));
			const targetPerChunk = Math.max(1, Math.ceil(totalTok / targetChunks));

			const blocks = txt.split(/\n{2,}/g).map(x => x.trim()).filter(Boolean);
			const atomic = [];
			for (const block of blocks) {
				const bt = __benchmarkEstimateTokens(block);
				const splitBudget = bt > targetPerChunk ? targetPerChunk : budget;
				const parts = __benchmarkSplitAtomicTextByBudget(block, splitBudget);
				for (const p of parts) atomic.push(p);
			}
			if (!atomic.length) return [];

			const tokenList = atomic.map(s => __benchmarkEstimateTokens(s));
			const cuts = __benchmarkBuildBalancedCuts(tokenList, targetChunks, budget);
			if (!cuts.length) {
				return __benchmarkChunkItemsByToken(atomic, budget, (x) => x, 0)
					.map(g => g.map(x => __benchmarkString(x).trim()).filter(Boolean).join('\n\n').trim())
					.filter(Boolean);
			}

			const groups = [];
			let start = 0;
			for (const c of cuts) {
				groups.push(atomic.slice(start, c));
				start = c;
			}
			groups.push(atomic.slice(start));
			return groups
				.map(g => g.map(x => __benchmarkString(x).trim()).filter(Boolean).join('\n\n').trim())
				.filter(Boolean);
		}

		function __benchmarkSplitTextByDelimiter(rawText, delimiter) {
			const txt = __benchmarkString(rawText).replace(/\r\n/g, '\n');
			const delim = __benchmarkTrim(delimiter || '');
			if (!__benchmarkTrim(txt)) return [];
			if (!delim) return [__benchmarkTrim(txt)];
			return txt
				.split(delim)
				.map(part => __benchmarkTrim(part))
				.filter(Boolean);
		}

		function __benchmarkChunkItemsByToken(items, maxTokens, getText, baseOverheadTokens = 0) {
			const list = Array.isArray(items) ? items : [];
			if (!list.length) return [];
			const budget = __benchmarkClampInt(maxTokens, { min: 500, max: 200000, fallback: 12000 });
			const overhead = Math.max(0, __benchmarkClampInt(baseOverheadTokens, { min: 0, max: 200000, fallback: 0 }));
			const effectiveBudget = Math.max(1, budget - overhead);
			const infos = list.map(item => {
				const text = __benchmarkString(getText ? getText(item) : item);
				return { item, tok: Math.max(1, __benchmarkEstimateTokens(text)) };
			});
			const totalTok = infos.reduce((s, x) => s + x.tok, 0);
			const targetChunks = Math.max(1, Math.ceil(totalTok / effectiveBudget));
			const softTarget = Math.max(1, Math.ceil(totalTok / targetChunks));
			const out = [];
			let cur = [];
			let curTok = 0;
			for (let i = 0; i < infos.length; i++) {
				const info = infos[i];
				const remainingItems = infos.length - i;
				const remainingChunksAfterCurrent = Math.max(0, targetChunks - out.length - 1);
				const hardOverflow = cur.length && (curTok + info.tok > effectiveBudget);
				const softSplit =
					cur.length &&
					(curTok >= softTarget) &&
					(out.length < targetChunks - 1) &&
					(remainingItems > remainingChunksAfterCurrent);
				if (hardOverflow || softSplit) {
					out.push(cur.map(x => x.item));
					cur = [];
					curTok = 0;
				}
				cur.push(info);
				curTok += info.tok;
			}
			if (cur.length) out.push(cur.map(x => x.item));
			return out;
		}

		function __benchmarkSafeQid(v, idx = 0) {
			const raw = __benchmarkTrim(v);
			if (raw) return raw;
			return `Q${idx + 1}`;
		}

		function __benchmarkExtractBalancedJsonSnippet(text) {
			const s = __benchmarkString(text);
			if (!s) return '';
			const starts = [];
			const firstObj = s.indexOf('{');
			const firstArr = s.indexOf('[');
			if (firstObj >= 0) starts.push(firstObj);
			if (firstArr >= 0) starts.push(firstArr);
			if (!starts.length) return '';
			const start = Math.min(...starts);
			const stack = [];
			let inStr = false;
			let esc = false;
			for (let i = start; i < s.length; i++) {
				const ch = s[i];
				if (inStr) {
					if (esc) esc = false;
					else if (ch === '\\') esc = true;
					else if (ch === '"') inStr = false;
					continue;
				}
				if (ch === '"') {
					inStr = true;
					continue;
				}
				if (ch === '{' || ch === '[') stack.push(ch);
				else if (ch === '}' || ch === ']') {
					const top = stack[stack.length - 1];
					if ((top === '{' && ch === '}') || (top === '[' && ch === ']')) {
						stack.pop();
						if (!stack.length) return s.slice(start, i + 1);
					}
				}
			}
			return '';
		}

		function __benchmarkTryParseEmbeddedJsonFromXml(raw) {
			const txt = __benchmarkString(raw).trim();
			if (!txt || txt[0] !== '<') return null;
			let doc = null;
			try {
				doc = new DOMParser().parseFromString(txt, 'application/xml');
			} catch {
				doc = null;
			}
			if (!doc) return null;

			const candidates = [];
			const pushCandidate = (v) => {
				const s = __benchmarkTrim(v || '');
				if (s) candidates.push(s);
			};

			try {
				const root = doc.documentElement;
				if (root) {
					['json', 'data', 'payload', 'state', 'snapshot', 'content'].forEach((attr) => {
						try { pushCandidate(root.getAttribute(attr)); } catch { }
					});
					pushCandidate(root.textContent || '');
				}
				const nodes = doc.querySelectorAll('json,data,payload,state,snapshot,backup,appstate,app_state,export,content,body');
				nodes.forEach((n) => {
					try { pushCandidate(n.textContent || ''); } catch { }
				});
			} catch { }

			const tryParseCandidate = (candidate) => {
				if (!candidate) return null;
				try { return JSON.parse(__benchmarkRepairJsonStringEscapes(candidate)); } catch { }
				try { return JSON.parse(candidate); } catch { }
				const balanced = __benchmarkExtractBalancedJsonSnippet(candidate);
				if (balanced) {
					try { return JSON.parse(__benchmarkRepairJsonStringEscapes(balanced)); } catch { }
					try { return JSON.parse(balanced); } catch { }
				}
				return null;
			};

			for (const candidate of candidates) {
				const parsed = tryParseCandidate(candidate);
				if (parsed) return parsed;
			}
			return null;
		}

			function __benchmarkRepairJsonStringEscapes(raw) {
				const s = __benchmarkString(raw || '');
				// Repair should run for raw newlines inside strings even when there are no backslashes.
				// Many models output multiline JSON string values (invalid JSON) in short responses like coverage probes.
				if (!s || (s.indexOf('\\') < 0 && s.indexOf('\n') < 0 && s.indexOf('\r') < 0)) return s;
				let out = '';
				let inString = false;
				let escaped = false;
				for (let i = 0; i < s.length; i++) {
					const ch = s[i];
				if (!inString) {
					if (ch === '"') inString = true;
					out += ch;
					continue;
				}

				if (escaped) {
					escaped = false;
					out += ch;
					continue;
				}

				if (ch === '"') {
					inString = false;
					out += ch;
					continue;
				}

				if (ch === '\\') {
					const next = s[i + 1] || '';
					// Preserve JSON string structural escapes, but "neutralize" all other backslash escapes.
					// This prevents LaTeX like "\frac" from turning into a form-feed escape ("\f") during JSON.parse.
					if (next === '\\' || next === '"') out += '\\';
					else out += '\\\\';
					escaped = true;
					continue;
				}

				// JSON disallows raw newlines in strings; normalize them to a literal "\n" token.
				if (ch === '\r') {
					if (s[i + 1] === '\n') i += 1;
					out += '\\n';
					continue;
				}
				if (ch === '\n') {
					out += '\\n';
					continue;
				}

				out += ch;
			}
			return out;
		}

		function __benchmarkTryParseJson(raw) {
			const txt = __benchmarkString(raw).trim();
			if (!txt) return null;
			try { return JSON.parse(__benchmarkRepairJsonStringEscapes(txt)); } catch { }
			try { return JSON.parse(txt); } catch { }
			const fenced = txt.match(/```(?:json)?\s*([\s\S]*?)```/i);
			if (fenced && fenced[1]) {
				try { return JSON.parse(__benchmarkRepairJsonStringEscapes(fenced[1])); } catch { }
				try { return JSON.parse(fenced[1]); } catch { }
			}
			const tagWrapped =
				txt.match(/<\s*json\s*>([\s\S]*?)<\s*\/\s*json\s*>/i) ||
				txt.match(/<\s*data\s*>([\s\S]*?)<\s*\/\s*data\s*>/i);
			if (tagWrapped && tagWrapped[1]) {
				const inner = tagWrapped[1].trim();
				try { return JSON.parse(__benchmarkRepairJsonStringEscapes(inner)); } catch { }
				try { return JSON.parse(inner); } catch { }
			}
			const xmlEmbedded = __benchmarkTryParseEmbeddedJsonFromXml(txt);
			if (xmlEmbedded) return xmlEmbedded;
			const balanced = __benchmarkExtractBalancedJsonSnippet(txt);
			if (balanced) {
				try { return JSON.parse(__benchmarkRepairJsonStringEscapes(balanced)); } catch { }
				try { return JSON.parse(balanced); } catch { }
			}
			return null;
		}

		function __benchmarkExtractJsonErrorPosition(message) {
			const msg = __benchmarkString(message || '');
			if (!msg) return -1;
			const m1 = msg.match(/\bposition\s+(\d+)\b/i);
			if (m1) return __benchmarkClampInt(m1[1], { min: 0, max: 100000000, fallback: -1 });
			const m2 = msg.match(/\bat\s+(\d+)\s*$/i);
			if (m2) return __benchmarkClampInt(m2[1], { min: 0, max: 100000000, fallback: -1 });
			return -1;
		}

		function __benchmarkBuildErrorSnippet(raw, pos = -1, radius = 180) {
			const txt = __benchmarkString(raw || '');
			if (!txt) return '(empty)';
			const idx = __benchmarkClampInt(pos, { min: -1, max: 100000000, fallback: -1 });
			if (idx < 0 || idx >= txt.length) return __benchmarkPreview(txt, Math.max(220, radius * 2));
			const r = __benchmarkClampInt(radius, { min: 40, max: 1200, fallback: 180 });
			const start = Math.max(0, idx - r);
			const end = Math.min(txt.length, idx + r);
			const prefix = start > 0 ? '...[snip] ' : '';
			const suffix = end < txt.length ? ' [snip]...' : '';
			const segment = txt.slice(start, end);
			const pointerPad = Math.max(0, idx - start);
			const pointer = `${' '.repeat(pointerPad)}^`;
			return `${prefix}${segment}${suffix}\n${pointer} (pos=${idx})`;
		}

		function __benchmarkTryParseJsonDetailed(raw) {
			const txt = __benchmarkString(raw).trim();
			if (!txt) {
				return {
					ok: false,
					stage: 'empty',
					error: 'Empty JSON text',
					position: -1,
					snippet: '(empty)',
				};
			}

			const attempts = [];
			attempts.push({ stage: 'raw', text: txt });

			const fenced = txt.match(/```(?:json)?\s*([\s\S]*?)```/i);
			if (fenced && fenced[1]) attempts.push({ stage: 'fenced', text: fenced[1] });

			const tagWrapped =
				txt.match(/<\s*json\s*>([\s\S]*?)<\s*\/\s*json\s*>/i) ||
				txt.match(/<\s*data\s*>([\s\S]*?)<\s*\/\s*data\s*>/i);
			if (tagWrapped && tagWrapped[1]) attempts.push({ stage: 'tag_wrapped', text: tagWrapped[1].trim() });

			const balanced = __benchmarkExtractBalancedJsonSnippet(txt);
			if (balanced) attempts.push({ stage: 'balanced', text: balanced });

			let best = null;
			for (const at of attempts) {
				const stage = __benchmarkTrim(at?.stage || 'raw') || 'raw';
				const candidate = __benchmarkString(at?.text || '');
				if (!candidate) continue;
				try {
					const repaired = __benchmarkRepairJsonStringEscapes(candidate);
					const data = JSON.parse(repaired);
					return { ok: true, data, stage: (repaired === candidate ? stage : `${stage}+repaired_backslashes`) };
				} catch (e) {
					const msg = __benchmarkTrim(e?.message || e || 'JSON.parse failed');
					const pos = __benchmarkExtractJsonErrorPosition(msg);
					const diag = {
						ok: false,
						stage,
						error: msg,
						position: pos,
						snippet: __benchmarkBuildErrorSnippet(candidate, pos, 180),
					};
					if (!best) best = diag;
				}
			}

			if (best) return best;
			return {
				ok: false,
				stage: 'unknown',
				error: 'No JSON candidate found',
				position: -1,
				snippet: __benchmarkPreview(txt, 320),
			};
		}

		function __benchmarkPreview(raw, maxLen = 900) {
			const s = __benchmarkString(raw).replace(/\s+/g, ' ').trim();
			if (!s) return '(empty)';
			if (s.length <= maxLen) return s;
			return `${s.slice(0, maxLen)} ...[truncated ${s.length - maxLen} chars]`;
		}

		function __benchmarkGetDatasetJsonSchema() {
			return {
				type: 'object',
				properties: {
					version: { type: 'string' },
					name: { type: 'string' },
					description: { type: 'string' },
					problems: {
						type: 'array',
						items: {
							type: 'object',
							properties: {
								qid: { type: 'string' },
								question_text: { type: 'string' },
								answer_choices: { type: 'string' },
								official_answer: { type: 'string' },
								official_explanation: { type: 'string' },
								grading_mode: { type: 'string', enum: ['answer_only', 'answer_and_solution'] },
								grading_rubric: { type: 'string' },
								solution_keywords: { type: 'array', items: { type: 'string' } },
								solution_regex: { type: 'string' },
								source: { type: 'string' }
							},
							required: ['question_text']
						}
					}
				},
				required: ['problems']
			};
		}

		function __benchmarkGetCoverageProbeSchema() {
			return {
				type: 'object',
				properties: {
					estimated_problem_count: { type: 'integer' },
					qid_candidates: { type: 'array', items: { type: 'string' } },
					notes: { type: 'string' }
				},
				required: ['estimated_problem_count', 'qid_candidates']
			};
		}

		function __benchmarkGetMissingProblemsSchema() {
			return {
				type: 'object',
				properties: {
					problems: {
						type: 'array',
						items: {
							type: 'object',
							properties: {
								qid: { type: 'string' },
								question_text: { type: 'string' },
								answer_choices: { type: 'string' },
								official_answer: { type: 'string' },
								official_explanation: { type: 'string' },
								grading_mode: { type: 'string', enum: ['answer_only', 'answer_and_solution'] },
								grading_rubric: { type: 'string' },
								solution_keywords: { type: 'array', items: { type: 'string' } },
								solution_regex: { type: 'string' },
								source: { type: 'string' }
							},
							required: ['question_text']
						}
					}
				},
				required: ['problems']
			};
		}

		function __benchmarkGetQidRepairSchema() {
			return {
				type: 'object',
				properties: {
					qids: { type: 'array', items: { type: 'string' } }
				},
				required: ['qids']
			};
		}

		function __benchmarkGetSplitPlanSchema() {
			return {
				type: 'object',
				properties: {
					segments: {
						type: 'array',
						items: {
							type: 'object',
							properties: {
								start_line: { type: 'integer' },
								end_line: { type: 'integer' },
								qids: { type: 'array', items: { type: 'string' } },
								note: { type: 'string' }
							},
							required: ['start_line', 'end_line']
						}
					},
					all_qids: { type: 'array', items: { type: 'string' } }
				},
				required: ['segments']
			};
		}

		function __benchmarkGetQidSpanLocateSchema() {
			return {
				type: 'object',
				properties: {
					spans: {
						type: 'array',
						items: {
							type: 'object',
							properties: {
								qid: { type: 'string' },
								start_line: { type: 'integer' },
								end_line: { type: 'integer' },
								confidence: { type: 'number' },
								note: { type: 'string' }
							},
							required: ['qid', 'start_line', 'end_line']
						}
					}
				},
				required: ['spans']
			};
		}

		function __benchmarkToGeminiSchemaType(rawType) {
			const t = __benchmarkTrim(rawType).toLowerCase();
			if (t === 'object') return 'OBJECT';
			if (t === 'array') return 'ARRAY';
			if (t === 'string') return 'STRING';
			if (t === 'number') return 'NUMBER';
			if (t === 'integer') return 'INTEGER';
			if (t === 'boolean') return 'BOOLEAN';
			if (t === 'null') return 'NULL';
			return '';
		}

		function __benchmarkConvertJsonSchemaToGeminiSchema(schema) {
			const visit = (node, depth = 0) => {
				if (!node || typeof node !== 'object' || depth > 40) return null;
				const out = {};

				const typeRaw = node.type;
				let nonNullType = '';
				let nullable = false;
				if (Array.isArray(typeRaw)) {
					const normalized = typeRaw
						.map(x => __benchmarkTrim(x).toLowerCase())
						.filter(Boolean);
					nullable = normalized.includes('null');
					nonNullType = normalized.find(x => x !== 'null') || '';
				} else if (typeof typeRaw === 'string') {
					nonNullType = __benchmarkTrim(typeRaw).toLowerCase();
				}
				const gemType = __benchmarkToGeminiSchemaType(nonNullType);
				if (gemType) out.type = gemType;
				if (nullable) out.nullable = true;

				if (typeof node.description === 'string' && __benchmarkTrim(node.description)) {
					out.description = __benchmarkTrim(node.description);
				}
				if (typeof node.title === 'string' && __benchmarkTrim(node.title)) {
					out.title = __benchmarkTrim(node.title);
				}
				if (Array.isArray(node.enum) && node.enum.length) {
					out.enum = node.enum.filter(v => ['string', 'number', 'boolean'].includes(typeof v));
				}
				if (Number.isFinite(node.minimum)) out.minimum = Number(node.minimum);
				if (Number.isFinite(node.maximum)) out.maximum = Number(node.maximum);
				if (Number.isFinite(node.minItems)) out.minItems = Number(node.minItems);
				if (Number.isFinite(node.maxItems)) out.maxItems = Number(node.maxItems);

				if (nonNullType === 'array' && node.items && typeof node.items === 'object') {
					const child = visit(node.items, depth + 1);
					if (child) out.items = child;
				}

				if (nonNullType === 'object') {
					const props = (node.properties && typeof node.properties === 'object') ? node.properties : {};
					const keys = Object.keys(props);
					if (keys.length) {
						out.properties = {};
						for (const k of keys) {
							const child = visit(props[k], depth + 1);
							if (child) out.properties[k] = child;
						}
						if (Object.keys(out.properties).length) {
							out.propertyOrdering = Object.keys(out.properties);
						}
					}
					if (Array.isArray(node.required) && node.required.length) {
						out.required = node.required
							.map(x => __benchmarkTrim(x))
							.filter(Boolean);
					}
				}

				return Object.keys(out).length ? out : null;
			};

			return visit(schema, 0);
		}

		function __benchmarkUniqueTextList(values) {
			const out = [];
			const seen = new Set();
			for (const v of __benchmarkToArray(values)) {
				const t = __benchmarkTrim(v);
				if (!t) continue;
				if (seen.has(t)) continue;
				seen.add(t);
				out.push(t);
			}
			return out;
		}

		function __benchmarkBuildLineNumberedText(rawText) {
			const src = __benchmarkString(rawText).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
			const lines = src.split('\n');
			const numberedLines = lines.map((line, idx) => `L${String(idx + 1).padStart(5, '0')}: ${line}`);
			return {
				lines,
				numberedText: numberedLines.join('\n'),
			};
		}

		function __benchmarkNormalizeTextKey(v) {
			return __benchmarkTrim(v).toLowerCase().replace(/\s+/g, ' ');
		}

		function __benchmarkIsGenericQid(qid) {
			return /^q\d+(#\d+)?$/i.test(__benchmarkTrim(qid));
		}

		function __benchmarkEscapeRegExp(s) {
			return __benchmarkString(s).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
		}

			function __benchmarkTextContainsQid(rawText, qid) {
				const src = __benchmarkString(rawText || '');
				const q = __benchmarkTrim(qid || '');
				if (!src || !q) return false;
				const qEsc = __benchmarkEscapeRegExp(q);
				// Loose "word-ish" boundary: supports labels like A1, B12, P-3.
				const pat = new RegExp(`(^|[^A-Za-z0-9_])${qEsc}([^A-Za-z0-9_]|$)`, 'i');
				return pat.test(src);
			}

			function __benchmarkExtractQidHintsFromSourceText(rawText, options = {}) {
				const src = __benchmarkString(rawText || '');
				if (!src) return [];
				const maxQids = __benchmarkClampInt(options?.maxQids, { min: 1, max: 5000, fallback: 400 });
				const out = [];
				const seen = new Set();
				const push = (qid) => {
					const t = __benchmarkTrim(qid);
					if (!t) return;
					if (seen.has(t)) return;
					seen.add(t);
					out.push(t);
				};
				const pushRange = (a, b) => {
					const lo = __benchmarkClampInt(a, { min: 0, max: 1000000, fallback: -1 });
					const hi = __benchmarkClampInt(b, { min: 0, max: 1000000, fallback: -1 });
					if (lo < 0) return;
					if (hi < 0 || hi === lo) { push(`${lo}`); return; }
					const start = Math.min(lo, hi);
					const end = Math.max(lo, hi);
					if (end - start > 200) { push(`${start}`); push(`${end}`); return; }
					for (let x = start; x <= end && out.length < maxQids; x++) push(`${x}`);
				};
				try {
					const reQid = /\bQID\s*[:Ôºö]\s*([A-Za-z]{1,3}\d{1,4}|\d{1,4})\b/g;
					let m = null;
					while ((m = reQid.exec(src)) && out.length < maxQids) push(m[1]);
				} catch { }
				try {
					const reBracket = /\[\s*(\d{1,4})\s*(?:[ÔΩû~\-]\s*(\d{1,4}))?\s*\]/g;
					let m = null;
					while ((m = reBracket.exec(src)) && out.length < maxQids) pushRange(m[1], m[2] || '');
				} catch { }
				try {
					const reLineNum = /(?:^|\n)\s*(\d{1,4})\s*[.)]/g;
					let m = null;
					while ((m = reLineNum.exec(src)) && out.length < maxQids) push(m[1]);
				} catch { }
				try {
					const reLineAlpha = /(?:^|\n)\s*([A-Za-z]{1,3}\d{1,4})\b/g;
					let m = null;
					while ((m = reLineAlpha.exec(src)) && out.length < maxQids) push(m[1]);
				} catch { }
				return out;
			}

			function __benchmarkQuestionTextLooksLikeOptionsOnly(text) {
				const t = __benchmarkTrim(text || '');
				if (!t) return true;
				const markers = (t.match(/[‚ë†‚ë°‚ë¢‚ë£‚ë§]/g) || []).length;
				const hasStemCue = /[?]|Îã§Ïùå|Î¨ºÏùå|ÏÑ§Î™Ö|ÏùΩÍ≥†|Ïò≥ÏùÄ|ÎßûÎäî|ÏïÑÎãå|Ï†ÅÏ†à|ÏïåÎßû|Í∑ºÍ±∞|Ï∂îÎ°†|Ï£ºÏû•|ÏöîÏßÄ/.test(t);
				if (/^choices\s*:/i.test(t) && markers >= 2 && !hasStemCue) return true;
				if (/^[‚ë†‚ë°‚ë¢‚ë£‚ë§]/.test(t) && markers >= 2 && t.length < 220 && !hasStemCue) return true;
				return false;
			}

			function __benchmarkBuildHeadTailTextWindow(rawText, maxChars = 200000) {
				const src = __benchmarkString(rawText || '');
				const lim = __benchmarkClampInt(maxChars, { min: 20000, max: 2000000, fallback: 200000 });
				if (!src || src.length <= lim) return src;
				const half = Math.max(2000, Math.floor(lim / 2));
			const head = src.slice(0, half);
			const tail = src.slice(Math.max(0, src.length - half));
			return __benchmarkTrim(`${head}\n\n[...snip...]\n\n${tail}`);
		}

		function __benchmarkBuildFocusedSourceForQids(rawText, batchQids, allQids = []) {
			const src = __benchmarkString(rawText).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
			const targets = __benchmarkUniqueTextList(batchQids || []).filter(Boolean);
			if (!src || !targets.length) return __benchmarkTrim(src);

			const lines = src.split('\n');
			if (!lines.length) return '';

			const allLabels = __benchmarkUniqueTextList([...(allQids || []), ...targets]).filter(Boolean);
			const positions = new Map();
			const looksAnswerLine = (line) => /(?:answer\s*key|official\s*answer|accepted\s*answers?|final\s*answer|Ï†ïÎãµ|Îãµ\s*[:Ôºö])/i.test(line || '');
			const looksJsonMetaLine = (line) => /(?:\"qid\"|qid_candidates|official_answer|grading_mode)/i.test(line || '');

			for (const q of allLabels) {
				const qEsc = __benchmarkEscapeRegExp(q);
				const pat = new RegExp(`\\b${qEsc}\\b`, 'i');
				const lineStartPat = new RegExp(`^\\s*[\\[(]?\\s*${qEsc}(?:\\s*[\\])]?)(?:\\s*[\\.:\\)\\-]|\\s|$)`, 'i');
				let found = -1;
				let bestScore = -1e9;
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i] || '';
					if (!pat.test(line)) continue;
					let score = 0;
					if (lineStartPat.test(line)) score += 100;
					if (line.length >= 40) score += 10;
					if (looksAnswerLine(line)) score -= 120;
					if (looksJsonMetaLine(line)) score -= 140;
					if (/^\s*[\[\{]/.test(line)) score -= 25;
					if (score > bestScore) {
						bestScore = score;
						found = i;
					}
				}
				if (found >= 0) positions.set(q, found);
			}

			const intervals = [];
			for (const q of targets) {
				const pos = positions.has(q) ? positions.get(q) : -1;
				if (!Number.isFinite(pos) || pos < 0) continue;
				const nextStarts = [];
				for (const [k, p] of positions.entries()) {
					if (!Number.isFinite(p)) continue;
					if (p > pos && k !== q) nextStarts.push(p);
				}
				const next = nextStarts.length ? Math.min(...nextStarts) : -1;
				const start = Math.max(0, pos - 2);
				const endExclusive = (next > pos)
					? Math.min(lines.length, next + 2)
					: Math.min(lines.length, pos + 220);
				intervals.push({ start, end: Math.max(start + 1, endExclusive), qid: q });
			}

			if (!intervals.length) return '';

			intervals.sort((a, b) => a.start - b.start || a.end - b.end);
			const merged = [];
			for (const it of intervals) {
				const last = merged[merged.length - 1];
				if (!last || it.start > last.end) {
					merged.push({ ...it });
				} else {
					last.end = Math.max(last.end, it.end);
				}
			}

			const blocks = [];
			for (const seg of merged) {
				const chunk = __benchmarkTrim(lines.slice(seg.start, seg.end).join('\n'));
				if (!chunk) continue;
				const label = `### SOURCE_SEGMENT lines ${seg.start + 1}-${seg.end}`;
				blocks.push(`${label}\n${chunk}`);
			}

			const joined = __benchmarkTrim(blocks.join('\n\n'));
			return joined.length > 120000 ? joined.slice(0, 120000) : joined;
		}

		function __benchmarkMergeProblemLists(baseProblems, extraProblems) {
			const merged = [];
			const byQid = new Map();
			const byQuestion = new Map();

				const mergeTextList = (a, b) => {
					const out = [];
					const seen = new Set();
					[...(Array.isArray(a) ? a : []), ...(Array.isArray(b) ? b : [])].forEach(x => {
						const t = __benchmarkTrim(x);
						if (!t || seen.has(t)) return;
						seen.add(t);
						out.push(t);
					});
					return out;
				};

				const mergeFieldPreferOld = (oldV, newV) => {
					const a = __benchmarkTrim(oldV);
					const b = __benchmarkTrim(newV);
					return a || b;
				};
				const mergeFieldPreferLonger = (oldV, newV) => {
					const a = __benchmarkTrim(oldV);
					const b = __benchmarkTrim(newV);
					if (!a) return b;
					if (!b) return a;
					return b.length > a.length ? b : a;
				};
				const mergeFieldPreferNew = (oldV, newV) => {
					const a = __benchmarkTrim(oldV);
					const b = __benchmarkTrim(newV);
					return b || a;
				};

			const addOne = (raw) => {
				const p = { ...(raw || {}) };
				const qid = __benchmarkTrim(p.qid);
				const qKey = __benchmarkNormalizeTextKey(p.question_text);

				let idx = -1;
				if (qid && byQid.has(qid)) idx = byQid.get(qid);
				if (idx < 0 && qKey && byQuestion.has(qKey)) idx = byQuestion.get(qKey);

				if (idx < 0) {
					const next = { ...p };
					merged.push(next);
					const ni = merged.length - 1;
					if (qid) byQid.set(qid, ni);
					if (qKey) byQuestion.set(qKey, ni);
					return;
				}

					const cur = merged[idx];
					cur.question_text = mergeFieldPreferLonger(cur.question_text, p.question_text);
					cur.answer_choices = mergeFieldPreferLonger(cur.answer_choices, p.answer_choices);
					// Allow later/cleaner merges (e.g., answer key chunks) to correct earlier wrong answers.
					cur.official_answer = mergeFieldPreferNew(cur.official_answer, p.official_answer);
					cur.official_explanation = mergeFieldPreferNew(cur.official_explanation, p.official_explanation);
					cur.grading_mode = mergeFieldPreferNew(cur.grading_mode, p.grading_mode) || 'answer_only';
					cur.grading_rubric = mergeFieldPreferNew(cur.grading_rubric, p.grading_rubric);
					cur.solution_regex = mergeFieldPreferNew(cur.solution_regex, p.solution_regex);
					cur.source = mergeFieldPreferNew(cur.source, p.source);
					cur.solution_keywords = mergeTextList(cur.solution_keywords, p.solution_keywords);

				const curQid = __benchmarkTrim(cur.qid);
				const newQid = __benchmarkTrim(p.qid);
				if ((!curQid || __benchmarkIsGenericQid(curQid)) && newQid && !__benchmarkIsGenericQid(newQid)) {
					cur.qid = newQid;
					byQid.set(newQid, idx);
				}
			};

			(Array.isArray(baseProblems) ? baseProblems : []).forEach(addOne);
			(Array.isArray(extraProblems) ? extraProblems : []).forEach(addOne);
			return merged;
		}

				async function __benchmarkProbeCoverageWithApi(rawText, sourceName = 'source', contextLabel = 'ConvertProbe') {
					const txt = __benchmarkTrim(rawText);
					if (!txt) return { estimated_problem_count: 0, qid_candidates: [], notes: '' };
					const clipped = txt.length > 120000 ? txt.slice(0, 120000) : txt;
					const salvage = (raw) => {
						const s = __benchmarkString(raw || '');
						if (!s) return { estimated_problem_count: 0, qid_candidates: [], notes: '' };
						let count = 0;
						try {
							const m = s.match(/estimated_problem_count\s*["']?\s*:\s*(\d+)/i);
							if (m && m[1]) count = __benchmarkClampInt(m[1], { min: 0, max: 5000, fallback: 0 });
						} catch { }
						let body = '';
						try {
							const idx = s.toLowerCase().indexOf('qid_candidates');
							if (idx >= 0) {
								const start = s.indexOf('[', idx);
								if (start >= 0) {
									const end = s.indexOf(']', start + 1);
									if (end >= 0) body = s.slice(start + 1, end);
									else body = s.slice(start + 1, Math.min(s.length, start + 1 + 6000));
								}
							}
							if (!body) {
								const m = s.match(/qid_candidates\s*["']?\s*:\s*\[([\s\S]{0,6000})/i);
								if (m && m[1]) body = m[1];
							}
						} catch { body = ''; }
						const tokens = [];
						const pushToken = (v) => {
							const t = __benchmarkTrim(v);
							if (!t) return;
						if (/[<>]/.test(t)) return;
						if (/qid_from_source/i.test(t)) return;
						tokens.push(t);
					};
					if (body) {
						try {
							const reQ = /"([^"]+)"/g;
							let mm = null;
							while ((mm = reQ.exec(body))) pushToken(mm[1]);
						} catch { }
						try {
							const reT = /(^|[^A-Za-z0-9_])([A-Za-z]{1,3}\d{1,4}|\d{1,4})(?=[^A-Za-z0-9_]|$)/g;
							let mm = null;
							while ((mm = reT.exec(body))) pushToken(mm[2]);
						} catch { }
					}
					const uniq = __benchmarkUniqueTextList(tokens);
					if (!count && uniq.length) count = uniq.length;
					return { estimated_problem_count: count, qid_candidates: uniq, notes: '' };
				};
				const sys = 'You analyze exam text and estimate problem coverage. Output valid JSON only.';
				const user = `From the source text, estimate how many distinct problems/questions exist.

Output JSON only:
{
  "estimated_problem_count": <integer >= 0>,
  "qid_candidates": ["<qid_from_source_1>","<qid_from_source_2>", ...],
  "notes": "short note"
}

Rules:
- qid_candidates should include explicit labels seen in source.
- Do not hallucinate labels not present in source.
- If uncertain, still provide best estimate.

Source name: ${sourceName}
Source text:
${clipped}`;
			try {
				const resp = await __benchmarkCallApi('parse', [
					{ role: 'system', content: sys },
					{ role: 'user', content: user },
					], {
						temperature: 0,
						max_tokens: 1500,
						contextLabel,
						maxRetries: -1,
						expectJson: true,
						jsonSchema: __benchmarkGetCoverageProbeSchema(),
						});
						const parsed = __benchmarkTryParseJson(resp);
						if (Array.isArray(parsed)) {
							const qids = __benchmarkUniqueTextList(parsed.map(x => __benchmarkTrim(x)).filter(Boolean));
							return { estimated_problem_count: qids.length, qid_candidates: qids, notes: '' };
						}
						if (!parsed || typeof parsed !== 'object') return salvage(resp);
						const obj = parsed || {};
						let count = __benchmarkClampInt(obj.estimated_problem_count, { min: 0, max: 5000, fallback: 0 });
						let qids = __benchmarkUniqueTextList(__benchmarkToArray(obj.qid_candidates).map(x => __benchmarkTrim(x)).filter(Boolean));
						if (!count && qids.length) count = qids.length;
						// If we parsed the wrong shape (or got an incomplete object), fall back to regex salvage.
						if (!count && !qids.length) return salvage(resp);
						if (!qids.length) {
							const salvaged = salvage(resp);
							if (salvaged?.qid_candidates?.length) qids = salvaged.qid_candidates;
							if (!count && salvaged?.estimated_problem_count) count = salvaged.estimated_problem_count;
							if (!count && qids.length) count = qids.length;
						}
						return {
							estimated_problem_count: count,
							qid_candidates: qids,
							notes: __benchmarkTrim(obj.notes || '')
						};
				} catch (e) {
					__benchmarkLog('WARN', contextLabel, `Coverage probe failed: ${e?.message || e}`);
					return { estimated_problem_count: 0, qid_candidates: [], notes: '' };
				}
		}

		async function __benchmarkRepairGenericQidsWithApi(problems, rawText, sourceName = 'source', contextLabel = 'ConvertQidRepair') {
			const list = Array.isArray(problems) ? problems : [];
			if (!list.length) return list;
			const src = __benchmarkTrim(rawText || '');
			if (!src) return list;

			const clipped = src.length > 120000 ? src.slice(0, 120000) : src;
			const problemRows = list.map((p, idx) => ({
				index: idx + 1,
				qid: __benchmarkTrim(p?.qid || ''),
				question_text: __benchmarkTrim(p?.question_text || '').slice(0, 1200),
			}));

			const sys = 'You align extracted problems to original labels in source text. Return valid JSON only.';
			const user = `Given source text and extracted problems, assign qid labels from source.

Return JSON only:
{
  "qids": ["<qid_from_source_1>","<qid_from_source_2>", ...]
}

Rules:
- Output exactly ${list.length} qids, one per extracted problem (same order).
- Use the exact label text from source when available.
- If uncertain for an item, return empty string for that item.
- Do not output explanations.

Source name: ${sourceName}

Extracted problems:
${JSON.stringify(problemRows)}

Source text:
${clipped}`;

			try {
				const resp = await __benchmarkCallApi('parse', [
					{ role: 'system', content: sys },
					{ role: 'user', content: user },
				], {
					temperature: 0,
					max_tokens: 4000,
					contextLabel,
					maxRetries: -1,
					expectJson: true,
					jsonSchema: __benchmarkGetQidRepairSchema(),
				});
				const obj = __benchmarkTryParseJson(resp) || {};
				const qids = __benchmarkToArray(obj.qids).map(x => __benchmarkTrim(x));
				if (qids.length !== list.length) {
					__benchmarkLog('WARN', contextLabel, `QID repair skipped: length mismatch (got ${qids.length}, need ${list.length}).`);
					return list;
				}

				const used = new Set();
				const next = list.map((p, idx) => {
					const current = __benchmarkTrim(p?.qid || '');
					let candidate = __benchmarkTrim(qids[idx] || '');
					if (!candidate || __benchmarkIsGenericQid(candidate)) candidate = current;
					if (!candidate) candidate = __benchmarkSafeQid('', idx);
					let finalQid = candidate;
					let k = 2;
					while (used.has(finalQid)) {
						finalQid = `${candidate}#${k}`;
						k += 1;
					}
					used.add(finalQid);
					return { ...(p || {}), qid: finalQid };
				});
				return next;
			} catch (e) {
				__benchmarkLog('WARN', contextLabel, `QID repair failed: ${e?.message || e}`);
				return list;
			}
		}

		async function __benchmarkPlanQidAwareTextChunksWithApi(rawText, maxTokens, sourceName = 'source', contextLabel = 'SplitPlan') {
			const txt = __benchmarkTrim(rawText);
			const budget = __benchmarkClampInt(maxTokens, { min: 500, max: 200000, fallback: 12000 });
			if (!txt) return { chunks: [], qidHints: [], plannerUsed: false, reason: 'empty_input' };

			const totalTokens = __benchmarkEstimateTokens(txt);
			// If the whole source already fits into the configured split budget, never call planner.
			if (totalTokens <= budget) {
				return {
					chunks: [{ text: txt, qids: [] }],
					qidHints: [],
					plannerUsed: false,
					reason: 'below_budget',
				};
			}

			const { lines, numberedText } = __benchmarkBuildLineNumberedText(txt);
			const lineCount = lines.length;
			const targetSegments = __benchmarkClampInt(
				Math.max(1, Math.ceil(totalTokens / Math.max(1, budget))),
				{ min: 1, max: 24, fallback: 1 }
			);
			if (lineCount < 8) {
				const fallback = __benchmarkSplitTextByTokens(txt, budget).map(t => ({ text: t, qids: [] }));
				return { chunks: fallback, qidHints: [], plannerUsed: false, reason: 'too_few_lines' };
			}

			const sys = 'You are a split planner for benchmark extraction. Output valid JSON only.';
			const user = `Plan safe chunk boundaries for extraction.

Input is line-numbered text (L00001: ...). Return contiguous line ranges covering all lines.

Output JSON only:
{
  "segments": [
    { "start_line": 1, "end_line": 120, "qids": ["<qid_from_source_1>","<qid_from_source_2>"], "note": "optional" }
  ],
  "all_qids": ["<qid_from_source_1>","<qid_from_source_2>"]
}

Rules:
- Cover all lines from 1 to ${lineCount}.
- Keep ranges contiguous and non-overlapping.
- Aim for about ${targetSegments} segments.
- Prefer cuts BETWEEN problems; avoid splitting a single problem.
- Keep each segment likely under ${budget} tokens.
- qids must be labels found in source when possible.

Source name: ${sourceName}
Line-numbered text:
${numberedText}`;

			try {
				const resp = await __benchmarkCallApi('parse', [
					{ role: 'system', content: sys },
					{ role: 'user', content: user },
				], {
					temperature: 0,
					max_tokens: 5000,
					contextLabel,
					maxRetries: -1,
					expectJson: true,
					jsonSchema: __benchmarkGetSplitPlanSchema(),
				});
				const obj = __benchmarkTryParseJson(resp) || {};
				const rawSegments = __benchmarkToArray(obj.segments);
				if (!rawSegments.length) {
					throw new Error('No segments returned by planner.');
				}

				const normalized = rawSegments
					.map(seg => ({
						start_line: __benchmarkClampInt(seg?.start_line, { min: 1, max: lineCount, fallback: 1 }),
						end_line: __benchmarkClampInt(seg?.end_line, { min: 1, max: lineCount, fallback: lineCount }),
						qids: __benchmarkUniqueTextList(seg?.qids || []),
					}))
					.filter(seg => seg.end_line >= seg.start_line)
					.sort((a, b) => a.start_line - b.start_line || a.end_line - b.end_line);

				if (!normalized.length) {
					throw new Error('Planner returned invalid line ranges.');
				}

				// Fill gaps and clamp overlaps so all lines are covered safely.
				const stitched = [];
				let cursor = 1;
				for (const seg of normalized) {
					if (seg.end_line < cursor) continue;
					if (seg.start_line > cursor) {
						stitched.push({ start_line: cursor, end_line: seg.start_line - 1, qids: [] });
					}
					const start = Math.max(cursor, seg.start_line);
					const end = Math.max(start, Math.min(lineCount, seg.end_line));
					stitched.push({ start_line: start, end_line: end, qids: seg.qids || [] });
					cursor = end + 1;
					if (cursor > lineCount) break;
				}
				if (cursor <= lineCount) {
					stitched.push({ start_line: cursor, end_line: lineCount, qids: [] });
				}

				const chunks = [];
				for (const seg of stitched) {
					const segLines = lines.slice(seg.start_line - 1, seg.end_line);
					const segText = __benchmarkTrim(segLines.join('\n'));
					if (!segText) continue;
					const segTokens = __benchmarkEstimateTokens(segText);
					if (segTokens <= budget) {
						chunks.push({ text: segText, qids: __benchmarkUniqueTextList(seg.qids || []) });
						continue;
					}

					// Safety fallback for oversized planned range.
					const sub = __benchmarkSplitTextByTokens(segText, budget);
					sub.forEach(s => {
						const st = __benchmarkTrim(s);
						if (st) chunks.push({ text: st, qids: __benchmarkUniqueTextList(seg.qids || []) });
					});
				}

				if (!chunks.length) throw new Error('Planner output produced no usable chunks.');

				const allQids = __benchmarkUniqueTextList([
					...__benchmarkToArray(obj.all_qids),
					...stitched.flatMap(x => __benchmarkToArray(x.qids)),
				]);

				return {
					chunks,
					qidHints: allQids,
					plannerUsed: true,
					reason: 'api_planned',
				};
			} catch (e) {
				__benchmarkLog('WARN', contextLabel, `Split planner fallback: ${e?.message || e}`);
				const fallback = __benchmarkSplitTextByTokens(txt, budget).map(t => ({ text: t, qids: [] }));
				return {
					chunks: fallback,
					qidHints: [],
					plannerUsed: false,
					reason: 'fallback_tokens',
				};
			}
		}

		function __benchmarkBuildSnippetObjectsFromSpans(rawText, spanItems, qidOrder = []) {
			const src = __benchmarkString(rawText).replace(/\r\n/g, '\n').replace(/\r/g, '\n');
			const lines = src.split('\n');
			const lineCount = lines.length;
			const orderMap = new Map();
			__benchmarkUniqueTextList(qidOrder || []).forEach((q, i) => orderMap.set(__benchmarkTrim(q).toLowerCase(), i));
			const items = __benchmarkToArray(spanItems)
				.map((it) => {
					const qid = __benchmarkTrim(it?.qid || '');
					const start = __benchmarkClampInt(it?.start_line, { min: 1, max: Math.max(1, lineCount), fallback: 1 });
					const endRaw = __benchmarkClampInt(it?.end_line, { min: 1, max: Math.max(1, lineCount), fallback: start });
					const end = Math.max(start, endRaw);
					const text = __benchmarkTrim(lines.slice(start - 1, end).join('\n'));
					return {
						qid,
						start_line: start,
						end_line: end,
						text,
						tokens: __benchmarkEstimateTokens(text),
					};
				})
				.filter((x) => x.qid && x.text);
			items.sort((a, b) => {
				const ao = orderMap.has(a.qid.toLowerCase()) ? orderMap.get(a.qid.toLowerCase()) : Number.MAX_SAFE_INTEGER;
				const bo = orderMap.has(b.qid.toLowerCase()) ? orderMap.get(b.qid.toLowerCase()) : Number.MAX_SAFE_INTEGER;
				if (ao !== bo) return ao - bo;
				return a.start_line - b.start_line;
			});
			return items;
		}

		async function __benchmarkLocateQidSpansWithApi(rawText, sourceName, contextLabel, targetQids, options = {}) {
			const src = __benchmarkTrim(rawText || '');
			const targets = __benchmarkUniqueTextList(targetQids || []).filter(Boolean);
			if (!src || !targets.length) {
				return { spans: [], missingQids: targets };
			}

			const { lines, numberedText } = __benchmarkBuildLineNumberedText(src);
			const lineCount = lines.length;
			const maxRounds = __benchmarkClampInt(options?.maxRounds, { min: 1, max: 6, fallback: 3 });
			const batchSize = __benchmarkClampInt(options?.batchSize, { min: 1, max: 12, fallback: 6 });
			const maxSpanLines = __benchmarkClampInt(options?.maxSpanLines, { min: 40, max: 600, fallback: 320 });
			const toKey = (v) => __benchmarkTrim(v).toLowerCase();
			const targetKeySet = new Set(targets.map(toKey));
			const spanByKey = new Map();

			for (let round = 1; round <= maxRounds; round++) {
				const missing = targets.filter(q => !spanByKey.has(toKey(q)));
				if (!missing.length) break;
				__benchmarkLog('INFO', contextLabel, `Span locate round ${round}/${maxRounds}: missing=[${missing.join(', ')}]`);
				let improved = false;

				for (let i = 0; i < missing.length; i += batchSize) {
					const batch = missing.slice(i, i + batchSize);
					const sys = 'You locate problem spans in line-numbered source. Return valid JSON only.';
					const user = `Locate global line ranges for the target qids.

Return JSON only:
{
  "spans": [
    {
      "qid": "<qid_from_source>",
      "start_line": 123,
      "end_line": 180,
      "confidence": 0.9,
      "note": "optional"
    }
  ]
}

Rules:
- Use ONLY these target qids: ${batch.join(', ')}.
- Use line numbers from the provided source (L00001 format).
- Keep spans tight but include question body and nearby answer/explanation lines if present.
- If a qid is not locatable, omit it.
- Do not invent qids not in target list.

Source name: ${sourceName}
Line-numbered source:
${numberedText}`;

					let resp = '';
					try {
						resp = await __benchmarkCallApi('parse', [
							{ role: 'system', content: sys },
							{ role: 'user', content: user },
						], {
							temperature: 0,
							max_tokens: 4000,
							contextLabel: `${contextLabel}-R${round}-B${Math.floor(i / batchSize) + 1}`,
							maxRetries: -1,
							expectJson: true,
							jsonSchema: __benchmarkGetQidSpanLocateSchema(),
						});
					} catch (e) {
						__benchmarkLog('WARN', contextLabel, `Span locate batch failed: ${e?.message || e}`);
						continue;
					}

					const obj = __benchmarkTryParseJson(resp) || {};
					for (const raw of __benchmarkToArray(obj?.spans)) {
						const qid = __benchmarkTrim(raw?.qid || '');
						const key = toKey(qid);
						if (!qid || !targetKeySet.has(key)) continue;
						const s = __benchmarkClampInt(raw?.start_line, { min: 1, max: Math.max(1, lineCount), fallback: 1 });
						const eRaw = __benchmarkClampInt(raw?.end_line, { min: 1, max: Math.max(1, lineCount), fallback: s });
						let e = Math.max(s, eRaw);
						if (e - s + 1 > maxSpanLines) e = Math.min(lineCount, s + maxSpanLines - 1);
						if (e < s) continue;

						const prev = spanByKey.get(key);
						if (!prev || (e - s) < (prev.end_line - prev.start_line)) {
							spanByKey.set(key, { qid, start_line: s, end_line: e });
							improved = true;
						}
					}
				}

				if (!improved) {
					__benchmarkLog('WARN', contextLabel, 'Span locate stopped: no improvement in this round.');
					break;
				}
			}

			const spans = targets
				.map((q) => spanByKey.get(toKey(q)))
				.filter(Boolean);
			const missingQids = targets.filter(q => !spanByKey.has(toKey(q)));
			if (missingQids.length) {
				__benchmarkLog('WARN', contextLabel, `Span locate unresolved qids: ${missingQids.join(', ')}`);
			}
			return { spans, missingQids };
		}

		async function __benchmarkParseProblemsFromSpansWithApi(rawText, sourceName, contextLabel, spanItems, qidOrder = [], options = {}) {
			const snippets = __benchmarkBuildSnippetObjectsFromSpans(rawText, spanItems, qidOrder);
			if (!snippets.length) return __benchmarkBuildEmptyDataset(sourceName);

			const batchTokenBudget = __benchmarkClampInt(options?.batchTokenBudget, { min: 1200, max: 20000, fallback: 6000 });
			const batches = [];
			let current = [];
			let currentTokens = 0;
			for (const sn of snippets) {
				const t = Math.max(1, __benchmarkEstimateTokens(sn.text) + 120);
				if (current.length && currentTokens + t > batchTokenBudget) {
					batches.push(current);
					current = [];
					currentTokens = 0;
				}
				current.push(sn);
				currentTokens += t;
			}
			if (current.length) batches.push(current);

			let mergedProblems = [];
			for (let i = 0; i < batches.length; i++) {
				const batch = batches[i];
				const qids = batch.map(x => x.qid);
				const sys = 'You convert bounded source snippets into benchmark problem objects. Return valid JSON only.';
				const user = `Each snippet corresponds to exactly one problem qid.

Return JSON only:
{
  "problems": [ ... ]
}

Rules:
- Output exactly one problem per snippet.
- Preserve qid exactly as provided for each snippet.
- Do not invent extra qids.
- official_answer must be taken only from an explicit final-answer statement in the snippet; if none exists, set it to "".
- Never infer official_answer from explanation text.
- Keep official_explanation concise (max ~500 chars).
- Use empty string / [] for missing fields.

Snippets (JSON):
${JSON.stringify(batch.map(s => ({
	qid: s.qid,
	start_line: s.start_line,
	end_line: s.end_line,
	text: s.text,
})))}`;

				let resp = '';
				try {
					resp = await __benchmarkCallApi('parse', [
						{ role: 'system', content: sys },
						{ role: 'user', content: user },
					], {
						temperature: 0,
						max_tokens: 8000,
						contextLabel: `${contextLabel}-ParseBatch-${i + 1}/${batches.length}`,
						maxRetries: -1,
						expectJson: true,
						jsonSchema: __benchmarkGetMissingProblemsSchema(),
					});
				} catch (e) {
					__benchmarkLog('WARN', contextLabel, `Span parse batch failed: ${e?.message || e}`);
					resp = '';
				}

				const parsedDs = await __benchmarkNormalizeDatasetFromModelOutput(
					resp,
					sourceName,
					`${contextLabel}-ParseBatch-${i + 1}/${batches.length}-Normalize`,
					0
				) || { problems: [] };
				const parsedByQid = new Map();
				for (const p of __benchmarkToArray(parsedDs.problems)) {
					const qid = __benchmarkTrim(p?.qid || '');
					if (!qid || parsedByQid.has(qid)) continue;
					parsedByQid.set(qid, p);
				}

				for (const sn of batch) {
					let p = parsedByQid.get(sn.qid);
					if (!p) {
						// Last-resort fallback: keep snippet as question text so qid coverage is preserved.
						p = {
							qid: sn.qid,
							question_text: sn.text,
							answer_choices: '',
							official_answer: '',
							official_explanation: '',
							grading_mode: 'answer_only',
							grading_rubric: '',
							solution_keywords: [],
							solution_regex: '',
							source: sourceName,
						};
					} else {
						p = { ...p, qid: sn.qid };
					}
					mergedProblems.push(p);
				}
			}

			const normalized = __benchmarkNormalizeDataset({
				version: __BENCHMARK_SCHEMA_VERSION,
				name: sourceName,
				description: '',
				problems: mergedProblems,
			}, sourceName);
			return normalized || __benchmarkBuildEmptyDataset(sourceName);
		}

		async function __benchmarkRecoverProblemsByQidSpansWithApi(rawText, sourceName, contextLabel, targetQids, options = {}) {
			const src = __benchmarkTrim(rawText || '');
			const targets = __benchmarkUniqueTextList(targetQids || []).filter(Boolean);
			if (!src || !targets.length) {
				return {
					dataset: __benchmarkBuildEmptyDataset(sourceName),
					missingQids: targets,
					spans: [],
				};
			}

			const locate = await __benchmarkLocateQidSpansWithApi(
				src,
				sourceName,
				`${contextLabel}-Locate`,
				targets,
				{
					maxRounds: __benchmarkClampInt(options?.locateRounds, { min: 1, max: 6, fallback: 3 }),
					batchSize: __benchmarkClampInt(options?.locateBatchSize, { min: 1, max: 12, fallback: 6 }),
					maxSpanLines: __benchmarkClampInt(options?.maxSpanLines, { min: 40, max: 600, fallback: 320 }),
				}
			);
			const spans = __benchmarkToArray(locate?.spans || []);
			const parsed = await __benchmarkParseProblemsFromSpansWithApi(
				src,
				sourceName,
				`${contextLabel}-Parse`,
				spans,
				targets,
				{
					batchTokenBudget: __benchmarkClampInt(options?.parseBatchTokenBudget, { min: 1200, max: 20000, fallback: 6000 }),
				}
			);
			const present = new Set(
				__benchmarkToArray(parsed?.problems || [])
					.map(p => __benchmarkTrim(p?.qid || ''))
					.filter(Boolean)
					.map(x => x.toLowerCase())
			);
			const missingQids = targets.filter(q => !present.has(__benchmarkTrim(q).toLowerCase()));
			return { dataset: parsed, missingQids, spans };
		}

			async function __benchmarkTargetedQidRecoveryWithApi(rawText, sourceName, contextLabel, currentDataset, targetQids, options = {}) {
				const ds = __benchmarkNormalizeDataset(currentDataset || { problems: [] }, sourceName) || __benchmarkBuildEmptyDataset(sourceName);
				const src = __benchmarkTrim(rawText);
				if (!src) return ds;

			const targets = __benchmarkUniqueTextList(targetQids || []).filter(q => !__benchmarkIsGenericQid(q));
			if (!targets.length) return ds;

				const toKey = (v) => __benchmarkTrim(v).toLowerCase();
					const computeMissing = () => {
						const present = new Set(
							(ds.problems || [])
								.filter((p) => {
									const q = __benchmarkTrim(p?.qid || '');
									if (!q || __benchmarkIsGenericQid(q)) return false;
									// Treat empty question_text as "not recovered" so we retry instead of locking in blanks.
									const qt = __benchmarkTrim(p?.question_text || '');
									if (!qt) return false;
									if (__benchmarkQuestionTextLooksLikeOptionsOnly(qt)) return false;
									return true;
								})
								.map(p => toKey(__benchmarkTrim(p?.qid || '')))
						);
						return targets.filter(q => !present.has(toKey(q)));
					};

					const batchSize = __benchmarkClampInt(options.batchSize, { min: 1, max: 30, fallback: 8 });
					const maxPasses = __benchmarkClampInt(options.maxPasses, { min: 1, max: 20, fallback: 3 });
					const maxTokens = __benchmarkClampInt(options?.maxTokens, { min: 800, max: 30000, fallback: 12000 });
					let missing = computeMissing();
					if (!missing.length) return ds;

					let noImprovePasses = 0;
					for (let pass = 1; pass <= maxPasses; pass++) {
						let improvedThisPass = false;
						let attemptedBatches = 0;
						missing = computeMissing();
					if (!missing.length) break;

				__benchmarkLog('INFO', contextLabel, `Targeted recovery pass ${pass}/${maxPasses}: missing_qids=${missing.length}`);
					for (let i = 0; i < missing.length; i += batchSize) {
						const batch = missing.slice(i, i + batchSize);
						__benchmarkLog('INFO', contextLabel, `Targeted batch ${Math.floor(i / batchSize) + 1}: [${batch.join(', ')}]`);
						const focusedSource = src;
						attemptedBatches += 1;
						const sys = 'Extract only requested qids from source text. Output valid JSON only.';
						const user = `Extract ONLY problems whose qid is in this target list:
${batch.join(', ')}

Return JSON only:
{
  "problems": [ ... problem objects ... ]
}

		Rules:
		- Include only target qids found in source.
		- Keep qid exactly as in source.
		- Do not include non-target qids.
		- question_text and answer_choices must be copied verbatim from source (no paraphrasing).
		- question_text must include the full stem (and any "Î≥¥Í∏∞"/statements like „Ñ± „Ñ¥ „Ñ∑), not just the option list.
		- If the problem references a shared passage (e.g., [19~20] common text), include that shared passage in question_text for each qid so each item is self-contained.
		- official_answer: copy the explicit final answer exactly as it appears in the source (answer key or conclusion sentence). Do not leave blank if explicit. If truly absent, set to "".
		- official_explanation: copy the official explanation/solution text verbatim when present. If too long, include a verbatim excerpt that still contains the final answer sentence (<= ~6000 chars).
		- Do not "fix" LaTeX, wording, punctuation, or line breaks; preserve source text.

Source name: ${sourceName}
Source text:
${focusedSource}`;

					let resp = '';
					try {
						resp = await __benchmarkCallApi('parse', [
							{ role: 'system', content: sys },
							{ role: 'user', content: user },
						], {
							temperature: 0,
							max_tokens: maxTokens,
							contextLabel: `${contextLabel}-P${pass}-B${Math.floor(i / batchSize) + 1}`,
							maxRetries: -1,
							expectJson: true,
							jsonSchema: __benchmarkGetMissingProblemsSchema(),
						});
					} catch (e) {
						__benchmarkLog('WARN', contextLabel, `Targeted recovery batch failed: ${e?.message || e}`);
						continue;
					}

						const addDs = await __benchmarkNormalizeDatasetFromModelOutput(
							resp,
							sourceName,
							`${contextLabel}-Normalize-P${pass}-B${Math.floor(i / batchSize) + 1}`,
							0
						);
					const batchKeySet = new Set(batch.map(toKey));
						let incoming = __benchmarkToArray(addDs?.problems || []).filter(p => {
							const q = toKey(__benchmarkTrim(p?.qid || ''));
							return q && batchKeySet.has(q);
						});
						// Reject incomplete extractions where question_text is missing; keep qid unresolved so we retry.
						incoming = incoming.filter((p) => !!__benchmarkTrim(p?.question_text || ''));
						if (!incoming.length && batch.length === 1) {
							const rawIncoming = __benchmarkToArray(addDs?.problems || []);
							const first = rawIncoming[0];
							const q = __benchmarkTrim(first?.qid || '');
							if (first && (!q || __benchmarkIsGenericQid(q)) && __benchmarkTrim(first?.question_text || '')) {
								incoming = [{ ...first, qid: batch[0] }];
								__benchmarkLog('WARN', contextLabel, `Targeted batch fallback: assigned missing qid ${batch[0]} to generic extracted problem.`);
							}
						}
						const beforeMissing = computeMissing().length;
						const mergedProblems = __benchmarkMergeProblemLists(ds.problems || [], incoming);
						const mergedDs = __benchmarkNormalizeDataset({
						version: __BENCHMARK_SCHEMA_VERSION,
						name: sourceName,
						description: '',
						problems: mergedProblems,
					}, sourceName);
					if (mergedDs?.problems?.length) ds.problems = mergedDs.problems;
					const afterMissing = computeMissing().length;
					if (afterMissing < beforeMissing) improvedThisPass = true;
				}

					if (attemptedBatches === 0) {
						__benchmarkLog('WARN', contextLabel, 'Targeted recovery stopped: no callable batches in this chunk.');
						break;
					}
					if (!improvedThisPass) {
						noImprovePasses += 1;
						__benchmarkLog('WARN', contextLabel, `Targeted recovery no-progress pass: ${noImprovePasses}/2`);
						if (noImprovePasses >= 2) {
							__benchmarkLog('WARN', contextLabel, 'Targeted recovery stopped: no qid progress after repeated passes.');
							break;
						}
					} else {
						noImprovePasses = 0;
					}
				}

				const unresolved = computeMissing();
				if (unresolved.length) {
				__benchmarkLog('WARN', contextLabel, `Targeted recovery unresolved qids: ${unresolved.join(', ')}`);
			} else {
				__benchmarkLog('SUCCESS', contextLabel, 'Targeted recovery resolved all target qids.');
			}
			return ds;
		}

		function __benchmarkExtractProblemObjectLiteralsFromBrokenJson(rawText, maxObjects = 400) {
			const text = __benchmarkString(rawText || '');
			if (!text) return [];
			const keyMatch = /"problems"\s*:\s*\[/i.exec(text);
			let start = -1;
			if (keyMatch) {
				start = keyMatch.index + keyMatch[0].length;
			} else {
				// Fallback: some outputs are just an array.
				const arrStart = text.indexOf('[');
				if (arrStart >= 0) start = arrStart + 1;
			}
			if (start < 0) return [];

			let inString = false;
			let escape = false;
			let objDepth = 0;
			let arrDepth = 1;
			let objStart = -1;
			const out = [];

			for (let i = start; i < text.length; i++) {
				const ch = text[i];
				if (inString) {
					if (escape) {
						escape = false;
						continue;
					}
					if (ch === '\\') {
						escape = true;
						continue;
					}
					if (ch === '"') {
						inString = false;
					}
					continue;
				}

				if (ch === '"') {
					inString = true;
					continue;
				}
				if (ch === '[') {
					arrDepth += 1;
					continue;
				}
				if (ch === ']') {
					arrDepth -= 1;
					if (arrDepth <= 0) break;
					continue;
				}
				if (ch === '{') {
					if (objDepth === 0) objStart = i;
					objDepth += 1;
					continue;
				}
				if (ch === '}') {
					if (objDepth > 0) objDepth -= 1;
					if (objDepth === 0 && objStart >= 0) {
						const lit = __benchmarkTrim(text.slice(objStart, i + 1));
						if (lit) out.push(lit);
						objStart = -1;
						if (out.length >= maxObjects) break;
					}
				}
			}
			return out;
		}

		function __benchmarkExtractPartialDatasetFromBrokenOutput(rawModelOutput, sourceName, contextLabel) {
			const lits = __benchmarkExtractProblemObjectLiteralsFromBrokenJson(rawModelOutput, 400);
			if (!lits.length) return null;
			const rawProblems = [];
			for (const lit of lits) {
				try {
					const parsed = JSON.parse(__benchmarkRepairJsonStringEscapes(lit));
					if (parsed && typeof parsed === 'object') rawProblems.push(parsed);
				} catch {
					// ignore malformed partial object
				}
			}
			if (!rawProblems.length) return null;
			const ds = __benchmarkNormalizeDataset({
				version: __BENCHMARK_SCHEMA_VERSION,
				name: sourceName,
				description: '',
				problems: rawProblems,
			}, sourceName);
			if (ds?.problems?.length) {
				__benchmarkLog('WARN', contextLabel, `Recovered ${ds.problems.length} complete problem(s) from truncated/invalid JSON.`);
				return ds;
			}
			return null;
		}

		async function __benchmarkNormalizeDatasetFromModelOutput(rawModelOutput, sourceName, contextLabel, maxRepairRounds = 2) {
			let candidate = __benchmarkTrim(rawModelOutput);
			if (!candidate) {
				__benchmarkLog('ERROR', contextLabel, 'Empty model output.');
				return null;
			}

			const rawRepair = maxRepairRounds;
			const infiniteRepair =
				rawRepair === -1 ||
				rawRepair === Number.POSITIVE_INFINITY ||
				`${rawRepair}`.trim().toLowerCase() === 'infinite';
			const rounds = infiniteRepair
				? Number.POSITIVE_INFINITY
				: Math.max(0, __benchmarkClampInt(maxRepairRounds, { min: 0, max: 20, fallback: 2 }));
			let round = 0;
			let bestPartial = null;
			const keepBestPartial = (ds, why = '') => {
				const n = Number(ds?.problems?.length || 0);
				const b = Number(bestPartial?.problems?.length || 0);
				if (n > b) {
					bestPartial = ds;
					if (why) __benchmarkLog('INFO', contextLabel, `${why} (partial_problems=${n}).`);
				}
			};
			while (true) {
				const parseDiag = __benchmarkTryParseJsonDetailed(candidate);
				if (parseDiag?.ok) {
					const parsed = parseDiag.data;
					const normalized = __benchmarkNormalizeDataset(parsed, sourceName);
					if (normalized?.problems?.length) {
						if (round > 0) __benchmarkLog('SUCCESS', contextLabel, `Recovered valid dataset after repair round ${round}.`);
						return normalized;
					}
					const topKeys = (parsed && typeof parsed === 'object' && !Array.isArray(parsed))
						? Object.keys(parsed).slice(0, 20).join(', ')
						: (Array.isArray(parsed) ? `array(len=${parsed.length})` : typeof parsed);
					__benchmarkLog('WARN', contextLabel, `JSON parsed but normalized problems=0 (round ${round}). top_keys=${topKeys || '(none)'}`);
				} else {
					const stage = __benchmarkTrim(parseDiag?.stage || 'unknown');
					const err = __benchmarkTrim(parseDiag?.error || 'Invalid JSON');
					const snippet = __benchmarkTrim(parseDiag?.snippet || __benchmarkPreview(candidate, 420));
					__benchmarkLog('WARN', contextLabel, `Model output is not valid JSON (round ${round}). stage=${stage} | err=${err} | snippet=${snippet}`);
				}
				const partial = __benchmarkExtractPartialDatasetFromBrokenOutput(candidate, sourceName, contextLabel);
				if (partial?.problems?.length) keepBestPartial(partial, `Partial extraction updated at round ${round}`);

				if (!infiniteRepair && round >= rounds) break;

				const repairSys = 'You are a strict JSON normalizer. Output valid JSON only. No markdown, no commentary.';
				const repairUser = `Normalize the following model output into this benchmark schema:
{
  "version": "${__BENCHMARK_SCHEMA_VERSION}",
  "name": "string",
  "description": "string",
  "problems": [
    {
      "qid": "string",
      "question_text": "string",
      "answer_choices": "string",
      "official_answer": "string",
      "official_explanation": "string",
      "grading_mode": "answer_only | answer_and_solution",
      "grading_rubric": "string",
      "solution_keywords": ["string"],
      "solution_regex": "string"
    }
  ]
}

Rules:
- Keep every valid problem in the source output.
- If a field is missing, use empty string (or [] for arrays).
- official_answer must be taken only from explicit final-answer text in the source output.
- Never infer official_answer from derivations/explanations.
- Do not invent problems.
- Return JSON object only.

Model output to normalize:
${candidate.slice(0, 120000)}`;

				try {
					__benchmarkLog('INFO', contextLabel, `Running JSON repair round ${round + 1}/${infiniteRepair ? '‚àû' : rounds} via parse API.`);
					candidate = await __benchmarkCallApi('parse', [
						{ role: 'system', content: repairSys },
						{ role: 'user', content: repairUser },
					], {
						temperature: 0,
						max_tokens: 6000,
						contextLabel: `${contextLabel}-Repair-${round + 1}`,
						maxRetries: -1,
						expectJson: true,
						jsonSchema: __benchmarkGetDatasetJsonSchema(),
					});
				} catch (e) {
					__benchmarkLog('ERROR', contextLabel, `Repair round ${round + 1} failed: ${e?.message || e}`);
					return bestPartial;
				}
				round += 1;
			}

			return bestPartial;
		}

		function __benchmarkExtractXmlTagValue(block, tag) {
			const re = new RegExp(`<\\s*${tag}\\s*>([\\s\\S]*?)<\\s*\\/\\s*${tag}\\s*>`, 'i');
			const m = __benchmarkString(block).match(re);
			return m ? __benchmarkTrim(m[1]) : '';
		}

		function __benchmarkDedupeNonEmpty(values) {
			const out = [];
			const seen = new Set();
			for (const v of (__benchmarkToArray(values) || [])) {
				const t = __benchmarkTrim(v);
				if (!t || seen.has(t)) continue;
				seen.add(t);
				out.push(t);
			}
			return out;
		}

			function __benchmarkCanonicalizeOfficialAnswerText(text) {
				const raw = __benchmarkTrim(text);
				if (!raw) return '';
				// Keep the full official answer text as-is; grading handles semantic equivalence.
				return raw;
			}

			function __benchmarkGetExpectedAnswerList(problem) {
				const canonical = __benchmarkCanonicalizeOfficialAnswerText(problem?.official_answer);
				if (!canonical) return [];
				// Multiple official answer variants can be provided in one field using "||".
				const variants = canonical
					.split(/\s*\|\|\s*/g)
					.map(v => __benchmarkTrim(v))
					.filter(Boolean);
				return variants.length ? __benchmarkDedupeNonEmpty(variants) : [canonical];
			}

		function __benchmarkNormalizeProblem(input, idx = 0, source = '') {
			const p = (input && typeof input === 'object') ? input : {};
			const officialRawInput = Array.isArray(p.official_answer)
				? p.official_answer.join(' || ')
				: (p.official_answer || '');
			const officialRaw = __benchmarkCanonicalizeOfficialAnswerText(officialRawInput);

			const qid = __benchmarkSafeQid(p.qid || p.id || p.local_qid, idx);
			return {
				qid,
				question_text: __benchmarkTrim(p.question_text || p.question || p.prompt),
				answer_choices: __benchmarkTrim(p.answer_choices || p.choices),
				official_answer: officialRaw,
				official_explanation: __benchmarkTrim(p.official_explanation || p.explanation || p.solution),
				grading_mode: __benchmarkTrim(p.grading_mode || p.mode || (p.grading && p.grading.mode) || ''),
				solution_keywords: __benchmarkToArray(p.solution_keywords || (p.grading && p.grading.solution_keywords)).map(x => __benchmarkTrim(x)).filter(Boolean),
				solution_regex: __benchmarkTrim(p.solution_regex || (p.grading && p.grading.solution_regex)),
				grading_rubric: __benchmarkTrim(p.grading_rubric || (p.grading && p.grading.rubric)),
				source: __benchmarkTrim(p.source || source),
			};
		}

			function __benchmarkNormalizeDataset(rawObj, sourceLabel = 'Benchmark') {
				if (!rawObj || typeof rawObj !== 'object') return null;

				const origin = __benchmarkTrim(rawObj.origin || (rawObj.meta && rawObj.meta.origin) || '');
				const allowEmptyProblems = !!rawObj.allow_empty_problems || origin === 'manual';

				let rawProblems = [];
				if (Array.isArray(rawObj)) rawProblems = rawObj.slice();
				else if (Array.isArray(rawObj.problems)) rawProblems = rawObj.problems.slice();
				else if (Array.isArray(rawObj.items)) rawProblems = rawObj.items.slice();
				else if (Array.isArray(rawObj.questions)) rawProblems = rawObj.questions.slice();
			else if (Array.isArray(rawObj.data?.problems)) rawProblems = rawObj.data.problems.slice();
			else if (Array.isArray(rawObj.result?.problems)) rawProblems = rawObj.result.problems.slice();
			else if (rawObj.types && typeof rawObj.types === 'object') {
				Object.entries(rawObj.types).forEach(([typeName, typeObj]) => {
					const problems = Array.isArray(typeObj?.problems)
						? typeObj.problems
						: (Array.isArray(typeObj?.items) ? typeObj.items : []);
					problems.forEach((pr) => rawProblems.push({ ...pr, source: __benchmarkTrim(pr?.source || typeName || sourceLabel) }));
				});
			} else if (rawObj.qasByQid && typeof rawObj.qasByQid === 'object') {
				rawProblems = Object.entries(rawObj.qasByQid).map(([qid, qa]) => ({ ...(qa || {}), qid }));
			} else if (rawObj.problems && typeof rawObj.problems === 'object') {
					rawProblems = Object.entries(rawObj.problems).map(([qid, p]) => ({ ...(p || {}), qid: __benchmarkTrim(p?.qid || qid) }));
				}

				if (!Array.isArray(rawProblems) || !rawProblems.length) {
					// Allow empty datasets for manual benchmark authoring.
					const looksLikeDataset =
						allowEmptyProblems ||
						__benchmarkTrim(rawObj?.version || '') === __BENCHMARK_SCHEMA_VERSION ||
						!!__benchmarkTrim(rawObj?.name || rawObj?.title || '') ||
						!!__benchmarkTrim(rawObj?.description || '');
					if (!looksLikeDataset) return null;
					return {
						version: __BENCHMARK_SCHEMA_VERSION,
						name: __benchmarkTrim(rawObj.name || rawObj.title || sourceLabel || 'Benchmark'),
						description: __benchmarkTrim(rawObj.description || ''),
						origin,
						allow_empty_problems: allowEmptyProblems,
						created_at: Number.isFinite(rawObj.created_at) ? rawObj.created_at : Date.now(),
						updated_at: Number.isFinite(rawObj.updated_at) ? rawObj.updated_at : Date.now(),
						problems: [],
					};
				}

				let normalized = rawProblems.map((p, i) => __benchmarkNormalizeProblem(p, i, sourceLabel));
				if (!allowEmptyProblems) {
					normalized = normalized.filter(p => p.question_text || p.official_answer || p.official_explanation);
				}
				if (!normalized.length) return null;

				// Ensure unique qids.
				const seenQid = new Map();
				normalized.forEach((p) => {
				const base = p.qid || 'Q';
				const cur = seenQid.get(base) || 0;
				if (cur === 0) {
					seenQid.set(base, 1);
					return;
				}
				seenQid.set(base, cur + 1);
				p.qid = `${base}#${cur + 1}`;
				});

				return {
					version: __BENCHMARK_SCHEMA_VERSION,
					name: __benchmarkTrim(rawObj.name || rawObj.title || sourceLabel || 'Benchmark'),
					description: __benchmarkTrim(rawObj.description || ''),
					origin,
					allow_empty_problems: allowEmptyProblems,
					created_at: Number.isFinite(rawObj.created_at) ? rawObj.created_at : Date.now(),
					updated_at: Number.isFinite(rawObj.updated_at) ? rawObj.updated_at : Date.now(),
					problems: normalized,
				};
			}

			function __benchmarkBuildEmptyDataset(sourceLabel = 'Benchmark') {
				return {
					version: __BENCHMARK_SCHEMA_VERSION,
					name: __benchmarkTrim(sourceLabel || 'Benchmark'),
					description: '',
					created_at: Date.now(),
					problems: [],
				};
			}

			function __benchmarkBuildManualDataset(name = 'Manual Benchmark', description = '') {
				const ds = __benchmarkBuildEmptyDataset(name);
				ds.description = __benchmarkTrim(description || '');
				ds.origin = 'manual';
				ds.allow_empty_problems = true;
				ds.updated_at = Date.now();
				return ds;
			}

			function __benchmarkPromptNewManualDataset(options = {}) {
				const opts = (options && typeof options === 'object') ? options : {};
				const defaultName = __benchmarkTrim(opts.defaultName || 'Manual Benchmark') || 'Manual Benchmark';
				const defaultDescription = __benchmarkString(opts.defaultDescription || '');
				const nameRaw = prompt('Benchmark name', defaultName);
				if (nameRaw === null) return null;
				const name = __benchmarkTrim(nameRaw) || defaultName;
				const descRaw = prompt('Description (optional)', defaultDescription);
				const desc = (descRaw === null) ? defaultDescription : __benchmarkString(descRaw || '');
				return __benchmarkBuildManualDataset(name, desc);
			}

			function __benchmarkMakeUniqueQid(desired, takenSet) {
				const base = __benchmarkTrim(desired) || 'Q';
				if (!takenSet || typeof takenSet.has !== 'function') return base;
				if (!takenSet.has(base)) return base;
				let n = 2;
				while (takenSet.has(`${base}#${n}`)) n += 1;
				return `${base}#${n}`;
			}

			function __benchmarkBuildBlankProblem(qid = '', idx = 0) {
				return {
					qid: __benchmarkSafeQid(qid, idx),
					question_text: '',
					answer_choices: '',
					official_answer: '',
					official_explanation: '',
					grading_mode: '',
					solution_keywords: [],
					solution_regex: '',
					grading_rubric: '',
					source: 'manual',
				};
			}

			async function __benchmarkExtractTextFromPdfFile(file) {
				if (typeof pdfjsLib === 'undefined' || !pdfjsLib?.getDocument) throw new Error('pdfjs-dist is not available');
				const buf = await file.arrayBuffer();
				const pdf = await pdfjsLib.getDocument({ data: new Uint8Array(buf) }).promise;
				const pages = [];
			for (let i = 1; i <= pdf.numPages; i++) {
				const page = await pdf.getPage(i);
				const tc = await page.getTextContent();
				const txt = (tc.items || []).map(it => (it?.str || '')).join(' ').trim();
				pages.push({ page: i, text: txt });
			}
			return pages;
		}

			function __benchmarkUpdateDatasetSummary(dataset, metaText = '', { announce = false } = {}) {
				const summaryEl = document.getElementById('benchmarkSummary');
				if (!summaryEl) return false;
				if (!dataset || typeof dataset !== 'object') {
					summaryEl.innerText = 'No benchmark loaded.';
					if (announce) __benchmarkSetProgress('No benchmark loaded');
					return false;
				}
				const problems = Array.isArray(dataset.problems) ? dataset.problems : [];
				const withAnswer = problems.filter(p => __benchmarkTrim(p.official_answer)).length;
				const withExplanation = problems.filter(p => __benchmarkTrim(p.official_explanation)).length;
				const name = __benchmarkTrim(dataset.name || 'Benchmark');
				const description = __benchmarkTrim(dataset.description || '');
				const lines = [
					`Loaded benchmark: ${name}`,
					`Problems: ${problems.length} | With answer: ${withAnswer} | With explanation: ${withExplanation}`,
				];
				if (description) lines.push(`Description: ${description}`);
				if (!problems.length) lines.push('Tip: click "‚ûï Add Problem" to start authoring.');
				if (metaText) lines.push(metaText);
				summaryEl.innerText = lines.join('\n');
				if (announce) __benchmarkSetProgress(`Benchmark loaded: ${name} (${problems.length} problems)`);
				return true;
			}

		function __benchmarkEnsureProblemEditorEventBindings() {
			const box = document.getElementById('benchmarkProblemEditor');
			if (!box || box.dataset.bound === '1') return;
			box.dataset.bound = '1';

			box.addEventListener('click', (e) => {
				try {
					const btn = e?.target?.closest?.('button[data-action]');
					if (!btn) return;
					const action = __benchmarkTrim(btn.dataset.action || '');
					const card = btn.closest('details.benchmark-problem-card');
					if (!card) return;
					const idx = __benchmarkClampInt(card.dataset.problemIndex, { min: 0, max: 1000000, fallback: -1 });
					const ds = __benchmarkStudio.dataset;
					if (!ds?.problems?.length || idx < 0 || idx >= ds.problems.length) {
						alert('Benchmark dataset is missing or out of sync.');
						return;
					}

						const normalizedAction = (action === 'save-official')
							? 'save-problem'
							: (action === 'reset-official' ? 'reset-problem' : action);

							if (normalizedAction === 'save-problem') {
								let p = ds.problems[idx];
								if (!p || typeof p !== 'object') {
									p = {};
									ds.problems[idx] = p;
								}
								const beforeQid = __benchmarkTrim(p.qid || `Q${idx + 1}`) || `Q${idx + 1}`;
								const beforeQ = (p.question_text || '').toString();
								const beforeChoices = (p.answer_choices || '').toString();

							const qidEl = card.querySelector('input[data-field=\"qid\"]');
							const qTa = card.querySelector('textarea[data-field=\"question_text\"]');
							const choicesTa = card.querySelector('textarea[data-field=\"answer_choices\"]');
							const ansTa = card.querySelector('textarea[data-field=\"official_answer\"]');
							const explTa = card.querySelector('textarea[data-field=\"official_explanation\"]');

							let qid = __benchmarkSafeQid((qidEl?.value || '').toString(), idx);
							const questionText = (qTa?.value || '').toString();
							const answerChoices = (choicesTa?.value || '').toString();
							const ans = (ansTa?.value || '').toString();
							const expl = (explTa?.value || '').toString();

							const taken = new Set();
							for (let j = 0; j < ds.problems.length; j++) {
								if (j === idx) continue;
								const other = ds.problems[j] || {};
								const otherQid = __benchmarkTrim(other.qid || `Q${j + 1}`) || `Q${j + 1}`;
								taken.add(otherQid);
							}
							const uniqueQid = __benchmarkMakeUniqueQid(qid, taken);
							if (uniqueQid !== qid) {
								qid = uniqueQid;
								if (qidEl) qidEl.value = uniqueQid;
							}

							p.qid = qid;
							p.question_text = questionText;
							p.answer_choices = answerChoices;
							p.official_answer = ans;
							p.official_explanation = expl;

							ds.allow_empty_problems = true;
							if (!__benchmarkTrim(ds.origin || '')) ds.origin = 'manual';
							try { ds.updated_at = Date.now(); } catch { }

							const promptChanged = (qid !== beforeQid) || (questionText !== beforeQ) || (answerChoices !== beforeChoices);
							if (promptChanged) {
								__benchmarkStudio.appliedToUi = false;
								__benchmarkStudio.runCheckpoint = null;
							}

							try {
								const snippet = __benchmarkTrim(__benchmarkTrim(questionText).replace(/\s+/g, ' ').slice(0, 140));
								const hasAns = !!__benchmarkTrim(ans);
								const hasExpl = !!__benchmarkTrim(expl);
								const title = `${idx + 1}. ${qid} (${hasAns ? 'A‚úì' : 'A¬∑'}, ${hasExpl ? 'E‚úì' : 'E¬∑'})${snippet ? ` ‚Äî ${snippet}` : ''}`;
								const sum = card.querySelector('summary');
								if (sum) sum.textContent = title;
							} catch { }
							__benchmarkUpdateDatasetSummary(ds, '', { announce: false });
							saveToLocalStorage();
							const status = card.querySelector('[data-role=\"save-status\"]');
							if (status) status.textContent = `Saved (${new Date().toLocaleTimeString()})${promptChanged ? ' ‚Äî prompts changed' : ''}.`;
							return;
						}

						if (normalizedAction === 'reset-problem') {
							const p = ds.problems[idx] || {};
							const qidEl = card.querySelector('input[data-field=\"qid\"]');
							const qTa = card.querySelector('textarea[data-field=\"question_text\"]');
							const choicesTa = card.querySelector('textarea[data-field=\"answer_choices\"]');
							const ansTa = card.querySelector('textarea[data-field=\"official_answer\"]');
							const explTa = card.querySelector('textarea[data-field=\"official_explanation\"]');
							if (qidEl) qidEl.value = (__benchmarkTrim(p.qid || `Q${idx + 1}`) || `Q${idx + 1}`).toString();
							if (qTa) qTa.value = (p.question_text || '').toString();
							if (choicesTa) choicesTa.value = (p.answer_choices || '').toString();
							if (ansTa) ansTa.value = (p.official_answer || '').toString();
							if (explTa) explTa.value = (p.official_explanation || '').toString();
							const status = card.querySelector('[data-role=\"save-status\"]');
							if (status) status.textContent = 'Reset to dataset values (not saved).';
							return;
						}

						if (normalizedAction === 'delete-problem') {
							const p = ds.problems[idx] || {};
							const qid = __benchmarkTrim(p.qid || `Q${idx + 1}`) || `Q${idx + 1}`;
							if (!confirm(`Delete ${qid}? This cannot be undone.`)) return;
							ds.problems.splice(idx, 1);
							ds.allow_empty_problems = true;
							if (!__benchmarkTrim(ds.origin || '')) ds.origin = 'manual';
							try { ds.updated_at = Date.now(); } catch { }
							__benchmarkStudio.appliedToUi = false;
							__benchmarkStudio.runCheckpoint = null;
							__benchmarkUpdateDatasetSummary(ds, '', { announce: false });
							__benchmarkRenderProblemEditor();
							saveToLocalStorage();
							return;
						}
					} catch { }
				});
			}

			function __benchmarkRenderProblemEditor() {
				const box = document.getElementById('benchmarkProblemEditor');
				if (!box) return;
				__benchmarkEnsureProblemEditorEventBindings();

				const ds = __benchmarkStudio.dataset;
				if (!ds || typeof ds !== 'object') {
					box.innerText = 'No benchmark loaded.';
					return;
				}
				const problems = Array.isArray(ds.problems) ? ds.problems : [];
				if (!problems.length) {
					box.innerHTML = '<div style="font-size:11px; color:var(--text-3);">No problems yet. Click <b>‚ûï Add Problem</b> to start.</div>';
					return;
				}

					const filterRaw = __benchmarkTrim(document.getElementById('benchmarkProblemFilter')?.value || '');
					const filter = (filterRaw || '').toLowerCase();
					const explicitIndices = __benchmarkParseExplicitProblemIndices(filterRaw, problems.length);
					const explicitIndexSet = Array.isArray(explicitIndices) ? new Set(explicitIndices) : null;
				const parts = [];
				for (let i = 0; i < problems.length; i++) {
					const p = problems[i] || {};
					const qid = __benchmarkTrim(p.qid || `Q${i + 1}`) || `Q${i + 1}`;
					const qRaw = (p.question_text || '').toString();
					const q = __benchmarkTrim(qRaw);
					const choicesRaw = (p.answer_choices || '').toString();
					const choices = __benchmarkTrim(choicesRaw);
					const ans = (p.official_answer || '').toString();
					const expl = (p.official_explanation || '').toString();
					const hasAns = !!__benchmarkTrim(ans);
					const hasExpl = !!__benchmarkTrim(expl);
					const snippet = __benchmarkTrim(q.replace(/\s+/g, ' ').slice(0, 140));

					if (explicitIndexSet) {
						if (!explicitIndexSet.has(i)) continue;
					} else if (filter && !__benchmarkProblemMatchesTextFilter(p, filter, i)) {
						continue;
					}

					const title = `${i + 1}. ${qid} (${hasAns ? 'A‚úì' : 'A¬∑'}, ${hasExpl ? 'E‚úì' : 'E¬∑'})${snippet ? ` ‚Äî ${snippet}` : ''}`;
					parts.push(`
						<details class="benchmark-problem-card" data-problem-index="${i}" open>
							<summary>${__benchmarkXmlEscape(title)}</summary>
							<div style="margin-top:8px;">
								<label class="cs-input__label">QID</label>
								<input class="cs-input" data-field="qid" value="${__benchmarkXmlEscape(qid)}" placeholder="e.g., Problem 8 or AMC12-2023-7">
							</div>
							<div style="margin-top:8px;">
								<label class="cs-input__label">Question (editable)</label>
								<textarea class="cs-input" data-field="question_text" style="min-height:120px;">${__benchmarkXmlEscape(qRaw)}</textarea>
							</div>
							<div style="margin-top:8px;">
								<label class="cs-input__label">Choices (optional)</label>
								<textarea class="cs-input" data-field="answer_choices" style="min-height:90px;" placeholder="(leave empty if not multiple-choice)">${__benchmarkXmlEscape(choicesRaw)}</textarea>
							</div>
							<details style="margin-top:8px;">
								<summary style="cursor:pointer; font-weight:700;">Official answer (editable)</summary>
								<textarea class="cs-input" data-field="official_answer" style="margin-top:6px; min-height:80px;">${__benchmarkXmlEscape(ans)}</textarea>
							</details>
						<details style="margin-top:8px;">
							<summary style="cursor:pointer; font-weight:700;">Official explanation (editable)</summary>
							<textarea class="cs-input" data-field="official_explanation" style="margin-top:6px; min-height:180px;">${__benchmarkXmlEscape(expl)}</textarea>
							</details>
							<div style="display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;">
								<button class="cs-btn" data-action="save-problem">üíæ Save (to dataset)</button>
								<button class="cs-btn" data-action="reset-problem">‚Ü© Reset</button>
								<button class="cs-btn" data-action="delete-problem">üóë Delete</button>
								<span data-role="save-status" style="font-size:11px; color:var(--text-3);"></span>
							</div>
						</details>
					`);
				}

			box.innerHTML = parts.length
				? parts.join('\n')
				: '<div style="font-size:11px; color:var(--text-3);">No problems match the filter.</div>';
		}

			function __benchmarkSetDataset(dataset, metaText = '') {
				__benchmarkStudio.dataset = dataset;
				__benchmarkStudio.appliedToUi = false;
				__benchmarkStudio.runCheckpoint = null;
				__benchmarkStudio.manualSpawnMode = false;
				__benchmarkStudio.pendingSpawnUniqueIds = [];
				__benchmarkUpdateDatasetSummary(dataset, metaText, { announce: true });
				try { __benchmarkRenderProblemEditor(); } catch { }
			}

		function __benchmarkInitTaskApiDefaultsFromArchitecture() {
			const archKeys = (document.getElementById('apiKeyList')?.value || '').toString();
			const archUrl = (document.getElementById('apiUrl')?.value || '').toString();
			const archProxy = (document.getElementById('apiProxyUrl')?.value || '').toString();
			const archModel = (document.getElementById('modelName')?.value || '').toString();
			const archBypass = !!document.getElementById('bypassSystemRole')?.checked;

			const assignIfEmpty = (id, value) => {
				const el = document.getElementById(id);
				if (!el) return;
				if ((el.value || '').toString().trim()) return;
				el.value = value || '';
			};
			assignIfEmpty('benchmarkParseApiKeyList', archKeys);
			assignIfEmpty('benchmarkParseApiUrl', archUrl);
			assignIfEmpty('benchmarkParseApiProxyUrl', archProxy);
			assignIfEmpty('benchmarkParseModelName', archModel);
			assignIfEmpty('benchmarkGradeApiKeyList', archKeys);
			assignIfEmpty('benchmarkGradeApiUrl', archUrl);
			assignIfEmpty('benchmarkGradeApiProxyUrl', archProxy);
			assignIfEmpty('benchmarkGradeModelName', archModel);

			const parseBypass = document.getElementById('benchmarkParseBypassSystemRole');
			if (parseBypass && parseBypass.checked === false) parseBypass.checked = archBypass;
			const gradeBypass = document.getElementById('benchmarkGradeBypassSystemRole');
			if (gradeBypass && gradeBypass.checked === false) gradeBypass.checked = archBypass;
		}

			function __benchmarkGetSelectedArchitectures() {
				const out = [];
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
					if (!chk?.checked) return;
					const id = (chk.id || '').replace('chk-', '');
					if (!id || !ARCH_DEFINITIONS.some(d => d?.id === id)) return;
					out.push({ archId: id, count: __getEffectiveArchCount(id) });
				});
				return out;
			}

			function __benchmarkCaptureArchUiSelectionState() {
				const out = [];
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
					const id = (chk.id || '').replace('chk-', '');
					if (!id) return;
					const cntEl = document.getElementById(`cnt-${id}`);
					const rawCount = parseInt(cntEl?.value || '1', 10);
					const count = Number.isFinite(rawCount) ? Math.min(999, Math.max(1, rawCount)) : 1;
					out.push({ archId: id, checked: !!chk.checked, count });
				});
				return out;
			}

			function __benchmarkApplyArchSelection(selection = []) {
				const desired = new Map();
				(selection || []).forEach(s => {
					const id = __benchmarkTrim(s?.archId || '');
					if (!id) return;
					const rawCount = parseInt(s?.count || '1', 10);
					const count = Number.isFinite(rawCount) ? Math.min(999, Math.max(1, rawCount)) : 1;
					desired.set(id, count);
				});
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
					const id = (chk.id || '').replace('chk-', '');
					if (!id) return;
					const cntEl = document.getElementById(`cnt-${id}`);
					if (!desired.has(id)) {
						chk.checked = false;
						return;
					}
					chk.checked = true;
					if (cntEl) cntEl.value = `${desired.get(id)}`;
				});
			}

			function __benchmarkRestoreArchUiSelectionState(snapshot = []) {
				const saved = new Map();
				(snapshot || []).forEach(s => {
					const id = __benchmarkTrim(s?.archId || '');
					if (!id) return;
					const rawCount = parseInt(s?.count || '1', 10);
					const count = Number.isFinite(rawCount) ? Math.min(999, Math.max(1, rawCount)) : 1;
					saved.set(id, { checked: !!s?.checked, count });
				});
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
					const id = (chk.id || '').replace('chk-', '');
					if (!id) return;
					const cntEl = document.getElementById(`cnt-${id}`);
					const rec = saved.get(id);
					if (!rec) return;
					chk.checked = !!rec.checked;
					if (cntEl) cntEl.value = `${rec.count}`;
				});
			}

		function __benchmarkProblemToPrompt(problem) {
			const p = problem || {};
			const parts = [];
			const qid = __benchmarkTrim(p.qid);
			if (qid) parts.push(`[QID:${qid}]`);
			parts.push(__benchmarkTrim(p.question_text));
			const choices = __benchmarkTrim(p.answer_choices);
			if (choices) parts.push(`Choices:\n${choices}`);
			return parts.filter(Boolean).join('\n\n').trim();
		}

		function __benchmarkPromptToProblemFields(rawPrompt, fallbackQid = '', idx = 0) {
			const raw = __benchmarkString(rawPrompt || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
			let body = __benchmarkTrim(raw);
			let qid = '';

			const qidMatch = body.match(/^\[\s*QID\s*:\s*([^\]\n]+?)\s*\]\s*/i);
			if (qidMatch) {
				qid = __benchmarkTrim(qidMatch[1] || '');
				body = __benchmarkTrim(body.slice(qidMatch[0].length));
			}

			let questionText = body;
			let answerChoices = '';
			const choicesMatch = body.match(/\n{2,}Choices:\s*\n([\s\S]*)$/i);
			if (choicesMatch) {
				questionText = __benchmarkTrim(body.slice(0, choicesMatch.index || 0));
				answerChoices = __benchmarkTrim(choicesMatch[1] || '');
			}

			const resolvedQid = __benchmarkSafeQid(qid || fallbackQid, idx);
			return {
				qid: resolvedQid,
				question_text: questionText,
				answer_choices: answerChoices,
			};
		}

		function __benchmarkBuildDatasetFromUiProblems(options = {}) {
			const opts = (options && typeof options === 'object') ? options : {};
			const uiQueries = __getProblemQueriesFromUi({ includeEmpty: false })
				.map((q) => __benchmarkString(q || ''))
				.map((q) => q.trim())
				.filter(Boolean);
			if (!uiQueries.length) return null;

			const prev = (__benchmarkStudio?.dataset && typeof __benchmarkStudio.dataset === 'object')
				? __benchmarkStudio.dataset
				: null;
			const prevProblems = Array.isArray(prev?.problems) ? prev.problems : [];
			const prevByQid = new Map();
			prevProblems.forEach((p, i) => {
				const qid = __benchmarkTrim(p?.qid || `Q${i + 1}`) || `Q${i + 1}`;
				if (!prevByQid.has(qid)) prevByQid.set(qid, p || {});
			});

			const takenQids = new Set();
			const nextProblems = [];
			for (let i = 0; i < uiQueries.length; i++) {
				const rawPrompt = uiQueries[i] || '';
				const fallbackQid = __benchmarkTrim(prevProblems?.[i]?.qid || `Q${i + 1}`) || `Q${i + 1}`;
				const parsed = __benchmarkPromptToProblemFields(rawPrompt, fallbackQid, i);
				const desiredQid = __benchmarkTrim(parsed?.qid || fallbackQid || `Q${i + 1}`) || `Q${i + 1}`;
				const qid = __benchmarkMakeUniqueQid(desiredQid, takenQids);
				takenQids.add(qid);

				const prevBySameQid = prevByQid.get(qid) || null;
				const prevByIndex = prevProblems?.[i] || null;
				const prevProblem = (prevBySameQid && typeof prevBySameQid === 'object')
					? prevBySameQid
					: ((prevByIndex && typeof prevByIndex === 'object') ? prevByIndex : {});

				const questionText = __benchmarkTrim(parsed?.question_text || '') || __benchmarkTrim(rawPrompt || '');
				const answerChoices = __benchmarkTrim(parsed?.answer_choices || '');
				nextProblems.push({
					qid,
					question_text: questionText,
					answer_choices: answerChoices,
					official_answer: __benchmarkTrim(prevProblem?.official_answer || ''),
					official_explanation: __benchmarkTrim(prevProblem?.official_explanation || ''),
					grading_mode: __benchmarkTrim(prevProblem?.grading_mode || ''),
					solution_keywords: __benchmarkToArray(prevProblem?.solution_keywords).map(x => __benchmarkTrim(x)).filter(Boolean),
					solution_regex: __benchmarkTrim(prevProblem?.solution_regex || ''),
					grading_rubric: __benchmarkTrim(prevProblem?.grading_rubric || ''),
					source: __benchmarkTrim(prevProblem?.source || 'ui'),
				});
			}

			const rawDataset = {
				version: __BENCHMARK_SCHEMA_VERSION,
				name: __benchmarkTrim(opts.name || prev?.name || 'UI Problems Benchmark') || 'UI Problems Benchmark',
				description: __benchmarkTrim(opts.description || prev?.description || ''),
				origin: __benchmarkTrim(opts.origin || prev?.origin || 'ui-sync') || 'ui-sync',
				allow_empty_problems: true,
				created_at: Number.isFinite(prev?.created_at) ? prev.created_at : Date.now(),
				updated_at: Date.now(),
				problems: nextProblems,
			};

			return __benchmarkNormalizeDataset(rawDataset, rawDataset.name || 'UI Problems Benchmark') || rawDataset;
		}

		function __benchmarkUpsertDatasetFromUiProblems(options = {}) {
			const opts = (options && typeof options === 'object') ? options : {};
			const prev = (__benchmarkStudio?.dataset && typeof __benchmarkStudio.dataset === 'object')
				? __benchmarkStudio.dataset
				: null;
			const hasPrev = !!(prev && Array.isArray(prev.problems) && prev.problems.length);
			const allowCreate = (typeof opts.allowWhenNoDataset === 'boolean') ? opts.allowWhenNoDataset : true;
			const syncOrigins = __benchmarkToArray(opts.syncOrigins || ['ui-sync'])
				.map((v) => __benchmarkTrim(v || '').toLowerCase())
				.filter(Boolean);
			const originSet = new Set(syncOrigins);
			const prevOrigin = __benchmarkTrim(prev?.origin || '').toLowerCase();
			const force = !!opts.force;

			const shouldCreate = !hasPrev && allowCreate;
			const shouldSyncExisting = hasPrev && (force || originSet.has(prevOrigin));
			if (!shouldCreate && !shouldSyncExisting) return { synced: false, reason: 'skipped' };

			const next = __benchmarkBuildDatasetFromUiProblems({
				origin: hasPrev ? (prev?.origin || 'ui-sync') : 'ui-sync',
				name: prev?.name || 'UI Problems Benchmark',
				description: prev?.description || '',
			});
			if (!next?.problems?.length) return { synced: false, reason: 'no-ui-problems' };

			const prevPrompts = hasPrev
				? (prev.problems || []).map(__benchmarkProblemToPrompt).filter(Boolean)
				: [];
			const nextPrompts = (next.problems || []).map(__benchmarkProblemToPrompt).filter(Boolean);
			const promptsChanged =
				(prevPrompts.length !== nextPrompts.length) ||
				prevPrompts.some((txt, i) => txt !== nextPrompts[i]);
			const shouldWrite = !hasPrev || promptsChanged || force;
			if (!shouldWrite) {
				__benchmarkStudio.appliedToUi = true;
				return { synced: false, reason: 'unchanged', dataset: prev };
			}

				__benchmarkStudio.dataset = next;
				__benchmarkStudio.appliedToUi = true;
				__benchmarkStudio.runCheckpoint = null;
				__benchmarkStudio.manualSpawnMode = false;
				__benchmarkStudio.pendingSpawnUniqueIds = [];
				try { __benchmarkUpdateDatasetSummary(next, '', { announce: false }); } catch { }
			try { __benchmarkRenderProblemEditor(); } catch { }
			try {
				const action = hasPrev ? 'Synced' : 'Created';
				__benchmarkLog('INFO', 'BenchmarkSync', `${action} dataset from Problems UI (${next.problems.length} problems).`);
			} catch { }
			return { synced: true, created: !hasPrev, promptsChanged, dataset: next };
		}

		function __benchmarkBuildRunAssignments(dataset, selection, options = {}) {
			const ds = dataset || {};
			const probs = Array.isArray(ds?.problems) ? ds.problems : [];
			const sel = __benchmarkNormalizeSelectionForSignature(selection);
			const opts = (options && typeof options === 'object') ? options : {};
			const indices = (() => {
				if (!Array.isArray(opts.problemIndices) || opts.problemIndices.length === 0) return null;
				const max = Math.max(0, probs.length - 1);
				const set = new Set();
				for (const raw of opts.problemIndices) {
					const n = __benchmarkClampInt(raw, { min: 0, max, fallback: -1 });
					if (n >= 0 && n < probs.length) set.add(n);
				}
				if (set.size === 0) return [];
				return Array.from(set).sort((a, b) => a - b);
			})();
			const out = [];
			const iter = indices ?? probs.map((_, idx) => idx);
			for (const pIdx of iter) {
				const problem = (pIdx >= 0 && pIdx < probs.length) ? (probs[pIdx] || {}) : {};
				const qid = __benchmarkTrim(problem.qid || `Q${pIdx + 1}`) || `Q${pIdx + 1}`;
				let query = __benchmarkProblemToPrompt(problem);
				if (!query) {
					const fallbackText =
						__benchmarkTrim(problem?.question || '') ||
						__benchmarkTrim(problem?.prompt || '') ||
						__benchmarkTrim(problem?.problem_text || '') ||
						__benchmarkTrim(problem?.official_explanation || '');
					if (fallbackText) {
						query = [`[QID:${qid}]`, fallbackText].filter(Boolean).join('\n\n').trim();
					}
				}
				if (!query) {
					try {
						const compact = __benchmarkTrim(JSON.stringify(problem || {}));
						if (compact) query = [`[QID:${qid}]`, compact.slice(0, 2000)].join('\n\n').trim();
					} catch { }
				}
				if (!query) continue;
				for (const s of sel) {
					const archId = __benchmarkTrim(s?.archId || '');
					if (!archId) continue;
					const def = ARCH_DEFINITIONS.find(d => d && d.id === archId);
					if (!def) continue;
					const count = __benchmarkClampInt(s?.count, { min: 1, max: 999, fallback: 1 });
					for (let run = 1; run <= count; run++) {
						out.push({
							problemIndex: pIdx,
							problemQid: qid,
							query,
							archId,
							runIndex: run,
							instanceId: `P${pIdx + 1}-R${run}`,
						});
					}
				}
			}
			return out;
		}

		function __benchmarkInferAgentBenchmarkMeta(agent, dataset = null) {
			if (!agent || typeof agent !== 'object') return null;
			const ds = dataset || __benchmarkStudio?.dataset || {};
			const probs = Array.isArray(ds?.problems) ? ds.problems : [];
			const qidToIndex = new Map();
			const byPrompt = new Map();
			const byQuestion = new Map();
			const byQuestionChoices = new Map();
			const pushIndex = (map, key, idx) => {
				const k = __benchmarkNormalizeTextKey(key || '');
				if (!k) return;
				const prev = map.get(k);
				if (prev) prev.push(idx);
				else map.set(k, [idx]);
			};
			for (let i = 0; i < probs.length; i++) {
				const q = __benchmarkTrim(probs[i]?.qid || '');
				if (q && !qidToIndex.has(q)) qidToIndex.set(q, i);
				const prompt = __benchmarkProblemToPrompt(probs[i] || {});
				const qText = __benchmarkTrim(probs[i]?.question_text || '');
				const choices = __benchmarkTrim(probs[i]?.answer_choices || '');
				pushIndex(byPrompt, prompt, i);
				pushIndex(byQuestion, qText, i);
				pushIndex(byQuestionChoices, `${qText}\n\nChoices:\n${choices}`, i);
			}

			let problemIndex = -1;
			let problemQid = '';
			let runIndex = -1;

			const explicit = (agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object') ? agent.benchmarkMeta : null;
			if (explicit) {
				problemIndex = __benchmarkClampInt(explicit.problemIndex, { min: 0, max: 1000000, fallback: -1 });
				problemQid = __benchmarkTrim(explicit.problemQid || '');
				runIndex = __benchmarkClampInt(explicit.runIndex, { min: 1, max: 1000000, fallback: 1 });
			}

			const uniqueId = __benchmarkTrim(agent?.uniqueId || '');
			const card = uniqueId ? document.getElementById(`agent-card-${uniqueId}`) : null;
			if (card) {
				if (problemIndex < 0) {
					problemIndex = __benchmarkClampInt(card?.dataset?.problemIndex, { min: 0, max: 1000000, fallback: -1 });
				}
				if (!problemQid) {
					problemQid = __benchmarkTrim(card?.dataset?.problemQid || '');
				}
			}

			const inst = __benchmarkTrim(agent?.instanceId || '');
			if (inst) {
				const m = inst.match(/P(\d+)-R(\d+)/i);
				if (m) {
					const parsedProblemIndex = __benchmarkClampInt(m[1], { min: 1, max: 1000000, fallback: -1 });
					const parsedRunIndex = __benchmarkClampInt(m[2], { min: 1, max: 1000000, fallback: 1 });
					if (problemIndex < 0 && parsedProblemIndex > 0) problemIndex = parsedProblemIndex - 1;
					if (runIndex < 1) runIndex = parsedRunIndex;
				} else {
					const parsedRunIndex = parseInt(inst, 10);
					if (runIndex < 1 && Number.isFinite(parsedRunIndex) && parsedRunIndex > 0) {
						runIndex = parsedRunIndex;
					}
				}
			}

			if (!problemQid) {
				const q = __benchmarkTrim(agent?.jobQuery || '');
				const qidM = q.match(/\[QID\s*:\s*([^\]]+)\]/i) || q.match(/\[QID:([^\]]+)\]/i);
				problemQid = __benchmarkTrim(qidM?.[1] || '');
			}

			if (problemIndex < 0) {
				const pickUnique = (arr) => {
					const list = Array.isArray(arr) ? arr : [];
					return (list.length === 1) ? list[0] : -1;
				};
				const queryCandidates = __benchmarkUniqueTextList([
					__benchmarkTrim(agent?.jobQuery || ''),
					__benchmarkTrim(agent?.state?.initialQuery || ''),
				]).filter(Boolean);
				for (const queryText of queryCandidates) {
					const parsed = __benchmarkPromptToProblemFields(queryText, '', 0);
					const parsedQid = __benchmarkTrim(parsed?.qid || '');
					if (parsedQid && qidToIndex.has(parsedQid)) {
						problemIndex = qidToIndex.get(parsedQid);
						if (!problemQid) problemQid = parsedQid;
						break;
					}

					const byPromptHit = pickUnique(byPrompt.get(__benchmarkNormalizeTextKey(queryText)));
					if (byPromptHit >= 0) { problemIndex = byPromptHit; break; }

					const qText = __benchmarkTrim(parsed?.question_text || '');
					const choices = __benchmarkTrim(parsed?.answer_choices || '');
					const byQcHit = pickUnique(byQuestionChoices.get(__benchmarkNormalizeTextKey(`${qText}\n\nChoices:\n${choices}`)));
					if (byQcHit >= 0) { problemIndex = byQcHit; break; }

					const byQHit = pickUnique(byQuestion.get(__benchmarkNormalizeTextKey(qText)));
					if (byQHit >= 0) { problemIndex = byQHit; break; }
				}
			}

			if (problemIndex < 0 && problemQid && qidToIndex.has(problemQid)) {
				problemIndex = qidToIndex.get(problemQid);
			}
			if (problemIndex < 0 && probs.length === 1) {
				problemIndex = 0;
			}
			if (!problemQid && problemIndex >= 0 && problemIndex < probs.length) {
				problemQid = __benchmarkTrim(probs[problemIndex]?.qid || '');
			}
			if (!problemQid && problemIndex >= 0) {
				problemQid = `Q${problemIndex + 1}`;
			}
			if ((problemIndex < 0) && problemQid && qidToIndex.has(problemQid)) {
				problemIndex = qidToIndex.get(problemQid);
			}
			if (problemIndex < 0 || !problemQid) return null;
			runIndex = __benchmarkClampInt(runIndex, { min: 1, max: 1000000, fallback: 1 });

			return { problemIndex, problemQid, runIndex };
		}

		function __benchmarkCollectRowsFromAgents({ selectedIds = null, mode = 'answer_only', existingRows = [], preserveMissingRows = false } = {}) {
			const selectedSet = (selectedIds instanceof Set) ? selectedIds : null;
			const rowMap = new Map();
			const seenUniqueIds = new Set();
			(Array.isArray(existingRows) ? existingRows : []).forEach((r) => {
				const key = __benchmarkTrim(r?.uniqueId || '');
				if (!key) return;
				if (selectedSet) {
					const arch = __benchmarkTrim(r?.archId || '');
					if (arch && !selectedSet.has(arch)) return;
				}
				rowMap.set(key, { ...(r || {}) });
			});

			(agents || []).forEach((agent) => {
				if (!agent) return;
				const archId = __benchmarkTrim(agent?.config?.id || '');
				if (!archId) return;
				if (selectedSet && !selectedSet.has(archId)) return;
				const meta = __benchmarkInferAgentBenchmarkMeta(agent, __benchmarkStudio?.dataset || null);
				if (!meta) return;
				const problemQid = __benchmarkTrim(meta.problemQid || '');
				const problemIndex = __benchmarkClampInt(meta.problemIndex, { min: 0, max: 1000000, fallback: -1 });
				if (!problemQid || problemIndex < 0) return;
				const uniqueId = __benchmarkTrim(agent?.uniqueId || '');
				if (!uniqueId) return;
				seenUniqueIds.add(uniqueId);
				const prior = rowMap.get(uniqueId) || {};
				const priorFinal = __benchmarkTrim(prior?.finalResult || '');
				const nextFinal = __benchmarkTrim(agent?.state?.finalResult || '');
				const finalChanged = priorFinal !== nextFinal;
				const cleared = finalChanged ? {
					finalAnswerRaw: '',
					finalAnswerNorm: '',
					expectedAnswerRaw: '',
					expectedAnswerNorm: '',
					answerCorrect: null,
					solutionCorrect: null,
					isCorrect: null,
					graded: false,
					note: '',
					gradeMode: __benchmarkTrim(mode || 'answer_only') || 'answer_only',
					effectiveGradeMode: __benchmarkTrim(mode || 'answer_only') || 'answer_only',
				} : {};
				const runIndexRaw = parseInt(meta.runIndex || agent?.instanceId || 1, 10);
				const runIndex = Number.isFinite(runIndexRaw) ? Math.max(1, runIndexRaw) : 1;
				rowMap.set(uniqueId, {
					...prior,
					...cleared,
					problemQid,
					problemIndex,
					runIndex,
					archId,
					archName: __benchmarkTrim(agent?.config?.name || ''),
					instanceId: agent?.instanceId || runIndex,
					uniqueId,
					status: __benchmarkTrim(agent?.state?.status || ''),
					finalResult: nextFinal,
					calls: Number(agent?.state?.metrics?.calls || 0),
					tokens: Number(agent?.state?.metrics?.tokens || 0),
					finalAnswerRaw: __benchmarkTrim((finalChanged ? '' : prior?.finalAnswerRaw) || ''),
					finalAnswerNorm: __benchmarkTrim((finalChanged ? '' : prior?.finalAnswerNorm) || ''),
					expectedAnswerRaw: __benchmarkTrim((finalChanged ? '' : prior?.expectedAnswerRaw) || ''),
					expectedAnswerNorm: __benchmarkTrim((finalChanged ? '' : prior?.expectedAnswerNorm) || ''),
					answerCorrect: finalChanged ? null : ((prior?.answerCorrect === null || typeof prior?.answerCorrect === 'boolean') ? prior.answerCorrect : null),
					solutionCorrect: finalChanged ? null : ((prior?.solutionCorrect === null || typeof prior?.solutionCorrect === 'boolean') ? prior.solutionCorrect : null),
					isCorrect: finalChanged ? null : ((prior?.isCorrect === null || typeof prior?.isCorrect === 'boolean') ? prior.isCorrect : null),
					graded: finalChanged ? false : !!prior?.graded,
					note: __benchmarkTrim((finalChanged ? '' : prior?.note) || ''),
					gradeMode: __benchmarkTrim((finalChanged ? (mode || 'answer_only') : (prior?.gradeMode || mode || 'answer_only')) || 'answer_only') || 'answer_only',
				});
			});

			// Prevent stale rows (old run / old problem mapping) from contaminating new grading.
			// For resume grading, keep checkpoint rows even if some agent cards are currently missing.
			if (!preserveMissingRows && seenUniqueIds.size > 0) {
				for (const key of Array.from(rowMap.keys())) {
					if (!seenUniqueIds.has(key)) rowMap.delete(key);
				}
			}

			const out = Array.from(rowMap.values());
			out.sort((a, b) => {
				const pa = __benchmarkClampInt(a?.problemIndex, { min: -1, max: 1000000, fallback: -1 });
				const pb = __benchmarkClampInt(b?.problemIndex, { min: -1, max: 1000000, fallback: -1 });
				if (pa !== pb) return pa - pb;
				const aa = __benchmarkTrim(a?.archId || '');
				const ab = __benchmarkTrim(b?.archId || '');
				if (aa !== ab) return aa.localeCompare(ab);
				const ra = __benchmarkClampInt(a?.runIndex, { min: 0, max: 1000000, fallback: 0 });
				const rb = __benchmarkClampInt(b?.runIndex, { min: 0, max: 1000000, fallback: 0 });
				if (ra !== rb) return ra - rb;
				return __benchmarkTrim(a?.uniqueId || '').localeCompare(__benchmarkTrim(b?.uniqueId || ''));
			});
			return out;
		}

			function __benchmarkSetButtonsDisabled(disabled) {
				const ids = [
					'benchmarkNewBtn',
					'benchmarkConvertBtn',
						'benchmarkLoadJsonBtn',
						'benchmarkDownloadBtn',
						'benchmarkApplyBtn',
						'benchmarkRunFilteredBtn',
							'benchmarkGradeBtn',
						'benchmarkRegradeBtn',
						'benchmarkGradeCopyBtn',
						'benchmarkResultCopyBtn',
						'benchmarkProblemAddBtn',
					];
				ids.forEach(id => {
					const el = document.getElementById(id);
					if (el) el.disabled = !!disabled;
				});
			__benchmarkSyncTaskButtons();
		}

		function __benchmarkAnswerPreview(v, maxLen = 40) {
			let s = __benchmarkTrim(v || '');
			if (!s) return 'none';
			s = s.replace(/\s+/g, ' ').trim();
			const n = __benchmarkClampInt(maxLen, { min: 8, max: 200, fallback: 40 });
			if (s.length <= n) return s;
			return `${s.slice(0, Math.max(1, n - 3))}...`;
		}

		function __benchmarkAvgSafe(sum, denom) {
			const d = Number.isFinite(denom) ? Number(denom) : 0;
			if (!d) return 0;
			const s = Number.isFinite(sum) ? Number(sum) : 0;
			return s / d;
		}

			function __benchmarkProjectGradeVerdict(row, mode = 'answer_only') {
				const answerCorrect = (typeof row?.answerCorrect === 'boolean') ? row.answerCorrect : null;
				const solutionCorrect = (typeof row?.solutionCorrect === 'boolean') ? row.solutionCorrect : null;
				const hasTriSignals = (answerCorrect !== null) || (solutionCorrect !== null);
				const normalizedMode = __benchmarkTrim(mode || 'answer_only') || 'answer_only';
				if (hasTriSignals) {
					if (normalizedMode === 'answer_only') {
						if (answerCorrect === null) return { graded: false, isCorrect: null };
						return { graded: true, isCorrect: answerCorrect };
					}
					// Strict: in answer_and_solution mode, unknown counts as incorrect (unless we have no signals at all).
					if (answerCorrect === null && solutionCorrect === null) return { graded: false, isCorrect: null };
					return { graded: true, isCorrect: (answerCorrect === true && solutionCorrect === true) };
				}
				if (typeof row?.isCorrect === 'boolean') return { graded: true, isCorrect: row.isCorrect };
				return { graded: false, isCorrect: null };
			}

		function __benchmarkBuildGradeTextReport(rows, mode = 'answer_only') {
			const listRaw = Array.isArray(rows) ? rows : [];
			const list = listRaw.map((r) => {
				const verdict = __benchmarkProjectGradeVerdict(r, mode);
				return {
					...(r || {}),
					__viewGraded: !!verdict.graded,
					__viewIsCorrect: (typeof verdict.isCorrect === 'boolean') ? verdict.isCorrect : null,
				};
			});
			if (!list.length) return 'No grading results yet.';
			const map = new Map();
			const problemArchMap = new Map();
			let totalCalls = 0;
			let totalTokens = 0;
			list.forEach(r => {
				const k = __benchmarkString(r.archId || 'unknown');
				if (!map.has(k)) map.set(k, { correct: 0, attempts: 0, calls: 0, tokens: 0 });
				const m = map.get(k);
				if (r.__viewGraded) {
					m.attempts += 1;
					if (r.__viewIsCorrect) m.correct += 1;
				}
				if (Number.isFinite(r.calls)) m.calls += r.calls;
				if (Number.isFinite(r.tokens)) m.tokens += r.tokens;
				if (Number.isFinite(r.calls)) totalCalls += Number(r.calls || 0);
				if (Number.isFinite(r.tokens)) totalTokens += Number(r.tokens || 0);
			});
			const byProblem = new Map();
			list.forEach(r => {
				const qid = __benchmarkTrim(r.problemQid || 'UNKNOWN');
				if (!byProblem.has(qid)) byProblem.set(qid, { correct: 0, attempts: 0 });
				const p = byProblem.get(qid);
				if (r.__viewGraded) {
					p.attempts += 1;
					if (r.__viewIsCorrect) p.correct += 1;
				}
				const arch = __benchmarkTrim(r.archId || 'unknown');
				const key = `${qid}||${arch}`;
				if (!problemArchMap.has(key)) problemArchMap.set(key, { qid, archId: arch, correct: 0, attempts: 0, calls: 0, tokens: 0, problemIndex: __benchmarkClampInt(r.problemIndex, { min: -1, max: 1000000, fallback: -1 }) });
				const pa = problemArchMap.get(key);
				if (r.__viewGraded) {
					pa.attempts += 1;
					if (r.__viewIsCorrect) pa.correct += 1;
				}
				if (Number.isFinite(r.calls)) pa.calls += Number(r.calls || 0);
				if (Number.isFinite(r.tokens)) pa.tokens += Number(r.tokens || 0);
			});

			const lines = [];
			lines.push(`Mode: ${mode}`);
			lines.push(`Attempts: ${list.length}`);
			lines.push(`Average calls/attempt: ${__benchmarkAvgSafe(totalCalls, list.length).toFixed(2)}`);
			lines.push(`Average tokens/attempt: ${Math.round(__benchmarkAvgSafe(totalTokens, list.length))}`);
			lines.push('');
			lines.push('Architecture summary:');
			Array.from(map.entries())
				.sort((a, b) => (b[1].attempts ? (b[1].correct / b[1].attempts) : 0) - (a[1].attempts ? (a[1].correct / a[1].attempts) : 0))
				.forEach(([arch, m]) => {
					const acc = m.attempts ? ((m.correct / m.attempts) * 100).toFixed(1) : 'n/a';
					const avgCalls = __benchmarkAvgSafe(m.calls, m.attempts || 0).toFixed(2);
					const avgTokens = Math.round(__benchmarkAvgSafe(m.tokens, m.attempts || 0));
					lines.push(`- ${arch}: ${m.correct}/${m.attempts} (${acc}%), calls=${m.calls}, avg_calls=${avgCalls}, tokens=${m.tokens}, avg_tokens=${avgTokens}`);
				});
			lines.push('');
			lines.push('Problem summary (QID x Architecture):');
			Array.from(problemArchMap.values())
				.sort((a, b) => {
					if (a.problemIndex !== b.problemIndex) return a.problemIndex - b.problemIndex;
					const q = a.qid.localeCompare(b.qid);
					if (q !== 0) return q;
					return a.archId.localeCompare(b.archId);
				})
				.forEach((p) => {
					const acc = p.attempts ? ((p.correct / p.attempts) * 100).toFixed(1) : 'n/a';
					const avgCalls = __benchmarkAvgSafe(p.calls, p.attempts || 0).toFixed(2);
					const avgTokens = Math.round(__benchmarkAvgSafe(p.tokens, p.attempts || 0));
					lines.push(`- ${p.qid} | ${p.archId}: ${p.correct}/${p.attempts} (${acc}%), calls=${p.calls}, avg_calls=${avgCalls}, tokens=${p.tokens}, avg_tokens=${avgTokens}`);
				});
			lines.push('');
			lines.push('Problem summary (overall):');
			Array.from(byProblem.entries()).forEach(([qid, p]) => {
				const acc = p.attempts ? ((p.correct / p.attempts) * 100).toFixed(1) : 'n/a';
				lines.push(`- ${qid}: ${p.correct}/${p.attempts} (${acc}%)`);
			});
			lines.push('');
			lines.push('Detailed attempts:');
			list.forEach(r => {
				const status = !r.__viewGraded ? 'UNGRADED' : (r.__viewIsCorrect ? 'OK' : 'NO');
				const exp = __benchmarkAnswerPreview(r.expectedAnswerRaw || '-', 64);
				const got = __benchmarkAnswerPreview(r.finalAnswerRaw || '-', 64);
				const note = __benchmarkTrim(r.note || '');
				const calls = Number.isFinite(r.calls) ? Number(r.calls || 0) : 0;
				const tokens = Number.isFinite(r.tokens) ? Number(r.tokens || 0) : 0;
				lines.push(`- [${status}] ${__benchmarkTrim(r.problemQid || '')} | ${__benchmarkTrim(r.archId || '')}#${__benchmarkTrim(r.instanceId || '')} | run=${__benchmarkTrim(r.runIndex || '')} | expected=${exp || '-'} | got=${got || '-'} | calls=${calls} | tokens=${tokens}${note ? ` | ${note}` : ''}`);
			});
			return lines.join('\n');
		}

		function __benchmarkBuildTableRows(rows, columns) {
			return (rows || []).map((row) => `<tr>${columns.map((c) => `<td style="padding:4px 6px; border-bottom:1px solid var(--border-dark); white-space:nowrap;">${c(row)}</td>`).join('')}</tr>`).join('');
		}

			function __benchmarkCopyGradeReport() {
				const text = __benchmarkBuildGradeTextReport(__benchmarkStudio.lastRunRows, __benchmarkStudio.lastGradeMode || 'answer_only');
				const write = async () => {
					try {
					await navigator.clipboard.writeText(text);
					__benchmarkLog('SUCCESS', 'Grade', 'Copied grade report to clipboard.');
					__benchmarkSetProgress('Grade report copied');
					return true;
				} catch {
					return false;
				}
			};
			(async () => {
				if (await write()) return;
				try {
					const ta = document.createElement('textarea');
					ta.value = text;
					ta.style.position = 'fixed';
					ta.style.opacity = '0';
					document.body.appendChild(ta);
					ta.focus();
					ta.select();
					document.execCommand('copy');
					document.body.removeChild(ta);
					__benchmarkLog('SUCCESS', 'Grade', 'Copied grade report to clipboard (fallback).');
					__benchmarkSetProgress('Grade report copied');
				} catch (e) {
					__benchmarkLog('ERROR', 'Grade', `Copy failed: ${e?.message || e}`);
					alert('Copy failed. See benchmark log.');
					}
				})();
			}

			function __benchmarkBuildResultsTextReport() {
				const mode = __benchmarkTrim(
					__benchmarkStudio.lastGradeMode ||
					document.getElementById('benchmarkGradeMode')?.value ||
					'answer_only'
				) || 'answer_only';
				const rows = Array.isArray(__benchmarkStudio.lastRunRows) ? __benchmarkStudio.lastRunRows : [];
				const summary = __benchmarkTrim(document.getElementById('benchmarkSummary')?.innerText || '');
				const progress = __benchmarkTrim(document.getElementById('benchmarkProgress')?.innerText || '');
				const gradeCounter = __benchmarkTrim(document.getElementById('benchmarkGradeApiCounter')?.innerText || '');
				const convertCounter = __benchmarkTrim(document.getElementById('benchmarkConvertApiCounter')?.innerText || '');
				const gradeOutput = __benchmarkTrim(document.getElementById('benchmarkGradeOutput')?.innerText || '');

				const lines = [];
				lines.push(`Benchmark results snapshot @ ${new Date().toISOString()}`);
				lines.push(`grade_mode=${mode}`);
				if (summary) {
					lines.push('');
					lines.push('[Dataset summary]');
					lines.push(summary);
				}
				if (progress || gradeCounter || convertCounter) {
					lines.push('');
					lines.push('[Runtime summary]');
					if (progress) lines.push(`- progress: ${progress}`);
					if (gradeCounter) lines.push(`- grade_api: ${gradeCounter}`);
					if (convertCounter) lines.push(`- convert_api: ${convertCounter}`);
				}

				lines.push('');
				if (rows.length) {
					lines.push(__benchmarkBuildGradeTextReport(rows, mode));
				} else {
					lines.push('[Grade output]');
					lines.push(gradeOutput || 'No grading results yet.');
				}
				return lines.join('\n').trim();
			}

			function __benchmarkCopyResultsReport() {
				const text = __benchmarkBuildResultsTextReport();
				if (!text) {
					alert('No benchmark results to copy.');
					return;
				}
				const write = async () => {
					try {
						await navigator.clipboard.writeText(text);
						__benchmarkLog('SUCCESS', 'Benchmark', 'Copied benchmark results to clipboard.');
						__benchmarkSetProgress('Benchmark results copied');
						return true;
					} catch {
						return false;
					}
				};
				(async () => {
					if (await write()) return;
					try {
						const ta = document.createElement('textarea');
						ta.value = text;
						ta.style.position = 'fixed';
						ta.style.opacity = '0';
						document.body.appendChild(ta);
						ta.focus();
						ta.select();
						document.execCommand('copy');
						document.body.removeChild(ta);
						__benchmarkLog('SUCCESS', 'Benchmark', 'Copied benchmark results to clipboard (fallback).');
						__benchmarkSetProgress('Benchmark results copied');
					} catch (e) {
						__benchmarkLog('ERROR', 'Benchmark', `Copy failed: ${e?.message || e}`);
						alert('Copy failed. See benchmark log.');
					}
				})();
			}

			function __benchmarkRenderGradeOutput(rows, mode = 'answer_only') {
			const outEl = document.getElementById('benchmarkGradeOutput');
			if (!outEl) return;
			const listRaw = Array.isArray(rows) ? rows : [];
			const list = listRaw.map((r) => {
				const verdict = __benchmarkProjectGradeVerdict(r, mode);
				return {
					...(r || {}),
					__viewGraded: !!verdict.graded,
					__viewIsCorrect: (typeof verdict.isCorrect === 'boolean') ? verdict.isCorrect : null,
				};
			});
			if (!list.length) {
				outEl.innerText = 'No grading results yet.';
				return;
			}

			const archMap = new Map();
			const problemMap = new Map();
			const problemArchMap = new Map();
			let totalCalls = 0;
			let totalTokens = 0;
			for (const r of list) {
				const arch = __benchmarkTrim(r.archId || 'unknown');
				if (!archMap.has(arch)) archMap.set(arch, { archId: arch, correct: 0, attempts: 0, calls: 0, tokens: 0 });
				const ar = archMap.get(arch);
				if (r.__viewGraded) {
					ar.attempts += 1;
					if (r.__viewIsCorrect) ar.correct += 1;
				}
				if (Number.isFinite(r.calls)) ar.calls += Number(r.calls || 0);
				if (Number.isFinite(r.tokens)) ar.tokens += Number(r.tokens || 0);
				if (Number.isFinite(r.calls)) totalCalls += Number(r.calls || 0);
				if (Number.isFinite(r.tokens)) totalTokens += Number(r.tokens || 0);

				const qid = __benchmarkTrim(r.problemQid || 'UNKNOWN');
				if (!problemMap.has(qid)) problemMap.set(qid, { qid, correct: 0, attempts: 0 });
				const pr = problemMap.get(qid);
				if (r.__viewGraded) {
					pr.attempts += 1;
					if (r.__viewIsCorrect) pr.correct += 1;
				}
				const pak = `${qid}||${arch}`;
				if (!problemArchMap.has(pak)) problemArchMap.set(pak, {
					qid,
					archId: arch,
					correct: 0,
					attempts: 0,
					calls: 0,
					tokens: 0,
					problemIndex: __benchmarkClampInt(r.problemIndex, { min: -1, max: 1000000, fallback: -1 }),
				});
				const pa = problemArchMap.get(pak);
				if (r.__viewGraded) {
					pa.attempts += 1;
					if (r.__viewIsCorrect) pa.correct += 1;
				}
				if (Number.isFinite(r.calls)) pa.calls += Number(r.calls || 0);
				if (Number.isFinite(r.tokens)) pa.tokens += Number(r.tokens || 0);
			}

			const archRows = Array.from(archMap.values()).sort((a, b) => (b.attempts ? b.correct / b.attempts : 0) - (a.attempts ? a.correct / a.attempts : 0));
			const problemArchRows = Array.from(problemArchMap.values()).sort((a, b) => {
				if (a.problemIndex !== b.problemIndex) return a.problemIndex - b.problemIndex;
				const q = a.qid.localeCompare(b.qid);
				if (q !== 0) return q;
				return a.archId.localeCompare(b.archId);
			});
			const probRows = Array.from(problemMap.values()).sort((a, b) => a.qid.localeCompare(b.qid));
			const attempts = list.slice().sort((a, b) => {
				const pa = __benchmarkClampInt(a?.problemIndex, { min: -1, max: 1000000, fallback: -1 });
				const pb = __benchmarkClampInt(b?.problemIndex, { min: -1, max: 1000000, fallback: -1 });
				if (pa !== pb) return pa - pb;
				const aa = __benchmarkTrim(a?.archId || '');
				const ab = __benchmarkTrim(b?.archId || '');
				if (aa !== ab) return aa.localeCompare(ab);
				const ra = __benchmarkClampInt(a?.runIndex, { min: 0, max: 1000000, fallback: 0 });
				const rb = __benchmarkClampInt(b?.runIndex, { min: 0, max: 1000000, fallback: 0 });
				if (ra !== rb) return ra - rb;
				return __benchmarkTrim(a?.instanceId || '').localeCompare(__benchmarkTrim(b?.instanceId || ''));
			});

			const __budgetPercentile = (sortedArr, p) => {
				const arr = Array.isArray(sortedArr) ? sortedArr : [];
				if (!arr.length) return null;
				const pp = Math.max(0, Math.min(100, Number(p) || 0));
				if (pp <= 0) return arr[0];
				if (pp >= 100) return arr[arr.length - 1];
				const k = (arr.length - 1) * (pp / 100);
				const f = Math.floor(k);
				const c = Math.ceil(k);
				if (f === c) return arr[f];
				const d = k - f;
				return arr[f] * (1 - d) + arr[c] * d;
			};

			const __buildHardStopBudgetCard = (archId) => {
				const target = __benchmarkTrim(archId || '');
				if (!target) return '';

				const sub = list.filter(r => __benchmarkTrim(r?.archId || '') === target && !!r.__viewGraded && Number.isFinite(r?.calls));
				if (!sub.length) return '';

				const N = sub.length;
				const calls = sub.map(r => Number(r.calls || 0));
				const okMask = sub.map(r => !!r.__viewIsCorrect);
				const okCalls = calls.filter((_, i) => okMask[i]).slice().sort((a, b) => a - b);
				const noCalls = calls.filter((_, i) => !okMask[i]).slice().sort((a, b) => a - b);

				const okN = okCalls.length;
				const acc = okN / N;

				const sum = (arr) => arr.reduce((a, b) => a + b, 0);
				const avg = (arr) => arr.length ? (sum(arr) / arr.length) : 0;
				const avgAll = avg(calls);
				const avgOk = avg(okCalls);
				const avgNo = avg(noCalls);

				const p50ok = __budgetPercentile(okCalls, 50);
				const p75ok = __budgetPercentile(okCalls, 75);
				const p90ok = __budgetPercentile(okCalls, 90);
				const p95ok = __budgetPercentile(okCalls, 95);
				const maxOk = okCalls.length ? okCalls[okCalls.length - 1] : null;
				const p50no = __budgetPercentile(noCalls, 50);

				// Hard-stop simulation: treat attempts that exceed K calls as failures, and cost=min(calls,K).
				const candidateCaps = [18, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 120, 150, 180, 200, 250, 300];
				const capRows = candidateCaps.map((K) => {
					const k = Math.max(1, Math.floor(Number(K) || 0));
					let okUnder = 0;
					let cost = 0;
					let under = 0;
					for (let i = 0; i < N; i++) {
						const c = calls[i];
						const used = Math.min(c, k);
						cost += used;
						if (c <= k) under += 1;
						if (okMask[i] && c <= k) okUnder += 1;
					}
					const accCap = okUnder / N;
					const avgCost = cost / N;
					const eff = avgCost > 0 ? (accCap / avgCost) : 0; // correct per call
					const pOkGivenUnder = under ? (okUnder / under) : 0;
					return { k, okUnder, accCap, avgCost, eff, underFrac: under / N, pOkGivenUnder };
				});

				let bestEff = null;
				for (const r of capRows) {
					if (!bestEff) { bestEff = r; continue; }
					const betterEff = r.eff > bestEff.eff + 1e-12;
					const tieEff = Math.abs(r.eff - bestEff.eff) <= 1e-12;
					if (betterEff) bestEff = r;
					else if (tieEff) {
						// Tie-break: higher accuracy under cap, then lower avgCost, then smaller cap.
						if (r.accCap > bestEff.accCap + 1e-12) bestEff = r;
						else if (Math.abs(r.accCap - bestEff.accCap) <= 1e-12) {
							if (r.avgCost < bestEff.avgCost - 1e-9) bestEff = r;
							else if (Math.abs(r.avgCost - bestEff.avgCost) <= 1e-9 && r.k < bestEff.k) bestEff = r;
						}
					}
				}

				const accMax = capRows.reduce((m, r) => Math.max(m, r.accCap), 0);
				const recFrac = 0.95;
				const targetAcc = accMax * recFrac;
				let rec = null;
				for (const r of capRows) {
					if (r.accCap + 1e-12 >= targetAcc) { rec = r; break; }
				}
				if (!rec) rec = capRows[capRows.length - 1] || null;

				const rcapHeuristic = (() => {
					if (!okCalls.length) return null;
					const base = Number.isFinite(p75ok) ? p75ok : (Number.isFinite(avgOk) ? avgOk : null);
					if (!Number.isFinite(base)) return null;
					const slack = 5; // allow for XML validator retries / minor extra gates
					const raw = Math.round(base + slack);
					return Math.max(12, Math.min(5000, raw));
				})();

				// Tail signal: very high-call attempts are usually failures.
				const hiThr = 120;
				const hiIdx = calls.map((c, i) => ({ c, ok: okMask[i] })).filter(x => x.c > hiThr);
				const hiAcc = hiIdx.length ? (hiIdx.filter(x => x.ok).length / hiIdx.length) : null;

				const fmt1 = (x) => Number.isFinite(x) ? x.toFixed(1) : 'n/a';
				const fmt0 = (x) => Number.isFinite(x) ? `${Math.round(x)}` : 'n/a';
				const fmtPct = (x) => Number.isFinite(x) ? `${(x * 100).toFixed(1)}%` : 'n/a';

				const recLine = rec
					? `Recommended hard-stop cap (>=${Math.round(recFrac * 100)}% of max acc): K=${rec.k} (acc=${fmtPct(rec.accCap)}, avg_cost=${fmt1(rec.avgCost)}).`
					: 'No cap recommendation available.';
				const effLine = bestEff
					? `Efficiency-optimal cap (acc/avg_cost): K=${bestEff.k} (acc=${fmtPct(bestEff.accCap)}, avg_cost=${fmt1(bestEff.avgCost)}).`
					: '';
				const rcapLine = (rcapHeuristic != null)
					? `rcap heuristic (per-round): ~${rcapHeuristic} calls (from OK p75‚âà${fmt0(p75ok)} + slack).`
					: '';

				return `<div style="margin-bottom:8px; padding:6px; border:1px solid var(--border-dark); border-radius:6px; background:var(--bg);">
					<div style="font-weight:700; margin-bottom:4px;">Budget analysis (Status-derived) ‚Äî ${__benchmarkXmlEscape(target)}</div>
					<div>Accuracy: ${okN}/${N} (${fmtPct(acc)})</div>
					<div>Avg calls: all=${fmt1(avgAll)} | OK=${fmt1(avgOk)} | NO=${fmt1(avgNo)} (NO median=${fmt0(p50no)})</div>
					<div>OK calls percentiles: p50=${fmt0(p50ok)} | p75=${fmt0(p75ok)} | p90=${fmt0(p90ok)} | p95=${fmt0(p95ok)} | max=${fmt0(maxOk)}</div>
					<div style="margin-top:6px;">${__benchmarkXmlEscape(recLine)}</div>
					${effLine ? `<div style="margin-top:4px; color:var(--text-3); font-size:11px;">${__benchmarkXmlEscape(effLine)}</div>` : ''}
					${rcapLine ? `<div style="margin-top:4px; color:var(--text-3); font-size:11px;">${__benchmarkXmlEscape(rcapLine)}</div>` : ''}
					${(hiAcc == null) ? '' : `<div style="margin-top:4px; color:var(--text-3); font-size:11px;">Tail check: calls&gt;${hiThr} accuracy=${fmtPct(hiAcc)} (n=${hiIdx.length}).</div>`}
					<div style="margin-top:4px; color:var(--text-3); font-size:11px;">
						Note: this treats K as a hard stop on <em>total calls/attempt</em> (lower bound). For per-round control, use <code>test43-2-rcap*</code> variants and compare accuracy vs calls directly.
					</div>
				</div>`;
			};

			const budgetCard = __buildHardStopBudgetCard('test43-2');

			const statCard = `<div style="margin-bottom:8px; padding:6px; border:1px solid var(--border-dark); border-radius:6px; background:var(--bg);">
				<div><strong>Mode:</strong> ${__benchmarkXmlEscape(mode)}</div>
				<div><strong>Attempts:</strong> ${list.length}</div>
				<div><strong>Avg calls/attempt:</strong> ${__benchmarkAvgSafe(totalCalls, list.length).toFixed(2)}</div>
				<div><strong>Avg tokens/attempt:</strong> ${Math.round(__benchmarkAvgSafe(totalTokens, list.length))}</div>
			</div>`;

			const archTable = `<div style="margin-top:8px;">
				<div style="font-weight:bold; margin-bottom:4px;">Architecture summary</div>
				<div style="overflow:auto; max-height:180px; border:1px solid var(--border-dark); border-radius:6px;">
					<table style="width:100%; border-collapse:collapse; font-size:12px;">
						<thead><tr>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Architecture</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Correct</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Attempts</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Accuracy</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Calls</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Avg Calls</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Tokens</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Avg Tokens</th>
						</tr></thead>
						<tbody>${__benchmarkBuildTableRows(archRows, [
				(r) => __benchmarkXmlEscape(r.archId),
				(r) => `${r.correct}`,
				(r) => `${r.attempts}`,
				(r) => `${r.attempts ? ((r.correct / r.attempts) * 100).toFixed(1) : 'n/a'}%`,
				(r) => `${r.calls}`,
				(r) => `${__benchmarkAvgSafe(r.calls, r.attempts || 0).toFixed(2)}`,
				(r) => `${r.tokens}`,
				(r) => `${Math.round(__benchmarkAvgSafe(r.tokens, r.attempts || 0))}`,
			])}</tbody>
					</table>
				</div>
			</div>`;

			const problemTable = `<div style="margin-top:8px;">
				<div style="font-weight:bold; margin-bottom:4px;">Problem summary (QID x Architecture)</div>
				<div style="overflow:auto; max-height:160px; border:1px solid var(--border-dark); border-radius:6px;">
					<table style="width:100%; border-collapse:collapse; font-size:12px;">
						<thead><tr>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">QID</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Architecture</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Correct</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Attempts</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Accuracy</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Calls</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Avg Calls</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Tokens</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Avg Tokens</th>
						</tr></thead>
						<tbody>${__benchmarkBuildTableRows(problemArchRows, [
				(r) => __benchmarkXmlEscape(r.qid),
				(r) => __benchmarkXmlEscape(r.archId),
				(r) => `${r.correct}`,
				(r) => `${r.attempts}`,
				(r) => `${r.attempts ? ((r.correct / r.attempts) * 100).toFixed(1) : 'n/a'}%`,
				(r) => `${r.calls}`,
				(r) => `${__benchmarkAvgSafe(r.calls, r.attempts || 0).toFixed(2)}`,
				(r) => `${r.tokens}`,
				(r) => `${Math.round(__benchmarkAvgSafe(r.tokens, r.attempts || 0))}`,
			])}</tbody>
					</table>
				</div>
			</div>`;

			const attemptsTable = `<div style="margin-top:8px;">
				<div style="font-weight:bold; margin-bottom:4px;">Detailed attempts</div>
				<div style="overflow:auto; max-height:280px; border:1px solid var(--border-dark); border-radius:6px;">
					<table style="width:100%; border-collapse:collapse; font-size:12px;">
						<thead><tr>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Status</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">QID</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Arch</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Instance</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Run</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Expected</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Got</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Calls</th>
							<th style="text-align:right; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Tokens</th>
							<th style="text-align:left; padding:4px 6px; position:sticky; top:0; background:var(--secondary-bg);">Note</th>
						</tr></thead>
						<tbody>${__benchmarkBuildTableRows(attempts, [
				(r) => {
					const status = !r.__viewGraded ? 'UNGRADED' : (r.__viewIsCorrect ? 'OK' : 'NO');
					const color = status === 'OK' ? '#22c55e' : (status === 'NO' ? '#ef4444' : '#f59e0b');
					return `<span style="font-weight:700; color:${color};">${status}</span>`;
				},
				(r) => __benchmarkXmlEscape(__benchmarkTrim(r.problemQid || '')),
				(r) => __benchmarkXmlEscape(__benchmarkTrim(r.archId || '')),
				(r) => __benchmarkXmlEscape(__benchmarkTrim(r.instanceId || '')),
				(r) => `${__benchmarkTrim(r.runIndex || '')}`,
				(r) => __benchmarkXmlEscape(__benchmarkAnswerPreview(r.expectedAnswerRaw || '-', 64)),
				(r) => __benchmarkXmlEscape(__benchmarkAnswerPreview(r.finalAnswerRaw || '-', 64)),
				(r) => `${Number.isFinite(r.calls) ? Number(r.calls || 0) : 0}`,
				(r) => `${Number.isFinite(r.tokens) ? Number(r.tokens || 0) : 0}`,
				(r) => __benchmarkXmlEscape(__benchmarkTrim(r.note || '')),
			])}</tbody>
					</table>
				</div>
			</div>`;

			outEl.innerHTML = `${statCard}${budgetCard}${archTable}${problemTable}${attemptsTable}`;
		}

			function __benchmarkExportState() {
				const sourceTextEl = document.getElementById('benchmarkSourceText');
				return {
					dataset: __benchmarkStudio.dataset,
					lastRunRows: Array.isArray(__benchmarkStudio.lastRunRows) ? __benchmarkStudio.lastRunRows : [],
					lastGradeMode: __benchmarkStudio.lastGradeMode || 'answer_only',
					manualSpawnMode: !!__benchmarkStudio.manualSpawnMode,
					pendingSpawnUniqueIds: Array.isArray(__benchmarkStudio.pendingSpawnUniqueIds)
						? __benchmarkStudio.pendingSpawnUniqueIds.slice()
						: [],
					logLines: Array.isArray(__benchmarkStudio.logLines) ? __benchmarkStudio.logLines.slice() : [],
					runCheckpoint: __benchmarkSafeClone(__benchmarkStudio.runCheckpoint || null),
				parseCheckpoint: __benchmarkSafeClone(__benchmarkStudio.parseCheckpoint || null),
				gradeCheckpoint: __benchmarkSafeClone(__benchmarkStudio.gradeCheckpoint || null),
				artifacts: __benchmarkSafeClone(__benchmarkEnsureArtifacts()),
				apiCounters: __benchmarkSafeClone(__benchmarkEnsureApiCounters()),
				ui: {
					sourceText: sourceTextEl ? sourceTextEl.value : '',
					convertDelimiter: (document.getElementById('benchmarkConvertDelimiter')?.value || '').toString(),
						answerKeyText: (document.getElementById('benchmarkAnswerKeyText')?.value || '').toString(),
						appliedToUi: !!__benchmarkStudio.appliedToUi,
						runFilterEnabled: !!document.getElementById('benchmarkRunFilterEnabled')?.checked,
						problemFilterText: (document.getElementById('benchmarkProblemFilter')?.value || '').toString(),
						gradeMode: document.getElementById('benchmarkGradeMode')?.value || 'answer_only',
						autoGrade: !!document.getElementById('benchmarkAutoGrade')?.checked,
					parseApiKeyList: (document.getElementById('benchmarkParseApiKeyList')?.value || '').toString(),
					parseApiUrl: (document.getElementById('benchmarkParseApiUrl')?.value || '').toString(),
					parseApiProxyUrl: (document.getElementById('benchmarkParseApiProxyUrl')?.value || '').toString(),
					parseModelName: (document.getElementById('benchmarkParseModelName')?.value || '').toString(),
					parseBypassSystemRole: !!document.getElementById('benchmarkParseBypassSystemRole')?.checked,
					parseSplitTokens: __benchmarkClampInt(document.getElementById('benchmarkParseSplitTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
					parseMergeTokens: __benchmarkClampInt(document.getElementById('benchmarkParseMergeTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
					parseRpmLimit: __normalizeRateLimit(document.getElementById('benchmarkParseRpmLimit')?.value),
					parseTpmLimit: __normalizeRateLimit(document.getElementById('benchmarkParseTpmLimit')?.value),
					parseMaxInflightPerKey: __normalizeInflightLimit(document.getElementById('benchmarkParseMaxInflightPerKey')?.value),
					gradeApiKeyList: (document.getElementById('benchmarkGradeApiKeyList')?.value || '').toString(),
					gradeApiUrl: (document.getElementById('benchmarkGradeApiUrl')?.value || '').toString(),
					gradeApiProxyUrl: (document.getElementById('benchmarkGradeApiProxyUrl')?.value || '').toString(),
					gradeModelName: (document.getElementById('benchmarkGradeModelName')?.value || '').toString(),
					gradeBypassSystemRole: !!document.getElementById('benchmarkGradeBypassSystemRole')?.checked,
					gradeSplitTokens: __benchmarkClampInt(document.getElementById('benchmarkGradeSplitTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
					gradeMergeTokens: __benchmarkClampInt(document.getElementById('benchmarkGradeMergeTokens')?.value, { min: 500, max: 200000, fallback: 12000 }),
					gradeRpmLimit: __normalizeRateLimit(document.getElementById('benchmarkGradeRpmLimit')?.value),
					gradeTpmLimit: __normalizeRateLimit(document.getElementById('benchmarkGradeTpmLimit')?.value),
					gradeMaxInflightPerKey: __normalizeInflightLimit(document.getElementById('benchmarkGradeMaxInflightPerKey')?.value),
				},
			};
		}

		function __benchmarkRestoreState(saved) {
				if (!saved || typeof saved !== 'object') {
					__benchmarkSetDataset(null);
					__benchmarkStudio.lastRunRows = [];
					__benchmarkStudio.lastGradeMode = 'answer_only';
					__benchmarkStudio.manualSpawnMode = false;
					__benchmarkStudio.pendingSpawnUniqueIds = [];
					__benchmarkStudio.runCheckpoint = null;
				__benchmarkSetTaskCheckpoint('parse', null);
				__benchmarkSetTaskCheckpoint('grade', null);
				__benchmarkSetTaskRunning('parse', false);
				__benchmarkSetTaskRunning('grade', false);
				__benchmarkSetTaskStopRequested('parse', false);
				__benchmarkSetTaskStopRequested('grade', false);
				__benchmarkStudio.taskRateState = { parse: new Map(), grade: new Map() };
				__benchmarkStudio.taskInflightState = { parse: new Map(), grade: new Map() };
				__benchmarkStudio.artifacts = __benchmarkCreateArtifactsState();
				__benchmarkStudio.apiCounters = __benchmarkCreateApiCountersState();
				__benchmarkStudio.appliedToUi = false;
				__benchmarkRenderGradeOutput([], 'answer_only');
				__benchmarkRenderLog();
				__benchmarkRenderRawIoViewer(true);
				__benchmarkRenderApiCounters();
				return;
			}
			try {
				const ui = saved.ui || {};
				const sourceTextEl = document.getElementById('benchmarkSourceText');
				if (sourceTextEl && typeof ui.sourceText === 'string') sourceTextEl.value = ui.sourceText;
					if (typeof ui.convertDelimiter === 'string') document.getElementById('benchmarkConvertDelimiter').value = ui.convertDelimiter;
					if (typeof ui.answerKeyText === 'string') document.getElementById('benchmarkAnswerKeyText').value = ui.answerKeyText;
					if (typeof ui.runFilterEnabled === 'boolean') document.getElementById('benchmarkRunFilterEnabled').checked = ui.runFilterEnabled;
					if (typeof ui.problemFilterText === 'string') document.getElementById('benchmarkProblemFilter').value = ui.problemFilterText;
					if (typeof ui.gradeMode === 'string') document.getElementById('benchmarkGradeMode').value = ui.gradeMode;
				if (typeof ui.autoGrade === 'boolean') document.getElementById('benchmarkAutoGrade').checked = ui.autoGrade;
				if (ui.parseApiKeyList != null) document.getElementById('benchmarkParseApiKeyList').value = __coerceApiKeyListTextareaValue(ui.parseApiKeyList);
				if (typeof ui.parseApiUrl === 'string') document.getElementById('benchmarkParseApiUrl').value = ui.parseApiUrl;
				if (typeof ui.parseApiProxyUrl === 'string') document.getElementById('benchmarkParseApiProxyUrl').value = ui.parseApiProxyUrl;
				if (typeof ui.parseModelName === 'string') document.getElementById('benchmarkParseModelName').value = ui.parseModelName;
				if (typeof ui.parseBypassSystemRole === 'boolean') document.getElementById('benchmarkParseBypassSystemRole').checked = ui.parseBypassSystemRole;
				if (Number.isFinite(ui.parseSplitTokens)) document.getElementById('benchmarkParseSplitTokens').value = `${__benchmarkClampInt(ui.parseSplitTokens, { min: 500, max: 200000, fallback: 12000 })}`;
				if (Number.isFinite(ui.parseMergeTokens)) document.getElementById('benchmarkParseMergeTokens').value = `${__benchmarkClampInt(ui.parseMergeTokens, { min: 500, max: 200000, fallback: 12000 })}`;
				if (Number.isFinite(ui.parseRpmLimit)) document.getElementById('benchmarkParseRpmLimit').value = `${__normalizeRateLimit(ui.parseRpmLimit)}`;
				if (Number.isFinite(ui.parseTpmLimit)) document.getElementById('benchmarkParseTpmLimit').value = `${__normalizeRateLimit(ui.parseTpmLimit)}`;
				if (Number.isFinite(ui.parseMaxInflightPerKey)) document.getElementById('benchmarkParseMaxInflightPerKey').value = `${__normalizeInflightLimit(ui.parseMaxInflightPerKey)}`;
				if (ui.gradeApiKeyList != null) document.getElementById('benchmarkGradeApiKeyList').value = __coerceApiKeyListTextareaValue(ui.gradeApiKeyList);
				if (typeof ui.gradeApiUrl === 'string') document.getElementById('benchmarkGradeApiUrl').value = ui.gradeApiUrl;
				if (typeof ui.gradeApiProxyUrl === 'string') document.getElementById('benchmarkGradeApiProxyUrl').value = ui.gradeApiProxyUrl;
				if (typeof ui.gradeModelName === 'string') document.getElementById('benchmarkGradeModelName').value = ui.gradeModelName;
				if (typeof ui.gradeBypassSystemRole === 'boolean') document.getElementById('benchmarkGradeBypassSystemRole').checked = ui.gradeBypassSystemRole;
				if (Number.isFinite(ui.gradeSplitTokens)) document.getElementById('benchmarkGradeSplitTokens').value = `${__benchmarkClampInt(ui.gradeSplitTokens, { min: 500, max: 200000, fallback: 12000 })}`;
				if (Number.isFinite(ui.gradeMergeTokens)) document.getElementById('benchmarkGradeMergeTokens').value = `${__benchmarkClampInt(ui.gradeMergeTokens, { min: 500, max: 200000, fallback: 12000 })}`;
				if (Number.isFinite(ui.gradeRpmLimit)) document.getElementById('benchmarkGradeRpmLimit').value = `${__normalizeRateLimit(ui.gradeRpmLimit)}`;
				if (Number.isFinite(ui.gradeTpmLimit)) document.getElementById('benchmarkGradeTpmLimit').value = `${__normalizeRateLimit(ui.gradeTpmLimit)}`;
				if (Number.isFinite(ui.gradeMaxInflightPerKey)) document.getElementById('benchmarkGradeMaxInflightPerKey').value = `${__normalizeInflightLimit(ui.gradeMaxInflightPerKey)}`;
			} catch { }

			const ds = __benchmarkNormalizeDataset(saved.dataset || {}, saved.dataset?.name || 'Benchmark');
			__benchmarkSetDataset(ds);
				__benchmarkStudio.lastRunRows = Array.isArray(saved.lastRunRows) ? saved.lastRunRows.slice() : [];
				__benchmarkStudio.lastGradeMode = (__benchmarkTrim(document.getElementById('benchmarkGradeMode')?.value || '') || __benchmarkTrim(saved.lastGradeMode || '') || 'answer_only').toString();
				__benchmarkStudio.manualSpawnMode = !!saved.manualSpawnMode;
				__benchmarkStudio.pendingSpawnUniqueIds = Array.isArray(saved.pendingSpawnUniqueIds)
					? saved.pendingSpawnUniqueIds
						.map((id) => __benchmarkTrim(id || ''))
						.filter(Boolean)
					: [];
				__benchmarkStudio.logLines = Array.isArray(saved.logLines) ? saved.logLines.slice() : [];
			__benchmarkStudio.runCheckpoint = __benchmarkNormalizeRunCheckpoint(saved.runCheckpoint || null);
			__benchmarkSetTaskCheckpoint('parse', __benchmarkNormalizeParseCheckpoint(saved.parseCheckpoint || null));
			__benchmarkSetTaskCheckpoint('grade', __benchmarkNormalizeGradeCheckpoint(saved.gradeCheckpoint || null));
			__benchmarkSetTaskRunning('parse', false);
			__benchmarkSetTaskRunning('grade', false);
			__benchmarkSetTaskStopRequested('parse', false);
			__benchmarkSetTaskStopRequested('grade', false);
			__benchmarkStudio.artifacts = __benchmarkNormalizeArtifactsState(saved.artifacts || null);
			__benchmarkStudio.apiCounters = __benchmarkNormalizeApiCounters(saved.apiCounters || null);
			__benchmarkStudio.appliedToUi = !!(saved?.ui && saved.ui.appliedToUi === true);
			__benchmarkRenderGradeOutput(__benchmarkStudio.lastRunRows, __benchmarkStudio.lastGradeMode);
			__benchmarkRenderLog();
			__benchmarkRenderRawIoViewer(true);
			if (!saved.apiCounters || typeof saved.apiCounters !== 'object') {
				__benchmarkRebuildApiCountersFromArtifacts();
			} else {
				__benchmarkRenderApiCounters();
			}
			const cp = __benchmarkStudio.runCheckpoint;
			if (cp && cp.status === 'running' && Number.isFinite(cp.total_problems) && cp.total_problems > 0) {
				const next = Math.min(cp.total_problems, Math.max(0, cp.next_problem_index) + 1);
				__benchmarkSetProgress(`Resume available: problem ${next}/${cp.total_problems}`);
				__benchmarkLog('INFO', 'RunSuite', `Restored resumable checkpoint at problem ${next}/${cp.total_problems}.`);
			}
		}

		function __benchmarkDownloadJson(filename, obj) {
			const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = filename;
			a.click();
		}

		function __benchmarkTaskPrefix(kind) {
			return kind === 'grade' ? 'benchmarkGrade' : 'benchmarkParse';
		}

		function __benchmarkParseApiKeys(raw) {
			return __parseApiKeyList(raw);
		}

		function __benchmarkCoerceGeminiUrlModel(url, model) {
			const rawUrl = __benchmarkTrim(url);
			const m = __benchmarkTrim(model);
			if (!rawUrl || !m) return rawUrl;
			// If URL is hardcoded like .../models/gemini-3-flash:generateContent,
			// force it to use the Model input to avoid silent model drift.
			return rawUrl.replace(
				/(\/models\/)([^/:?#]+)(:(?:generateContent|streamGenerateContent)\b)/i,
				(_all, p1, _oldModel, p3) => `${p1}${m}${p3}`
			);
		}

		function __benchmarkRedactUrlForLog(rawUrl) {
			const txt = __benchmarkTrim(rawUrl);
			if (!txt) return '';
			const redactParam = (urlObj, key) => {
				if (urlObj.searchParams.has(key)) urlObj.searchParams.set(key, '***');
			};
			try {
				const u = new URL(txt);
				['key', 'api_key', 'apikey', 'token', 'access_token', 'auth', 'authorization'].forEach(k => redactParam(u, k));
				return u.toString();
			} catch {
				return txt.replace(/([?&](?:key|api_key|apikey|token|access_token|auth|authorization)=)[^&]*/ig, '$1***');
			}
		}

		function __benchmarkSummarizeUrlForLog(rawUrl, maxLen = 220) {
			const redacted = __benchmarkRedactUrlForLog(rawUrl);
			if (!redacted) return '';
			if (redacted.length <= maxLen) return redacted;
			return `${redacted.slice(0, maxLen)}...[truncated ${redacted.length - maxLen} chars]`;
		}

		function __benchmarkGetTaskApiConfig(kind) {
			const prefix = __benchmarkTaskPrefix(kind);
			const keyRaw = (document.getElementById(`${prefix}ApiKeyList`)?.value || '').toString();
			const keys = __benchmarkParseApiKeys(keyRaw);
			const apiUrl = (document.getElementById(`${prefix}ApiUrl`)?.value || '').toString().trim();
			const apiProxyUrl = (document.getElementById(`${prefix}ApiProxyUrl`)?.value || '').toString().trim();
			const modelInput = (document.getElementById(`${prefix}ModelName`)?.value || '').toString().trim();
			const bypassSystemRole = !!document.getElementById(`${prefix}BypassSystemRole`)?.checked;
			const rpmLimit = __normalizeRateLimit(document.getElementById(`${prefix}RpmLimit`)?.value);
			const tpmLimit = __normalizeRateLimit(document.getElementById(`${prefix}TpmLimit`)?.value);
			const maxInflightPerKey = __normalizeInflightLimit(document.getElementById(`${prefix}MaxInflightPerKey`)?.value);

			if (!apiUrl) throw new Error(`${kind} API URL is empty.`);
			if (!modelInput) throw new Error(`${kind} model is empty.`);
			if (!keys.length) throw new Error(`${kind} API key list is empty.`);

			const model = modelInput.replace(/^models\//i, '').trim();
			let url = apiUrl.replaceAll('{model}', model).replaceAll('{{MODEL}}', model);
			url = __benchmarkCoerceGeminiUrlModel(url, model);
			const lower = url.toLowerCase();
			const apiMode = (() => {
				if (lower.includes('/ai/run/')) return 'cf_ai_run';
				if (lower.includes('/ai/v1/responses')) return 'cf_responses';
				if (lower.includes('/openai/')) return 'openai_chat_completions';
				if (lower.includes(':generatecontent') || lower.includes(':streamgeneratecontent')) return 'gemini_generatecontent';
				return 'openai_chat_completions';
			})();
			return {
				kind,
				keys,
				url,
				apiProxyUrl,
				model,
				apiMode,
				bypassSystemRole,
				rpmLimit,
				tpmLimit,
				maxInflightPerKey,
			};
		}

		function __benchmarkPickTaskApiKey(kind, keys) {
			const list = Array.isArray(keys) ? keys : [];
			if (!list.length) throw new Error(`${kind} API key list is empty.`);
			const cur = Number.isFinite(__benchmarkStudio.apiKeyCursor?.[kind]) ? __benchmarkStudio.apiKeyCursor[kind] : 0;
			const idx = ((cur % list.length) + list.length) % list.length;
			const key = list[idx];
			__benchmarkStudio.apiKeyCursor[kind] = (idx + 1) % list.length;
			return key;
		}

		function __benchmarkSanitizeModelText(raw) {
			let s = (raw ?? '').toString().replace(/\uFEFF/g, '').trim();
			for (let i = 0; i < 3; i++) {
				const m =
					s.match(/^\s*```[a-zA-Z0-9_-]*\s*\n([\s\S]*?)\n```\s*$/) ||
					s.match(/^\s*```[a-zA-Z0-9_-]*\s*([\s\S]*?)```\s*$/);
				if (!m) break;
				s = (m[1] ?? '').toString().trim();
			}
			return s.trim();
		}

		function __benchmarkGetApiHelper() {
			if (__benchmarkApiAgent) return __benchmarkApiAgent;
			__benchmarkApiAgent = new AgentSystem({
				id: 'benchmark-helper',
				name: 'Benchmark Helper',
				group: 'Utility',
				who: 'solver',
				accRun: false,
				accCross: false,
			}, 1);
			__benchmarkApiAgent.uniqueId = 'benchmark-helper';
			__benchmarkApiAgent.log = () => { };
			__benchmarkApiAgent.logBlock = () => { };
			__benchmarkApiAgent.updateMetricsUI = () => { };
			__benchmarkApiAgent.updateStatusUI = () => { };
			__benchmarkApiAgent.refreshWhiteboardUI = () => { };
			return __benchmarkApiAgent;
		}

		async function __benchmarkCallApi(kind, messages, options = {}) {
			const requestOptions = { ...(options || {}) };
			const contextLabel = __benchmarkTrim(requestOptions.contextLabel || `${kind.toUpperCase()} API`);
			let cfg = null;
			try {
				cfg = __benchmarkGetTaskApiConfig(kind);
			} catch (e) {
				__benchmarkLog('ERROR', contextLabel, `API config error: ${e?.message || e}`);
				throw e;
			}
			const endpointLog = __benchmarkSummarizeUrlForLog(cfg.url);
			const proxyLog = __benchmarkSummarizeUrlForLog(cfg.apiProxyUrl);
			__benchmarkLog(
				'INFO',
				contextLabel,
				`API config | kind=${kind} | mode=${cfg.apiMode} | model=${cfg.model} | endpoint=${endpointLog || '(empty)'}${proxyLog ? ` | proxy=${proxyLog}` : ''} | keys=${cfg.keys.length} | bypass_system=${cfg.bypassSystemRole ? 'on' : 'off'} | rpm=${cfg.rpmLimit || 0} | tpm=${cfg.tpmLimit || 0} | inflight=${cfg.maxInflightPerKey || 0}`
			);
			const finalMessages = cfg.bypassSystemRole ? __adaptMessagesNoSystem(messages || []) : (messages || []);
			const temperature = typeof requestOptions.temperature === 'number' ? requestOptions.temperature : 0;
			const timeoutMs = Number.isFinite(requestOptions.timeoutMs) ? Math.max(1000, requestOptions.timeoutMs) : 10 * 60 * 1000;
			const rawMaxRetries = requestOptions.maxRetries;
			const infiniteRetries =
				rawMaxRetries === -1 ||
				rawMaxRetries === Number.POSITIVE_INFINITY ||
				`${rawMaxRetries}`.trim().toLowerCase() === 'infinite';
			const maxRetries = infiniteRetries ? 0 : __benchmarkClampInt(rawMaxRetries, { min: 0, max: 20, fallback: 1 });
			const totalAttempts = 1 + maxRetries;
			const retryBaseMs = __benchmarkClampInt(requestOptions.retryBaseMs, { min: 100, max: 20000, fallback: 1200 });
			let strictJsonMode = !!requestOptions.expectJson;
			let geminiSchemaEnabled =
				strictJsonMode &&
				cfg.apiMode === 'gemini_generatecontent' &&
				!!(requestOptions.jsonSchema && typeof requestOptions.jsonSchema === 'object');
			let openaiSchemaEnabled =
				strictJsonMode &&
				cfg.apiMode === 'openai_chat_completions' &&
				!!(requestOptions.jsonSchema && typeof requestOptions.jsonSchema === 'object');
			const geminiResponseSchema = geminiSchemaEnabled
				? __benchmarkConvertJsonSchemaToGeminiSchema(requestOptions.jsonSchema)
				: null;
			if (geminiSchemaEnabled && !geminiResponseSchema) {
				geminiSchemaEnabled = false;
				__benchmarkLog('WARN', contextLabel, 'Gemini schema conversion failed; using JSON mime-only mode.');
			}

			let lastErr = null;
			for (let attempt = 1; infiniteRetries || attempt <= totalAttempts; attempt++) {
				__benchmarkThrowIfTaskStopped(kind);
				const keySlotRaw = Number.isFinite(__benchmarkStudio.apiKeyCursor?.[kind]) ? __benchmarkStudio.apiKeyCursor[kind] : 0;
				const keySlot = cfg.keys.length ? ((((keySlotRaw % cfg.keys.length) + cfg.keys.length) % cfg.keys.length) + 1) : 1;
				const key = __benchmarkPickTaskApiKey(kind, cfg.keys);
				let requestUrl = cfg.url;
				let headers = { 'Content-Type': 'application/json' };
				let body = null;
				const estimatedInTokens = __benchmarkEstimateTokens(JSON.stringify(finalMessages || []));
				const t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
				const attemptTag = infiniteRetries ? `${attempt}/‚àû` : `${attempt}/${totalAttempts}`;
				const callRecord = __benchmarkRecordApiCallStart({
					kind,
					context: contextLabel,
					model: cfg.model,
					mode: cfg.apiMode,
					attempt: attemptTag,
					key_slot: `${keySlot}/${cfg.keys.length}`,
					request: {
						endpoint: __benchmarkRedactUrlForLog(cfg.url),
						proxy: __benchmarkRedactUrlForLog(cfg.apiProxyUrl),
						messages: __benchmarkSafeClone(finalMessages),
						messages_text: __benchmarkMessagesToRawText(finalMessages),
						est_in_tokens: estimatedInTokens,
						body: null,
					},
				});

				__benchmarkLog('INFO', contextLabel, `Attempt ${attemptTag} | kind=${kind} | mode=${cfg.apiMode} | model=${cfg.model} | key_slot=${keySlot}/${cfg.keys.length} | key=${maskKey(key)} | est_in_tokens=${estimatedInTokens}`);

				let releaseRateSlot = null;
				try {
					releaseRateSlot = await __benchmarkAcquireTaskRateSlot(kind, cfg, key, estimatedInTokens, contextLabel);
					if (cfg.apiMode === 'gemini_generatecontent') {
						requestUrl = __withKeyParam(requestUrl, key);
						const payload = __toGeminiPayload(finalMessages);
						const generationConfig = { temperature };
						if (Number.isFinite(requestOptions.top_p)) generationConfig.topP = requestOptions.top_p;
						if (Number.isFinite(requestOptions.top_k)) generationConfig.topK = requestOptions.top_k;
						if (Number.isFinite(requestOptions.max_tokens)) generationConfig.maxOutputTokens = requestOptions.max_tokens;
						if (strictJsonMode) {
							generationConfig.responseMimeType = 'application/json';
							if (geminiSchemaEnabled && geminiResponseSchema) generationConfig.responseSchema = geminiResponseSchema;
						}
						body = { contents: payload.contents, generationConfig };
						if (payload.systemInstruction) body.systemInstruction = payload.systemInstruction;
					} else if (cfg.apiMode === 'cf_ai_run') {
						const cf = __toCfResponsesPayload(finalMessages);
						headers = { ...headers, 'Authorization': `Bearer ${key}` };
						body = { input: cf.inputText || '' };
						if (Number.isFinite(temperature)) body.temperature = temperature;
					} else if (cfg.apiMode === 'cf_responses') {
						const cf = __toCfResponsesPayload(finalMessages);
						headers = { ...headers, 'Authorization': `Bearer ${key}` };
						body = { model: cfg.model, input: cf.inputText || '', stream: false };
						if (Number.isFinite(temperature)) body.temperature = temperature;
					} else {
						headers = { ...headers, 'Authorization': `Bearer ${key}` };
						body = { model: cfg.model, messages: finalMessages, temperature, stream: false };
						if (Number.isFinite(requestOptions.top_p)) body.top_p = requestOptions.top_p;
						if (Number.isFinite(requestOptions.max_tokens)) {
							// OpenAI-compatible gateways are inconsistent: some honor max_tokens,
							// some require max_completion_tokens or max_output_tokens.
							body.max_tokens = requestOptions.max_tokens;
							body.max_completion_tokens = requestOptions.max_tokens;
							body.max_output_tokens = requestOptions.max_tokens;
						}
						if (strictJsonMode) {
							if (openaiSchemaEnabled && requestOptions.jsonSchema && typeof requestOptions.jsonSchema === 'object') {
								body.response_format = {
									type: 'json_schema',
									json_schema: {
										name: __benchmarkTrim(requestOptions.jsonSchemaName || `${kind}_schema`) || `${kind}_schema`,
										strict: true,
										schema: requestOptions.jsonSchema,
									},
								};
							} else {
								body.response_format = { type: 'json_object' };
							}
						}
					}

					if (cfg.apiProxyUrl) {
						const targetUrl = requestUrl;
						const encodedTarget = encodeURIComponent(targetUrl);
						if (cfg.apiProxyUrl.includes('{url}') || cfg.apiProxyUrl.includes('{{URL}}')) {
							requestUrl = cfg.apiProxyUrl.replaceAll('{url}', encodedTarget).replaceAll('{{URL}}', encodedTarget);
						} else {
							const targetHeaders = { ...headers };
							requestUrl = cfg.apiProxyUrl;
							headers = { 'Content-Type': 'application/json' };
							body = {
								url: targetUrl,
								method: 'POST',
								headers: targetHeaders,
								body
							};
						}
					}

					if (callRecord) {
						callRecord.request = {
							...(callRecord.request || {}),
							endpoint: __benchmarkRedactUrlForLog(requestUrl),
							body: __benchmarkSafeClone(body),
						};
						__benchmarkTouchArtifacts();
					}

					const ac = new AbortController();
					let timeoutId = null;
					try {
						timeoutId = setTimeout(() => {
							try { ac.abort(); } catch { }
						}, timeoutMs);

						const resp = await fetch(requestUrl, {
							method: 'POST',
							headers,
							body: JSON.stringify(body),
							signal: ac.signal,
						});
						if (!resp.ok) {
							let errBody = '';
							try { errBody = await resp.text(); } catch { }
							let effectiveStatus = resp.status;
							if (resp.status === 500) {
								const body429 = /\b429\b/.test(errBody || '');
								const streamWrapped = /stream request failed|too many requests|rate limit|overloaded/i.test(errBody || '');
								if (body429 && streamWrapped) effectiveStatus = 429;
							}
							let retryAfterMs = null;
							try {
								const ra = __benchmarkTrim(resp.headers?.get?.('retry-after') || '');
								if (/^\d+(\.\d+)?$/.test(ra)) retryAfterMs = Math.max(0, Math.round(Number(ra) * 1000));
							} catch { }
							const statusLabel = (effectiveStatus !== resp.status)
								? `${effectiveStatus} (proxy ${resp.status})`
								: `${resp.status}`;
							const err = new Error(`HTTP ${statusLabel}${errBody ? `: ${errBody.slice(0, 1500)}` : ''}`);
							try {
								err.__httpStatus = effectiveStatus;
								err.__rawHttpStatus = resp.status;
								err.__errorBody = errBody;
								err.__retryAfterMs = retryAfterMs;
							} catch { }
							throw err;
						}
						const data = await resp.json();
						let content = '';
						if (cfg.apiMode === 'gemini_generatecontent') {
							const parts = data?.candidates?.[0]?.content?.parts || [];
							content = parts.map(p => p?.text || '').filter(Boolean).join('') || '';
						} else if (cfg.apiMode === 'cf_ai_run' || cfg.apiMode === 'cf_responses') {
							content = __extractCfResponseText(data, cfg.apiMode);
						} else {
							content = data?.choices?.[0]?.message?.content || data?.output_text || '';
						}
							const cleaned = __benchmarkSanitizeModelText(content);
							const actualTokens = __extractActualTokens(data);
							const elapsedMs = (((typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now()) - t0).toFixed(0);
							__benchmarkRecordApiCallFinish(callRecord, {
								status: 'ok',
								response: {
									elapsed_ms: Number(elapsedMs),
									usage_tokens: Number(actualTokens || 0),
									raw_text: __benchmarkString(content),
									clean_text: __benchmarkString(cleaned),
								},
							});
							__benchmarkLog('SUCCESS', contextLabel, `Attempt ${attemptTag} OK | ${elapsedMs}ms | model=${cfg.model} | out_chars=${cleaned.length} | usage_tokens=${actualTokens || 0}`);
						if (strictJsonMode) {
							const looksJson = /^[\s]*[\{\[]/.test(cleaned || '');
							if (!looksJson) {
								__benchmarkLog('WARN', contextLabel, `Strict JSON mode returned non-JSON-looking text. Preview: ${__benchmarkPreview(cleaned)}`);
							}
						}
						return cleaned;
					} finally {
						if (timeoutId) clearTimeout(timeoutId);
					}
				} catch (e) {
					if (__benchmarkIsTaskStopError(e, kind)) {
						__benchmarkLog('WARN', contextLabel, `${__benchmarkTaskKindLabel(kind)} stop requested; aborting API attempts.`);
						throw e;
					}
					lastErr = e;
					const elapsedMs = (((typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now()) - t0).toFixed(0);
					const reason = __benchmarkTrim(e?.message || e || 'Unknown error');
					const httpStatus = Number.isFinite(e?.__httpStatus) ? Number(e.__httpStatus) : 0;
					const isAuthError =
						httpStatus === 401 ||
						httpStatus === 403 ||
						/(invalid[_\s-]*api[_\s-]*key|authentication_error|unauthorized|forbidden)/i.test(reason || '');
						__benchmarkRecordApiCallFinish(callRecord, {
							status: 'error',
							error: {
								message: reason,
								http_status: httpStatus || null,
								body: __benchmarkString(e?.__errorBody || ''),
							},
							response: {
								elapsed_ms: Number(elapsedMs),
							},
						});
						__benchmarkLog('ERROR', contextLabel, `Attempt ${attemptTag} failed after ${elapsedMs}ms | ${reason}`);
						if (e?.__benchmarkNoRetry) {
							__benchmarkLog('ERROR', contextLabel, 'Not retrying this request (fatal wait/guard).');
							throw e;
						}
						if (isAuthError) {
							__benchmarkLog('ERROR', contextLabel, 'Authentication failed (401/403). Stopping retries for this request.');
							throw e;
						}
						if (strictJsonMode && /(response_format|responsemimetype|response mime|response_schema|json schema|unsupported|invalid argument|invalid json payload|unknown name)/i.test(reason)) {
							if (geminiSchemaEnabled) {
								geminiSchemaEnabled = false;
								__benchmarkLog('WARN', contextLabel, 'Gemini structured schema rejected by endpoint/model. Retrying with JSON mime-only mode.');
							} else if (openaiSchemaEnabled) {
								openaiSchemaEnabled = false;
								__benchmarkLog('WARN', contextLabel, 'OpenAI JSON schema rejected by endpoint/model. Retrying with response_format=json_object.');
							} else if (cfg.apiMode === 'openai_chat_completions') {
								strictJsonMode = false;
								__benchmarkLog('WARN', contextLabel, 'OpenAI-compatible strict JSON mode appears unsupported. Falling back to plain text mode.');
							} else {
								strictJsonMode = false;
								__benchmarkLog('WARN', contextLabel, 'Strict JSON response mode appears unsupported by endpoint/model. Falling back to plain text mode.');
							}
						}
						if (infiniteRetries || attempt < totalAttempts) {
							const retryAfterMs = Number.isFinite(e?.__retryAfterMs) ? Math.max(0, Number(e.__retryAfterMs)) : 0;
							let waitMs = Math.min(60000, retryBaseMs * Math.max(1, Math.min(attempt, 20)));
							if (httpStatus === 429) {
								waitMs = Math.max(waitMs, retryAfterMs || 12000);
							}
							__benchmarkLog('INFO', contextLabel, `Retry in ${waitMs}ms`);
							await __benchmarkSleepInterruptible(kind, waitMs);
						}
					} finally {
						try { releaseRateSlot?.(); } catch { }
					}
				}
				throw (lastErr || new Error(`${contextLabel} failed`));
			}

			async function __benchmarkConvertWithLlm(rawText, sourceName = 'source', contextLabel = 'Convert', options = {}) {
					const txt = __benchmarkTrim(rawText);
					if (!txt) return null;
					const probeText = __benchmarkBuildHeadTailTextWindow(txt, 120000);
					const clipped = __benchmarkBuildHeadTailTextWindow(txt, 200000);
				const clippedTokens = __benchmarkEstimateTokens(clipped);
					const presetQidHints = __benchmarkUniqueTextList(options?.qidHints || []);
					const coverage = await __benchmarkProbeCoverageWithApi(probeText, sourceName, `${contextLabel}-CoverageProbe`);
					const expectedCount = Math.max(0, __benchmarkClampInt(coverage?.estimated_problem_count, { min: 0, max: 5000, fallback: 0 }));
					let qidHints = __benchmarkUniqueTextList([
						...presetQidHints,
						...__benchmarkToArray(coverage?.qid_candidates),
					]);
					if (!qidHints.length && expectedCount <= 0) {
						const local = __benchmarkExtractQidHintsFromSourceText(txt, { maxQids: 800 });
						if (local.length) qidHints = __benchmarkUniqueTextList([...presetQidHints, ...local]);
					}
						const targetQids = qidHints
							.filter(q => !__benchmarkIsGenericQid(q))
							.filter(q => __benchmarkTextContainsQid(txt, q));
				__benchmarkLog('INFO', contextLabel, `Coverage probe result: expected=${expectedCount}, qid_hints=[${qidHints.join(', ') || '(none)'}]`);
				if (expectedCount > 0 || qidHints.length) {
					__benchmarkLog('INFO', contextLabel, `Coverage hint: expected_problems=${expectedCount || 'unknown'} | qid_hints=${qidHints.length}`);
				}

			const toKey = (v) => __benchmarkTrim(v).toLowerCase();
			const empty = {
				version: __BENCHMARK_SCHEMA_VERSION,
				name: sourceName,
				description: '',
				problems: [],
			};
				let normalized = __benchmarkNormalizeDataset(empty, sourceName) || __benchmarkBuildEmptyDataset(sourceName);

					const computeMissingTargetQids = () => {
						if (!targetQids.length) return [];
						const extracted = new Set(
						(normalized?.problems || [])
							.map(p => ({
								qid: __benchmarkTrim(p?.qid || ''),
								question: __benchmarkTrim(p?.question_text || ''),
							}))
							.filter(rec => !!rec.qid && !!rec.question)
							.map(rec => toKey(rec.qid))
						);
						return targetQids.filter(q => !extracted.has(toKey(q)));
					};

				// Prefer a qid-driven extraction pass when we have reliable qid hints.
				// This avoids giant monolithic JSON outputs (easy to truncate/escape-break) and aligns with
				// "qid list -> extract per-qid -> retry missing" workflow.
				const preferQidExtract =
					targetQids.length > 0 &&
					options?.preferQidExtract !== false &&
					(expectedCount <= 0 || targetQids.length >= expectedCount);
				if (preferQidExtract) {
					normalized = await __benchmarkTargetedQidRecoveryWithApi(
						txt,
						sourceName,
						`${contextLabel}-QidExtract`,
						normalized,
						targetQids,
						{
							batchSize: __benchmarkClampInt(options?.qidBatchSize, { min: 1, max: 30, fallback: Math.min(6, Math.max(2, targetQids.length)) }),
							maxPasses: __benchmarkClampInt(options?.qidMaxPasses, { min: 1, max: 20, fallback: 4 }),
							maxTokens: __benchmarkClampInt(options?.qidMaxTokens, { min: 800, max: 30000, fallback: 16000 }),
							allQids: qidHints,
						}
					) || normalized;
				}

				const bootstrapCompleteByQid = targetQids.length > 0 && computeMissingTargetQids().length === 0;
				const bootstrapCompleteByCount = expectedCount > 0 && (normalized?.problems?.length || 0) >= expectedCount;
				const shouldRunFullConvert = !preferQidExtract && (targetQids.length > 0
					? (!bootstrapCompleteByQid && !bootstrapCompleteByCount)
					: !bootstrapCompleteByCount);
				if (shouldRunFullConvert) {
					const missingTargetQids = computeMissingTargetQids();
					const convertSource = clipped;
					const qidConstraint = (targetQids.length > 0 && missingTargetQids.length > 0)
						? `\n- Extract ONLY these qids: ${missingTargetQids.join(', ')}.\n- If a listed qid is not found, skip it (do not invent).`
						: '\n- Extract ALL distinct problems in the source. Do not stop early.';

				const sys = 'You convert raw exam/problem text into benchmark JSON. Return valid JSON only.';
				const user = `Convert the text into this JSON shape:
{
  "version": "${__BENCHMARK_SCHEMA_VERSION}",
  "name": "string",
  "description": "string",
  "problems": [
    {
      "qid": "string",
      "question_text": "string",
      "answer_choices": "string",
      "official_answer": "string",
      "official_explanation": "string",
      "grading_mode": "answer_only | answer_and_solution",
      "grading_rubric": "string",
      "solution_keywords": ["string"],
      "solution_regex": "string"
    }
  ]
}

	Rules:${qidConstraint}
	- Keep each problem self-contained.
	- If answer/explanation/rubric is not available, use empty string.
	- Prefer verbatim copying for question_text, answer_choices, and official_explanation; do not paraphrase or "correct" formatting.
	- official_answer: copy the explicit final answer exactly as it appears in the source (answer key or conclusion sentence). Do not leave blank if explicit.
	- If the final answer is truly not present, set official_answer to "".
	- official_explanation: copy the official explanation/solution verbatim when present. If too long, include a verbatim excerpt that still contains the final answer sentence (<= ~6000 chars).
	- Use [] for missing keyword lists.
	- Set grading_mode to:
	  - "answer_and_solution" if solution quality should be graded.
	  - "answer_only" otherwise.
- Do not invent answers.
- Preserve original problem labels exactly in qid when present. Do not renumber.
- Return JSON only.

Source name: ${sourceName}
Raw text:
${convertSource}`;
				let resp = '';
				try {
					resp = await __benchmarkCallApi('parse', [
						{ role: 'system', content: sys },
						{ role: 'user', content: user },
					], {
						temperature: 0,
						max_tokens: 12000,
						contextLabel: `${contextLabel}-FullConvert`,
						maxRetries: -1,
						expectJson: true,
						jsonSchema: __benchmarkGetDatasetJsonSchema(),
					});
				} catch (e) {
					__benchmarkLog('ERROR', contextLabel, `Conversion API call failed: ${e?.message || e}`);
					if (!normalized?.problems?.length) return null;
					resp = '';
				}
				if (__benchmarkTrim(resp)) {
					const fullConverted = await __benchmarkNormalizeDatasetFromModelOutput(resp, sourceName, `${contextLabel}-FullConvert`, 2);
					if (!fullConverted?.problems?.length) {
						__benchmarkLog('ERROR', contextLabel, 'Failed to normalize conversion response into benchmark JSON.');
						if (!normalized?.problems?.length) return null;
					} else {
						normalized = __benchmarkNormalizeDataset({
							version: __BENCHMARK_SCHEMA_VERSION,
							name: sourceName,
							description: '',
							problems: __benchmarkMergeProblemLists(normalized?.problems || [], fullConverted.problems || []),
						}, sourceName) || normalized;
					}
				}
			}

			const needCoverageFix = () => {
				if (targetQids.length > 0) return false;
				if (!normalized?.problems?.length) return false;
				const countWeak = expectedCount > 0 && normalized.problems.length < expectedCount;
				const hintWeak =
					qidHints.length > 0 &&
					normalized.problems.every(p => __benchmarkIsGenericQid(__benchmarkTrim(p?.qid || '')));
				const lowRecallWeak = normalized.problems.length <= 1 && clippedTokens >= 3000;
				const sparseRecallWeak = expectedCount === 0 && normalized.problems.length <= 2 && clippedTokens >= 7000;
				return countWeak || hintWeak || lowRecallWeak || sparseRecallWeak;
			};

			if (needCoverageFix()) {
				let noImproveRounds = 0;
				const maxFixRounds = 6;
				for (let r = 1; r <= maxFixRounds; r++) {
					if (!needCoverageFix()) break;
					const beforeCount = normalized.problems.length;
					const beforeNonGeneric = normalized.problems.filter(p => !__benchmarkIsGenericQid(__benchmarkTrim(p?.qid || ''))).length;
					__benchmarkLog('INFO', contextLabel, `Coverage fix round ${r}/${maxFixRounds}: current_problems=${beforeCount}, expected=${expectedCount || 'unknown'}`);

					const fixSys = 'You complete benchmark extraction by adding missing problems. Output valid JSON only.';
					const fixUser = `You are given source text and an already extracted benchmark dataset.
Extract ONLY missing problems not already included. Keep qid labels exactly as in source.

Return JSON ONLY with this shape:
{
  "problems": [ ... same problem object schema ... ]
}

Rules:
- Do NOT repeat existing problems.
- Prefer missing qid labels from this hint list: ${qidHints.length ? qidHints.join(', ') : '(none)'}
- official_answer must be taken only from explicit final-answer text in source; if not explicit, set to "".
- If nothing is missing, return {"problems":[]}.

Existing extracted dataset:
${JSON.stringify({ problems: normalized.problems })}

Source text:
${clipped}`;
					let addResp = '';
					try {
						addResp = await __benchmarkCallApi('parse', [
							{ role: 'system', content: fixSys },
							{ role: 'user', content: fixUser },
						], {
							temperature: 0,
							max_tokens: 12000,
							contextLabel: `${contextLabel}-CoverageFix-${r}`,
							maxRetries: -1,
							expectJson: true,
							jsonSchema: __benchmarkGetMissingProblemsSchema(),
						});
					} catch (e) {
						__benchmarkLog('WARN', contextLabel, `Coverage fix round ${r} failed: ${e?.message || e}`);
						continue;
					}

					const addDs = await __benchmarkNormalizeDatasetFromModelOutput(
						addResp,
						sourceName,
						`${contextLabel}-CoverageFix-${r}-Normalize`,
						0
					);
					const mergedProblems = __benchmarkMergeProblemLists(
						normalized.problems,
						addDs?.problems || []
					);
					normalized = __benchmarkNormalizeDataset({
						version: __BENCHMARK_SCHEMA_VERSION,
						name: sourceName,
						description: '',
						problems: mergedProblems,
					}, sourceName) || normalized;

					const afterCount = normalized.problems.length;
					const afterNonGeneric = normalized.problems.filter(p => !__benchmarkIsGenericQid(__benchmarkTrim(p?.qid || ''))).length;
					const improved = (afterCount > beforeCount) || (afterNonGeneric > beforeNonGeneric);
					__benchmarkLog('INFO', contextLabel, `Coverage fix round ${r} result: problems ${beforeCount} -> ${afterCount}, non_generic_qid ${beforeNonGeneric} -> ${afterNonGeneric}`);
					if (!improved) noImproveRounds += 1;
					else noImproveRounds = 0;
					if (noImproveRounds >= 1) {
						__benchmarkLog('WARN', contextLabel, 'Coverage fix stopped: no improvement in this round.');
						break;
					}
				}
			}

				if (targetQids.length > 0) {
					const unresolved = computeMissingTargetQids();
					if (unresolved.length) {
						__benchmarkLog('WARN', contextLabel, `Unresolved target qids after convert: ${unresolved.join(', ')}`);
						normalized = await __benchmarkTargetedQidRecoveryWithApi(
							txt,
							sourceName,
							`${contextLabel}-MissingQids`,
							normalized,
							unresolved,
						{
							batchSize: __benchmarkClampInt(options?.qidBatchSize, { min: 1, max: 30, fallback: Math.min(12, Math.max(4, unresolved.length)) }),
							maxPasses: __benchmarkClampInt(options?.qidMaxPasses, { min: 1, max: 20, fallback: 4 }),
							maxTokens: __benchmarkClampInt(options?.qidMaxTokens, { min: 800, max: 30000, fallback: 12000 }),
							allQids: qidHints,
						}
					) || normalized;
				}
			}

			const allGenericQids = normalized.problems.length > 0 &&
				normalized.problems.every(p => __benchmarkIsGenericQid(__benchmarkTrim(p?.qid || '')));
			if (allGenericQids) {
				__benchmarkLog('WARN', contextLabel, 'All qids are generic after extraction. Running qid recovery.');
				if (qidHints.length === normalized.problems.length && qidHints.some(q => !__benchmarkIsGenericQid(q))) {
					const used = new Set();
					normalized.problems = normalized.problems.map((p, idx) => {
						const fallback = __benchmarkTrim(p?.qid || '');
						let qid = __benchmarkTrim(qidHints[idx] || '') || fallback;
						if (!qid) qid = __benchmarkSafeQid('', idx);
						let finalQid = qid;
						let k = 2;
						while (used.has(finalQid)) {
							finalQid = `${qid}#${k}`;
							k += 1;
						}
						used.add(finalQid);
						return { ...(p || {}), qid: finalQid };
					});
					__benchmarkLog('INFO', contextLabel, 'QID recovery applied from coverage hints.');
				} else {
					normalized.problems = await __benchmarkRepairGenericQidsWithApi(
						normalized.problems,
						clipped,
						sourceName,
						`${contextLabel}-QidRepair`
					);
				}
			}

			return normalized;
		}

		function __benchmarkMergeDatasetsLocally(datasets, sourceName = 'Merged') {
			const list = (Array.isArray(datasets) ? datasets : []).filter(Boolean);
			if (!list.length) return null;
			let mergedProblems = [];
			for (const ds of list) {
				mergedProblems = __benchmarkMergeProblemLists(mergedProblems, __benchmarkToArray(ds?.problems));
			}
			return __benchmarkNormalizeDataset({
				version: __BENCHMARK_SCHEMA_VERSION,
				name: sourceName,
				description: '',
				problems: mergedProblems,
			}, sourceName);
		}

			async function __benchmarkMergeDatasetBatchWithLlm(datasets, sourceName = 'Merged', contextLabel = 'Merge') {
				const list = (Array.isArray(datasets) ? datasets : []).filter(Boolean);
				if (!list.length) return null;
				if (list.length === 1) return list[0];
				const localFallback = __benchmarkMergeDatasetsLocally(list, sourceName);

				const payload = {
					version: __BENCHMARK_SCHEMA_VERSION,
					name: sourceName,
					description: 'Partial benchmark datasets to merge',
				datasets: list,
			};

			const sys = 'You merge partial benchmark JSON datasets into one clean benchmark JSON. Return JSON only.';
			const user = `Merge these partial benchmark datasets into one dataset.

Target schema:
{
  "version": "${__BENCHMARK_SCHEMA_VERSION}",
  "name": "string",
  "description": "string",
  "problems": [
    {
      "qid": "string",
      "question_text": "string",
      "answer_choices": "string",
      "official_answer": "string",
      "official_explanation": "string",
      "grading_mode": "answer_only | answer_and_solution",
      "grading_rubric": "string",
      "solution_keywords": ["string"],
      "solution_regex": "string",
      "source": "string"
    }
  ]
}

Rules:
- Keep all valid problems.
- Remove exact duplicates.
- Preserve answer/explanation/rubric fields.
- official_answer must be taken only from explicit final-answer text already present in inputs.
- Never infer official_answer from explanation/proof text during merge.
- Do not hallucinate new problems.
- Return JSON only.

Input datasets:
${JSON.stringify(payload)}`;

			let resp = '';
				try {
					resp = await __benchmarkCallApi('parse', [
						{ role: 'system', content: sys },
						{ role: 'user', content: user },
					], { temperature: 0, max_tokens: 12000, contextLabel, maxRetries: -1, expectJson: true, jsonSchema: __benchmarkGetDatasetJsonSchema() });
				} catch (e) {
					__benchmarkLog('ERROR', contextLabel, `Merge API call failed: ${e?.message || e}`);
					const fallback = __benchmarkMergeDatasetsLocally(list, sourceName);
					if (fallback?.problems?.length) {
						__benchmarkLog('WARN', contextLabel, `Merge fallback applied: local merge used (${fallback.problems.length} problems).`);
						return fallback;
					}
					return null;
				}
					const normalized = await __benchmarkNormalizeDatasetFromModelOutput(resp, sourceName, contextLabel, 2);
					if (!normalized?.problems?.length) {
						__benchmarkLog('ERROR', contextLabel, 'Failed to normalize merge response into benchmark JSON.');
						const fallback = __benchmarkMergeDatasetsLocally(list, sourceName);
					if (fallback?.problems?.length) {
						__benchmarkLog('WARN', contextLabel, `Merge fallback applied after normalization failure (${fallback.problems.length} problems).`);
						return fallback;
						}
						return null;
					}
				// If the LLM merge truncated/omitted problems, patch coverage using a deterministic local merge.
				try {
					const expected = Array.isArray(localFallback?.problems) ? localFallback.problems : [];
					const expectedCount = expected.length;
					const got = Array.isArray(normalized?.problems) ? normalized.problems : [];
					const expectedQids = new Set(expected.map(p => __benchmarkTrim(p?.qid || '')).filter(Boolean));
					const gotQids = new Set(got.map(p => __benchmarkTrim(p?.qid || '')).filter(Boolean));
					const missingQids = expectedQids.size
						? Array.from(expectedQids).filter(q => !gotQids.has(q))
						: [];
					const looksIncomplete =
						(expectedCount > 0 && got.length < expectedCount) ||
						(missingQids.length > 0);
					if (looksIncomplete && expectedCount > 0) {
						__benchmarkLog(
							'WARN',
							contextLabel,
							`LLM merge incomplete: got=${got.length}, expected‚âà${expectedCount}${missingQids.length ? `, missing_qids=${missingQids.slice(0, 12).join(', ')}${missingQids.length > 12 ? '‚Ä¶' : ''}` : ''}. Patching with local merge.`
						);
						const patchedProblems = __benchmarkMergeProblemLists(expected, got);
						const patched = __benchmarkNormalizeDataset({
							version: __BENCHMARK_SCHEMA_VERSION,
							name: normalized.name || sourceName,
							description: normalized.description || '',
							problems: patchedProblems,
						}, sourceName);
						__benchmarkLog('SUCCESS', contextLabel, `Merge patched: ${got.length} -> ${patchedProblems.length} problems.`);
						return patched;
					}
				} catch { }
				return normalized;
			}

			function __benchmarkGetAnswerRegroundSchema() {
				return {
					type: 'object',
					properties: {
						answers: {
							type: 'array',
							items: {
								type: 'object',
								properties: {
									qid: { type: 'string' },
									official_answer: { type: 'string' },
									evidence_quote: { type: 'string' }
								},
								required: ['qid', 'official_answer', 'evidence_quote'],
								additionalProperties: false
							}
						}
					},
					required: ['answers'],
					additionalProperties: false
				};
			}

				function __benchmarkGetAnswerFillSchema() {
					return {
						type: 'object',
						properties: {
							answers: {
								type: 'array',
								items: {
									type: 'object',
									properties: {
										qid: { type: 'string' },
										official_answer: { type: 'string' },
										evidence_quote: { type: 'string' },
									},
									required: ['qid', 'official_answer', 'evidence_quote'],
									additionalProperties: false
								}
							}
						},
						required: ['answers'],
					additionalProperties: false
				};
			}

				function __benchmarkNormalizeLooseMathText(v) {
					return __benchmarkString(v || '')
						.toLowerCase()
						.replace(/\\boxed\s*\{([^}]*)\}/g, '$1')
						.replace(/\\text\s*\{([^}]*)\}/g, '$1')
					.replace(/\\left|\\right/g, '')
					.replace(/[\s"'`‚Äú‚Äù‚Äò‚Äô$]/g, '')
					.replace(/[,:;.!?()[\]{}]/g, '')
					.trim();
			}

			function __benchmarkIsProofStyleQuestionText(text) {
				const t = __benchmarkTrim(text || '');
				if (!t) return false;
				const low = t.toLowerCase();
				// "Let ... Prove that ..." style (Putnam/IMO), also catches "Show that ...".
				if (/\b(prove|show)\s+that\b/.test(low)) return true;
				if (/\bprove\s+or\s+disprove\b/.test(low)) return true;
				// Korean cues (rare but cheap to support).
				if (/(Ï¶ùÎ™ÖÌïòÎùº|Ï¶ùÎ™ÖÌïòÏó¨Îùº|Ï¶ùÎ™ÖÌïòÏãúÏò§|Î≥¥Ïó¨Îùº|Î≥¥Ïù¥ÏãúÏò§|Ï¶ùÎ™ÖÌïò[^\s]*|Î≥¥Ïù¥[^\s]*)/.test(t)) return true;
				return false;
			}

			function __benchmarkQuoteSupportsOfficialAnswer(answerText, evidenceQuote) {
				const ans = __benchmarkTrim(answerText || '');
				const quote = __benchmarkTrim(evidenceQuote || '');
				if (!ans) return true;
				if (!quote) return false;
			const nQuote = __benchmarkNormalizeLooseMathText(quote);
			if (!nQuote) return false;

			const candidates = __benchmarkUniqueTextList(
				ans.split('||')
					.map((x) => __benchmarkTrim(x))
					.filter(Boolean)
			);
			if (!candidates.length) return false;

			for (const cand of candidates) {
				const nCand = __benchmarkNormalizeLooseMathText(cand);
				if (nCand && nQuote.includes(nCand)) return true;
			}
			return false;
		}

				async function __benchmarkRegroundOfficialAnswersWithApi(dataset, rawText, sourceName = 'API-Converted', contextLabel = 'ConvertReground', options = {}) {
				const ds = __benchmarkNormalizeDataset(dataset || { problems: [] }, sourceName);
				if (!ds?.problems?.length) return ds;
				const src = __benchmarkTrim(rawText || '');
				if (!src) return ds;

				const allQids = __benchmarkUniqueTextList(ds.problems.map(p => __benchmarkTrim(p?.qid || '')).filter(Boolean));
				const targetQids = allQids.filter(q => !__benchmarkIsGenericQid(q));
				if (!targetQids.length) {
					__benchmarkLog('WARN', contextLabel, 'Answer reground skipped: no non-generic qids available.');
					return ds;
				}

				const batchSize = __benchmarkClampInt(options?.batchSize, { min: 1, max: 12, fallback: 12 });
				const maxPasses = __benchmarkClampInt(options?.maxPasses, { min: 1, max: 10, fallback: 4 });
				const maxTokens = __benchmarkClampInt(options?.maxTokens, { min: 300, max: 30000, fallback: 6000 });
				const maxSourceChars = __benchmarkClampInt(options?.maxSourceChars, { min: 40000, max: 400000, fallback: 200000 });
				const found = new Map(); // qid -> official_answer (non-empty, evidence-verified)
				const proofQids = new Set(
					ds.problems
						.map((p) => ({
							qid: __benchmarkTrim(p?.qid || ''),
							isProof: __benchmarkIsProofStyleQuestionText(p?.question_text || ''),
						}))
						.filter((x) => x.qid && x.isProof)
						.map((x) => x.qid)
				);
				let unresolved = targetQids.slice();
				for (let pass = 1; pass <= maxPasses && unresolved.length; pass += 1) {
						for (let i = 0; i < unresolved.length; i += batchSize) {
							const batch = unresolved.slice(i, i + batchSize);
							// For answer re-grounding, prefer giving full context when feasible so answer keys/appendices
							// aren't accidentally dropped by a focused window heuristic.
								const focusedSource = (src.length <= maxSourceChars)
									? src
									: __benchmarkBuildHeadTailTextWindow(src, maxSourceChars);
								if (!__benchmarkTrim(focusedSource)) {
									__benchmarkLog('WARN', contextLabel, `Answer reground batch skipped: empty source window [${batch.join(', ')}].`);
									continue;
								}

						const sys = 'Extract explicit final answers only. Return valid JSON only.';
					const user = `Extract ONLY explicit official final answers for these qids:
${batch.join(', ')}

Return JSON only:
{
  "answers": [
    { "qid": "<qid>", "official_answer": "string", "evidence_quote": "exact snippet from source" }
  ]
}

	Rules:
	- Include only target qids.
	- Keep qid exactly as in source.
	- official_answer must come from an explicit conclusion in the source for that qid (problem text, answer key, or the final conclusion sentence of the official solution).
	- If the problem is a proof/derivation task with no concise final answer (e.g., "show that", "prove that"), set official_answer to "" (do not restate the claim as the answer).
	- Do not derive new results by doing extra math; if the final answer is not explicitly stated, set official_answer to "".
	- Do not rewrite/simplify math notation; copy the answer expression verbatim as it appears in source.
- If multiple explicit final answers are present, join with " || ".
- evidence_quote must be a short exact substring copied from source that directly contains the final-answer expression.
- If official_answer is "", set evidence_quote to "".
- If official_answer is non-empty, it must appear as a substring of evidence_quote.
- Do not output any extra fields.

Source name: ${sourceName}
Source text:
${focusedSource}`;

					let resp = '';
					try {
							resp = await __benchmarkCallApi('parse', [
								{ role: 'system', content: sys },
								{ role: 'user', content: user },
							], {
								temperature: 0,
								max_tokens: maxTokens,
								contextLabel: `${contextLabel}-P${pass}-B${Math.floor(i / batchSize) + 1}/${Math.ceil(unresolved.length / batchSize)}`,
								maxRetries: -1,
								expectJson: true,
								jsonSchema: __benchmarkGetAnswerRegroundSchema(),
							});
					} catch (e) {
						__benchmarkLog('WARN', contextLabel, `Answer reground batch failed: ${e?.message || e}`);
						continue;
						}

							const obj = __benchmarkTryParseJson(resp) || {};
							const normalizedSource = __benchmarkString(focusedSource).replace(/\s+/g, ' ').toLowerCase();
							const looseSource = __benchmarkNormalizeLooseMathText(focusedSource);
							for (const item of __benchmarkToArray(obj?.answers)) {
								const qid = __benchmarkTrim(item?.qid || '');
								if (!qid || !batch.includes(qid)) continue;
								if (proofQids.has(qid)) continue;
								const hasAnswerField = (item && typeof item === 'object' && Object.prototype.hasOwnProperty.call(item, 'official_answer'));
								if (!hasAnswerField) continue;
								const ans = __benchmarkTrim(item?.official_answer || '');
								const quote = __benchmarkTrim(item?.evidence_quote || '');
								if (!ans) continue; // keep unresolved; retry on later passes if needed
								const quoteContainsAnswer = __benchmarkQuoteSupportsOfficialAnswer(ans, quote);
								if (!quoteContainsAnswer) {
									__benchmarkLog('WARN', contextLabel, `Answer reground evidence rejected for ${qid}: quote does not contain official_answer text.`);
									continue;
								}
								const normalizedQuote = __benchmarkString(quote).replace(/\s+/g, ' ').toLowerCase();
								const quoteOk = normalizedQuote && normalizedSource.includes(normalizedQuote);
								const nAns = __benchmarkNormalizeLooseMathText(ans);
								const ansFoundInSource = nAns && looseSource && looseSource.includes(nAns);
								if (!quoteOk && !ansFoundInSource) {
									// Avoid noisy "not found" loops: only accept answers we can verify by either quote match or answer match.
									__benchmarkLog('WARN', contextLabel, `Answer reground evidence rejected for ${qid}: unverifiable.`);
									continue;
								}
								found.set(qid, ans);
							}
						}
					unresolved = unresolved.filter(qid => !found.has(qid));
				}

				if (!found.size) {
					__benchmarkLog('WARN', contextLabel, `Answer reground finished with 0 accepted answers (qids=${targetQids.length}).`);
					return ds;
				}

				let changed = 0;
				const patchedProblems = ds.problems.map((p) => {
					const qid = __benchmarkTrim(p?.qid || '');
					if (!qid || !targetQids.includes(qid)) return { ...(p || {}) };
					const curAnswer = __benchmarkTrim(p?.official_answer || '');
					const nextAnswer = found.has(qid) ? __benchmarkTrim(found.get(qid) || '') : curAnswer;
					if (nextAnswer !== curAnswer) changed += 1;
					return {
						...(p || {}),
						official_answer: nextAnswer,
					};
				});

			const normalized = __benchmarkNormalizeDataset({
				version: __BENCHMARK_SCHEMA_VERSION,
				name: ds.name || sourceName,
				description: ds.description || '',
				problems: patchedProblems,
			}, sourceName) || ds;
				__benchmarkLog('SUCCESS', contextLabel, `Answer reground complete: found=${found.size}/${targetQids.length}, changed=${changed}, unresolved=${unresolved.length}.`);
				return normalized;
			}

				async function __benchmarkFillMissingOfficialAnswersFromExplanationWithApi(dataset, contextLabel = 'AnswerFill', options = {}) {
					const ds = __benchmarkNormalizeDataset(dataset || { problems: [] }, dataset?.name || 'Benchmark');
					if (!ds?.problems?.length) return ds;

					const needs = ds.problems
						.map((p) => ({
							qid: __benchmarkTrim(p?.qid || ''),
							question_text: __benchmarkTrim(p?.question_text || ''),
							official_explanation: __benchmarkTrim(p?.official_explanation || ''),
							official_answer: __benchmarkTrim(p?.official_answer || ''),
						}))
						.filter((p) => p.qid && !__benchmarkIsGenericQid(p.qid) && !p.official_answer && p.official_explanation && !__benchmarkIsProofStyleQuestionText(p.question_text));
				if (!needs.length) return ds;

				const batchSize = __benchmarkClampInt(options?.batchSize, { min: 1, max: 12, fallback: 6 });
				const maxPasses = __benchmarkClampInt(options?.maxPasses, { min: 1, max: 6, fallback: 2 });
					const maxTokens = __benchmarkClampInt(options?.maxTokens, { min: 300, max: 12000, fallback: 1600 });

					const filled = new Map(); // qid -> official_answer (non-empty)
					let unresolved = needs.map(x => x.qid);
					for (let pass = 1; pass <= maxPasses && unresolved.length; pass += 1) {
					for (let i = 0; i < unresolved.length; i += batchSize) {
						const batchQids = unresolved.slice(i, i + batchSize);
							const batch = needs
								.filter((p) => batchQids.includes(p.qid))
								.map((p) => ({
									qid: p.qid,
									question_text: p.question_text,
									official_explanation: p.official_explanation,
								}));
							if (!batch.length) continue;

						const sys = 'Extract explicit final answers only. Return valid JSON only.';
						const user = `Fill missing official_answer values using ONLY the provided question and official_explanation for each qid.

Return JSON only:
{
  "answers": [
    { "qid": "<qid>", "official_answer": "<explicit final answer or empty>", "evidence_quote": "<exact substring from official_explanation that contains the answer>" }
  ]
}

Rules:
- Do NOT do new math or inference. official_answer must be copied verbatim from the provided official_explanation (or be empty).
- If the problem is a proof/derivation task with no concise final answer (e.g., "show that", "prove that") then set official_answer="".
- Keep official_answer concise (prefer <= 120 chars).
- If official_answer is "", set evidence_quote to "".
- If official_answer is non-empty, evidence_quote must be an exact substring of official_explanation and must contain official_answer as a substring.
- Do not include extra fields.

Items:
${JSON.stringify({ items: batch })}`;

						let resp = '';
						try {
							resp = await __benchmarkCallApi('parse', [
								{ role: 'system', content: sys },
								{ role: 'user', content: user },
							], {
								temperature: 0,
								max_tokens: maxTokens,
								contextLabel: `${contextLabel}-P${pass}-B${Math.floor(i / batchSize) + 1}/${Math.ceil(unresolved.length / batchSize)}`,
								maxRetries: -1,
								expectJson: true,
								jsonSchema: __benchmarkGetAnswerFillSchema(),
							});
						} catch (e) {
							__benchmarkLog('WARN', contextLabel, `Answer fill batch failed: ${e?.message || e}`);
							continue;
						}

						const obj = __benchmarkTryParseJson(resp) || {};
						const batchByQid = new Map(batch.map((it) => [__benchmarkTrim(it?.qid || ''), it]));
						for (const item of __benchmarkToArray(obj?.answers)) {
							const qid = __benchmarkTrim(item?.qid || '');
							if (!qid || !batchQids.includes(qid)) continue;
							const ans = __benchmarkTrim(item?.official_answer || '');
							const quote = __benchmarkTrim(item?.evidence_quote || '');
							if (!ans) continue;
							if (ans.length > 240) continue;
							const base = batchByQid.get(qid) || {};
							const expl = __benchmarkTrim(base?.official_explanation || '');
							const normExpl = __benchmarkString(expl).replace(/\s+/g, ' ').toLowerCase();
							const normQuote = __benchmarkString(quote).replace(/\s+/g, ' ').toLowerCase();
							const evidenceOk = normQuote && normExpl.includes(normQuote);
							if (!evidenceOk) continue;
							const quoteContainsAnswer = __benchmarkQuoteSupportsOfficialAnswer(ans, quote);
							if (!quoteContainsAnswer) continue;
							filled.set(qid, ans);
						}
					}
					unresolved = unresolved.filter(qid => !filled.has(qid));
				}

				if (!filled.size) {
					__benchmarkLog('WARN', contextLabel, `Answer fill finished with 0 derived answers (missing=${needs.length}).`);
					return ds;
				}

				let changed = 0;
				const patchedProblems = ds.problems.map((p) => {
					const qid = __benchmarkTrim(p?.qid || '');
					if (!qid || !filled.has(qid)) return { ...(p || {}) };
					const cur = __benchmarkTrim(p?.official_answer || '');
					const next = __benchmarkTrim(filled.get(qid) || '');
					if (!cur && next) changed += 1;
					return { ...(p || {}), official_answer: cur || next };
				});
				const out = __benchmarkNormalizeDataset({
					version: __BENCHMARK_SCHEMA_VERSION,
					name: ds.name || 'Benchmark',
					description: ds.description || '',
					problems: patchedProblems,
				}, ds.name || 'Benchmark') || ds;
				__benchmarkLog('SUCCESS', contextLabel, `Answer fill complete: filled=${filled.size}/${needs.length}, changed=${changed}.`);
				return out;
			}

			async function __benchmarkMergeDatasetsWithLlm(datasets, mergeTokens, sourceName = 'API-Converted') {
				let cur = (Array.isArray(datasets) ? datasets : []).filter(Boolean);
				if (!cur.length) return null;
				if (cur.length === 1) return cur[0];

			let round = 1;
			while (cur.length > 1) {
				const grouped = __benchmarkChunkItemsByToken(
					cur,
					mergeTokens,
					(ds) => JSON.stringify(ds || {}),
					800
				);
				__benchmarkLog('INFO', 'ConvertMerge', `Round ${round}: ${cur.length} partial datasets -> ${grouped.length} merge batches`);
				const next = [];
				for (let i = 0; i < grouped.length; i++) {
					const batch = grouped[i];
					if (!batch?.length) continue;
					if (batch.length === 1) {
						next.push(batch[0]);
						continue;
					}
					const merged = await __benchmarkMergeDatasetBatchWithLlm(
						batch,
						sourceName,
						`ConvertMerge-R${round}-B${i + 1}/${grouped.length}`
					);
					if (!merged?.problems?.length) {
						__benchmarkLog('WARN', 'ConvertMerge', `Batch ${i + 1} merge failed; trying local fallback merge.`);
						const fallback = __benchmarkMergeDatasetsLocally(batch, sourceName);
						if (!fallback?.problems?.length) {
							__benchmarkLog('ERROR', 'ConvertMerge', `Batch ${i + 1} merge failed.`);
							return null;
						}
						next.push(fallback);
						continue;
					}
					next.push(merged);
				}
				cur = next.filter(Boolean);
				round += 1;
			}
			return cur[0] || null;
		}

		async function __benchmarkConvertSourceToDataset(options = {}) {
			if (__benchmarkStudio.isRunning) return;
			if (__benchmarkIsTaskRunning('parse')) {
				__benchmarkSetProgress('Benchmark conversion is already running');
				return;
			}
			const resumeRequested = !!(options && options.resume);
			if (!resumeRequested) __benchmarkResetApiCounters('parse');
			const pausedCheckpoint = __benchmarkGetTaskCheckpoint('parse');
			if (resumeRequested) {
				if (!pausedCheckpoint || __benchmarkTrim(pausedCheckpoint?.status || '') !== 'paused') {
					throw new Error('No paused conversion checkpoint to resume.');
				}
				if (!Array.isArray(pausedCheckpoint?.text_chunks) || !pausedCheckpoint.text_chunks.length) {
					throw new Error('Paused conversion checkpoint is missing chunk data.');
				}
			}
			const sourceFileEl = document.getElementById('benchmarkSourceFile');
			const sourceTextEl = document.getElementById('benchmarkSourceText');
			const files = Array.from(sourceFileEl?.files || []);
			const rawSourceText = __benchmarkTrim(sourceTextEl?.value || '');
			const convertDelimiter = __benchmarkTrim(document.getElementById('benchmarkConvertDelimiter')?.value || '');
			const answerKeyText = __benchmarkTrim((document.getElementById('benchmarkAnswerKeyText')?.value || '').toString());
			const answerKeyBlock = answerKeyText ? `\n\n### ANSWER KEY (global)\n${answerKeyText}` : '';

			if (!resumeRequested && !files.length && !rawSourceText) {
				alert('Provide at least one source file or paste source text.');
				return;
			}

			let convertSession = null;
			let pausedByUser = false;
			let parseCheckpointWorking = resumeRequested ? __benchmarkNormalizeParseCheckpoint(pausedCheckpoint) : null;
			__benchmarkSetButtonsDisabled(true);
			__benchmarkSetTaskRunning('parse', true);
			__benchmarkSetTaskStopRequested('parse', false);
			try {
				convertSession = __benchmarkRecordConvertSessionStart({
					mode: resumeRequested ? 'resume' : 'convert',
					source_files: files.map(f => ({
						name: __benchmarkTrim(f?.name || ''),
						size: Number(f?.size || 0),
						type: __benchmarkTrim(f?.type || ''),
					})),
					pasted_text: rawSourceText,
					chunking: __benchmarkGetChunkingConfig(),
				});
				__benchmarkSetProgress(resumeRequested ? 'Resuming benchmark conversion' : 'Preparing benchmark conversion input');
				__benchmarkLog('INFO', 'Convert', `${resumeRequested ? 'Resume' : 'Start'} conversion: files=${files.length}, pasted_text=${rawSourceText ? 'yes' : 'no'}`);
				try {
					await __benchmarkEnsureGptTokenizer();
					__benchmarkLog('SUCCESS', 'Tokenizer', 'gpt-tokenizer loaded (o200k_base).');
				} catch (e) {
					__benchmarkLog('WARN', 'Tokenizer', `Failed to load gpt-tokenizer; fallback estimate will be used. ${e?.message || e}`);
				}
				const uiChunkCfg = __benchmarkGetChunkingConfig();
				const chunkCfg = resumeRequested
					? {
						parseSplitTokens: __benchmarkClampInt(parseCheckpointWorking?.chunk_cfg?.parseSplitTokens, { min: 500, max: 200000, fallback: uiChunkCfg.parseSplitTokens }),
						parseMergeTokens: __benchmarkClampInt(parseCheckpointWorking?.chunk_cfg?.parseMergeTokens, { min: 500, max: 200000, fallback: uiChunkCfg.parseMergeTokens }),
					}
					: uiChunkCfg;
				const textChunks = [];
				let totalInputTokens = 0;
				let partialDatasets = [];
				let startChunkIndex = 0;

				if (resumeRequested) {
					textChunks.push(...(Array.isArray(parseCheckpointWorking?.text_chunks) ? parseCheckpointWorking.text_chunks : []));
					totalInputTokens = __benchmarkClampInt(parseCheckpointWorking?.total_input_tokens, {
						min: 0,
						max: 1000000000,
						fallback: textChunks.reduce((sum, c) => sum + __benchmarkEstimateTokens(__benchmarkTrim(c?.text || '')), 0),
					});
					partialDatasets = Array.isArray(parseCheckpointWorking?.partial_datasets)
						? parseCheckpointWorking.partial_datasets.slice()
						: [];
					startChunkIndex = __benchmarkClampInt(parseCheckpointWorking?.next_chunk_index, {
						min: 0,
						max: Math.max(0, textChunks.length),
						fallback: 0,
					});
					__benchmarkLog(
						'INFO',
						'Convert',
						`Resuming from checkpoint: next_chunk=${startChunkIndex + 1}/${textChunks.length}, partial_datasets=${partialDatasets.length}`
					);
				} else {
					for (const file of files) {
						const name = __benchmarkTrim(file?.name || 'source');
						const lower = name.toLowerCase();
						let text = '';
						__benchmarkLog('INFO', 'ConvertInput', `Reading file: ${name}`);

						if (lower.endsWith('.pdf') || file?.type === 'application/pdf') {
							try {
								const pages = await __benchmarkExtractTextFromPdfFile(file);
								let pushed = 0;
								for (const p of pages) {
									const pageText = __benchmarkTrim(p?.text || '');
									if (!pageText) continue;
									const delimChunks = __benchmarkSplitTextByDelimiter(pageText, convertDelimiter);
									const useChunks = delimChunks.length ? delimChunks : [pageText];
									for (let i = 0; i < useChunks.length; i++) {
										const ch = __benchmarkTrim(useChunks[i]);
										if (!ch) continue;
										const wrapped = `### FILE: ${name} | PAGE ${p.page}${useChunks.length > 1 ? ` | PART ${i + 1}/${useChunks.length}` : ''}\n${ch}${answerKeyBlock}`;
										textChunks.push({ text: wrapped, qidHints: [] });
										totalInputTokens += __benchmarkEstimateTokens(ch + (answerKeyText ? `\n\n${answerKeyText}` : ''));
										pushed += 1;
									}
								}
								__benchmarkLog('SUCCESS', 'ConvertInput', `PDF extracted: ${name} (${pages.length} pages -> ${pushed} chunks)`);
							} catch (e) {
								__benchmarkLog('ERROR', 'ConvertInput', `PDF extraction failed: ${name} | ${e?.message || e}`);
							}
							continue;
						}

						try { text = await file.text(); } catch { text = ''; }
						if (!text) continue;
						const delimChunks = __benchmarkSplitTextByDelimiter(text, convertDelimiter);
						const useChunks = delimChunks.length ? delimChunks : [text];
						for (let i = 0; i < useChunks.length; i++) {
							const ch = __benchmarkTrim(useChunks[i]);
							if (!ch) continue;
							textChunks.push({
								text: `### FILE: ${name} | CHUNK ${i + 1}/${useChunks.length}\n${ch}${answerKeyBlock}`,
								qidHints: [],
							});
							totalInputTokens += __benchmarkEstimateTokens(ch + (answerKeyText ? `\n\n${answerKeyText}` : ''));
						}
						__benchmarkLog(
							'SUCCESS',
							'ConvertInput',
							`Text loaded: ${name} (${useChunks.length} chunks, ~${__benchmarkEstimateTokens(text)} tokens, split_mode=${convertDelimiter ? 'delimiter' : 'none'}, delimiter=${convertDelimiter ? __benchmarkPreview(convertDelimiter, 24) : '(empty)'}, answer_key=${answerKeyText ? 'yes' : 'no'})`
						);
					}

					if (rawSourceText) {
						const delimChunks = __benchmarkSplitTextByDelimiter(rawSourceText, convertDelimiter);
						const useChunks = delimChunks.length ? delimChunks : [rawSourceText];
						for (let i = 0; i < useChunks.length; i++) {
							const ch = __benchmarkTrim(useChunks[i]);
							if (!ch) continue;
							textChunks.push({
								text: `### PASTED TEXT | CHUNK ${i + 1}/${useChunks.length}\n${ch}${answerKeyBlock}`,
								qidHints: [],
							});
							totalInputTokens += __benchmarkEstimateTokens(ch + (answerKeyText ? `\n\n${answerKeyText}` : ''));
						}
						__benchmarkLog(
							'INFO',
							'ConvertInput',
							`Pasted text added (${useChunks.length} chunks, ~${__benchmarkEstimateTokens(rawSourceText)} tokens, split_mode=${convertDelimiter ? 'delimiter' : 'none'}, delimiter=${convertDelimiter ? __benchmarkPreview(convertDelimiter, 24) : '(empty)'}, answer_key=${answerKeyText ? 'yes' : 'no'})`
						);
					}
				}

				if (!textChunks.length) {
					alert('No readable source text was collected from inputs.');
					__benchmarkSetDataset(null);
					__benchmarkSetProgress('Conversion failed: no readable input text');
					__benchmarkLog('ERROR', 'Convert', 'No readable input text collected.');
					if (convertSession) __benchmarkRecordConvertSessionFinish(convertSession, { status: 'failed', error: 'No readable input text collected.' });
					return;
				}
				const sourceSignature = __benchmarkBuildConvertSourceSignature(textChunks, chunkCfg);
				if (convertSession) {
					convertSession.prepared_chunks = textChunks.map((chunkItem, idx) => {
						const text = __benchmarkTrim(chunkItem?.text || '');
						return {
							index: idx + 1,
							token_estimate: __benchmarkEstimateTokens(text),
							qid_hints: __benchmarkUniqueTextList(chunkItem?.qidHints || []),
							text,
						};
					});
					convertSession.total_input_tokens = totalInputTokens;
					__benchmarkTouchArtifacts();
				}
				parseCheckpointWorking = __benchmarkNormalizeParseCheckpoint({
					status: 'running',
					created_at: parseCheckpointWorking?.created_at || Date.now(),
					updated_at: Date.now(),
					source_signature: sourceSignature,
					source_label: resumeRequested ? (parseCheckpointWorking?.source_label || 'resume') : 'input',
					chunk_cfg: chunkCfg,
					total_input_tokens: totalInputTokens,
					text_chunks: textChunks,
					next_chunk_index: startChunkIndex,
					partial_datasets: partialDatasets,
					note: resumeRequested ? 'resumed' : 'initial',
				});
				__benchmarkSetTaskCheckpoint('parse', parseCheckpointWorking);
				__benchmarkSchedulePersist(50);
				__benchmarkSetProgress(`Converting ${textChunks.length} chunks via parsing API`);
				__benchmarkLog(
					'INFO',
					'Convert',
					`Chunking complete: total ~${totalInputTokens} tokens -> ${textChunks.length} chunks (split_mode=${convertDelimiter ? 'delimiter' : 'none'}, delimiter=${convertDelimiter ? __benchmarkPreview(convertDelimiter, 24) : '(empty)'}, answer_key=${answerKeyText ? 'yes' : 'no'}, merge=${chunkCfg.parseMergeTokens})`
				);

				for (let i = startChunkIndex; i < textChunks.length; i++) {
					__benchmarkThrowIfTaskStopped('parse');
					const chunkItem = textChunks[i] || {};
					const chunkText = __benchmarkTrim(chunkItem.text || '');
					if (!chunkText) continue;
					const chunkQidHints = __benchmarkUniqueTextList(chunkItem.qidHints || []);
					const chunkTokens = await __benchmarkCountTokensAsync(chunkText);
					__benchmarkSetProgress(`Converting chunk ${i + 1}/${textChunks.length}`);
					const ds = await __benchmarkConvertWithLlm(
						chunkText,
						`API-Converted chunk ${i + 1}`,
						`ConvertChunk-${i + 1}/${textChunks.length}`,
						{ qidHints: chunkQidHints }
					);
					if (!ds?.problems?.length) {
						__benchmarkLog('ERROR', 'Convert', `Chunk ${i + 1}/${textChunks.length} failed (~${chunkTokens} tokens).`);
						if (convertSession) {
							convertSession.chunk_results.push({
								index: i + 1,
								token_estimate: chunkTokens,
								qid_hints: chunkQidHints,
								status: 'failed',
								problems: 0,
								output_dataset: null,
							});
							__benchmarkTouchArtifacts();
						}
						continue;
					}
					partialDatasets.push(ds);
					parseCheckpointWorking = __benchmarkNormalizeParseCheckpoint({
						...(parseCheckpointWorking || {}),
						status: 'running',
						updated_at: Date.now(),
						source_signature: sourceSignature,
						chunk_cfg: chunkCfg,
						total_input_tokens: totalInputTokens,
						text_chunks: textChunks,
						next_chunk_index: i + 1,
						partial_datasets: partialDatasets,
						note: `converted chunk ${i + 1}/${textChunks.length}`,
					});
					__benchmarkSetTaskCheckpoint('parse', parseCheckpointWorking);
					__benchmarkSchedulePersist(50);
					if (convertSession) {
						convertSession.chunk_results.push({
							index: i + 1,
							token_estimate: chunkTokens,
							qid_hints: chunkQidHints,
							status: 'ok',
							problems: Number(ds?.problems?.length || 0),
							output_dataset: __benchmarkSafeClone(ds),
						});
						__benchmarkTouchArtifacts();
					}
					__benchmarkLog('SUCCESS', 'Convert', `Chunk ${i + 1}/${textChunks.length} converted: ${ds.problems.length} problems (~${chunkTokens} tokens).`);
				}

				if (!partialDatasets.length) {
					alert('API conversion failed or returned no valid problems.');
					__benchmarkSetDataset(null);
					__benchmarkSetProgress('Conversion failed: all chunks failed');
					__benchmarkLog('ERROR', 'Convert', 'All conversion chunks failed.');
					if (convertSession) {
						convertSession.partial_datasets = [];
						__benchmarkRecordConvertSessionFinish(convertSession, { status: 'failed', error: 'All conversion chunks failed.' });
					}
					return;
				}
				if (convertSession) {
					convertSession.partial_datasets = __benchmarkSafeClone(partialDatasets);
					__benchmarkTouchArtifacts();
				}

					let llmDs = null;
					if (partialDatasets.length === 1) {
						llmDs = partialDatasets[0];
						__benchmarkLog('INFO', 'ConvertMerge', 'Single partial dataset: merge step skipped.');
					} else {
						__benchmarkSetProgress(`Merging ${partialDatasets.length} partial datasets locally`);
						llmDs = __benchmarkMergeDatasetsLocally(partialDatasets, 'API-Converted');
						__benchmarkLog('INFO', 'ConvertMerge', `Local merge applied: ${partialDatasets.length} datasets -> ${Number(llmDs?.problems?.length || 0)} problems.`);
					}
				if (!llmDs?.problems?.length) {
					alert('API merge failed after chunk conversion.');
					__benchmarkSetDataset(null);
					__benchmarkSetProgress('Conversion failed: merge step failed');
					__benchmarkLog('ERROR', 'ConvertMerge', 'Dataset merge failed.');
					if (convertSession) __benchmarkRecordConvertSessionFinish(convertSession, { status: 'failed', error: 'Dataset merge failed.' });
					return;
				}

				// Final grounding pass: re-extract explicit official answers from full source text.
				// This reduces answer contamination introduced during parse/merge stages.
				const fullSourceText = textChunks
					.map((c) => __benchmarkTrim(c?.text || ''))
					.filter(Boolean)
					.join('\n\n');
					if (__benchmarkTrim(fullSourceText)) {
						__benchmarkSetProgress('Re-grounding official answers from source text');
						llmDs = await __benchmarkRegroundOfficialAnswersWithApi(
							llmDs,
							fullSourceText,
							'API-Converted',
							'ConvertReground',
							{ batchSize: 12, maxPasses: 4, maxTokens: 6000 }
						) || llmDs;
					}
					{
						// Optional fallback: if official answers are still empty but we have official_explanation,
						// derive concise canonical answers from the official explanation text.
						const stillMissing = __benchmarkToArray(llmDs?.problems || []).filter((p) => {
							const qid = __benchmarkTrim(p?.qid || '');
							if (!qid || __benchmarkIsGenericQid(qid)) return false;
							const hasAns = !!__benchmarkTrim(p?.official_answer || '');
							const hasExpl = !!__benchmarkTrim(p?.official_explanation || '');
							return !hasAns && hasExpl;
						}).length;
						if (stillMissing > 0) {
							__benchmarkSetProgress('Filling missing official answers from explanations');
							llmDs = await __benchmarkFillMissingOfficialAnswersFromExplanationWithApi(
								llmDs,
								'ConvertAnswerFill',
								{ batchSize: 6, maxPasses: 2, maxTokens: 1600 }
							) || llmDs;
						}
					}

					__benchmarkSetDataset(llmDs, 'Converted via parsing API (API-only mode).');
					__benchmarkApplyProblemsToUi();
					{
					const preservedRows = Array.isArray(__benchmarkStudio.lastRunRows) ? __benchmarkStudio.lastRunRows : [];
					__benchmarkRenderGradeOutput(
						preservedRows,
						__benchmarkStudio.lastGradeMode || (document.getElementById('benchmarkGradeMode')?.value || 'answer_only')
					);
					if (preservedRows.length) {
						__benchmarkLog('INFO', 'Convert', `Preserved existing benchmark results: rows=${preservedRows.length}. You can re-grade against the newly converted dataset.`);
					}
				}
				__benchmarkSetProgress(`Conversion complete + applied: ${llmDs.problems.length} problems`);
				__benchmarkLog('SUCCESS', 'Convert', `Conversion complete: ${llmDs.problems.length} problems.`);
				__benchmarkSetTaskCheckpoint('parse', null);
				if (convertSession) {
					convertSession.final_dataset = __benchmarkSafeClone(llmDs);
					__benchmarkRecordConvertSessionFinish(convertSession, { status: 'success', final_dataset: llmDs });
				}
			} catch (e) {
				if (__benchmarkIsTaskStopError(e, 'parse')) {
					pausedByUser = true;
					const cp = __benchmarkNormalizeParseCheckpoint({
						...(parseCheckpointWorking || {}),
						status: 'paused',
						updated_at: Date.now(),
						note: 'stopped-by-user',
					});
					__benchmarkSetTaskCheckpoint('parse', cp);
					__benchmarkSetProgress(`Conversion paused at chunk ${Math.min((cp?.next_chunk_index || 0) + 1, (cp?.text_chunks || []).length)}/${(cp?.text_chunks || []).length || 0}`);
					__benchmarkLog('WARN', 'Convert', 'Conversion paused by user. Use Resume Convert to continue.');
					if (convertSession) __benchmarkRecordConvertSessionFinish(convertSession, { status: 'paused', note: 'stopped-by-user' });
					return;
				}
				__benchmarkSetProgress('Conversion failed');
				__benchmarkLog('ERROR', 'Convert', `Unhandled conversion error: ${e?.message || e}`);
				if (convertSession) __benchmarkRecordConvertSessionFinish(convertSession, { status: 'failed', error: __benchmarkString(e?.message || e) });
				throw e;
			} finally {
				__benchmarkSetTaskRunning('parse', false);
				__benchmarkSetTaskStopRequested('parse', false);
				if (!pausedByUser && __benchmarkTrim(__benchmarkGetTaskCheckpoint('parse')?.status || '') === 'running') {
					__benchmarkSetTaskCheckpoint('parse', null);
				}
				__benchmarkSetButtonsDisabled(false);
				try { saveToLocalStorage(); } catch { }
			}
		}

			function __benchmarkLoadDatasetFromJsonText(rawText, sourceLabel = 'Benchmark JSON') {
				try {
					const obj = __benchmarkTryParseJson(rawText);
					if (!obj) throw new Error('Invalid JSON/XML payload.');
					const version = __benchmarkTrim(obj?.version || '');
					// Accept benchmark artifacts exports (mini-artichokes-artifacts-v1) and restore full benchmark state.
					if (version === 'mini-artichokes-artifacts-v1' && obj && typeof obj === 'object' && obj.benchmark && typeof obj.benchmark === 'object') {
						const current = __benchmarkExportState();
						const restored = __benchmarkSafeClone(obj.benchmark) || obj.benchmark;
						// Artifacts downloads redact API keys; keep current API configuration on restore.
						try {
							if (!restored.ui || typeof restored.ui !== 'object') restored.ui = {};
							const curUi = (current && typeof current === 'object') ? (current.ui || {}) : {};
							const keep = [
								'parseApiKeyList', 'parseApiUrl', 'parseApiProxyUrl', 'parseModelName', 'parseBypassSystemRole',
								'parseSplitTokens', 'parseMergeTokens', 'parseRpmLimit', 'parseTpmLimit', 'parseMaxInflightPerKey',
								'gradeApiKeyList', 'gradeApiUrl', 'gradeApiProxyUrl', 'gradeModelName', 'gradeBypassSystemRole',
								'gradeSplitTokens', 'gradeMergeTokens', 'gradeRpmLimit', 'gradeTpmLimit', 'gradeMaxInflightPerKey',
							];
							for (const k of keep) {
								if (Object.prototype.hasOwnProperty.call(curUi, k)) restored.ui[k] = curUi[k];
							}
						} catch { }

					__benchmarkRestoreState(restored);
					const dsAfter = __benchmarkStudio.dataset;
					if (!dsAfter || !Array.isArray(dsAfter.problems) || !dsAfter.problems.length) {
						throw new Error('Artifacts file did not include a valid benchmark dataset.');
					}
					// In job windows, the multi-problem query UI is hidden; benchmark runs use the dataset directly.
					// Only auto-apply to query slots in the main window (or if the saved state explicitly had it applied).
					try {
						const wasApplied = !!(restored?.ui && restored.ui.appliedToUi === true);
						if (!__isJobWindow && wasApplied) __benchmarkApplyProblemsToUi();
					} catch { }
					__benchmarkLog('SUCCESS', 'BenchmarkArtifacts', `Loaded benchmark artifacts: ${dsAfter.name || 'Benchmark'} (${dsAfter.problems.length} problems).`);
					return;
				}

					const session = __benchmarkRecordConvertSessionStart({
						mode: 'json_load',
						source_label: sourceLabel,
						pasted_text: __benchmarkString(rawText || ''),
					});
					const ds = __benchmarkNormalizeDataset(obj, sourceLabel);
					if (!ds || !Array.isArray(ds.problems) || !ds.problems.length) throw new Error('No valid problems in JSON.');
					__benchmarkSetDataset(ds);
					const preservedRows = Array.isArray(__benchmarkStudio.lastRunRows) ? __benchmarkStudio.lastRunRows : [];
					__benchmarkRenderGradeOutput(
					preservedRows,
					__benchmarkStudio.lastGradeMode || (document.getElementById('benchmarkGradeMode')?.value || 'answer_only')
				);
				if (preservedRows.length) {
					__benchmarkLog('INFO', 'BenchmarkJSON', `Preserved existing benchmark results: rows=${preservedRows.length}. You can re-grade against the newly loaded dataset.`);
				}
				__benchmarkLog('SUCCESS', 'BenchmarkJSON', `Loaded dataset from JSON: ${ds.name || sourceLabel} (${ds.problems.length} problems)`);
					session.prepared_chunks = [{
						index: 1,
						token_estimate: __benchmarkEstimateTokens(rawText || ''),
						qid_hints: [],
						text: __benchmarkString(rawText || ''),
					}];
					session.final_dataset = __benchmarkSafeClone(ds);
					__benchmarkRecordConvertSessionFinish(session, { status: 'success', final_dataset: ds });
				} catch (e) {
					throw e;
				}
			}

		function __benchmarkApplyProblemsToUi() {
			const ds = __benchmarkStudio.dataset;
			if (!ds?.problems?.length) {
				alert('Load or convert a benchmark first.');
				return;
			}
			const prompts = ds.problems.map(__benchmarkProblemToPrompt).filter(Boolean);
			__setProblemQueriesInUi(prompts);
			__benchmarkStudio.appliedToUi = true;
			__benchmarkSetProgress(`Applied ${prompts.length} benchmark problems to query slots`);
			__benchmarkLog('INFO', 'BenchmarkApply', `Applied ${prompts.length} benchmark problems to UI`);
		}

		async function __benchmarkExtractAnswerToken(problemPrompt, finalResult, contextLabel = 'GradeExtract') {
			const helper = __benchmarkGetApiHelper();
			const draft = __benchmarkTrim(finalResult);
			if (!draft) return { raw: '', normalized: '' };

			let raw = __benchmarkTrim(helper.extractFinalAnswerTokenHeuristic(draft));
			if (!raw || raw.toLowerCase() === 'unknown') {
				try {
					const extractPrompt = `Extract the final answer ONLY from the response.

Rules:
- If multiple-choice, return ONLY the choice label (e.g., ‚ë†/‚ë°/‚ë¢/‚ë£/‚ë§ or A/B/C/D/E or 1/2/3/4/5).
- If numeric/textual, return only the final answer token/string.
- If unclear, return UNKNOWN.

Query:
${problemPrompt || '(empty)'}

Response:
${draft}`;
						raw = __benchmarkTrim(await __benchmarkCallApi('grade', [
							{ role: 'system', content: 'You are an answer extractor. Output only the final answer token.' },
							{ role: 'user', content: extractPrompt }
						], { temperature: 0.1, max_tokens: 120, contextLabel, maxRetries: -1 }));
					} catch { }
				}
			const normalized = __benchmarkTrim(helper.normalizeAnswerToken(raw));
			return { raw, normalized };
		}

		async function __benchmarkJudgeSolutionWithApi(problem, candidateText, contextLabel = 'GradeJudge') {
			const q = __benchmarkTrim(problem?.question_text);
			const answer = __benchmarkTrim(problem?.official_answer);
			const expl = __benchmarkTrim(problem?.official_explanation);
			const rubric = __benchmarkTrim(problem?.grading_rubric);
			const candidate = __benchmarkTrim(candidateText);
			if (!q || !candidate) return { pass: false, reason: 'Empty candidate solution.' };

			const sys = 'You are a strict grader. Return only <grade>PASS</grade> or <grade>FAIL</grade> and <reason>...</reason>.';
			const user = `Evaluate whether the candidate solution is correct under this benchmark record.

Question:
${q}

Official answer:
${answer || '(not provided)'}

Official explanation:
${expl || '(not provided)'}

Rubric:
${rubric || '(none)'}

Candidate solution:
${candidate}

Rules:
- PASS only if the final answer is correct and the reasoning is consistent with the official explanation/rubric.
- If official explanation is missing, base the decision mainly on answer correctness and internal rigor.
- Output XML only:
<grade>PASS|FAIL</grade>
<reason>short reason</reason>`;

			let resp = '';
				try {
					resp = await __benchmarkCallApi('grade', [
						{ role: 'system', content: sys },
						{ role: 'user', content: user },
					], { temperature: 0, max_tokens: 900, contextLabel, maxRetries: -1 });
				} catch (e) {
					return { pass: false, reason: `API grading failed: ${e?.message || e}` };
				}

			const grade = (resp.match(/<\s*grade\s*>([\s\S]*?)<\s*\/\s*grade\s*>/i)?.[1] || '').trim().toUpperCase();
			const reason = (resp.match(/<\s*reason\s*>([\s\S]*?)<\s*\/\s*reason\s*>/i)?.[1] || '').trim();
			if (grade === 'PASS') return { pass: true, reason: reason || 'PASS' };
			if (grade === 'FAIL') return { pass: false, reason: reason || 'FAIL' };
			return { pass: false, reason: 'Invalid grader response.' };
		}

		async function __benchmarkJudgeAnswerByExplanationWithApi(problem, candidateText, extractedRaw = '', extractedNorm = '', contextLabel = 'GradeAnswerJudge') {
			const q = __benchmarkTrim(problem?.question_text);
			const officialAnswer = __benchmarkCanonicalizeOfficialAnswerText(problem?.official_answer);
			const expl = __benchmarkTrim(problem?.official_explanation);
			const candidate = __benchmarkTrim(candidateText);
			if (!q || !candidate || (!officialAnswer && !expl)) {
				return { pass: null, reason: 'Missing question/candidate/(official_answer or official_explanation).', expectedAnswer: '' };
			}

			const sys = 'You are a strict final-answer grader. Judge only whether the final answer is correct. Ignore solution quality. Output XML only.';
			const user = `Evaluate final-answer correctness from official answer/explanation.

Question:
${q}

Official final answer (canonical):
${officialAnswer || '(not provided)'}

Official explanation:
${expl || '(not provided)'}

Candidate full response:
${candidate}

Candidate extracted final answer (raw):
${__benchmarkTrim(extractedRaw) || '(empty)'}

Candidate extracted final answer (normalized):
${__benchmarkTrim(extractedNorm) || '(empty)'}

Rules:
- Judge only final-answer correctness.
- Do NOT evaluate reasoning quality in this step.
- If official final answer is provided, use it as primary truth and accept mathematically equivalent expressions.
- Use official explanation only as supporting context for semantic equivalence, not as a separate rubric.
- If official final answer is empty, infer canonical final answer from explanation if possible.
- Output XML only:
<grade>PASS|FAIL</grade>
<reason>short reason</reason>
<expected_answer>canonical expected answer</expected_answer>`;

			let resp = '';
			try {
				resp = await __benchmarkCallApi('grade', [
					{ role: 'system', content: sys },
					{ role: 'user', content: user },
				], { temperature: 0, max_tokens: 700, contextLabel, maxRetries: -1 });
			} catch (e) {
				return { pass: false, reason: `API answer grading failed: ${e?.message || e}`, expectedAnswer: '' };
			}

			const grade = (resp.match(/<\s*grade\s*>([\s\S]*?)<\s*\/\s*grade\s*>/i)?.[1] || '').trim().toUpperCase();
			const reason = (resp.match(/<\s*reason\s*>([\s\S]*?)<\s*\/\s*reason\s*>/i)?.[1] || '').trim();
			const expectedAnswer = (resp.match(/<\s*expected_answer\s*>([\s\S]*?)<\s*\/\s*expected_answer\s*>/i)?.[1] || '').trim();
			if (grade === 'PASS') return { pass: true, reason: reason || 'PASS', expectedAnswer };
			if (grade === 'FAIL') return { pass: false, reason: reason || 'FAIL', expectedAnswer };
			return { pass: false, reason: 'Invalid answer grader response.', expectedAnswer };
		}

		async function __benchmarkGradeAttempt(problem, row, mode = 'answer_only') {
			const helper = __benchmarkGetApiHelper();
			const expectedRawList = __benchmarkGetExpectedAnswerList(problem);
			const expectedNorms = expectedRawList
				.map(v => __benchmarkTrim(helper.normalizeAnswerToken(v)))
				.filter(Boolean);
			const rowLabel = `${__benchmarkTrim(row?.archId || 'arch')}#${row?.instanceId || 1} ${__benchmarkTrim(row?.problemQid || '')} run${row?.runIndex || 1}`;

			const prompt = __benchmarkProblemToPrompt(problem);
			const extracted = await __benchmarkExtractAnswerToken(prompt, row.finalResult || '', `GradeExtract ${rowLabel}`);
			row.finalAnswerRaw = extracted.raw || row.finalAnswerRaw || '';
			row.finalAnswerNorm = extracted.normalized || row.finalAnswerNorm || '';
			row.expectedAnswerRaw = expectedRawList.join(' || ');
			row.expectedAnswerNorm = expectedNorms.join(' || ');

			let answerCorrect = null;
			let answerNote = '';
			if (expectedNorms.length || __benchmarkTrim(problem?.official_explanation)) {
				const judgedAnswer = await __benchmarkJudgeAnswerByExplanationWithApi(
					problem,
					row.finalResult || '',
					row.finalAnswerRaw || '',
					row.finalAnswerNorm || '',
					`GradeAnswerJudge ${rowLabel}`
				);
				answerCorrect = (judgedAnswer.pass === true) ? true : (judgedAnswer.pass === false ? false : null);
				answerNote = judgedAnswer.reason || '';
				const inferredExpectedRaw = __benchmarkTrim(judgedAnswer.expectedAnswer || '');
				const inferredExpectedNorm = inferredExpectedRaw ? __benchmarkTrim(helper.normalizeAnswerToken(inferredExpectedRaw)) : '';
				if (!row.expectedAnswerRaw && inferredExpectedRaw) row.expectedAnswerRaw = inferredExpectedRaw;
				if (!row.expectedAnswerNorm && inferredExpectedNorm) row.expectedAnswerNorm = inferredExpectedNorm;
			} else {
				answerNote = 'No official_answer or official_explanation provided for answer grading.';
			}

			let solutionCorrect = null;
			let note = answerNote;

			if (mode === 'answer_and_solution') {
				if (answerCorrect !== true) {
					solutionCorrect = false;
					note = answerNote || 'Answer mismatch.';
				} else {
					const keywords = __benchmarkToArray(problem?.solution_keywords).map(x => __benchmarkTrim(x)).filter(Boolean);
					const regexSpec = __benchmarkTrim(problem?.solution_regex);
					const officialExplanation = __benchmarkTrim(problem?.official_explanation);
					const rubricText = __benchmarkTrim(problem?.grading_rubric);

					if (keywords.length) {
						const low = __benchmarkTrim(row.finalResult || '').toLowerCase();
						const missing = keywords.filter(k => !low.includes(k.toLowerCase()));
						solutionCorrect = missing.length === 0;
						note = solutionCorrect ? 'Keyword rubric passed.' : `Missing keywords: ${missing.slice(0, 5).join(', ')}`;
					} else if (regexSpec) {
						try {
							const re = new RegExp(regexSpec, 'i');
							solutionCorrect = re.test(__benchmarkTrim(row.finalResult || ''));
							note = solutionCorrect ? 'Regex rubric passed.' : 'Regex rubric failed.';
						} catch {
							solutionCorrect = false;
							note = 'Invalid solution_regex in benchmark.';
							}
						} else if (!officialExplanation && !rubricText) {
							solutionCorrect = false;
							note = 'No official explanation/rubric; cannot validate solution in answer+solution mode.';
						} else {
						const judged = await __benchmarkJudgeSolutionWithApi(problem, row.finalResult || '', `GradeJudge ${rowLabel}`);
						solutionCorrect = !!judged.pass;
						note = judged.reason || '';
					}
				}
			}

			let isCorrect = null;
			if (mode === 'answer_only') {
				isCorrect = (answerCorrect === null) ? null : (answerCorrect === true);
			} else {
				isCorrect = (answerCorrect === true && solutionCorrect === true);
			}

			row.answerCorrect = answerCorrect;
			row.solutionCorrect = solutionCorrect;
			row.isCorrect = isCorrect;
			row.graded = isCorrect !== null;
			row.note = note;
			row.gradeMode = mode;
			row.effectiveGradeMode = mode;
			return row;
		}

		function __benchmarkBuildGradeAttemptId(row, fallback = 0) {
			const idx = Number.isFinite(row?.__origIndex) ? row.__origIndex : fallback;
			return `R${idx + 1}`;
		}

		function __benchmarkCompactGradeText(value, maxLen = 160) {
			const lim = __benchmarkClampInt(maxLen, { min: 8, max: 2000, fallback: 160 });
			const txt = __benchmarkTrim(value || '').replace(/\s+/g, ' ');
			if (!txt) return '';
			if (txt.length <= lim) return txt;
			return `${txt.slice(0, lim - 1).trim()}‚Ä¶`;
		}

		function __benchmarkXmlEscape(v) {
			return __benchmarkString(v)
				.replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/"/g, '&quot;')
				.replace(/'/g, '&apos;');
		}

		function __benchmarkGetGradeJsonSchema() {
			return {
				type: 'object',
				properties: {
					mode: { type: 'string', enum: ['answer_only', 'answer_and_solution'] },
					attempts: {
						type: 'array',
						items: {
							type: 'object',
							properties: {
								id: { type: 'string' },
								final_answer: { type: 'string' },
								answer_correct: { type: 'boolean' },
								solution_correct: { type: 'boolean' },
								is_correct: { type: 'boolean' },
								note: { type: 'string' },
							},
							required: ['id', 'final_answer', 'is_correct', 'note'],
							additionalProperties: true,
						},
					},
				},
				required: ['attempts'],
				additionalProperties: true,
			};
		}

		function __benchmarkBuildBatchGradeJsonMessages(chunkItems, mode = 'answer_only') {
			const modeNorm = (__benchmarkTrim(mode || 'answer_only').toLowerCase() === 'answer_and_solution')
				? 'answer_and_solution'
				: 'answer_only';
			const items = Array.isArray(chunkItems) ? chunkItems : [];
			const firstProblem = (items[0]?.problem && typeof items[0].problem === 'object') ? items[0].problem : {};
			const firstQid = __benchmarkTrim(firstProblem?.qid || '');
			const allSameProblem = items.length > 0 && items.every((it) => {
				const p = (it?.problem && typeof it.problem === 'object') ? it.problem : {};
				return __benchmarkTrim(p?.qid || '') === firstQid;
			});

			const sys = [
				'You are a strict grading engine.',
				'Return JSON only. No markdown, no prose, no code fence.',
				'Output schema:',
				'{',
				'  "mode": "answer_only|answer_and_solution",',
				'  "attempts": [',
				'    {',
				'      "id": "R1",',
				'      "final_answer": "short canonical answer",',
				'      "is_correct": true,',
				'      "note": "very short reason"',
				'    }',
				'  ]',
				'}',
				'Rules:',
				'- Keep final_answer concise (<= 120 chars, prefer <= 48). Use "NONE" if unavailable.',
				'- Keep note concise (<= 180 chars, prefer <= 100).',
				'- Include every ATTEMPT_ID exactly once in attempts.',
				'- answer_only mode: is_correct depends on answer only.',
				'- answer_and_solution mode: is_correct is true only when both answer and solution are correct.',
				'- Never include chain-of-thought.',
			].join('\n');

			const rules = [
				`Current grading mode: ${modeNorm}`,
				'Answer evaluation rules:',
				'- Compare candidate final answer against official_answer first (mathematical/semantic equivalence allowed).',
				'- Treat equivalent forms as correct (e.g., algebraic rearrangement, equivalent set/list order, equivalent notation).',
				'- If both are empty, infer expected final answer from official_explanation if possible; otherwise mark incorrect unless strong evidence exists.',
				'Solution evaluation rules:',
				'- In answer_only mode: ignore solution quality for final verdict.',
				'- In answer_and_solution mode: require both answer correctness and solution correctness.',
				'- For solution correctness, compare against official_explanation/grading_rubric/solution_keywords/solution_regex when provided.',
				'- If answer_and_solution mode and solution evidence is missing, mark incorrect.',
			].join('\n');

			const sharedKeywords = __benchmarkToArray(firstProblem?.solution_keywords).map(x => __benchmarkTrim(x)).filter(Boolean);
			const sharedExpected = __benchmarkGetExpectedAnswerList(firstProblem);
			const sharedProblemBlock = allSameProblem ? [
				'SHARED_PROBLEM_CONTEXT:',
				`QID: ${__benchmarkTrim(firstProblem?.qid || '')}`,
				'QUESTION:',
				__benchmarkTrim(firstProblem?.question_text || ''),
				'ANSWER_CHOICES:',
				__benchmarkTrim(firstProblem?.answer_choices || ''),
				'OFFICIAL_ANSWER:',
				sharedExpected.join(' || '),
				'OFFICIAL_EXPLANATION:',
				__benchmarkTrim(firstProblem?.official_explanation || ''),
				'GRADING_RUBRIC:',
				__benchmarkTrim(firstProblem?.grading_rubric || ''),
				'SOLUTION_KEYWORDS:',
				sharedKeywords.length ? sharedKeywords.join(' || ') : '',
				'SOLUTION_REGEX:',
				__benchmarkTrim(firstProblem?.solution_regex || ''),
			].join('\n') : '';

			const blocks = items.map((it, idx) => {
				const p = it?.problem || {};
				const r = it?.row || {};
				const attemptId = __benchmarkBuildGradeAttemptId(r, idx);
				const base = [
					`ATTEMPT_ID: ${attemptId}`,
					`QID: ${__benchmarkTrim(p?.qid || r?.problemQid || '')}`,
					`ARCH_ID: ${__benchmarkTrim(r?.archId || '')}`,
					`INSTANCE: ${__benchmarkTrim(r?.instanceId || '')}`,
					'CANDIDATE_RESPONSE:',
					__benchmarkTrim(r?.finalResult || ''),
				];
				if (!allSameProblem) {
					const keywords = __benchmarkToArray(p?.solution_keywords).map(x => __benchmarkTrim(x)).filter(Boolean);
					const expected = __benchmarkGetExpectedAnswerList(p);
					base.splice(4, 0,
						'QUESTION:',
						__benchmarkTrim(p?.question_text || ''),
						'ANSWER_CHOICES:',
						__benchmarkTrim(p?.answer_choices || ''),
						'OFFICIAL_ANSWER:',
						expected.join(' || '),
						'OFFICIAL_EXPLANATION:',
						__benchmarkTrim(p?.official_explanation || ''),
						'GRADING_RUBRIC:',
						__benchmarkTrim(p?.grading_rubric || ''),
						'SOLUTION_KEYWORDS:',
						keywords.length ? keywords.join(' || ') : '',
						'SOLUTION_REGEX:',
						__benchmarkTrim(p?.solution_regex || ''),
					);
				}
				return base.join('\n');
			});

			const user = [
				rules,
				'',
				(allSameProblem ? sharedProblemBlock : ''),
				(allSameProblem ? '' : ''),
				'Grade all attempts below and return exactly one JSON object following the schema.',
				'----- ATTEMPTS START -----',
				blocks.join('\n\n----- NEXT ATTEMPT -----\n\n'),
				'----- ATTEMPTS END -----',
			].join('\n');

			return [
				{ role: 'system', content: sys },
				{ role: 'user', content: user },
			];
		}

		function __benchmarkGradeNormalizeSmartQuotes(rawText) {
			return __benchmarkString(rawText || '')
				.replace(/[\u201C\u201D]/g, '"')
				.replace(/[\u2018\u2019]/g, "'")
				.replace(/\u00A0/g, ' ')
				.replace(/\u2028|\u2029/g, '\n')
				.replace(/^\uFEFF/, '');
		}

		function __benchmarkGradeStripJsonComments(rawText) {
			const s = __benchmarkString(rawText || '');
			if (!s) return '';
			let out = '';
			let inString = false;
			let quote = '';
			let esc = false;
			for (let i = 0; i < s.length; i++) {
				const ch = s[i];
				const next = s[i + 1] || '';
				if (inString) {
					out += ch;
					if (esc) {
						esc = false;
						continue;
					}
					if (ch === '\\') {
						esc = true;
						continue;
					}
					if (ch === quote) {
						inString = false;
						quote = '';
					}
					continue;
				}
				if (ch === '"' || ch === "'") {
					inString = true;
					quote = ch;
					out += ch;
					continue;
				}
				if (ch === '/' && next === '/') {
					i += 2;
					while (i < s.length && s[i] !== '\n' && s[i] !== '\r') i += 1;
					i -= 1;
					continue;
				}
				if (ch === '/' && next === '*') {
					i += 2;
					while (i < s.length - 1 && !(s[i] === '*' && s[i + 1] === '/')) i += 1;
					i += 1;
					continue;
				}
				out += ch;
			}
			return out;
		}

		function __benchmarkGradeStripTrailingCommas(rawText) {
			const s = __benchmarkString(rawText || '');
			if (!s) return '';
			let out = '';
			let inString = false;
			let quote = '';
			let esc = false;
			for (let i = 0; i < s.length; i++) {
				const ch = s[i];
				if (inString) {
					out += ch;
					if (esc) {
						esc = false;
						continue;
					}
					if (ch === '\\') {
						esc = true;
						continue;
					}
					if (ch === quote) {
						inString = false;
						quote = '';
					}
					continue;
				}
				if (ch === '"' || ch === "'") {
					inString = true;
					quote = ch;
					out += ch;
					continue;
				}
				if (ch === ',') {
					let j = i + 1;
					while (j < s.length && /\s/.test(s[j])) j += 1;
					const nxt = s[j] || '';
					if (nxt === '}' || nxt === ']') continue;
				}
				out += ch;
			}
			return out;
		}

		function __benchmarkGradeReplacePythonLiterals(rawText) {
			return __benchmarkString(rawText || '')
				.replace(/\bTrue\b/g, 'true')
				.replace(/\bFalse\b/g, 'false')
				.replace(/\bNone\b/g, 'null');
		}

		function __benchmarkGradeQuoteBareKeys(rawText) {
			return __benchmarkString(rawText || '').replace(
				/([{,]\s*)([A-Za-z_][A-Za-z0-9_\-]*)(\s*:)/g,
				'$1"$2"$3'
			);
		}

		function __benchmarkGradeConvertSingleQuotedStrings(rawText) {
			return __benchmarkString(rawText || '').replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, (_, inner) => {
				const normalized = __benchmarkString(inner || '')
					.replace(/\\'/g, "'")
					.replace(/\\"/g, '"')
					.replace(/\\\\/g, '\\');
				return JSON.stringify(normalized);
			});
		}

		function __benchmarkGradeAutoCloseJson(rawText) {
			let s = __benchmarkTrim(rawText || '');
			if (!s) return '';
			const firstObj = s.indexOf('{');
			const firstArr = s.indexOf('[');
			const starts = [firstObj, firstArr].filter((n) => n >= 0);
			if (starts.length) s = s.slice(Math.min(...starts));
			let out = '';
			const stack = [];
			let inString = false;
			let quote = '';
			let esc = false;
			for (let i = 0; i < s.length; i++) {
				const ch = s[i];
				if (inString) {
					out += ch;
					if (esc) {
						esc = false;
						continue;
					}
					if (ch === '\\') {
						esc = true;
						continue;
					}
					if (ch === quote) {
						inString = false;
						quote = '';
					}
					continue;
				}
				if (ch === '"' || ch === "'") {
					inString = true;
					quote = ch;
					out += ch;
					continue;
				}
				if (ch === '{') {
					stack.push('{');
					out += ch;
					continue;
				}
				if (ch === '[') {
					stack.push('[');
					out += ch;
					continue;
				}
				if (ch === '}') {
					if (stack[stack.length - 1] === '{') {
						stack.pop();
						out += ch;
					}
					continue;
				}
				if (ch === ']') {
					if (stack[stack.length - 1] === '[') {
						stack.pop();
						out += ch;
					}
					continue;
				}
				out += ch;
			}
			while (stack.length) {
				const top = stack.pop();
				out += (top === '{') ? '}' : ']';
			}
			return __benchmarkTrim(out);
		}

		function __benchmarkBuildGradeJsonRepairCandidates(rawText) {
			const out = [];
			const seen = new Set();
			const push = (stage, text) => {
				const t = __benchmarkTrim(text || '');
				if (!t || seen.has(t)) return;
				seen.add(t);
				out.push({ stage, text: t });
			};

			const raw = __benchmarkString(rawText || '');
			const sanitized = __benchmarkSanitizeModelText(raw);
			push('raw', raw);
			push('sanitized', sanitized);
			push('balanced_raw', __benchmarkExtractBalancedJsonSnippet(raw));
			push('balanced_sanitized', __benchmarkExtractBalancedJsonSnippet(sanitized));

			const bases = [raw, sanitized];
			for (const seed of bases) {
				const s1 = __benchmarkGradeNormalizeSmartQuotes(seed);
				const s2 = __benchmarkGradeStripJsonComments(s1);
				const s3 = __benchmarkGradeStripTrailingCommas(s2);
				const s4 = __benchmarkGradeReplacePythonLiterals(s3);
				const s5 = __benchmarkGradeQuoteBareKeys(s4);
				const s6 = __benchmarkGradeConvertSingleQuotedStrings(s5);
				const s7 = __benchmarkRepairJsonStringEscapes(s6);
				const s8 = __benchmarkGradeAutoCloseJson(s7);
				push('repair_normalize', s1);
				push('repair_strip_comments', s2);
				push('repair_strip_trailing_commas', s3);
				push('repair_python_literals', s4);
				push('repair_quote_keys', s5);
				push('repair_single_quotes', s6);
				push('repair_escaped_strings', s7);
				push('repair_auto_close', s8);
				push('repair_auto_close_balanced', __benchmarkExtractBalancedJsonSnippet(s8));
			}
			return out;
		}

		function __benchmarkTryParseGradeJsonDetailed(rawText) {
			const base = __benchmarkTryParseJsonDetailed(rawText);
			if (base?.ok) return base;

			const candidates = __benchmarkBuildGradeJsonRepairCandidates(rawText);
			let best = base && !base.ok ? base : null;
			for (const c of candidates) {
				const stage = __benchmarkTrim(c?.stage || 'repair') || 'repair';
				const text = __benchmarkString(c?.text || '');
				if (!text) continue;
				try {
					const data = JSON.parse(text);
					return { ok: true, data, stage };
				} catch (e) {
					const msg = __benchmarkTrim(e?.message || e || 'JSON.parse failed');
					const pos = __benchmarkExtractJsonErrorPosition(msg);
					if (!best) {
						best = {
							ok: false,
							stage,
							error: msg,
							position: pos,
							snippet: __benchmarkBuildErrorSnippet(text, pos, 180),
						};
					}
				}
			}

			return best || {
				ok: false,
				stage: 'unknown',
				error: 'No JSON candidate found',
				position: -1,
				snippet: __benchmarkPreview(rawText, 320),
			};
		}

		function __benchmarkBuildGradeResultFromRow(rawRow, mode = 'answer_only') {
			const row = (rawRow && typeof rawRow === 'object') ? rawRow : {};
			const modeNorm = (__benchmarkTrim(mode || '').toLowerCase() === 'answer_and_solution')
				? 'answer_and_solution'
				: 'answer_only';
			const toBool = (v) => {
				if (typeof v === 'boolean') return v;
				const t = __benchmarkTrim(v).toLowerCase();
				if (t === 'true') return true;
				if (t === 'false') return false;
				return null;
			};

			const id = __benchmarkTrim(row?.id || row?.attempt_id || row?.attemptId || '');
			if (!id) return { ok: false, error: 'attempt missing id' };
			const finalAnswer = __benchmarkCompactGradeText(
				row?.final_answer ?? row?.finalAnswer ?? row?.answer ?? 'NONE',
				120
			) || 'NONE';
			const answerCorrect = toBool(row?.answer_correct ?? row?.answerCorrect);
			let solutionCorrect = toBool(row?.solution_correct ?? row?.solutionCorrect);
			if (modeNorm === 'answer_only') solutionCorrect = null;
			let isCorrect = toBool(row?.is_correct ?? row?.isCorrect);
			if (isCorrect === null) {
				if (modeNorm === 'answer_only') {
					if (typeof answerCorrect === 'boolean') isCorrect = answerCorrect;
				} else {
					if (answerCorrect === false) {
						isCorrect = false;
					} else if (answerCorrect === true && solutionCorrect === true) {
						isCorrect = true;
					} else if (answerCorrect === true && solutionCorrect !== true) {
						isCorrect = false;
					} else if (answerCorrect === null && solutionCorrect === false) {
						isCorrect = false;
					}
				}
			}
			if (isCorrect === null) return { ok: false, error: `attempt ${id} invalid is_correct` };
			const note = __benchmarkCompactGradeText(row?.note || row?.reason || (isCorrect ? 'PASS' : 'FAIL'), 180);
			return {
				ok: true,
				id,
				data: {
					finalAnswer,
					answerCorrect,
					solutionCorrect,
					isCorrect,
					note: note || (isCorrect ? 'PASS' : 'FAIL'),
				},
			};
		}

		function __benchmarkSalvageGradeRowsFromRawText(rawText) {
			const txt = __benchmarkString(rawText || '');
			if (!txt) return [];
			const rows = [];
			const objRegex = /\{[\s\S]*?\}/g;
			let m = null;
			let guard = 0;
			while ((m = objRegex.exec(txt)) && guard < 500) {
				guard += 1;
				const block = __benchmarkTrim(m[0] || '');
				if (!/(?:["']?(?:attempt_id|attemptId|id)["']?\s*:)/i.test(block)) continue;
				const parsed = __benchmarkTryParseGradeJsonDetailed(block);
				if (!parsed?.ok || !parsed?.data || typeof parsed.data !== 'object' || Array.isArray(parsed.data)) continue;
				rows.push(parsed.data);
			}
			return rows;
		}

		function __benchmarkValidateBatchGradeJson(rawText, expectedIds = [], mode = 'answer_only') {
			const parseDiag = __benchmarkTryParseGradeJsonDetailed(rawText);
			let parsed = (parseDiag?.ok && parseDiag?.data && typeof parseDiag.data === 'object')
				? parseDiag.data
				: null;

			const out = new Map();
			const parseErrors = [];
			const mergeRow = (row) => {
				const built = __benchmarkBuildGradeResultFromRow(row, mode);
				if (!built?.ok) {
					if (built?.error) parseErrors.push(built.error);
					return;
				}
				out.set(built.id, built.data);
			};

			if (parsed) {
				let rows = [];
				if (Array.isArray(parsed)) rows = parsed;
				else if (Array.isArray(parsed?.attempts)) rows = parsed.attempts;
				else if (Array.isArray(parsed?.results)) rows = parsed.results;
				else if (Array.isArray(parsed?.data?.attempts)) rows = parsed.data.attempts;
				else if (parsed?.attempts_by_id && typeof parsed.attempts_by_id === 'object') {
					rows = Object.entries(parsed.attempts_by_id).map(([id, value]) => ({ ...(value || {}), id }));
				} else if (parsed && typeof parsed === 'object' && (parsed.id || parsed.attempt_id || parsed.attemptId)) {
					rows = [parsed];
				}
				for (const row of rows) mergeRow(row);
			}

			for (const row of __benchmarkSalvageGradeRowsFromRawText(rawText)) {
				const id = __benchmarkTrim(row?.id || row?.attempt_id || row?.attemptId || '');
				if (!id || out.has(id)) continue;
				mergeRow(row);
			}

			const looksXml = /<\s*grading\b|<\s*attempt\b/i.test(__benchmarkString(rawText || ''));
			if (looksXml) {
				const xmlDiag = __benchmarkValidateBatchGradeXml(rawText, expectedIds);
				if (xmlDiag?.ok && xmlDiag?.data instanceof Map) {
					for (const [id, v] of xmlDiag.data.entries()) if (!out.has(id)) out.set(id, v);
				} else if (xmlDiag?.partialData instanceof Map) {
					for (const [id, v] of xmlDiag.partialData.entries()) if (!out.has(id)) out.set(id, v);
					if (xmlDiag?.error) parseErrors.push(`xml_fallback: ${xmlDiag.error}`);
				}
			}

			const missingIds = [];
			for (const id of (Array.isArray(expectedIds) ? expectedIds : [])) {
				if (!out.has(id)) missingIds.push(id);
			}
			if (missingIds.length === 0 && out.size > 0) {
				return { ok: true, data: out };
			}

			const stage = __benchmarkTrim(parseDiag?.stage || 'unknown');
			const err = __benchmarkTrim(parseDiag?.error || '');
			const snippet = __benchmarkTrim(
				parseDiag?.snippet ||
				parseDiag?.debug?.snippet ||
				__benchmarkPreview(rawText, 320)
			);
			const errParts = [];
			if (parseErrors.length) errParts.push(parseErrors[0]);
			if (missingIds.length) errParts.push(`Missing attempt id: ${missingIds[0]}`);
			if (!errParts.length && err) errParts.push(`JSON parse error [stage=${stage}]: ${err}`);

			return {
				ok: false,
				error: errParts.join(' | ') || 'Invalid JSON grading payload',
				partialData: out,
				missingIds,
				recoverable: out.size > 0,
				debug: {
					stage,
					error: err,
					position: Number.isFinite(parseDiag?.position) ? parseDiag.position : -1,
					snippet,
				},
			};
		}

		function __benchmarkBuildBatchGradeMessages(chunkItems, mode = 'answer_only') {
			return __benchmarkBuildBatchGradeJsonMessages(chunkItems, mode);
		}

		function __benchmarkParseBoolTri(v) {
			const t = __benchmarkTrim(v).toLowerCase();
			if (t === 'true') return true;
			if (t === 'false') return false;
			return null;
		}

		function __benchmarkExtractGradingXmlEnvelope(rawText) {
			const txt = __benchmarkTrim(__benchmarkSanitizeModelText(rawText || ''));
			if (!txt) return '';
			const start = txt.indexOf('<grading');
			if (start < 0) return txt;
			const end = txt.lastIndexOf('</grading>');
			if (end >= start) return __benchmarkTrim(txt.slice(start, end + '</grading>'.length));
			return __benchmarkTrim(txt.slice(start));
		}

		function __benchmarkStripDanglingXmlTail(rawText) {
			const txt = __benchmarkTrim(rawText || '');
			if (!txt) return '';
			const lt = txt.lastIndexOf('<');
			const gt = txt.lastIndexOf('>');
			if (lt > gt) return __benchmarkTrim(txt.slice(0, lt));
			return txt;
		}

		function __benchmarkCountXmlTag(rawText, tagName, closing = false) {
			const txt = __benchmarkString(rawText || '');
			const tag = __benchmarkTrim(tagName || '');
			if (!txt || !tag) return 0;
			const safe = tag.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
			const re = new RegExp(`<${closing ? '/' : ''}${safe}(?:\\s[^>]*)?>`, 'gi');
			let count = 0;
			while (re.exec(txt)) count += 1;
			return count;
		}

		function __benchmarkTryAutoCloseGradingXml(rawText) {
			let xml = __benchmarkExtractGradingXmlEnvelope(rawText || '');
			if (!xml || !xml.startsWith('<grading')) return '';
			xml = __benchmarkStripDanglingXmlTail(xml);
			if (!xml) return '';
			const closeOrder = ['final_answer', 'answer_correct', 'solution_correct', 'is_correct', 'note', 'attempt', 'grading'];
			for (const tag of closeOrder) {
				let openN = __benchmarkCountXmlTag(xml, tag, false);
				let closeN = __benchmarkCountXmlTag(xml, tag, true);
				while (closeN < openN) {
					xml += `</${tag}>`;
					closeN += 1;
				}
			}
			return __benchmarkTrim(xml);
		}

		function __benchmarkValidateBatchGradeXml(xmlText, expectedIds = []) {
			const rawInput = __benchmarkExtractGradingXmlEnvelope(xmlText || '');
			let raw = __benchmarkTrim(rawInput || '');
			if ((!raw.startsWith('<grading') || !raw.endsWith('</grading>')) && raw.includes('<grading')) {
				const repaired = __benchmarkTryAutoCloseGradingXml(raw);
				if (repaired) raw = repaired;
			}
			if (!raw.startsWith('<grading') || !raw.endsWith('</grading>')) {
				return { ok: false, error: 'Not wrapped in <grading>...</grading>.' };
			}
			let doc = null;
			try {
				doc = new DOMParser().parseFromString(raw, 'application/xml');
			} catch {
				return {
					ok: false,
					error: `DOMParser failed. | snippet=${__benchmarkBuildErrorSnippet(raw, -1, 180)}`,
				};
			}
			if (!doc) {
				return {
					ok: false,
					error: `XML parse error: empty document. | snippet=${__benchmarkBuildErrorSnippet(raw, -1, 180)}`,
				};
			}
			const parserErrNode = doc.getElementsByTagName('parsererror')[0];
			if (parserErrNode) {
				const parserMsg = __benchmarkTrim(parserErrNode.textContent || 'XML parse error');
				return {
					ok: false,
					error: `XML parse error: ${parserMsg} | snippet=${__benchmarkBuildErrorSnippet(raw, -1, 180)}`,
				};
			}
			const root = doc.documentElement;
			if (!root || root.nodeName !== 'grading') {
				return { ok: false, error: 'Root node is not <grading>.' };
			}
			const modeAttr = __benchmarkTrim(root.getAttribute('mode') || '').toLowerCase();
			const answerOnlyMode = modeAttr === 'answer_only';
			const nodes = Array.from(root.getElementsByTagName('attempt'));
			const out = new Map();
			const parseErrors = [];
			for (const n of nodes) {
				const id = __benchmarkTrim(n.getAttribute('id') || '');
				if (!id) {
					parseErrors.push('attempt missing id');
					continue;
				}
				const finalAnswer = __benchmarkCompactGradeText(n.getElementsByTagName('final_answer')[0]?.textContent || '', 120);
				const answerCorrect = __benchmarkParseBoolTri(n.getElementsByTagName('answer_correct')[0]?.textContent || 'unknown');
				const solutionCorrect = __benchmarkParseBoolTri(n.getElementsByTagName('solution_correct')[0]?.textContent || 'unknown');
				const isCorrectRaw = __benchmarkTrim(n.getElementsByTagName('is_correct')[0]?.textContent || '').toLowerCase();
				let inferredIsCorrect = null;
				if (isCorrectRaw === 'true') {
					inferredIsCorrect = true;
				} else if (isCorrectRaw === 'false') {
					inferredIsCorrect = false;
				} else if (answerOnlyMode) {
					if (answerCorrect === true) inferredIsCorrect = true;
					else if (answerCorrect === false) inferredIsCorrect = false;
				} else {
					if (answerCorrect === false) {
						inferredIsCorrect = false;
					} else if (answerCorrect === true && solutionCorrect === true) {
						inferredIsCorrect = true;
					} else if (answerCorrect === true && solutionCorrect !== true) {
						inferredIsCorrect = false;
					} else if (answerCorrect === null && solutionCorrect === false) {
						inferredIsCorrect = false;
					}
				}
				const note = __benchmarkCompactGradeText(n.getElementsByTagName('note')[0]?.textContent || '', 180);
				if (inferredIsCorrect === null) {
					parseErrors.push(`attempt ${id} has invalid is_correct`);
					continue;
				}
				out.set(id, {
					finalAnswer,
					answerCorrect,
					solutionCorrect,
					isCorrect: inferredIsCorrect,
					note: note || (inferredIsCorrect ? 'PASS' : 'FAIL'),
				});
			}
			const missingIds = [];
			for (const id of (Array.isArray(expectedIds) ? expectedIds : [])) {
				if (!out.has(id)) missingIds.push(id);
			}
			if (missingIds.length === 0 && parseErrors.length === 0) {
				return { ok: true, data: out };
			}
			const errParts = [];
			if (parseErrors.length) errParts.push(parseErrors[0]);
			if (missingIds.length) errParts.push(`Missing attempt id: ${missingIds[0]}`);
			const snippet = __benchmarkTrim(__benchmarkPreview(raw, 320));
			return {
				ok: false,
				error: errParts.join(' | ') || 'Invalid XML payload',
				partialData: out,
				missingIds,
				recoverable: out.size > 0,
				debug: { snippet },
			};
		}

			async function __benchmarkGradeChunkBatch(chunkItems, mode = 'answer_only', contextLabel = 'GradeChunk') {
				const items = Array.isArray(chunkItems) ? chunkItems : [];
				const expectedIds = items.map((it, idx) => __benchmarkBuildGradeAttemptId(it?.row || {}, idx));
				if (!items.length) return { data: new Map(), missingIds: [], error: '' };

				const bestPartial = new Map();
				let bestMissingIds = Array.isArray(expectedIds) ? [...expectedIds] : [];
				let lastError = '';
				const maxTokens = Math.max(1200, Math.min(12000, 900 + items.length * 260));

				const mergeParsed = (parsedResult) => {
					if (parsedResult?.ok && parsedResult?.data instanceof Map) {
						for (const [id, value] of parsedResult.data.entries()) bestPartial.set(id, value);
					}
					if (parsedResult?.partialData instanceof Map) {
						for (const [id, value] of parsedResult.partialData.entries()) bestPartial.set(id, value);
					}
					const nextMissing = [];
					for (const id of expectedIds) {
						if (!bestPartial.has(id)) nextMissing.push(id);
					}
					bestMissingIds = nextMissing;
				};

				const tryJsonOnce = async (attemptName, extraHint = '', opts = {}) => {
					const baseMessages = __benchmarkBuildBatchGradeMessages(items, mode);
					const messages = extraHint
						? [...baseMessages, { role: 'user', content: extraHint }]
						: baseMessages;
					const resp = await __benchmarkCallApi(
						'grade',
						messages,
						{
							temperature: 0,
							max_tokens: maxTokens,
							contextLabel,
							maxRetries: -1,
							expectJson: (opts.expectJson !== false),
							jsonSchema: opts.useSchema === false ? null : __benchmarkGetGradeJsonSchema(),
							jsonSchemaName: 'grade_batch_v1',
						}
					);
					return __benchmarkValidateBatchGradeJson(resp, expectedIds, mode);
				};

				const attempts = [
					{
						name: 'initial',
						hint: '',
						opts: { expectJson: true, useSchema: true },
					},
					{
						name: 'schema-repair',
						hint: [
							'Your previous output was invalid JSON or incomplete for this batch.',
							'Return exactly one JSON object that follows the schema.',
							'Include every ATTEMPT_ID exactly once; do not omit any id.',
							'No markdown and no extra text.',
						].join('\n'),
						opts: { expectJson: true, useSchema: true },
					},
					{
						name: 'json-object-repair',
						hint: [
							'Return JSON only with key "attempts".',
							'Each element must include: id, final_answer, is_correct, note.',
							'No markdown fences.',
						].join('\n'),
						opts: { expectJson: true, useSchema: false },
					},
					{
						name: 'plain-text-json-repair',
						hint: [
							'Previous responses were malformed.',
							'Emit only a compact JSON object and nothing else.',
						].join('\n'),
						opts: { expectJson: false, useSchema: false },
					},
				];

				for (const attempt of attempts) {
					let parsed = null;
					try {
						parsed = await tryJsonOnce(attempt.name, attempt.hint, attempt.opts);
					} catch (e) {
						lastError = __benchmarkString(e?.message || e || 'unknown');
						__benchmarkLog('WARN', contextLabel, `Batch JSON grading API failed (${attempt.name}): ${lastError}`);
						continue;
					}
					mergeParsed(parsed);
					if (parsed?.ok && bestMissingIds.length === 0) {
						return { data: parsed.data, missingIds: [], error: '' };
					}
					const failMsg = __benchmarkTrim(parsed?.error || '');
					const failSnippet = __benchmarkTrim(parsed?.debug?.snippet || '');
					if (failMsg) {
						__benchmarkLog(
							'WARN',
							contextLabel,
							`Batch JSON validation failed (${attempt.name}): ${failMsg}${failSnippet ? ` | snippet=${failSnippet}` : ''}`
						);
					}
					if (bestMissingIds.length === 0) {
						return { data: bestPartial, missingIds: [], error: '' };
					}
					lastError = __benchmarkTrim(parsed?.error || lastError || '');
				}

				return {
					data: bestPartial,
					missingIds: bestMissingIds,
					error: __benchmarkTrim(lastError || 'Batch JSON grading unresolved attempts'),
				};
			}

		function __benchmarkApplyGradeResultToRow(problem, row, gradeResult, mode = 'answer_only') {
			const helper = __benchmarkGetApiHelper();
			const modeNorm = (__benchmarkTrim(mode || '').toLowerCase() === 'answer_and_solution')
				? 'answer_and_solution'
				: 'answer_only';
			const expectedRawList = __benchmarkGetExpectedAnswerList(problem);
			const expectedNorms = expectedRawList
				.map(v => __benchmarkTrim(helper.normalizeAnswerToken(v)))
				.filter(Boolean);

			const finalRaw = __benchmarkTrim(gradeResult?.finalAnswer || row?.finalAnswerRaw || '');
			const finalNorm = __benchmarkTrim(helper.normalizeAnswerToken(finalRaw));

			row.finalAnswerRaw = finalRaw;
				row.finalAnswerNorm = finalNorm;
				row.expectedAnswerRaw = expectedRawList[0] || row.expectedAnswerRaw || '';
				row.expectedAnswerNorm = expectedNorms[0] || row.expectedAnswerNorm || '';
				{
					const nextAnswerCorrect = (typeof gradeResult?.answerCorrect === 'boolean') ? gradeResult.answerCorrect : null;
					row.answerCorrect = (nextAnswerCorrect !== null)
						? nextAnswerCorrect
						: ((typeof row?.answerCorrect === 'boolean') ? row.answerCorrect : null);
				}
				{
					const nextSolutionCorrect = (typeof gradeResult?.solutionCorrect === 'boolean') ? gradeResult.solutionCorrect : null;
					if (modeNorm === 'answer_only') {
						row.solutionCorrect = null;
					} else {
						row.solutionCorrect = (nextSolutionCorrect !== null)
							? nextSolutionCorrect
							: ((typeof row?.solutionCorrect === 'boolean') ? row.solutionCorrect : null);
					}
				}
				row.isCorrect = (typeof gradeResult?.isCorrect === 'boolean') ? gradeResult.isCorrect : null;
				{
					const projected = __benchmarkProjectGradeVerdict(row, modeNorm);
					row.isCorrect = (typeof projected?.isCorrect === 'boolean') ? projected.isCorrect : null;
					row.graded = !!projected?.graded;
				}
				row.note = __benchmarkTrim(gradeResult?.note || row.note || '');
				row.gradeMode = modeNorm;
				row.effectiveGradeMode = modeNorm;
			return row;
		}

		async function __benchmarkGradeRows(rows, mode = 'answer_only', options = {}) {
			const ds = __benchmarkStudio.dataset;
			if (!ds?.problems?.length) throw new Error('No benchmark dataset loaded.');
			const onProgress = (options && typeof options.onProgress === 'function') ? options.onProgress : null;
			const forceRegrade = !!(options && options.forceRegrade);
			const skipUnfinished = !!(options && options.skipUnfinished);
			const __isTerminalAgentStatus = (statusRaw) => {
				const s = __benchmarkTrim(statusRaw || '').toLowerCase();
				if (!s) return false;
				if (s.includes('success')) return true;
				if (s.includes('failed')) return true;
				if (s.includes('error')) return true;
				return false;
			};
			try {
				await __benchmarkEnsureGptTokenizer();
				__benchmarkLog('INFO', 'Tokenizer', 'gpt-tokenizer ready for grading chunking.');
			} catch (e) {
				__benchmarkLog('WARN', 'Tokenizer', `Tokenizer load failed for grading; fallback estimate used. ${e?.message || e}`);
			}
			const byQid = new Map();
			for (let i = 0; i < ds.problems.length; i++) {
				const p = ds.problems[i] || {};
				const qid = __benchmarkTrim(p?.qid || `Q${i + 1}`) || `Q${i + 1}`;
				if (!byQid.has(qid)) byQid.set(qid, { problem: p, index: i });
			}
			const allRows = Array.isArray(rows) ? rows : [];
			const workRows = [];
			const chunkCfg = __benchmarkGetChunkingConfig();
			const out = [];
			const gradable = [];
			let reusedCount = 0;

				for (let idx = 0; idx < allRows.length; idx++) {
					const row = { ...(allRows[idx] || {}), __origIndex: idx };
					workRows.push(row);
					const qid = __benchmarkTrim(row.problemQid);
					const pIdx = __benchmarkClampInt(row.problemIndex, { min: 0, max: 1000000, fallback: -1 });
					let resolved = null;
					const resolvedByIndex = (pIdx >= 0 && pIdx < ds.problems.length)
						? { problem: ds.problems[pIdx] || {}, index: pIdx }
						: null;
					const resolvedByQid = (qid && byQid.has(qid)) ? byQid.get(qid) : null;
					if (resolvedByIndex && resolvedByQid) {
						// Prefer qid when index points to a different problem (dataset order changed).
						const idxQid = __benchmarkTrim(resolvedByIndex.problem?.qid || '');
						resolved = (idxQid && idxQid !== qid) ? resolvedByQid : resolvedByIndex;
					} else {
						resolved = resolvedByQid || resolvedByIndex;
					}
					if (!resolved) {
						row.graded = false;
						row.isCorrect = null;
						row.note = `No benchmark problem found for qid=${qid || '(empty)'}, idx=${pIdx}`;
						out.push(row);
						continue;
					}
				const canonicalQid = __benchmarkTrim(resolved.problem?.qid || `Q${resolved.index + 1}`) || `Q${resolved.index + 1}`;
				row.problemIndex = resolved.index;
				row.problemQid = canonicalQid;
				if (skipUnfinished) {
					const st = __benchmarkTrim(row?.status || '');
					const hasOutput = !!__benchmarkTrim(row?.finalResult || '');
					const isTerminal = st ? __isTerminalAgentStatus(st) : null;
					if (st && isTerminal === false) {
						row.graded = false;
						row.isCorrect = null;
						row.note = `Skipped (unfinished): ${st}`;
						row.gradeMode = mode;
						row.effectiveGradeMode = mode;
						out.push(row);
						continue;
					}
					if (!st && !hasOutput) {
						row.graded = false;
						row.isCorrect = null;
						row.note = 'Skipped (unfinished)';
						row.gradeMode = mode;
						row.effectiveGradeMode = mode;
						out.push(row);
						continue;
					}
					if (st && isTerminal === true && !hasOutput) {
						row.graded = true;
						row.isCorrect = false;
						row.note = `Empty output (${st})`;
						row.gradeMode = mode;
						row.effectiveGradeMode = mode;
						out.push(row);
						continue;
					}
				}
				if (!forceRegrade) {
					const modeNorm = (__benchmarkTrim(mode || '').toLowerCase() === 'answer_and_solution')
						? 'answer_and_solution'
						: 'answer_only';
					const rowMode = __benchmarkTrim(row?.effectiveGradeMode || row?.gradeMode || '').toLowerCase();
					const hasAnswerSignal = (typeof row?.answerCorrect === 'boolean');
					const hasSolutionSignal = (typeof row?.solutionCorrect === 'boolean');
					const canProjectFromSignals =
						(modeNorm === 'answer_only' && hasAnswerSignal) ||
						(modeNorm === 'answer_and_solution' && hasAnswerSignal && hasSolutionSignal);
					const sameMode = rowMode === modeNorm;
					const projected = __benchmarkProjectGradeVerdict(row, modeNorm);
					if ((sameMode || canProjectFromSignals) && projected.graded && typeof projected.isCorrect === 'boolean') {
						row.isCorrect = projected.isCorrect;
						row.graded = true;
						row.gradeMode = modeNorm;
						row.effectiveGradeMode = modeNorm;
						out.push(row);
						reusedCount += 1;
						continue;
					}
				}
				if (!forceRegrade && row.graded && __benchmarkTrim(row.gradeMode || '') === mode && typeof row.isCorrect === 'boolean') {
					out.push(row);
					reusedCount += 1;
					continue;
				}
				gradable.push({ row, problem: resolved.problem });
			}
			if (reusedCount > 0) {
				__benchmarkLog('INFO', 'Grade', `Reused pre-graded rows: ${reusedCount} (mode=${mode})`);
			}
			if (!gradable.length) {
				__benchmarkLog('INFO', 'Grade', `No rows require grading API calls (mode=${mode}).`);
			}

			if (gradable.length) {
				const gradeBudget = __benchmarkClampInt(chunkCfg.gradeSplitTokens, { min: 800, max: 200000, fallback: 12000 });
				const attemptIdOf = (item, fallback = 0) => __benchmarkBuildGradeAttemptId(item?.row || {}, fallback);
				const estimateAnswerTokens = (item) => {
					const row = item?.row || {};
					const payload = JSON.stringify({
						id: attemptIdOf(item, 0),
						arch: __benchmarkTrim(row?.archId || ''),
						instance: __benchmarkTrim(row?.instanceId || ''),
						answer: __benchmarkTrim(row?.finalResult || ''),
					});
					return Math.max(1, __benchmarkEstimateTokens(payload));
				};
				const estimateChunkAnswerTokens = (items) => {
					const list = Array.isArray(items) ? items : [];
					let sum = 0;
					for (const item of list) sum += estimateAnswerTokens(item);
					return sum;
				};
				const packGradeChunksByAnswers = (list, tokenBudget) => {
					const rows = Array.isArray(list) ? list : [];
					if (!rows.length) return [];
					const budget = __benchmarkClampInt(tokenBudget, { min: 800, max: 200000, fallback: 12000 });
					const chunks = [];
					let cur = [];
					let curTok = 0;
					for (const item of rows) {
						const tok = estimateAnswerTokens(item);
						if (cur.length && (curTok + tok > budget)) {
							chunks.push(cur);
							cur = [item];
							curTok = tok;
						} else {
							cur.push(item);
							curTok += tok;
						}
					}
					if (cur.length) chunks.push(cur);
					return chunks;
				};

				const byProblem = new Map();
				for (const item of gradable) {
					const qid = __benchmarkTrim(item?.problem?.qid || '');
					if (!byProblem.has(qid)) byProblem.set(qid, []);
					byProblem.get(qid).push(item);
				}

				let problemCursor = 0;
				for (const [qid, rowsForProblem] of byProblem.entries()) {
					problemCursor += 1;
					const gradeChunks = packGradeChunksByAnswers(rowsForProblem, gradeBudget);
					__benchmarkLog(
						'INFO',
						'Grade',
						`Problem ${problemCursor}/${byProblem.size} qid=${qid} | rows=${rowsForProblem.length} | chunks=${gradeChunks.length} | token_basis=answers_only`
					);

					const pendingById = new Map();
					const finalizedById = new Set();
					const registerMissing = (item, fallback = 0) => {
						const id = attemptIdOf(item, fallback);
						if (!id || finalizedById.has(id) || pendingById.has(id)) return;
						pendingById.set(id, item);
					};
					const finalizeRow = (item, gradeResult, fallback = 0) => {
						const id = attemptIdOf(item, fallback);
						if (!id || finalizedById.has(id)) return;
						const g = gradeResult || {
							finalAnswer: '',
							answerCorrect: null,
							solutionCorrect: null,
							isCorrect: false,
							note: `Missing grading result for ${id}.`,
						};
						__benchmarkApplyGradeResultToRow(item?.problem, item?.row, g, mode);
						out.push(item.row);
						finalizedById.add(id);
						pendingById.delete(id);
					};
					const processChunkResult = (chunkItems, batch, fallbackTag = '') => {
						const chunk = Array.isArray(chunkItems) ? chunkItems : [];
						const resultMap = (batch?.data instanceof Map) ? batch.data : new Map();
						const missingSet = new Set(Array.isArray(batch?.missingIds) ? batch.missingIds : []);
						for (let j = 0; j < chunk.length; j++) {
							const item = chunk[j] || {};
							const id = attemptIdOf(item, j);
							const got = resultMap.get(id) || null;
							if (got) {
								finalizeRow(item, got, j);
								continue;
							}
							registerMissing(item, j);
							if (!missingSet.has(id)) missingSet.add(id);
						}
						const missingCount = Array.from(missingSet).filter((id) => !finalizedById.has(id)).length;
						if (missingCount > 0) {
							__benchmarkLog(
								'WARN',
								'Grade',
								`qid=${qid} ${fallbackTag || 'chunk'} unresolved=${missingCount}. Deferred to later chunks with remaining budget.`
							);
						}
					};
					const takeAttachablePending = (remainingBudgetTokens) => {
						let remaining = Math.max(0, __benchmarkClampInt(remainingBudgetTokens, { min: 0, max: 200000, fallback: 0 }));
						if (remaining <= 0 || pendingById.size <= 0) return [];
						const picked = [];
						for (const [id, item] of pendingById.entries()) {
							const tok = estimateAnswerTokens(item);
							if (tok > remaining) continue;
							picked.push(item);
							remaining -= tok;
							pendingById.delete(id);
							if (remaining <= 0) break;
						}
						return picked;
					};

					for (let i = 0; i < gradeChunks.length; i++) {
						__benchmarkThrowIfTaskStopped('grade');
						const baseChunk = gradeChunks[i] || [];
						const baseTok = estimateChunkAnswerTokens(baseChunk);
						const attachable = takeAttachablePending(Math.max(0, gradeBudget - baseTok));
						const chunk = [...baseChunk, ...attachable];
						__benchmarkSetProgress(`Grading qid=${qid} chunk ${i + 1}/${gradeChunks.length} (${chunk.length} rows)`);
						__benchmarkLog(
							'INFO',
							'Grade',
							`qid=${qid} chunk ${i + 1}/${gradeChunks.length} started (base=${baseChunk.length}, attached_missing=${attachable.length}, total=${chunk.length})`
						);
						const batch = await __benchmarkGradeChunkBatch(chunk, mode, `Grade qid=${qid} C${i + 1}/${gradeChunks.length}`);
						processChunkResult(chunk, batch, `chunk ${i + 1}/${gradeChunks.length}`);
						if (onProgress) {
							try { onProgress(__benchmarkSafeClone(workRows)); } catch { }
						}
						__benchmarkLog('SUCCESS', 'Grade', `qid=${qid} chunk ${i + 1}/${gradeChunks.length} finished`);
					}

					for (let round = 1; round <= 4 && pendingById.size > 0; round++) {
						__benchmarkThrowIfTaskStopped('grade');
						const before = pendingById.size;
						const pendingList = Array.from(pendingById.values());
						const retryChunks = packGradeChunksByAnswers(pendingList, gradeBudget);
						__benchmarkLog('INFO', 'Grade', `qid=${qid} deferred retry round ${round}: pending=${before}, chunks=${retryChunks.length}`);
						for (let i = 0; i < retryChunks.length; i++) {
							__benchmarkThrowIfTaskStopped('grade');
							const chunk = retryChunks[i] || [];
							for (const item of chunk) pendingById.delete(attemptIdOf(item, 0));
							const batch = await __benchmarkGradeChunkBatch(chunk, mode, `Grade qid=${qid} RETRY${round} C${i + 1}/${retryChunks.length}`);
							processChunkResult(chunk, batch, `retry ${round} chunk ${i + 1}/${retryChunks.length}`);
							if (onProgress) {
								try { onProgress(__benchmarkSafeClone(workRows)); } catch { }
							}
						}
						if (pendingById.size >= before) {
							__benchmarkLog('WARN', 'Grade', `qid=${qid} deferred retry round ${round}: no progress. Switching to single-item fallback.`);
							break;
						}
					}

					if (pendingById.size > 0) {
						const leftovers = Array.from(pendingById.values());
						__benchmarkLog('WARN', 'Grade', `qid=${qid} unresolved after deferred retries: ${leftovers.length}. Running single-item fallback.`);
						for (let i = 0; i < leftovers.length; i++) {
							__benchmarkThrowIfTaskStopped('grade');
							const item = leftovers[i] || {};
							const id = attemptIdOf(item, i);
							const batch = await __benchmarkGradeChunkBatch([item], mode, `Grade qid=${qid} FINAL-S${i + 1}/${leftovers.length}`);
							const got = (batch?.data instanceof Map) ? batch.data.get(id) : null;
							if (got) {
								finalizeRow(item, got, i);
								continue;
							}
							finalizeRow(item, {
								finalAnswer: '',
								answerCorrect: null,
								solutionCorrect: null,
								isCorrect: false,
								note: `Missing grading result for ${id} after deferred+single retries.`,
							}, i);
						}
					}
				}
			}

			const mergeGroups = __benchmarkChunkItemsByToken(
				out,
				chunkCfg.gradeMergeTokens,
				(r) => JSON.stringify({
					qid: r?.problemQid || '',
					arch: r?.archId || '',
					instanceId: r?.instanceId || '',
					runIndex: r?.runIndex || '',
					graded: r?.graded,
					isCorrect: r?.isCorrect,
					note: r?.note || '',
				}),
				400
			);
			if (mergeGroups.length > 1) {
				__benchmarkLog('INFO', 'GradeMerge', `Merging graded rows in ${mergeGroups.length} buckets (merge=${chunkCfg.gradeMergeTokens})`);
			}

			const merged = [];
			for (let i = 0; i < mergeGroups.length; i++) {
				const group = mergeGroups[i] || [];
				for (const row of group) merged.push(row);
				if (mergeGroups.length > 1) {
					__benchmarkLog('INFO', 'GradeMerge', `Merged bucket ${i + 1}/${mergeGroups.length} (${group.length} rows)`);
				}
			}

			merged.sort((a, b) => (a.__origIndex || 0) - (b.__origIndex || 0));
			merged.forEach(r => { try { delete r.__origIndex; } catch { } });
			return merged;
		}

			function __benchmarkIsTerminalAgentStatus(statusRaw) {
				const s = __benchmarkTrim(statusRaw || '').toLowerCase();
				if (!s) return false;
				if (s.includes('success')) return true;
				if (s.includes('failed')) return true;
				if (s.includes('error')) return true;
				return false;
			}

			function __benchmarkResolveRunProblemScope(dataset) {
				const ds = dataset || {};
				const probs = Array.isArray(ds?.problems) ? ds.problems : [];
				const runFilterEnabled = !!document.getElementById('benchmarkRunFilterEnabled')?.checked;
				const runFilterRaw = runFilterEnabled
					? __benchmarkTrim(document.getElementById('benchmarkProblemFilter')?.value || '')
					: '';
				const runFilterLower = (runFilterRaw || '').toLowerCase();
				const explicitRunProblemIndices = (runFilterEnabled && runFilterRaw)
					? __benchmarkParseExplicitProblemIndices(runFilterRaw, probs.length)
					: null;
				const runProblemIndices = (runFilterEnabled && runFilterLower)
					? (Array.isArray(explicitRunProblemIndices)
						? explicitRunProblemIndices
						: probs
							.map((p, idx) => ({ idx, ok: __benchmarkProblemMatchesTextFilter(p || {}, runFilterLower, idx) }))
							.filter((item) => item.ok)
							.map((item) => item.idx))
					: null;
				const hasActiveFilter = !!(runFilterEnabled && runFilterLower);
				return {
					runFilterEnabled,
					runFilterRaw,
					runFilterLower,
					runProblemIndices,
					hasActiveFilter,
				};
			}

			function __benchmarkResolvePendingSpawnRunTargets() {
				const rawPending = Array.isArray(__benchmarkStudio.pendingSpawnUniqueIds)
					? __benchmarkStudio.pendingSpawnUniqueIds
					: [];
				const pendingSet = new Set(rawPending.map((id) => __benchmarkTrim(id || '')).filter(Boolean));
				if (!pendingSet.size) return [];
				const byUid = new Map();
				(agents || []).forEach((agent) => {
					const uid = __benchmarkTrim(agent?.uniqueId || '');
					if (uid) byUid.set(uid, agent);
				});
				const keep = [];
				const targets = [];
				for (const uid of pendingSet.values()) {
					const agent = byUid.get(uid);
					if (!agent) continue;
					const meta = (agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object') ? agent.benchmarkMeta : null;
					if (!meta) continue;
					if (__benchmarkIsTerminalAgentStatus(agent?.state?.status || '')) continue;
					keep.push(uid);
					targets.push(uid);
				}
				__benchmarkStudio.pendingSpawnUniqueIds = keep;
				if (!keep.length) __benchmarkStudio.manualSpawnMode = false;
				return targets;
			}

			async function __benchmarkRunIncrementalSpawned(options = {}) {
				if (__benchmarkStudio.isRunning) {
					__benchmarkSetProgress('Benchmark run already in progress');
					return;
				}
				const ds = __benchmarkStudio.dataset;
				if (!ds?.problems?.length) {
					alert('Load or convert a benchmark first.');
					return;
				}
				const opts = (options && typeof options === 'object') ? options : {};
				const mode = (document.getElementById('benchmarkGradeMode')?.value || 'answer_only').toString();
				const autoGrade = !!document.getElementById('benchmarkAutoGrade')?.checked;
				let runTargetIds = Array.isArray(opts.targetUniqueIds)
					? opts.targetUniqueIds.map((id) => __benchmarkTrim(id || '')).filter(Boolean)
					: __benchmarkResolvePendingSpawnRunTargets();
				if (!runTargetIds.length && __benchmarkStudio.manualSpawnMode) {
					runTargetIds = (agents || [])
						.filter((agent) => !!(agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object'))
						.filter((agent) => !__benchmarkIsTerminalAgentStatus(agent?.state?.status || ''))
						.map((agent) => __benchmarkTrim(agent?.uniqueId || ''))
						.filter(Boolean);
				}
				if (!runTargetIds.length) {
					alert('No pending spawned benchmark agents to run.');
					__benchmarkStudio.manualSpawnMode = false;
					__benchmarkStudio.pendingSpawnUniqueIds = [];
					saveToLocalStorage();
					return;
				}

				__benchmarkStudio.isRunning = true;
				__benchmarkSetButtonsDisabled(true);
				__benchmarkSetProgress(`Running pending spawned benchmark agents (${runTargetIds.length})`);
				__benchmarkLog('INFO', 'RunSpawn', `Running pending spawned benchmark agents: ${runTargetIds.length}`);
				try {
					await startComparison({
						benchmarkMode: true,
						skipPausedJobs: true,
						disableExtraProblemWindows: true,
						runOnlyUniqueIds: runTargetIds,
					});

					let rows = __benchmarkCollectRowsFromAgents({
						selectedIds: null,
						mode,
						existingRows: __benchmarkStudio.lastRunRows,
					});
					if (!rows.length) rows = (__benchmarkStudio.lastRunRows || []).map((r) => ({ ...(r || {}) }));
					if (autoGrade) {
						__benchmarkLog('INFO', 'AutoGrade', `Start auto-grade (incremental): rows=${rows.length}, mode=${mode}`);
						rows = await __benchmarkGradeRows(rows, mode, { skipUnfinished: true });
						__benchmarkLog('SUCCESS', 'AutoGrade', `Auto-grade complete (incremental): rows=${rows.length}, mode=${mode}`);
					}

					__benchmarkStudio.lastRunRows = rows;
					__benchmarkStudio.lastGradeMode = mode;
					__benchmarkRenderGradeOutput(rows, mode);

					const pendingSet = new Set(
						(Array.isArray(__benchmarkStudio.pendingSpawnUniqueIds) ? __benchmarkStudio.pendingSpawnUniqueIds : [])
							.map((id) => __benchmarkTrim(id || ''))
							.filter(Boolean)
					);
					const byUid = new Map();
					(agents || []).forEach((agent) => {
						const uid = __benchmarkTrim(agent?.uniqueId || '');
						if (uid) byUid.set(uid, agent);
					});
					for (const uid of runTargetIds) {
						const agent = byUid.get(uid);
						if (!agent || __benchmarkIsTerminalAgentStatus(agent?.state?.status || '')) {
							pendingSet.delete(uid);
						}
					}
					__benchmarkStudio.pendingSpawnUniqueIds = Array.from(pendingSet);
					if (__benchmarkStudio.pendingSpawnUniqueIds.length === 0) {
						__benchmarkStudio.manualSpawnMode = false;
					}
					__benchmarkSetProgress(`Incremental run complete: rows=${rows.length}, pending=${__benchmarkStudio.pendingSpawnUniqueIds.length}`);
					__benchmarkLog(
						'SUCCESS',
						'RunSpawn',
						`Incremental run complete: rows=${rows.length}, pending=${__benchmarkStudio.pendingSpawnUniqueIds.length}`
					);
				} catch (e) {
					const rows = __benchmarkCollectRowsFromAgents({
						selectedIds: null,
						mode,
						existingRows: __benchmarkStudio.lastRunRows,
					});
					__benchmarkStudio.lastRunRows = rows;
					__benchmarkStudio.lastGradeMode = mode;
					__benchmarkRenderGradeOutput(rows, mode);
					__benchmarkSetProgress('Incremental benchmark run failed');
					__benchmarkLog('ERROR', 'RunSpawn', `Incremental run failed: ${e?.message || e}`);
					throw e;
				} finally {
					__benchmarkStudio.isRunning = false;
					__benchmarkSetButtonsDisabled(false);
					saveToLocalStorage();
				}
			}

			function __benchmarkSpawnMoreForLoadedDataset() {
				const ds = __benchmarkStudio?.dataset;
				if (!ds?.problems?.length) {
					alert('Load or convert a benchmark first.');
					return { spawned: 0, changes: [] };
				}
				const selectedNorm = __benchmarkNormalizeSelectionForSignature(__benchmarkGetSelectedArchitectures());
				if (!selectedNorm.length) {
					alert('Select architectures first (checkboxes).');
					return { spawned: 0, changes: [] };
				}
				const scope = __benchmarkResolveRunProblemScope(ds);
				if (scope.hasActiveFilter && (!scope.runProblemIndices || scope.runProblemIndices.length === 0)) {
					alert('No benchmark problems match the filter. Clear the filter or disable the run filter.');
					return { spawned: 0, changes: [] };
				}
				const assignments = __benchmarkBuildRunAssignments(ds, selectedNorm, {
					problemIndices: scope.runProblemIndices || null,
				});
				if (!assignments.length) {
					alert('No benchmark assignments generated from the current selection/filter.');
					return { spawned: 0, changes: [] };
				}

				const existingUids = new Set(
					(agents || [])
						.map((agent) => __benchmarkTrim(agent?.uniqueId || ''))
						.filter(Boolean)
				);
				const pending = assignments
					.map((a) => ({
						...(a || {}),
						uid: `${__benchmarkTrim(a?.archId || '')}-${__benchmarkTrim(a?.instanceId || '')}`,
					}))
					.filter((a) => !!a.uid && !existingUids.has(a.uid));
				if (!pending.length) {
					alert('No new benchmark agents needed for the current filter/selection.');
					return { spawned: 0, changes: [] };
				}

				const byArch = new Map();
				pending.forEach((a) => {
					const id = __benchmarkTrim(a?.archId || '');
					if (!id) return;
					byArch.set(id, (byArch.get(id) || 0) + 1);
				});
				const changes = Array.from(byArch.entries())
					.sort((a, b) => a[0].localeCompare(b[0]))
					.map(([archId, add]) => ({ archId, add }));
				const preview = pending
					.slice(0, 10)
					.map((a) => `${__benchmarkTrim(a?.problemQid || '')} | ${a.archId}#${a.instanceId}`)
					.join('\n');
				const more = pending.length > 10 ? `\n‚Ä¶(+${pending.length - 10} more)` : '';
				const filterNote = scope.hasActiveFilter ? `\nFilter: ${scope.runFilterRaw}` : '';
				if (!confirm(`Spawn ${pending.length} benchmark agent(s)?${filterNote}\n\n${preview}${more}`)) {
					return { spawned: 0, changes: [] };
				}

				let spawned = 0;
				const spawnedUids = [];
				for (const a of pending) {
					const def = ARCH_DEFINITIONS.find((d) => d && d.id === a.archId);
					if (!def) continue;
					createAgentUI(def, a.instanceId, {
						benchmarkMeta: {
							problemIndex: a.problemIndex,
							problemQid: a.problemQid,
							runIndex: a.runIndex,
						},
					});
					const agent = agents[agents.length - 1];
					if (!agent) continue;
					agent.jobQuery = a.query;
					agent.benchmarkMeta = {
						problemIndex: a.problemIndex,
						problemQid: a.problemQid,
						runIndex: a.runIndex,
					};
					spawned += 1;
					spawnedUids.push(__benchmarkTrim(agent?.uniqueId || a.uid));
				}

				const pendingSet = new Set(
					(Array.isArray(__benchmarkStudio.pendingSpawnUniqueIds) ? __benchmarkStudio.pendingSpawnUniqueIds : [])
						.map((id) => __benchmarkTrim(id || ''))
						.filter(Boolean)
				);
				spawnedUids.filter(Boolean).forEach((uid) => pendingSet.add(uid));
				__benchmarkStudio.pendingSpawnUniqueIds = Array.from(pendingSet);
				__benchmarkStudio.manualSpawnMode = true;
				__benchmarkStudio.runCheckpoint = null;

				try { updateAnalysisGroupOptions(); } catch { }
				try { updateAnalysisArchOptions(); } catch { }
				try { updateAnalysisPanel(); } catch { }
				try { saveToLocalStorage(); } catch { }

				__benchmarkSetProgress(`Spawned ${spawned} benchmark agents (pending run=${__benchmarkStudio.pendingSpawnUniqueIds.length})`);
				__benchmarkLog(
					'INFO',
					'SpawnMore',
					`Spawned benchmark agents: ${spawned}, pending=${__benchmarkStudio.pendingSpawnUniqueIds.length}`
				);
				alert(
					`Spawned ${spawned} benchmark agent(s).\n\n` +
					`Run/Resume will execute pending spawned agents only, and grading reuses previous results.`
				);
				return { spawned, changes };
			}

			async function __benchmarkRunFilteredFromUi() {
				const ds = __benchmarkStudio.dataset;
				if (!ds?.problems?.length) {
					alert('Load or convert a benchmark first.');
					return;
				}
				const filterEl = document.getElementById('benchmarkProblemFilter');
				const raw = __benchmarkTrim(filterEl?.value || '');
				if (!raw) {
					alert('Enter a filter first. Examples: 1, 3-5, Problem 8, AMC12-2023-7');
					try { filterEl?.focus?.(); } catch { }
					return;
				}
				const chk = document.getElementById('benchmarkRunFilterEnabled');
				if (chk) chk.checked = true;
				try { saveToLocalStorage(); } catch { }
				await __benchmarkRunSuite();
			}

				async function __benchmarkRunSuite() {
					if (__benchmarkStudio.isRunning) {
						__benchmarkSetProgress('Run suite already in progress');
						__benchmarkLog('WARN', 'RunSuite', 'Ignored duplicate start: run suite already running.');
					return;
				}
				try {
					__benchmarkUpsertDatasetFromUiProblems({
						allowWhenNoDataset: false,
						syncOrigins: ['ui-sync'],
					});
				} catch { }
					const ds = __benchmarkStudio.dataset;
					if (!ds?.problems?.length) {
						alert('Load or convert a benchmark first.');
						return;
					}
					// Full run-suite owns the benchmark agent lifecycle; reset incremental spawn tracking.
					__benchmarkStudio.manualSpawnMode = false;
					__benchmarkStudio.pendingSpawnUniqueIds = [];
					if (!__benchmarkStudio.appliedToUi) {
						try { __benchmarkApplyProblemsToUi(); } catch { }
					}

				let selected = __benchmarkGetSelectedArchitectures();
				if (!selected.length) {
					const checkpointSelection = __benchmarkNormalizeSelectionForSignature(__benchmarkStudio?.runCheckpoint?.selected || []);
					if (checkpointSelection.length) {
						selected = checkpointSelection;
						try { __benchmarkApplyArchSelection(selected); } catch { }
						__benchmarkLog('WARN', 'RunSuite', `No architecture selected in UI. Reusing checkpoint selection: ${selected.map(s => `${s.archId}x${s.count}`).join(', ')}`);
					}
				}
				if (!selected.length) {
						const fallbackIds = ['test43-2-rcap35', 'pass@1'].filter((id) => ARCH_DEFINITIONS.some((d) => d?.id === id));
					if (fallbackIds.length) {
						selected = fallbackIds.map((id) => ({ archId: id, count: 1 }));
						try { __benchmarkApplyArchSelection(selected); } catch { }
						__benchmarkLog('WARN', 'RunSuite', `No architecture selected in UI. Applying fallback selection: ${fallbackIds.join(', ')}`);
					}
				}
				if (!selected.length) {
					alert('Select at least one architecture.');
					return;
				}

				const mode = (document.getElementById('benchmarkGradeMode')?.value || 'answer_only').toString();
				const autoGrade = !!document.getElementById('benchmarkAutoGrade')?.checked;
				const originalArchUiSelection = __benchmarkCaptureArchUiSelectionState();
				const selectedNorm = __benchmarkNormalizeSelectionForSignature(selected);
				const selectedIds = new Set(selectedNorm.map((s) => s.archId));
				const selectedSummary = selectedNorm.map((s) => `${s.archId}x${s.count}`).join(', ');
				__benchmarkLog('INFO', 'RunSuite', `Resolved architecture selection: ${selectedSummary || '(none)'}`);

					const runFilterEnabled = !!document.getElementById('benchmarkRunFilterEnabled')?.checked;
					const runFilterRaw = runFilterEnabled
						? __benchmarkTrim(document.getElementById('benchmarkProblemFilter')?.value || '')
						: '';
					const runFilterLower = (runFilterRaw || '').toLowerCase();
					const explicitRunProblemIndices = (runFilterEnabled && runFilterRaw)
						? __benchmarkParseExplicitProblemIndices(runFilterRaw, ds.problems.length)
						: null;
					const runProblemIndices = (runFilterEnabled && runFilterLower)
						? (Array.isArray(explicitRunProblemIndices)
							? explicitRunProblemIndices
							: ds.problems
								.map((p, idx) => ({ idx, ok: __benchmarkProblemMatchesTextFilter(p || {}, runFilterLower, idx) }))
								.filter((item) => item.ok)
								.map((item) => item.idx))
						: null;
					if (runFilterEnabled && runFilterLower && (!runProblemIndices || runProblemIndices.length === 0)) {
						alert('No benchmark problems match the filter. Clear the filter or disable the run filter.');
						return;
					}

				const assignments = __benchmarkBuildRunAssignments(ds, selectedNorm, { problemIndices: runProblemIndices || null });
				if (!assignments.length) throw new Error('No benchmark assignments generated.');
				const problemIndexSet = new Set(assignments.map((a) => __benchmarkClampInt(a?.problemIndex, { min: 0, max: 1000000, fallback: -1 })).filter((x) => x >= 0));
				const totalProblems = problemIndexSet.size;
				const expectedTotalRows = assignments.length;

				const subsetSig = (() => {
					if (!runFilterEnabled || !runFilterLower) return '';
					if (totalProblems === ds.problems.length) return '';
					const qids = Array.from(problemIndexSet)
						.sort((a, b) => a - b)
						.map((idx) => __benchmarkTrim(ds.problems?.[idx]?.qid || `Q${idx + 1}`) || `Q${idx + 1}`);
					return `${qids.length}:${__benchmarkHash32(qids.join('|'))}`;
				})();
				const runSignature = __benchmarkBuildRunSignature(ds, selectedNorm, mode, autoGrade, { subsetSig });
				const dsSignature = __benchmarkDatasetSignature(ds);
				const artifacts = __benchmarkEnsureArtifacts();
				const checkpoint = __benchmarkNormalizeRunCheckpoint(__benchmarkStudio.runCheckpoint || null);
				let rows = [];
				let resumed = false;
				let runSession = null;
				let failed = false;
				let setupAgents = true;

				if (
					checkpoint &&
					checkpoint.status === 'running' &&
					checkpoint.signature &&
					checkpoint.signature === runSignature &&
					Array.isArray(checkpoint.rows)
				) {
					rows = checkpoint.rows.map((r) => ({ ...(r || {}) }));
					resumed = rows.length > 0;
					if (checkpoint.run_session_id) {
						runSession = (Array.isArray(artifacts.runSessions) ? artifacts.runSessions : [])
							.find((s) => __benchmarkTrim(s?.id || '') === checkpoint.run_session_id) || null;
					}
				}

				const existingTaggedAgents = (agents || []).filter((agent) => {
					if (!agent) return false;
					const archId = __benchmarkTrim(agent?.config?.id || '');
					if (!selectedIds.has(archId)) return false;
					const meta = (agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object') ? agent.benchmarkMeta : null;
					if (!meta) return false;
					const cardId = `agent-card-${__benchmarkTrim(agent?.uniqueId || '')}`;
					if (!cardId || !document.getElementById(cardId)) return false;
					const qid = __benchmarkTrim(meta.problemQid || '');
					const pIdx = __benchmarkClampInt(meta.problemIndex, { min: 0, max: 1000000, fallback: -1 });
					return !!qid && pIdx >= 0;
				});

				const existingRunnableTaggedAgents = existingTaggedAgents.filter((agent) => {
					const st = __benchmarkTrim(agent?.state?.status || '');
					return !(st === 'Success' || st === 'Failed');
				});
				const expectedUids = new Set(assignments.map((a) => `${__benchmarkTrim(a?.archId || '')}-${__benchmarkTrim(a?.instanceId || '')}`));
				const existingUids = new Set(existingTaggedAgents.map((agent) => __benchmarkTrim(agent?.uniqueId || '')));
				const exactUidMatch =
					existingTaggedAgents.length === expectedUids.size &&
					existingUids.size === expectedUids.size &&
					Array.from(expectedUids).every((uid) => existingUids.has(uid));
				const canReuseExistingAgents = exactUidMatch && existingRunnableTaggedAgents.length > 0;

				if (canReuseExistingAgents) {
					setupAgents = false;
					resumed = true;
					rows = __benchmarkCollectRowsFromAgents({ selectedIds, mode, existingRows: rows });
				} else if (existingTaggedAgents.length > 0) {
					__benchmarkLog(
						'WARN',
						'RunSuite',
						`Ignoring stale/incomplete benchmark agents and creating fresh set (existing=${existingTaggedAgents.length}, expected=${expectedTotalRows}, runnable=${existingRunnableTaggedAgents.length})`
					);
				}

				__benchmarkStudio.isRunning = true;
				__benchmarkSetButtonsDisabled(true);
				const filterNote = (runFilterEnabled && runFilterLower)
					? ` (filtered: ${__benchmarkPreview(runFilterRaw, 48)})`
					: '';
				__benchmarkSetProgress(`${resumed ? 'Resuming' : 'Running'} benchmark suite: ${totalProblems} problems / ${expectedTotalRows} runs${filterNote}`);
				__benchmarkLog(
					'INFO',
					'RunSuite',
					`${resumed ? 'Resume' : 'Start'} all-problems run | problems=${totalProblems} | expected_rows=${expectedTotalRows} | arch=${selectedSummary} | mode=${mode} | autoGrade=${autoGrade}${filterNote}`
				);

				if (!runSession) {
					runSession = __benchmarkRecordRunSession({
						status: 'running',
						mode,
						auto_grade: autoGrade,
						benchmark_name: __benchmarkTrim(ds?.name || ''),
						problem_filter_enabled: !!(runFilterEnabled && runFilterLower),
						problem_filter: runFilterRaw || '',
						problem_subset_sig: subsetSig || '',
						problem_count: Number(totalProblems || 0),
						expected_rows_total: Number(expectedTotalRows || 0),
						strategy: 'all_at_once',
						architectures: selectedNorm.map((s) => ({ archId: s.archId, count: s.count })),
						resumed,
						rows: __benchmarkSafeClone(rows),
					});
				} else {
					runSession.status = 'running';
					runSession.mode = mode;
					runSession.auto_grade = autoGrade;
					runSession.problem_filter_enabled = !!(runFilterEnabled && runFilterLower);
					runSession.problem_filter = runFilterRaw || '';
					runSession.problem_subset_sig = subsetSig || '';
					runSession.problem_count = Number(totalProblems || 0);
					runSession.expected_rows_total = Number(expectedTotalRows || 0);
					runSession.strategy = 'all_at_once';
					runSession.architectures = selectedNorm.map((s) => ({ archId: s.archId, count: s.count }));
					runSession.rows = __benchmarkSafeClone(rows);
					runSession.resumed = true;
					runSession.updated_at = Date.now();
					__benchmarkTouchArtifacts();
				}

				__benchmarkStudio.runCheckpoint = __benchmarkNormalizeRunCheckpoint({
					status: 'running',
					created_at: checkpoint?.created_at || Date.now(),
					updated_at: Date.now(),
					signature: runSignature,
					dataset_signature: dsSignature,
					mode,
					auto_grade: autoGrade,
					total_problems: totalProblems,
					next_problem_index: 0,
					rows,
					run_session_id: __benchmarkTrim(runSession?.id || ''),
					selected: selectedNorm,
					note: setupAgents ? 'setup-agents' : 'resume-existing-agents',
				});
				__benchmarkSchedulePersist(50);

				try {
					if (setupAgents) {
						clearAll(false);
						__benchmarkLog('INFO', 'RunSuite', `Creating benchmark agents: ${assignments.length} assignments`);
						let created = 0;
						for (const a of assignments) {
							const def = ARCH_DEFINITIONS.find(d => d && d.id === a.archId);
							if (!def) continue;
							createAgentUI(def, a.instanceId, {
								benchmarkMeta: {
									problemIndex: a.problemIndex,
									problemQid: a.problemQid,
									runIndex: a.runIndex,
								},
							});
							const agent = agents[agents.length - 1];
							if (agent) {
								agent.jobQuery = a.query;
								agent.benchmarkMeta = {
									problemIndex: a.problemIndex,
									problemQid: a.problemQid,
									runIndex: a.runIndex,
								};
								created += 1;
							}
						}
						__benchmarkLog('INFO', 'RunSuite', `Benchmark agent creation result: created=${created}, agents_total=${agents.length}`);
						if (!agents.length || created === 0) throw new Error('Benchmark agent creation failed: 0 agents created.');
						try { updateAnalysisGroupOptions(); } catch { }
						try { updateAnalysisArchOptions(); } catch { }
					} else {
						const qByQid = new Map(ds.problems.map((p) => [__benchmarkTrim(p?.qid || ''), __benchmarkProblemToPrompt(p)]));
						(agents || []).forEach((agent) => {
							if (!agent) return;
							const archId = __benchmarkTrim(agent?.config?.id || '');
							if (!selectedIds.has(archId)) return;
							const meta = (agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object') ? agent.benchmarkMeta : null;
							const qid = __benchmarkTrim(meta?.problemQid || '');
							const q = qByQid.get(qid);
							if (q) agent.jobQuery = q;
						});
						__benchmarkLog('INFO', 'RunSuite', `Using existing benchmark agents: ${existingTaggedAgents.length}`);

						const runnableResumed = (agents || []).filter((agent) => {
							if (!agent) return false;
							const archId = __benchmarkTrim(agent?.config?.id || '');
							if (!selectedIds.has(archId)) return false;
							const meta = (agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object') ? agent.benchmarkMeta : null;
							if (!meta) return false;
							const st = __benchmarkTrim(agent?.state?.status || '');
							return !(st === 'Success' || st === 'Failed');
						}).length;
						if (runnableResumed === 0) {
							__benchmarkLog('WARN', 'RunSuite', 'Resumed agent set has no runnable agents. Rebuilding fresh benchmark agents.');
							clearAll(false);
							let created = 0;
							for (const a of assignments) {
								const def = ARCH_DEFINITIONS.find(d => d && d.id === a.archId);
								if (!def) continue;
								createAgentUI(def, a.instanceId, {
									benchmarkMeta: {
										problemIndex: a.problemIndex,
										problemQid: a.problemQid,
										runIndex: a.runIndex,
									},
								});
								const agent = agents[agents.length - 1];
								if (agent) {
									agent.jobQuery = a.query;
									agent.benchmarkMeta = {
										problemIndex: a.problemIndex,
										problemQid: a.problemQid,
										runIndex: a.runIndex,
									};
									created += 1;
								}
							}
							__benchmarkLog('INFO', 'RunSuite', `Rebuild creation result: created=${created}, agents_total=${agents.length}`);
							if (!agents.length || created === 0) throw new Error('Benchmark agent creation failed: 0 agents created.');
							try { updateAnalysisGroupOptions(); } catch { }
							try { updateAnalysisArchOptions(); } catch { }
						}
					}

					__benchmarkSetProgress(`Running all benchmark problems together (${expectedTotalRows} runs)`);
					await startComparison({
						benchmarkMode: true,
						skipPausedJobs: true,
						disableExtraProblemWindows: true,
						selectionOverride: selectedNorm,
					});

					rows = __benchmarkCollectRowsFromAgents({ selectedIds, mode, existingRows: rows });
					if (rows.length !== expectedTotalRows) {
						__benchmarkLog('WARN', 'RunSuite', `Row count mismatch after run: expected=${expectedTotalRows}, observed=${rows.length}`);
					}

					if (autoGrade) {
						__benchmarkLog('INFO', 'AutoGrade', `Start auto-grade: rows=${rows.length}, mode=${mode} (problem-grouped chunking)`);
						rows = await __benchmarkGradeRows(rows, mode);
						__benchmarkStudio.lastRunRows = rows;
						__benchmarkLog('SUCCESS', 'AutoGrade', `Auto-grade complete: rows=${rows.length}, mode=${mode}`);
					}

					const incomplete = (agents || []).some((agent) => {
						if (!agent) return false;
						const archId = __benchmarkTrim(agent?.config?.id || '');
						if (!selectedIds.has(archId)) return false;
						const meta = (agent?.benchmarkMeta && typeof agent.benchmarkMeta === 'object') ? agent.benchmarkMeta : null;
						if (!meta) return false;
						const st = __benchmarkTrim(agent?.state?.status || '');
						return !(st === 'Success' || st === 'Failed');
					});

					__benchmarkRenderGradeOutput(rows, mode);
					if (incomplete) {
						__benchmarkSetProgress('Run suite paused: incomplete agents detected');
						__benchmarkLog('WARN', 'RunSuite', 'Run paused with incomplete benchmark agents. Resume is available.');
						__benchmarkStudio.runCheckpoint = __benchmarkNormalizeRunCheckpoint({
							status: 'running',
							created_at: (__benchmarkStudio.runCheckpoint?.created_at || Date.now()),
							updated_at: Date.now(),
							signature: runSignature,
							dataset_signature: dsSignature,
							mode,
							auto_grade: autoGrade,
							total_problems: totalProblems,
							next_problem_index: 0,
							rows,
							run_session_id: __benchmarkTrim(runSession?.id || ''),
							selected: selectedNorm,
							note: 'paused-incomplete',
						});
						if (runSession && runSession.status !== 'failed') {
							runSession.status = 'paused';
							runSession.rows = __benchmarkSafeClone(rows);
							runSession.finished_at = Date.now();
							__benchmarkTouchArtifacts();
						}
					} else {
						__benchmarkStudio.runCheckpoint = null;
						__benchmarkSetProgress(`Run suite finished: ${rows.length} rows`);
						__benchmarkLog('INFO', 'RunSuite', `Finished all-problems run. total_rows=${rows.length}`);
						if (runSession && runSession.status !== 'failed') {
							runSession.status = 'success';
							runSession.rows = __benchmarkSafeClone(rows);
							runSession.finished_at = Date.now();
							__benchmarkTouchArtifacts();
						}
					}
				} catch (e) {
					failed = true;
					rows = __benchmarkCollectRowsFromAgents({ selectedIds, mode, existingRows: rows });
					__benchmarkRenderGradeOutput(rows, mode);
					__benchmarkSetProgress('Run suite failed');
					__benchmarkLog('ERROR', 'RunSuite', `Run suite failed: ${e?.message || e}`);
					if (runSession) {
						runSession.status = 'failed';
						runSession.error = __benchmarkString(e?.message || e);
						runSession.rows = __benchmarkSafeClone(rows);
						runSession.finished_at = Date.now();
						__benchmarkTouchArtifacts();
					}
					__benchmarkStudio.runCheckpoint = __benchmarkNormalizeRunCheckpoint({
						status: 'running',
						created_at: (__benchmarkStudio.runCheckpoint?.created_at || Date.now()),
						updated_at: Date.now(),
						signature: runSignature,
						dataset_signature: dsSignature,
						mode,
						auto_grade: autoGrade,
						total_problems: totalProblems,
						next_problem_index: 0,
						rows,
						run_session_id: __benchmarkTrim(runSession?.id || ''),
						selected: selectedNorm,
						note: `failed: ${__benchmarkString(e?.message || e)}`,
					});
					__benchmarkSchedulePersist(50);
					throw e;
				} finally {
					__benchmarkStudio.isRunning = false;
					__benchmarkStudio.lastRunRows = rows;
					__benchmarkStudio.lastGradeMode = mode;
					__benchmarkSetButtonsDisabled(false);
					__benchmarkRestoreArchUiSelectionState(originalArchUiSelection);
					if (!failed && !__benchmarkStudio.runCheckpoint) {
						__benchmarkLog('SUCCESS', 'RunSuite', `Completed run suite. rows=${rows.length}`);
					}
					saveToLocalStorage();
				}
			}

		async function __benchmarkDebugSmokeRun(options = {}) {
			const opts = (options && typeof options === 'object') ? options : {};
			const useArch = Array.isArray(opts.archIds) && opts.archIds.length
				? opts.archIds
				: ['pass@1'];
			const count = __benchmarkClampInt(opts.count, { min: 1, max: 50, fallback: 1 });
			const forceDataset = !!opts.forceDataset;
			try {
				const mockEl = document.getElementById('mockModeChk');
				if (mockEl) mockEl.checked = true;
			} catch { }

			if (forceDataset || !(__benchmarkStudio?.dataset?.problems?.length)) {
				const ds = __benchmarkNormalizeDataset({
					version: __BENCHMARK_SCHEMA_VERSION,
					name: 'debug-smoke',
					description: 'Auto-generated smoke benchmark',
					problems: [{
						qid: 'DBG-1',
						question_text: '2+2=?',
						answer_choices: '',
						official_answer: '4',
						official_explanation: '2+2=4',
						grading_mode: 'answer_only',
						solution_keywords: [],
						solution_regex: '',
						grading_rubric: '',
					}],
				}, 'debug-smoke');
				__benchmarkSetDataset(ds);
			}

			try { __benchmarkApplyProblemsToUi(); } catch { }
			const selection = useArch
				.filter((id) => ARCH_DEFINITIONS.some((d) => d?.id === id))
				.map((archId) => ({ archId, count }));
			if (!selection.length) throw new Error('No valid architecture for smoke run.');
			__benchmarkApplyArchSelection(selection);

			const beforeAgents = Array.isArray(agents) ? agents.length : 0;
			__benchmarkLog('INFO', 'DebugSmoke', `Start smoke run | arch=${selection.map(s => `${s.archId}x${s.count}`).join(', ')}`);
			await __benchmarkRunSuite();
			const afterAgents = Array.isArray(agents) ? agents.length : 0;
			const rows = Array.isArray(__benchmarkStudio.lastRunRows) ? __benchmarkStudio.lastRunRows : [];
			const out = {
				ok: true,
				beforeAgents,
				afterAgents,
				rows: rows.length,
				selection,
				datasetProblems: Number(__benchmarkStudio?.dataset?.problems?.length || 0),
			};
			__benchmarkLog('SUCCESS', 'DebugSmoke', `Smoke run finished | agents=${afterAgents}, rows=${rows.length}`);
			return out;
		}

		try { window.__benchmarkDebugSmokeRun = __benchmarkDebugSmokeRun; } catch { }

		async function __benchmarkGradeCurrentResults(options = {}) {
			const mode = (document.getElementById('benchmarkGradeMode')?.value || 'answer_only').toString();
			const userForceRegrade = !!(options && options.forceRegrade);
			const resumeRequested = !!(options && options.resume) && !userForceRegrade;
			if (!resumeRequested) __benchmarkResetApiCounters('grade');
			const forceRegrade = userForceRegrade;
			try {
				__benchmarkUpsertDatasetFromUiProblems({
					allowWhenNoDataset: true,
					syncOrigins: ['ui-sync'],
				});
			} catch { }
			const ds = __benchmarkStudio.dataset;
			const dsSignature = __benchmarkDatasetSignature(ds || {});
			if (__benchmarkIsTaskRunning('grade')) {
				__benchmarkSetProgress('Grading is already running');
				return;
			}

			let rows = [];
			let gradeSession = null;
			let pausedByUser = false;
			let latestRowsSnapshot = [];
			const pausedCheckpoint = __benchmarkNormalizeGradeCheckpoint(__benchmarkGetTaskCheckpoint('grade') || null);

			if (resumeRequested) {
				if (!pausedCheckpoint || __benchmarkTrim(pausedCheckpoint?.status || '') !== 'paused') {
					throw new Error('No paused grading checkpoint to resume.');
				}
				if (!Array.isArray(pausedCheckpoint?.rows) || !pausedCheckpoint.rows.length) {
					throw new Error('Paused grading checkpoint has no rows.');
				}
				const cpMode = __benchmarkTrim(pausedCheckpoint?.mode || '');
				if (cpMode && cpMode !== mode) {
					throw new Error(`Grade mode changed (checkpoint=${cpMode}, current=${mode}). Revert mode or start new grading.`);
				}
				const cpDsSig = __benchmarkTrim(pausedCheckpoint?.dataset_signature || '');
				if (cpDsSig && dsSignature && cpDsSig !== dsSignature) {
					throw new Error('Benchmark dataset changed since checkpoint. Cannot resume grading safely.');
				}
				rows = __benchmarkCollectRowsFromAgents({
					selectedIds: null,
					mode,
					existingRows: pausedCheckpoint.rows,
					preserveMissingRows: true,
				});
				if (!rows.length) rows = pausedCheckpoint.rows.map((r) => ({ ...(r || {}) }));
				__benchmarkLog('INFO', 'Grade', `Resume grading from checkpoint: rows=${rows.length}, mode=${mode}`);
			} else if (Array.isArray(__benchmarkStudio.lastRunRows) && __benchmarkStudio.lastRunRows.length) {
				rows = __benchmarkCollectRowsFromAgents({
					selectedIds: null,
					mode,
					existingRows: __benchmarkStudio.lastRunRows,
				});
				if (!rows.length) rows = __benchmarkStudio.lastRunRows.map(r => ({ ...r }));
			} else {
				if (!ds?.problems?.length) {
					alert('Load or convert a benchmark first.');
					return;
				}
				rows = __benchmarkCollectRowsFromAgents({ selectedIds: null, mode, existingRows: [] });
				if (!rows.length) {
					const fallbackRows = [];
					const unresolved = [];
					(agents || []).forEach((agent) => {
						const archId = __benchmarkTrim(agent?.config?.id || '');
						if (!archId) return;
						const inferred = __benchmarkInferAgentBenchmarkMeta(agent, ds);
						if (!inferred) {
							unresolved.push(__benchmarkTrim(agent?.uniqueId || `${archId}#${agent?.instanceId || ''}`));
							return;
						}
						fallbackRows.push({
							problemQid: __benchmarkTrim(inferred.problemQid || ''),
							problemIndex: __benchmarkClampInt(inferred.problemIndex, { min: 0, max: 1000000, fallback: -1 }),
							runIndex: __benchmarkClampInt(inferred.runIndex, { min: 1, max: 1000000, fallback: 1 }),
							archId,
							archName: __benchmarkTrim(agent?.config?.name || ''),
							instanceId: agent?.instanceId || 1,
							uniqueId: __benchmarkTrim(agent?.uniqueId || ''),
							status: __benchmarkTrim(agent?.state?.status || ''),
							finalResult: __benchmarkTrim(agent?.state?.finalResult || ''),
							calls: Number(agent?.state?.metrics?.calls || 0),
							tokens: Number(agent?.state?.metrics?.tokens || 0),
							finalAnswerRaw: '',
							finalAnswerNorm: '',
							expectedAnswerRaw: '',
							expectedAnswerNorm: '',
							answerCorrect: null,
							solutionCorrect: null,
							isCorrect: null,
							graded: false,
							note: '',
							gradeMode: mode,
						});
					});
					rows = fallbackRows;
					if (unresolved.length) {
						__benchmarkLog('WARN', 'Grade', `Fallback grade mapping skipped ${unresolved.length} agent(s) with unknown benchmark problem: ${unresolved.slice(0, 8).join(', ')}${unresolved.length > 8 ? ', ...' : ''}`);
					}
				}
			}

			if (!rows.length) {
				alert('No attempts available to grade.');
				return;
			}

			if (forceRegrade) {
				rows = rows.map((row) => ({
					...(row || {}),
					finalAnswerRaw: '',
					finalAnswerNorm: '',
					expectedAnswerRaw: '',
					expectedAnswerNorm: '',
					answerCorrect: null,
					solutionCorrect: null,
					isCorrect: null,
					graded: false,
					note: '',
					gradeMode: mode,
					effectiveGradeMode: mode,
				}));
				try {
					__benchmarkStudio.lastRunRows = rows.map((r) => ({ ...(r || {}) }));
					__benchmarkStudio.lastGradeMode = mode;
				} catch { }
				__benchmarkLog('INFO', 'Grade', `Fresh regrade: cleared previous grading fields for ${rows.length} rows.`);
			}

			__benchmarkSetButtonsDisabled(true);
			__benchmarkSetTaskRunning('grade', true);
			__benchmarkSetTaskStopRequested('grade', false);
			try {
				__benchmarkSetTaskCheckpoint('grade', {
					status: 'running',
					created_at: pausedCheckpoint?.created_at || Date.now(),
					updated_at: Date.now(),
					mode,
					dataset_signature: dsSignature,
					rows,
					note: resumeRequested ? 'resumed' : 'initial',
				});
				__benchmarkSchedulePersist(50);

				gradeSession = __benchmarkRecordGradeSession({
					status: 'running',
					mode,
					benchmark_name: __benchmarkTrim(__benchmarkStudio?.dataset?.name || ''),
					input_rows: __benchmarkSafeClone(rows),
				});
				const remainingRows = forceRegrade
					? rows.length
					: rows.filter((r) => !(r?.graded && __benchmarkTrim(r?.gradeMode || '') === mode && typeof r?.isCorrect === 'boolean')).length;
				__benchmarkSetProgress(`Grading ${rows.length} rows (${mode})`);
				__benchmarkLog('INFO', 'Grade', `Start grading: rows=${rows.length}, remaining=${remainingRows}, mode=${mode}, force_regrade=${forceRegrade ? 'on' : 'off'}`);
				const graded = await __benchmarkGradeRows(rows, mode, {
					forceRegrade,
					skipUnfinished: true,
					onProgress: (progressRows) => {
						latestRowsSnapshot = Array.isArray(progressRows) ? progressRows : [];
						__benchmarkSetTaskCheckpoint('grade', {
							status: 'running',
							created_at: pausedCheckpoint?.created_at || Date.now(),
							updated_at: Date.now(),
							mode,
							dataset_signature: dsSignature,
							rows: latestRowsSnapshot,
							note: 'in-progress',
						});
						__benchmarkSchedulePersist(50);
					},
				});
				__benchmarkStudio.lastRunRows = graded;
				__benchmarkStudio.lastGradeMode = mode;
				__benchmarkRenderGradeOutput(graded, mode);
				const pending = graded.filter((r) => !__benchmarkProjectGradeVerdict(r, mode).graded);
				if (pending.length > 0) {
					__benchmarkSetTaskCheckpoint('grade', {
						status: 'paused',
						created_at: pausedCheckpoint?.created_at || Date.now(),
						updated_at: Date.now(),
						mode,
						dataset_signature: dsSignature,
						rows: graded,
						note: `auto-paused: pending=${pending.length}`,
					});
					__benchmarkSchedulePersist(50);
					__benchmarkSetProgress(`Grading snapshot saved: ${graded.length} rows (pending=${pending.length})`);
					__benchmarkLog('WARN', 'Grade', `Grading snapshot saved for resume: pending=${pending.length}, mode=${mode}`);
				} else {
					__benchmarkSetTaskCheckpoint('grade', null);
					__benchmarkSetProgress(`Grading complete: ${graded.length} rows`);
					__benchmarkLog('SUCCESS', 'Grade', `Grading complete: rows=${graded.length}, mode=${mode}`);
				}
				if (gradeSession) {
					gradeSession.status = 'success';
					gradeSession.output_rows = __benchmarkSafeClone(graded);
					gradeSession.finished_at = Date.now();
					__benchmarkTouchArtifacts();
				}
			} catch (e) {
				if (__benchmarkIsTaskStopError(e, 'grade')) {
					pausedByUser = true;
					const pausedRows = (Array.isArray(latestRowsSnapshot) && latestRowsSnapshot.length)
						? latestRowsSnapshot
						: rows;
					__benchmarkStudio.lastRunRows = pausedRows;
					__benchmarkStudio.lastGradeMode = mode;
					__benchmarkRenderGradeOutput(pausedRows, mode);
					__benchmarkSetTaskCheckpoint('grade', {
						status: 'paused',
						created_at: pausedCheckpoint?.created_at || Date.now(),
						updated_at: Date.now(),
						mode,
						dataset_signature: dsSignature,
						rows: pausedRows,
						note: 'stopped-by-user',
					});
					__benchmarkSetProgress(`Grading paused (${pausedRows.length} rows snapshot)`);
					__benchmarkLog('WARN', 'Grade', 'Grading paused by user. Use Resume Grade to continue.');
					if (gradeSession) {
						gradeSession.status = 'paused';
						gradeSession.output_rows = __benchmarkSafeClone(pausedRows);
						gradeSession.finished_at = Date.now();
						__benchmarkTouchArtifacts();
					}
					return;
				}
				__benchmarkSetProgress('Grading failed');
				__benchmarkLog('ERROR', 'Grade', `Grading failed: ${e?.message || e}`);
				if (gradeSession) {
					gradeSession.status = 'failed';
					gradeSession.error = __benchmarkString(e?.message || e);
					gradeSession.finished_at = Date.now();
					__benchmarkTouchArtifacts();
				}
				throw e;
			} finally {
				__benchmarkSetTaskRunning('grade', false);
				__benchmarkSetTaskStopRequested('grade', false);
				if (!pausedByUser && __benchmarkTrim(__benchmarkGetTaskCheckpoint('grade')?.status || '') === 'running') {
					__benchmarkSetTaskCheckpoint('grade', null);
				}
				__benchmarkSetButtonsDisabled(false);
				saveToLocalStorage();
			}
		}

		function __collectSelectionForJobLaunch() {
			const selection = [];
			document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
				if (!chk?.checked) return;
				const id = (chk.id || '').replace('chk-', '');
				const count = __getEffectiveArchCount(id);
				if (!ARCH_DEFINITIONS.some(d => d?.id === id)) return;
				selection.push({ archId: id, count });
			});
			return selection;
		}

			function __launchJobWindow({ query, selection, autoStart = true, suppressPopupAlert = false } = {}) {
				try { __installJobPayloadMessageBridge(); } catch { }
				const q = (query || '').toString();
				const sel = Array.isArray(selection) ? selection : [];
				if (!q.trim()) { alert('Enter a Problem Statement.'); return null; }
				if (!sel.length) { alert('Select architectures first.'); return null; }

			const mockMode = !!document.getElementById('mockModeChk')?.checked;
			const rawKeys = (document.getElementById('apiKeyList')?.value || '').toString();
			const keys = __parseApiKeyList(rawKeys);
			if (!mockMode && !keys.length) { alert('Enter at least one API key (one per line).'); return null; }

			const jobId = `JWIN_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
			const windowName = `_job_${jobId}`;
			if (!__shared.jobLaunchPayloads) __shared.jobLaunchPayloads = {};
			const payload = {
				version: 1,
				createdAt: Date.now(),
				autoStart: !!autoStart,
				jobId,
				query: q,
				selection: sel,
				ui: {
					mockModeChk: mockMode,
					bypassSystemRole: !!document.getElementById('bypassSystemRole')?.checked,
					expDiverseRt2Personas: !!document.getElementById('expDiverseRt2Personas')?.checked,
				},
			};
			__shared.jobLaunchPayloads[jobId] = payload;
			try { __storeJobPayloadToLocalStorage(jobId, payload); } catch { }

			const u = (() => {
				try { return new URL(window.location.href); } catch { return null; }
			})();
			const urlStr = (() => {
				if (u) {
					u.searchParams.set('jobLaunch', jobId);
					u.searchParams.set('jobSession', jobId);
					return u.toString();
				}
				const base = (window.location.href || '').split('#')[0];
				const sep = base.includes('?') ? '&' : '?';
				return `${base}${sep}jobLaunch=${encodeURIComponent(jobId)}&jobSession=${encodeURIComponent(jobId)}`;
			})();

			try {
				const reg = __ensureJobWindowsRegistry();
				reg[jobId] = {
					id: jobId,
					createdAt: Date.now(),
					startedAt: null,
					closedAt: null,
					status: 'opening', // opening | running | blocked | closed
					title: __jobFirstLine(q).slice(0, 140),
					url: urlStr,
					windowName,
					lastSeenAt: null,
				};
			} catch { }
			try { window.__jobManager?.onInit?.(); } catch { }

			let w = null;
			const controllerWin = (() => {
				if (!__isJobWindow) return window;
				try { if (window.opener && !window.opener.closed) return window.opener; } catch { }
				return window;
			})();
			try { w = controllerWin.open(urlStr, windowName); } catch { w = null; }
			if (!w && controllerWin !== window) {
				try { w = window.open(urlStr, windowName); } catch { w = null; }
			}
				if (!w) {
					try {
						const reg = __ensureJobWindowsRegistry();
						if (reg[jobId]) reg[jobId].status = 'blocked';
					} catch { }
					try { window.__jobManager?.onInit?.(); } catch { }
					if (!suppressPopupAlert) {
						alert('Popup blocked. Allow popups for this site to open job windows.');
					}
					return null;
					}
				try { __jobWindowRefs.set(jobId, w); } catch { }
				try { __bindProxyHostForJobWindowRef(w); } catch { }
				try { window.__jobManager?.onInit?.(); } catch { }
				try { w.focus(); } catch { }
				return jobId;
			}

		function __launchJobWindowFromUi({ autoStart = true } = {}) {
			const query = (document.getElementById('userQuery')?.value || '').toString();
			const selection = __collectSelectionForJobLaunch();
			const jobId = __launchJobWindow({ query, selection, autoStart });
			if (!jobId) return;
			try {
				if (!__isJobWindow) {
					const pinned = __getMainPinnedQueryText();
					if (pinned.trim()) document.getElementById('userQuery').value = pinned;
				}
			} catch { }
		}

		function __broadcastJobControlToJobWindows(cmd, { recentMs = 15000 } = {}) {
			if (__isJobWindow) return;
			const message = { type: 'BRANCHING_V12_JOB_CONTROL', cmd: (cmd || '').toString() };
			if (!message.cmd) return;

			const reg = (() => { try { return __ensureJobWindowsRegistry(); } catch { return null; } })();
			const items = (() => {
				try {
					if (!reg || typeof reg !== 'object') return [];
					return Object.values(reg).filter(Boolean);
				} catch { return []; }
			})();

			const now = Date.now();
			for (const meta of items) {
				const id = (meta?.id || '').toString();
				if (!id) continue;
				const windowName = (meta?.windowName || `_job_${id}`).toString();
				const status = (meta?.status || '').toString();
				const lastSeenAt = Number.isFinite(meta?.lastSeenAt) ? meta.lastSeenAt : null;

				let w = null;
				try {
					const r0 = __jobWindowRefs.get(id);
					if (r0 && !r0.closed) w = r0;
				} catch { }

				// If we lost refs (main window reload), re-acquire by windowName only if the job was seen recently.
				if (!w && lastSeenAt && (now - lastSeenAt < Math.max(1000, Number(recentMs) || 0)) && status !== 'closed') {
					try {
						const maybe = window.open('', windowName);
						if (maybe && !maybe.closed) w = maybe;
					} catch { }
				}

				if (!w) continue;
				try { __jobWindowRefs.set(id, w); } catch { }
				try { __bindProxyHostForJobWindowRef(w); } catch { }
				try { w.postMessage(message, '*'); } catch { }
			}
		}

		function __runAllWindows() {
			if (__isJobWindow) {
				try { startComparison(); } catch { try { document.getElementById('runBtn')?.click?.(); } catch { } }
				return;
			}
			try { __broadcastJobControlToJobWindows('resume'); } catch { }
			try { startComparison(); } catch { try { document.getElementById('runBtn')?.click?.(); } catch { } }
		}

		function __stopAllWindows() {
			if (__isJobWindow) {
				try { stopComparison(); } catch { }
				return;
			}
			try { __broadcastJobControlToJobWindows('stop'); } catch { }
			try { stopComparison(); } catch { }
		}

		function __applyJobLaunchPayload(payload) {
			if (!payload || typeof payload !== 'object') return;

			try {
				const title = (payload.query || '').toString().split(/\r?\n/).find(l => l.trim()) || 'Job';
				document.title = `Job ‚Ä¢ ${title.slice(0, 60)}`;
			} catch { }

			try { document.getElementById('userQuery').value = (payload.query || '').toString(); } catch { }
			try { document.getElementById('mockModeChk').checked = !!payload.ui?.mockModeChk; } catch { }
			try { document.getElementById('bypassSystemRole').checked = !!payload.ui?.bypassSystemRole; } catch { }
			try { document.getElementById('expDiverseRt2Personas').checked = !!payload.ui?.expDiverseRt2Personas; } catch { }

			// Apply architecture selection
			try {
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => { chk.checked = false; });
				for (const sel of (payload.selection || [])) {
					const id = sel?.archId;
					if (!id) continue;
					const chk = document.getElementById(`chk-${id}`);
					const cntEl = document.getElementById(`cnt-${id}`);
					if (chk) chk.checked = true;
					const count = Math.max(1, parseInt(sel?.count || '1', 10) || 1);
					if (cntEl) cntEl.value = `${count}`;
				}
			} catch { }

			try { apiKeyManager.setKeys(getApiKeyListFromInput()); } catch { }
			try { __apiKeyLive.syncFromInput(); } catch { }
			try { setupKeyMonitorCard(); } catch { }
		}

		function __consumeJobLaunchPayloadIfAny() {
			if (!__jobLaunchId) return null;
			if (window.__JOB_LAUNCH_APPLIED) return null;

			const __applyPayloadOnce = (payload) => {
				if (!payload || typeof payload !== 'object') return null;
				if (window.__JOB_LAUNCH_APPLIED) return payload;
				window.__JOB_LAUNCH_APPLIED = true;

				__applyJobLaunchPayload(payload);
				__precreateAgentsForPayload(payload);

				// Register this window as a job window (for the Jobs list UI).
				try {
					const reg = __ensureJobWindowsRegistry();
					const id = (payload.jobId || __jobSessionId || __jobLaunchId || '').toString();
					if (id) {
						const now = Date.now();
						const prev = reg[id] || {};
						const jobStatus = payload.autoStart ? 'running' : 'ready';
						reg[id] = {
							...prev,
							id,
							createdAt: Number.isFinite(prev.createdAt) ? prev.createdAt : (Number.isFinite(payload.createdAt) ? payload.createdAt : now),
							startedAt: Number.isFinite(prev.startedAt) ? prev.startedAt : now,
							closedAt: null,
							status: jobStatus,
							title: __jobFirstLine(payload.query || prev.title || '').slice(0, 140),
							windowName: prev.windowName || `_job_${id}`,
							url: prev.url || window.location.href,
							lastSeenAt: now,
						};

						// Heartbeat + close tracking
						const beatId = setInterval(() => {
							try {
								const r = __ensureJobWindowsRegistry()?.[id];
								if (!r || r.status === 'closed') { clearInterval(beatId); return; }
								r.lastSeenAt = Date.now();
							} catch { }
						}, 1000);
						window.addEventListener('beforeunload', () => {
							try {
								const r = __ensureJobWindowsRegistry()?.[id];
								if (r) {
									r.status = 'closed';
									r.closedAt = Date.now();
									r.lastSeenAt = Date.now();
								}
							} catch { }
							try { clearInterval(beatId); } catch { }
						}, { once: true });
					}
				} catch { }

				// Remove jobLaunch from URL but keep jobSession so autosave stays isolated for this window.
				try {
					const u = new URL(window.location.href);
					u.searchParams.delete('jobLaunch');
					if (!u.searchParams.get('jobSession') && payload.jobId) u.searchParams.set('jobSession', payload.jobId);
					history.replaceState(null, '', u.toString());
					try {
						const reg = __ensureJobWindowsRegistry();
						const id = (payload.jobId || __jobSessionId || __jobLaunchId || '').toString();
						if (id && reg?.[id]) reg[id].url = window.location.href;
					} catch { }
				} catch { }

				if (payload.autoStart) {
					setTimeout(() => {
						try { startComparison(); } catch { try { document.getElementById('runBtn')?.click(); } catch { } }
					}, 50);
				}
				return payload;
			};

			const __updateWaitingUi = (msg) => {
				const pb = document.getElementById('progress-bar');
				if (pb && msg) pb.innerText = msg;
			};

			let payload = null;
			try { payload = __shared.jobLaunchPayloads?.[__jobLaunchId] || null; } catch { payload = null; }
			if (!payload) {
				try { payload = __takeJobPayloadFromLocalStorage(__jobLaunchId); } catch { payload = null; }
			}
			if (payload) {
				try { if (__shared.jobLaunchPayloads) delete __shared.jobLaunchPayloads[__jobLaunchId]; } catch { }
				return __applyPayloadOnce(payload);
			}

			// If we can't access opener state (file:// origin isolation), request payload via postMessage.
			try { __installJobPayloadMessageBridge(); } catch { }
			try {
				if (!window.__JOB_LAUNCH_MSG_BOUND) {
					window.__JOB_LAUNCH_MSG_BOUND = true;
					window.addEventListener('message', (e) => {
						const d = e?.data;
						if (!d || typeof d !== 'object') return;
						if (d.type !== 'BRANCHING_V12_JOB_DELIVER_PAYLOAD') return;
						if ((d.jobId || '').toString() !== __jobLaunchId) return;
						const p = d.payload;
						if (!p) return;
						try { if (__shared.jobLaunchPayloads) delete __shared.jobLaunchPayloads[__jobLaunchId]; } catch { }
						__applyPayloadOnce(p);
						try { clearInterval(window.__JOB_LAUNCH_REQ_TIMER); } catch { }
						window.__JOB_LAUNCH_REQ_TIMER = null;
					});
				}
			} catch { }

			__updateWaitingUi('Job window opened ‚Äî waiting for payload (allow popups).');
			try {
				if (!window.__JOB_LAUNCH_REQ_TIMER) {
					let tries = 0;
					const tick = () => {
						tries += 1;
						try { window.opener?.postMessage({ type: 'BRANCHING_V12_JOB_REQUEST_PAYLOAD', jobId: __jobLaunchId }, '*'); } catch { }
						if (window.__JOB_LAUNCH_APPLIED || tries >= 40) {
							try { clearInterval(window.__JOB_LAUNCH_REQ_TIMER); } catch { }
							window.__JOB_LAUNCH_REQ_TIMER = null;
							if (!window.__JOB_LAUNCH_APPLIED) __updateWaitingUi('Job payload not received. Click Open Job again (popup/origin restriction).');
						}
					};
					window.__JOB_LAUNCH_REQ_TIMER = setInterval(tick, 200);
					tick();
				}
			} catch { }

			return null;
		}

		function __estimateTokensFromMessages(messages) {
			const msgs = Array.isArray(messages) ? messages : [];
			const raw = msgs.map((m) => {
				const role = __benchmarkTrim(m?.role || 'user') || 'user';
				const content = __benchmarkString(m?.content ?? '');
				return `[${role}]\n${content}`;
			}).join('\n\n');
			return __benchmarkEstimateTokens(raw || JSON.stringify(msgs || []));
		}

		function __adaptMessagesNoSystem(messages) {
			const systemParts = [];
			const kept = [];
			for (const m of messages) {
				if (m.role === 'system' || m.role === 'developer') systemParts.push(m.content);
				else kept.push({ ...m });
			}
			if (systemParts.length === 0) return kept;

			const prefix = `### INSTRUCTIONS ###\n${systemParts.join('\n\n')}\n\n`;
			const firstUserIdx = kept.findIndex(m => m.role === 'user');
			if (firstUserIdx >= 0) {
				kept[firstUserIdx].content = prefix + kept[firstUserIdx].content;
				return kept;
			}
			return [{ role: 'user', content: prefix.trim() }, ...kept];
		}

		function __withKeyParam(u, key) {
			try {
				const parsed = new URL(u);
				parsed.searchParams.set('key', key);
				return parsed.toString();
			} catch {
				if (!u) return u;
				const sep = u.includes('?') ? '&' : '?';
				return `${u}${sep}key=${encodeURIComponent(key)}`;
			}
		}

		function __toGeminiPayload(msgs) {
			const systemParts = [];
			const contents = [];
			for (const m of (msgs || [])) {
				const role = (m?.role || '').toLowerCase();
				const text = (m?.content ?? '').toString();
				if (!text) continue;
				if (role === 'system') {
					systemParts.push(text);
					continue;
				}
				const gemRole = (role === 'assistant' || role === 'model') ? 'model' : 'user';
				contents.push({ role: gemRole, parts: [{ text }] });
			}
			const systemInstruction = systemParts.length ? { parts: [{ text: systemParts.join('\n\n') }] } : null;
			if (!contents.length && systemInstruction) {
				contents.push({ role: 'user', parts: [{ text: systemParts.join('\n\n') }] });
				return { contents, systemInstruction: null };
			}
			return { contents, systemInstruction };
		}

		function __extractTextContent(content) {
			if (typeof content === 'string') return content;
			if (Array.isArray(content)) {
				return content.map(part => part?.text || '').join('');
			}
			return content ? String(content) : '';
		}

		function __toCfResponsesPayload(messages) {
			const parts = [];
			for (const m of (messages || [])) {
				const role = (m?.role || '').toLowerCase();
				const text = __extractTextContent(m?.content).trim();
				if (!text) continue;
				if (role === 'system' || role === 'developer') {
					parts.push(`[System]\n${text}`);
				} else if (role === 'assistant') {
					parts.push(`[Assistant]\n${text}`);
				} else {
					parts.push(`[User]\n${text}`);
				}
			}
			return { inputText: parts.join('\n\n').trim() };
		}

		function __extractCfResponseText(data, apiMode) {
			if (apiMode === 'cf_ai_run') {
				return (
					data?.result?.response ||
					data?.result?.output_text ||
					data?.result?.output?.[0]?.content?.[0]?.text ||
					data?.result?.output?.[0]?.text ||
					data?.result?.choices?.[0]?.message?.content ||
					""
				);
			}
			return (
				data?.result?.response ||
				data?.result?.output_text ||
				data?.output_text ||
				data?.response?.output_text ||
				data?.response?.output?.[0]?.content?.[0]?.text ||
				data?.result?.output?.[0]?.content?.[0]?.text ||
				data?.choices?.[0]?.message?.content ||
				""
			);
		}

		function __extractActualTokens(data) {
			const usage = data?.usage || data?.response?.usage || data?.result?.usage || null;
			if (Number.isFinite(usage?.total_tokens)) return usage.total_tokens;
			if (Number.isFinite(usage?.totalTokens)) return usage.totalTokens;
			if (Number.isFinite(usage?.prompt_tokens) || Number.isFinite(usage?.completion_tokens)) {
				return (usage?.prompt_tokens || 0) + (usage?.completion_tokens || 0);
			}
			const meta = data?.usageMetadata || data?.response?.usageMetadata || data?.result?.usageMetadata || null;
			if (Number.isFinite(meta?.totalTokenCount)) return meta.totalTokenCount;
			if (Number.isFinite(meta?.promptTokenCount) || Number.isFinite(meta?.candidatesTokenCount)) {
				return (meta?.promptTokenCount || 0) + (meta?.candidatesTokenCount || 0);
			}
			return 0;
		}

			function __resolveMainProxyHostWindow() {
				if (!__isJobWindow) return null;
				try {
					if (window.opener && !window.opener.closed) return window.opener;
				} catch { }
				try {
					if (window.__JOB_PROXY_PARENT && !window.__JOB_PROXY_PARENT.closed) return window.__JOB_PROXY_PARENT;
				} catch { }
				return null;
			}

			function __useMainApiProxy() {
				if (!__isJobWindow) return false;
				if (window.__JOB_DETACHED) return false;
				if (window.__JOB_LOCAL_API) return false;
				return !!__resolveMainProxyHostWindow();
			}

			function __readMainWindowApiMirror() {
				if (!__isJobWindow) return null;
				const host = __resolveMainProxyHostWindow();
				if (!host) return null;
				try {
					const doc = host?.document;
					if (!doc) return null;
					const readVal = (id) => (doc.getElementById(id)?.value ?? '').toString();
					const readChk = (id) => !!doc.getElementById(id)?.checked;
					return {
						apiKeyList: readVal('apiKeyList'),
						apiUrl: readVal('apiUrl'),
						apiProxyUrl: readVal('apiProxyUrl'),
						modelName: readVal('modelName'),
						bypassSystemRole: readChk('bypassSystemRole'),
						enableRateLimit: readChk('enableRateLimit'),
						rpmLimit: readVal('rpmLimit'),
						tpmLimit: readVal('tpmLimit'),
						maxInflightPerKey: readVal('maxInflightPerKey'),
						expDiverseRt2Personas: readChk('expDiverseRt2Personas'),
						mockMode: readChk('mockModeChk'),
					};
				} catch {
					return null;
				}
			}

			function __syncProxyApiInputsFromMain({ force = false, includeKeys = false } = {}) {
				if (!__isJobWindow) return false;
				if (!__useMainApiProxy()) return false;
				const main = __readMainWindowApiMirror();
				if (!main) return false;
				let changed = false;

				const setInput = (id, value) => {
					const el = document.getElementById(id);
					if (!el) return;
					const cur = (el.value || '').toString();
					const next = (value ?? '').toString();
					if (!force) {
						if (__benchmarkTrim(cur)) return;
						if (!__benchmarkTrim(next)) return;
					}
					if (cur === next) return;
					el.value = next;
					changed = true;
				};
				const setCheckbox = (id, value) => {
					const el = document.getElementById(id);
					if (!el) return;
					const next = !!value;
					if (!force) {
						// In non-force mode, only "fill up" missing truthy values.
						if (!!el.checked === true) return;
						if (!next) return;
					}
					if (!!el.checked === next) return;
					el.checked = next;
					changed = true;
				};

				if (includeKeys) setInput('apiKeyList', main.apiKeyList);
				setInput('apiUrl', main.apiUrl);
				setInput('apiProxyUrl', main.apiProxyUrl);
				setInput('modelName', main.modelName);
				setCheckbox('bypassSystemRole', main.bypassSystemRole);
				setCheckbox('enableRateLimit', main.enableRateLimit);
				setInput('rpmLimit', main.rpmLimit);
				setInput('tpmLimit', main.tpmLimit);
				setInput('maxInflightPerKey', main.maxInflightPerKey);
				setCheckbox('expDiverseRt2Personas', main.expDiverseRt2Personas);
				setCheckbox('mockModeChk', main.mockMode);

				return changed;
			}

		const __apiProxyClient = (() => {
			if (!__isJobWindow) return { request: null };
			const pending = new Map();
			let nextId = 1;
			let bound = false;

			const ensureListener = () => {
				if (bound) return;
				bound = true;
				window.addEventListener('message', (e) => {
					const d = e?.data;
					if (!d || typeof d !== 'object') return;
					if (d.type !== 'BRANCHING_V12_API_PROXY_RESPONSE') return;
					const reqId = d.reqId;
					if (!reqId || !pending.has(reqId)) return;
					const p = pending.get(reqId);
					pending.delete(reqId);
					try { p?.abortCleanup?.(); } catch { }
					p.resolve(d);
				});
			};

			const request = (payload) => {
				ensureListener();
				const inbound = payload || {};
				const signal = inbound?.signal;
				const outbound = (() => {
					try {
						const o = { ...(inbound || {}) };
						delete o.signal;
						return o;
					} catch {
						return inbound;
					}
				})();
				return new Promise((resolve, reject) => {
					const reqId = `PROXY_${Date.now()}_${nextId++}`;
					let abortCleanup = null;
						const onAbort = () => {
							if (!pending.has(reqId)) return;
							pending.delete(reqId);
							try {
								const host = __resolveMainProxyHostWindow();
								host?.postMessage({ type: 'BRANCHING_V12_API_PROXY_CANCEL', reqId }, '*');
							} catch { }
							try { abortCleanup?.(); } catch { }
							reject(new Error('Aborted'));
						};
					if (signal && typeof signal.addEventListener === 'function') {
						if (signal.aborted) {
							onAbort();
							return;
						}
						try {
							signal.addEventListener('abort', onAbort, { once: true });
							abortCleanup = () => { try { signal.removeEventListener('abort', onAbort); } catch { } };
						} catch { abortCleanup = null; }
					}

					pending.set(reqId, { resolve, reject, ts: Date.now(), abortCleanup });
						try {
							const host = __resolveMainProxyHostWindow();
							if (!host) throw new Error('Main-window proxy host unavailable');
							host.postMessage({ type: 'BRANCHING_V12_API_PROXY_REQUEST', reqId, payload: outbound }, '*');
						} catch (e) {
							pending.delete(reqId);
							try { abortCleanup?.(); } catch { }
							reject(e);
						return;
					}
					const timeoutMs = Number.isFinite(outbound?.timeoutMs)
						? Math.max(10000, Number(outbound.timeoutMs))
						: (10 * 60 * 1000);
						setTimeout(() => {
							if (!pending.has(reqId)) return;
							const p = pending.get(reqId);
							pending.delete(reqId);
							try {
								const host = __resolveMainProxyHostWindow();
								host?.postMessage({ type: 'BRANCHING_V12_API_PROXY_CANCEL', reqId }, '*');
							} catch { }
							try { p?.abortCleanup?.(); } catch { }
							reject(new Error(`Main-window proxy timeout (${Math.round(timeoutMs / 1000)}s)`));
						}, timeoutMs + 5000);
				});
			};

			return { request };
		})();

		const __apiProxyServer = (() => {
			if (window.__API_PROXY_SERVER_INSTALLED) return null;
			window.__API_PROXY_SERVER_INSTALLED = true;

			const queue = [];
			const reqState = new Map(); // reqId -> { canceled: boolean, abortController: AbortController|null }
			let inflight = 0;
			let pumpScheduled = false;

			const __proxyStats = (() => {
				try {
					if (!__shared.proxyStatsV1 || typeof __shared.proxyStatsV1 !== 'object') {
						__shared.proxyStatsV1 = { latencyEmaMs: 30000, samples: 0, updatedAt: 0 };
					}
					const s = __shared.proxyStatsV1;
					if (!Number.isFinite(s.latencyEmaMs) || s.latencyEmaMs <= 0) s.latencyEmaMs = 30000;
					if (!Number.isFinite(s.samples) || s.samples < 0) s.samples = 0;
					if (!Number.isFinite(s.updatedAt) || s.updatedAt < 0) s.updatedAt = 0;
					return s;
				} catch {
					return { latencyEmaMs: 30000, samples: 0, updatedAt: 0 };
				}
			})();

			const __updateProxyLatencyEma = (latencyMs) => {
				const v = Number(latencyMs);
				if (!Number.isFinite(v) || v <= 0) return;
				const now = Date.now();
				const prev = Number.isFinite(__proxyStats.latencyEmaMs) ? __proxyStats.latencyEmaMs : v;
				const alpha = 0.18;
				const ema = prev * (1 - alpha) + v * alpha;
				__proxyStats.latencyEmaMs = Math.max(50, Math.min(300000, ema));
				__proxyStats.samples = (Number.isFinite(__proxyStats.samples) ? __proxyStats.samples : 0) + 1;
				__proxyStats.updatedAt = now;
			};

			const __setKeysIfChanged = (list) => {
				const next = Array.isArray(list) ? list : [];
				const cur = Array.isArray(apiKeyManager.keys) ? apiKeyManager.keys : [];
				if (next.length === cur.length && next.every((k, i) => k === cur[i])) return false;
				const prevIdx = Number.isFinite(apiKeyManager.idx) ? apiKeyManager.idx : 0;
				apiKeyManager.setKeys(next);
				if (next.length > 0) apiKeyManager.idx = prevIdx % next.length;
				return true;
			};

			const __proxyMaxConcurrent = () => {
				try {
					try { __setKeysIfChanged(getApiKeyListFromInput()); } catch { }
					const raw = (document.getElementById('apiKeyList')?.value || '').toString();
					const keys = __parseApiKeyList(raw);
					const m1 = Math.max(0, keys.length);
					const m2 = Math.max(0, (apiKeyManager.keys || []).length);
					const keyCount = Math.max(1, m1, m2);
					const perKeyCap = __getMaxInflightPerKeyLimit();
					const capMax = perKeyCap > 0 ? Math.max(1, keyCount * perKeyCap) : null;

					const enabled = !!document.getElementById('enableRateLimit')?.checked;
					if (!enabled) return capMax || keyCount;

					const rpmLimit = __normalizeRateLimit(document.getElementById('rpmLimit')?.value);
					const paceMs = rpmLimit > 0 ? Math.ceil(60000 / rpmLimit) : 0;
					const gapMs = Math.max(3000, paceMs);

					const latencyHintMs = Number.isFinite(__proxyStats.latencyEmaMs) ? __proxyStats.latencyEmaMs : 30000;
					const perKeyInflight = Math.max(1, Math.ceil(latencyHintMs / Math.max(1, gapMs)));

					// Keep enough parallelism to saturate RPM even when responses are slow, but clamp to avoid runaway memory.
					const headroom = Math.min(3, perKeyInflight);
					const rawMax = keyCount * (perKeyInflight + headroom);
					const hardCap = Math.min(5000, Math.max(200, keyCount * 50));
					const computed = Math.max(1, Math.min(hardCap, rawMax));
					return capMax ? Math.min(capMax, computed) : computed;
				} catch { return 1; }
			};

			const __ensureProxyKeys = (rawKeys) => {
				const raw = (rawKeys || '').toString();
				if (!raw) return;
				const cur = (document.getElementById('apiKeyList')?.value || '').toString();
				if (cur.trim() !== raw.trim()) {
					try { document.getElementById('apiKeyList').value = raw; } catch { }
				}
				try { __setKeysIfChanged(__parseApiKeyList(raw)); } catch { }
				try { __apiKeyLive.syncFromInput(); } catch { }
			};

			const __ensureProxyConfig = (cfg = {}) => {
				try {
					const enable = !!cfg.enableRateLimit;
					const curEnable = !!document.getElementById('enableRateLimit')?.checked;
					if (enable !== curEnable) document.getElementById('enableRateLimit').checked = enable;
				} catch { }
				try {
					if (Number.isFinite(cfg.rpmLimit)) document.getElementById('rpmLimit').value = `${parseInt(cfg.rpmLimit, 10) || 0}`;
				} catch { }
				try {
					if (Number.isFinite(cfg.tpmLimit)) document.getElementById('tpmLimit').value = `${parseInt(cfg.tpmLimit, 10) || 0}`;
				} catch { }
				try {
					const n = Number.isFinite(cfg.maxInflightPerKey) ? (parseInt(cfg.maxInflightPerKey, 10) || 0) : 0;
					document.getElementById('maxInflightPerKey').value = n > 0 ? `${n}` : '';
				} catch { }
			};

			const __proxyPickKeySmart = (estTokens) => {
				if (!apiKeyManager.hasKeys()) {
					__setKeysIfChanged(getApiKeyListFromInput());
				}
				try { __apiKeyLive.syncFromInput(); } catch { }
				const keys = Array.isArray(apiKeyManager.keys) ? apiKeyManager.keys : [];
				if (!keys.length) throw new Error("No API keys configured");
				const now = Date.now();
				const startIdx = Number.isFinite(apiKeyManager.idx) ? (apiKeyManager.idx % keys.length) : 0;
				const enabled = !!document.getElementById('enableRateLimit')?.checked;
				const rpmLimit = __normalizeRateLimit(document.getElementById('rpmLimit')?.value);
				const tpmLimit = __normalizeRateLimit(document.getElementById('tpmLimit')?.value);
				const paceMs = rpmLimit > 0 ? Math.ceil(60000 / rpmLimit) : 0;
				const baseGapMs = Math.max(3000, paceMs);
				const tokensForBucket = Number.isFinite(estTokens) ? Math.max(0, estTokens) : 0;

				let chosenKey = null;
				let chosenIdx = -1;
				let bestReadyDelta = Infinity;
				let bestQueueScore = Infinity;

				for (let off = 0; off < keys.length; off++) {
					const idx = (startIdx + off) % keys.length;
					const k = keys[idx];
					const cooldownUntil = (() => {
						try { return __apiKeyLive.getCooldownUntil?.(k); } catch { return null; }
					})();
					let readyAt = (Number.isFinite(cooldownUntil) && cooldownUntil > now) ? cooldownUntil : now;

					const live = (() => {
						try { return __apiKeyLive.getState?.().byKey?.get?.(k) || null; } catch { return null; }
					})();
					const inflight = Number.isFinite(live?.inflightCount) ? live.inflightCount : 0;
					const pending = Number.isFinite(live?.pendingCount) ? live.pendingCount : 0;

					if (enabled) {
						try {
							const state = __applySharedRateLimitsForKey(k, { rpmLimitUi: rpmLimit, tpmLimitUi: tpmLimit });
							__recoverRateStateIfStale(state, now);
							const effRpm = Number.isFinite(state?.rpmLimit) ? state.rpmLimit : rpmLimit;
							const effTpm = Number.isFinite(state?.tpmLimit) ? state.tpmLimit : tpmLimit;
							const effPaceMs = effRpm > 0 ? Math.ceil(60000 / effRpm) : 0;
							const gapMs = Math.max(3000, effPaceMs);
							const isTpmOversize = effTpm > 0 && tokensForBucket > effTpm;

							const lastSentAt = Number.isFinite(state?.lastSentAt) ? state.lastSentAt : 0;
							const nextByGap = lastSentAt ? (lastSentAt + gapMs) : 0;
							if (nextByGap && now < nextByGap) readyAt = Math.max(readyAt, nextByGap);

							let windowStart = Number.isFinite(state?.windowStart) ? state.windowStart : __minuteStart(now);
							let rpm = Number.isFinite(state?.rpm) ? state.rpm : 0;
							let tpm = Number.isFinite(state?.tpm) ? state.tpm : 0;
							const win = __minuteStart(now);
							if (win !== windowStart) {
								windowStart = win;
								rpm = 0;
								tpm = 0;
							}
							const hitRpm = effRpm > 0 && (rpm + 1 > effRpm);
							const hitTpm = effTpm > 0 && (isTpmOversize ? (tpm >= effTpm) : (tpm + tokensForBucket > effTpm));
							if (hitRpm || hitTpm) {
								const nextWin = windowStart + 60000 + 25;
								readyAt = Math.max(readyAt, nextWin);
							}
						} catch { }
					} else {
						const lastSentAt = Number.isFinite(live?.lastSentAt) ? live.lastSentAt : 0;
						const nextByGap = lastSentAt ? (lastSentAt + baseGapMs) : 0;
						if (nextByGap && now < nextByGap) readyAt = Math.max(readyAt, nextByGap);
					}

					const queueScore = inflight + pending;
					const readyDelta = Math.max(0, readyAt - now);
					if (readyDelta < bestReadyDelta || (readyDelta === bestReadyDelta && queueScore < bestQueueScore)) {
						bestReadyDelta = readyDelta;
						bestQueueScore = queueScore;
						chosenKey = k;
						chosenIdx = idx;
					}
					if (queueScore === 0 && readyDelta === 0) {
						chosenKey = k;
						chosenIdx = idx;
						break;
					}
				}

				if (chosenIdx >= 0) apiKeyManager.idx = (chosenIdx + 1) % keys.length;
				return chosenKey || keys[startIdx];
			};

			const proxyAgent = {
				stopFlag: false,
				log: () => { },
				sleepInterruptible: async (ms) => {
					const total = Math.max(0, Number(ms) || 0);
					const end = Date.now() + total;
					while (Date.now() < end) {
						const slice = Math.min(200, end - Date.now());
						await new Promise(res => setTimeout(res, slice));
					}
				},
			};

			const pump = () => {
				if (pumpScheduled) return;
				pumpScheduled = true;
				Promise.resolve().then(() => {
					pumpScheduled = false;
					const max = __proxyMaxConcurrent();
					while (inflight < max && queue.length) {
						const item = queue.shift();
						const { payload, source, reqId } = item || {};
						if (!source || !reqId) continue;
						const meta = reqState.get(reqId);
						if (meta?.canceled) {
							reqState.delete(reqId);
							try {
								source.postMessage({
									type: 'BRANCHING_V12_API_PROXY_RESPONSE',
									reqId,
									ok: false,
									status: 0,
									errorMessage: 'Canceled'
								}, '*');
							} catch { }
							continue;
						}
						inflight += 1;
						(async () => {
							const abortController = new AbortController();
							try {
								const st = reqState.get(reqId) || { canceled: false, abortController: null };
								st.abortController = abortController;
								reqState.set(reqId, st);
								if (st.canceled) {
									try { abortController.abort(); } catch { }
									throw new Error('Canceled');
								}
							} catch { }
							try {
								const result = await __handleProxyRequest(payload, abortController);
								try { __updateProxyLatencyEma(result?.latencyMs); } catch { }
								try { source.postMessage({ type: 'BRANCHING_V12_API_PROXY_RESPONSE', reqId, ...result }, '*'); } catch { }
							} catch (e) {
								try {
									source.postMessage({
										type: 'BRANCHING_V12_API_PROXY_RESPONSE',
										reqId,
										ok: false,
										status: 0,
										errorMessage: (e && e.message) ? e.message : (e ? e.toString() : 'Proxy error')
									}, '*');
								} catch { }
							} finally {
								try { reqState.delete(reqId); } catch { }
								inflight = Math.max(0, inflight - 1);
								pump();
							}
						})();
					}
				});
			};

			const __handleProxyRequest = async (payload, abortController) => {
				const p = payload || {};
				const messages = Array.isArray(p.messages) ? p.messages : [];
				const requestOptions = p.requestOptions || {};
				const temperature = Number.isFinite(p.temperature) ? p.temperature : 0.7;
				const meta = p.meta || {};
				const estTokens = Number.isFinite(p.estTokens) ? p.estTokens : __estimateTokensFromMessages(messages);
				const abortCtl = abortController || new AbortController();
				const reqAgent = {
					get stopFlag() { return !!abortCtl.signal?.aborted; },
					log: () => { },
					sleepInterruptible: async (ms) => {
						const total = Math.max(0, Number(ms) || 0);
						const end = Date.now() + total;
						while (Date.now() < end) {
							if (abortCtl.signal?.aborted) break;
							const slice = Math.min(200, end - Date.now());
							await new Promise(res => setTimeout(res, slice));
						}
					},
				};
				const __throwIfAborted = () => { if (abortCtl.signal?.aborted) throw new Error('Aborted'); };

				const rawUrl = (document.getElementById('apiUrl')?.value || '').toString().trim();
				const modelInput = (document.getElementById('modelName')?.value || '').toString().trim();
				const model = modelInput.replace(/^models\//i, '').trim();
				const url = rawUrl
					.replaceAll('{model}', model)
					.replaceAll('{{MODEL}}', model);
				const apiMode = (() => {
					const lower = (url || '').toLowerCase();
					if (lower.includes('/ai/run/')) return 'cf_ai_run';
					if (lower.includes('/ai/v1/responses')) return 'cf_responses';
					if (lower.includes('/openai/')) return 'openai_chat_completions';
					if (lower.includes(':generatecontent') || lower.includes(':streamgeneratecontent')) return 'gemini_generatecontent';
					return 'openai_chat_completions';
				})();
				const proxyUrl = (document.getElementById('apiProxyUrl')?.value || '').toString().trim();

				let keyToUse = '';
				const rateWaitStart = Date.now();
				keyToUse = __proxyPickKeySmart(estTokens);
				try { __apiKeyLive.onPrepare(keyToUse, meta); } catch { }
				const telemetryId = (() => {
					try {
						return __apiTelemetry.start({
							seq: Number.isFinite(meta?.seq) ? meta.seq : null,
							archId: meta?.archId || '',
							archName: meta?.archName || '',
							instanceId: meta?.instanceId || '',
							uniqueId: meta?.uniqueId || '',
							apiMode,
							model,
							url,
							key: maskKey(keyToUse),
							estTokens,
						});
					} catch { return null; }
				})();
				let telemetryDone = false;
				let __globalStatsSent = false;
				await __acquireRateSlot(reqAgent, keyToUse, estTokens);
				__throwIfAborted();
				const rateWaitMs = Date.now() - rateWaitStart;
				try { if (telemetryId) __apiTelemetry.markRateWait(telemetryId, rateWaitMs); } catch { }

				let requestUrl = url;
				let headers = { 'Content-Type': 'application/json' };
				let body = null;

				if (apiMode === 'gemini_generatecontent') {
					requestUrl = __withKeyParam(requestUrl, keyToUse);
					const payload = __toGeminiPayload(messages);
					const generationConfig = { temperature };
					if (Number.isFinite(requestOptions.top_p)) generationConfig.topP = requestOptions.top_p;
					if (Number.isFinite(requestOptions.top_k)) generationConfig.topK = requestOptions.top_k;
					if (Number.isFinite(requestOptions.max_tokens)) generationConfig.maxOutputTokens = requestOptions.max_tokens;
					body = { contents: payload.contents, generationConfig };
					if (payload.systemInstruction) body.systemInstruction = payload.systemInstruction;
				} else if (apiMode === 'cf_ai_run') {
					const cf = __toCfResponsesPayload(messages);
					headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
					body = { input: cf.inputText || '' };
					if (Number.isFinite(temperature)) body.temperature = temperature;
				} else if (apiMode === 'cf_responses') {
					const cf = __toCfResponsesPayload(messages);
					headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
					body = { model, input: cf.inputText || '', stream: false };
					if (Number.isFinite(temperature)) body.temperature = temperature;
				} else {
					headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
					body = { model, messages, temperature, stream: false };
					if (Number.isFinite(requestOptions.top_p)) body.top_p = requestOptions.top_p;
					if (Number.isFinite(requestOptions.top_k)) body.top_k = requestOptions.top_k;
					if (Number.isFinite(requestOptions.max_tokens)) {
						body.max_tokens = requestOptions.max_tokens;
						body.max_completion_tokens = requestOptions.max_tokens;
						body.max_output_tokens = requestOptions.max_tokens;
					}
				}

				if (proxyUrl && (apiMode === 'cf_ai_run' || apiMode === 'cf_responses')) {
					const targetUrl = requestUrl;
					const encodedTarget = encodeURIComponent(targetUrl);
					if (proxyUrl.includes('{url}') || proxyUrl.includes('{{URL}}')) {
						requestUrl = proxyUrl.replaceAll('{url}', encodedTarget).replaceAll('{{URL}}', encodedTarget);
					} else {
						const targetHeaders = { ...headers };
						requestUrl = proxyUrl;
						headers = { 'Content-Type': 'application/json' };
						body = {
							url: targetUrl,
							method: 'POST',
							headers: targetHeaders,
							body
						};
					}
				}

				const clientTimeoutMs = Number.isFinite(p.timeoutMs)
					? Math.max(10000, Number(p.timeoutMs))
					: (10 * 60 * 1000);
				const timeoutMs = Math.min(clientTimeoutMs, 10 * 60 * 1000);
				let timeoutId = null;
				let didTimeout = false;
				const timeoutPromise = new Promise((_, reject) => {
					timeoutId = setTimeout(() => {
						didTimeout = true;
						try { abortCtl.abort(); } catch { }
						reject(new Error(`Timeout (${Math.round(timeoutMs / 1000)}s)`));
					}, timeoutMs);
				});

				let resp = null;
				let data = null;
				let bodyText = '';
				let fetchStartAt = 0;
				let inflightRelease = null;
				try {
					const gate = await __perKeyInflightGate.acquire(reqAgent, keyToUse);
					inflightRelease = gate?.release || null;
					try { if (telemetryId) __apiTelemetry.markSent(telemetryId, { url: requestUrl }); } catch { }
					try { __globalCallStats.onSent({ ts: Date.now() }); __globalStatsSent = true; } catch { }
					try { __apiKeyLive.onSent(keyToUse, meta); } catch { }
					try { inflightRelease?.(); inflightRelease = null; } catch { }
					__throwIfAborted();
					fetchStartAt = Date.now();
					resp = await Promise.race([
						fetch(requestUrl, {
							method: 'POST',
							headers,
							body: JSON.stringify(body),
							signal: abortCtl.signal
						}),
						timeoutPromise
					]);
					if (!resp.ok) {
						try { bodyText = await resp.text(); } catch { bodyText = ''; }
						try { __apiKeyLive.onDone(keyToUse, { ...meta, httpStatus: resp.status, message: `HTTP ${resp.status}` }); } catch { }
						if (telemetryId && !telemetryDone) {
							try {
								__apiTelemetry.markResponse(telemetryId, {
									ok: false,
									httpStatus: resp.status,
									errorType: 'http',
									errorMessage: `HTTP ${resp.status}`,
									errorBody: bodyText,
									latencyMs: Date.now() - fetchStartAt,
								});
								telemetryDone = true;
							} catch { }
							try { if (__globalStatsSent) __globalCallStats.onFinal('fail', { ts: Date.now() }); } catch { }
						}
						return {
							ok: false,
							status: resp.status,
							bodyText,
							errorMessage: `HTTP ${resp.status}`,
							latencyMs: Date.now() - fetchStartAt,
							rateWaitMs,
							keyMasked: maskKey(keyToUse),
							apiMode,
							model,
							url,
						};
					}
					try { data = await resp.json(); } catch { data = null; }
					try { __apiKeyLive.onDone(keyToUse, { ...meta, httpStatus: resp.status, message: 'OK' }); } catch { }
					if (telemetryId && !telemetryDone) {
						try {
							__apiTelemetry.markResponse(telemetryId, {
								ok: true,
								httpStatus: resp.status,
								latencyMs: Date.now() - fetchStartAt,
							});
							telemetryDone = true;
						} catch { }
						try { if (__globalStatsSent) __globalCallStats.onFinal('success', { ts: Date.now() }); } catch { }
					}
					let contentText = '';
					try {
						if (apiMode === 'gemini_generatecontent') {
							const parts = data?.candidates?.[0]?.content?.parts || [];
							contentText = parts.map(p => p?.text || '').filter(Boolean).join('') || "";
						} else if (apiMode === 'cf_ai_run' || apiMode === 'cf_responses') {
							contentText = __extractCfResponseText(data, apiMode) || "";
						} else {
							contentText = (data?.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || "";
						}
					} catch { contentText = ''; }
					return {
						ok: true,
						status: resp.status,
						data,
						contentText,
						latencyMs: Date.now() - fetchStartAt,
						rateWaitMs,
						keyMasked: maskKey(keyToUse),
						apiMode,
						model,
						url,
					};
				} catch (e) {
					const errorMessage = didTimeout
						? `Timeout (${Math.round(timeoutMs / 1000)}s)`
						: ((e && e.message) ? e.message : (e ? e.toString() : 'Error'));
					try { __apiKeyLive.onDone(keyToUse, { ...meta, message: errorMessage }); } catch { }
					if (telemetryId && !telemetryDone) {
						try {
							const errorType = didTimeout ? 'timeout' : 'exception';
							__apiTelemetry.markResponse(telemetryId, {
								ok: false,
								errorType,
								errorMessage,
								latencyMs: Date.now() - fetchStartAt,
							});
							telemetryDone = true;
						} catch { }
						try { if (__globalStatsSent) __globalCallStats.onFinal('fail', { ts: Date.now() }); } catch { }
					}
					return {
						ok: false,
						status: 0,
						errorMessage,
						latencyMs: Date.now() - fetchStartAt,
						rateWaitMs,
						keyMasked: maskKey(keyToUse),
						apiMode,
						model,
						url,
					};
				} finally {
					try { inflightRelease?.(); } catch { }
					if (timeoutId) clearTimeout(timeoutId);
				}
			};

			window.addEventListener('message', (e) => {
				const d = e?.data;
				if (!d || typeof d !== 'object') return;
				if (d.type !== 'BRANCHING_V12_API_PROXY_CANCEL') return;
				const reqId = d.reqId;
				if (!reqId) return;
				try {
					const meta = reqState.get(reqId) || { canceled: false, abortController: null };
					meta.canceled = true;
					reqState.set(reqId, meta);
					try { meta.abortController?.abort(); } catch { }
				} catch { }
				try {
					// Remove queued items (and optionally notify) so we don't start them later.
					for (let i = queue.length - 1; i >= 0; i--) {
						const it = queue[i];
						if (it?.reqId !== reqId) continue;
						queue.splice(i, 1);
						try {
							it?.source?.postMessage({
								type: 'BRANCHING_V12_API_PROXY_RESPONSE',
								reqId,
								ok: false,
								status: 0,
								errorMessage: 'Canceled'
							}, '*');
						} catch { }
					}
				} catch { }
			});

			window.addEventListener('message', (e) => {
				const d = e?.data;
				if (!d || typeof d !== 'object') return;
				if (d.type !== 'BRANCHING_V12_API_PROXY_REQUEST') return;
				const reqId = d.reqId;
				if (!reqId) return;
				try { reqState.set(reqId, { canceled: false, abortController: null }); } catch { }
				queue.push({ payload: d.payload || {}, source: e.source, reqId });
				pump();
			});

			return true;
		})();

		async function __acquireRateSlot(arch, apiKey, estTokens) {
			const __isEnabled = () => !!document.getElementById('enableRateLimit')?.checked;
			const __getUiRpm = () => __normalizeRateLimit(document.getElementById('rpmLimit')?.value);
			const __getUiTpm = () => __normalizeRateLimit(document.getElementById('tpmLimit')?.value);

			const __waitInterruptible = async (ms) => {
				const total = Math.max(0, Number(ms) || 0);
				const end = Date.now() + total;
				while (Date.now() < end) {
					if (arch?.stopFlag || GLOBAL_EMERGENCY_STOP) return;
					const slice = Math.min(200, end - Date.now());
					await new Promise(res => setTimeout(res, slice));
				}
			};

			// Always enforce key cooldown (429 / repeated API errors), even when rate limit is disabled.
			while (true) {
				if (arch?.stopFlag || GLOBAL_EMERGENCY_STOP) return;
				const until = (() => {
					try { return __apiKeyLive.getCooldownUntil?.(apiKey); } catch { return null; }
				})();
				if (!Number.isFinite(until)) break;
				const now = Date.now();
				if (now >= until) break;
				const waitMs = Math.max(0, until - now + 5);
				arch?.log?.(`‚è≥ Key cooldown: wait ${(waitMs / 1000).toFixed(1)}s`);
				await __waitInterruptible(waitMs);
			}

			if (!__isEnabled()) return;

			const tokensForBucket = Number.isFinite(estTokens) ? Math.max(0, estTokens) : 0;
			const rpmLimitUi = __getUiRpm();
			const tpmLimitUi = __getUiTpm();
			const state = __applySharedRateLimitsForKey(apiKey, { rpmLimitUi, tpmLimitUi });

			// Prefer cross-window limiter (works even across multiple main windows) when available.
			try {
				const ls = await __rateLsLimiter.acquire(arch, apiKey, {
					rpmLimit: () => (__isEnabled() ? __getUiRpm() : 0),
					tpmLimit: () => (__isEnabled() ? __getUiTpm() : 0),
					tokensForBucket,
				});
				if (ls && ls.ok) {
					try {
						const s1 = ls.state || null;
						if (s1) {
							state.windowStart = Number.isFinite(s1.windowStart) ? s1.windowStart : state.windowStart;
							state.rpm = Number.isFinite(s1.rpm) ? s1.rpm : state.rpm;
							state.tpm = Number.isFinite(s1.tpm) ? s1.tpm : state.tpm;
							state.lastSentAt = Number.isFinite(s1.lastSentAt) ? s1.lastSentAt : Date.now();
							state.rpmLimit = __mergeRateLimit(state.rpmLimit, s1.rpmLimit);
							state.tpmLimit = __mergeRateLimit(state.tpmLimit, s1.tpmLimit);
						} else {
							state.lastSentAt = Date.now();
						}
					} catch { }
					return;
				}
			} catch { }

			// Serialize by key (guard against stale locks from closed job windows).
			__resetRateChainIfStale(state, Date.now());
			const lockId = `${Date.now()}_${Math.random().toString(36).slice(2)}`;
			const prevChain = state.chain;
			state.chainCreatedAt = Date.now();
			state.chain = Promise.resolve(prevChain).catch(() => { }).then(async () => {
				state.chainLockedAt = Date.now();
				state.chainOwner = lockId;
				const hardWaitStart = Date.now();
				let lastLogAt = 0;
				while (true) {
					if (arch?.stopFlag || GLOBAL_EMERGENCY_STOP) return;
					const now = Date.now();
					__recoverRateStateIfStale(state, now);

					const enabledNow = __isEnabled();
					if (!enabledNow) {
						try { state.lastSentAt = now; } catch { }
						return;
					}

					const rpmLimitUiNow = __getUiRpm();
					const tpmLimitUiNow = __getUiTpm();
					__applySharedRateLimitsForKey(apiKey, { rpmLimitUi: rpmLimitUiNow, tpmLimitUi: tpmLimitUiNow });
					const rpmLimit = Number.isFinite(state?.rpmLimit) ? state.rpmLimit : rpmLimitUiNow;
					const tpmLimit = Number.isFinite(state?.tpmLimit) ? state.tpmLimit : tpmLimitUiNow;
					const isTpmOversize = tpmLimit > 0 && tokensForBucket > tpmLimit;

					// RPM smoothing interval (60/RPM) + "Key Minimum 3s gap"
					const paceMs = rpmLimit > 0 ? Math.ceil(60000 / rpmLimit) : 0;
					const gapMs = Math.max(3000, paceMs); // Guarantee minimum 3s

					// (1) Smoothing: Guarantee per-key min gap (gapMs)
					const nextByGap = state.lastSentAt ? (state.lastSentAt + gapMs) : 0;
					if (nextByGap && now < nextByGap) {
						const waitMs = nextByGap - now + 5;
						if (!lastLogAt || (now - lastLogAt) > 1500) {
							lastLogAt = now;
							arch?.log?.(`‚è≥ Per-key pacing: wait ${(waitMs / 1000).toFixed(2)}s (min gap ${(gapMs / 1000).toFixed(1)}s)`);
						}
						await __waitInterruptible(Math.min(waitMs, 800));
						continue;
					}

					// (2) TPM/RPM bucket (Minute window)
					const win = __minuteStart(now);
					if (win !== state.windowStart) {
						state.windowStart = win;
						state.rpm = 0;
						state.tpm = 0;
					}

					const hitRpm = rpmLimit > 0 && (state.rpm + 1 > rpmLimit);
					const hitTpm = tpmLimit > 0 && (isTpmOversize ? (state.tpm >= tpmLimit) : (state.tpm + tokensForBucket > tpmLimit));

					if (!hitRpm && !hitTpm) {
						state.rpm += 1;
						if (tpmLimit > 0) {
							if (isTpmOversize) {
								state.tpm = Math.max(state.tpm, tpmLimit); // Saturate this key for the current minute window.
								arch?.log?.(`‚ö† Oversize TPM request (estTokens‚âà${tokensForBucket} > ${tpmLimit}). Sending once and locking this key until the window resets.`);
								try {
									__keySchedulerLog.add({
										type: 'tpm_oversize_saturate',
										uniqueId: arch?.uniqueId,
										archId: arch?.config?.id,
										instanceId: arch?.instanceId,
										key: maskKey(apiKey),
										estTokens: tokensForBucket,
										tpmLimit,
									});
								} catch { }
							} else {
								state.tpm += tokensForBucket; // provisional
							}
						}
						state.lastSentAt = Date.now(); // Record "sent time" for this key
						return;
					}

					const waitMs = (state.windowStart + 60000) - now + 25;
					if (Date.now() - hardWaitStart > 90000) {
						state.windowStart = __minuteStart(Date.now());
						state.rpm = 0;
						state.tpm = 0;
						state.lastSentAt = 0;
						arch?.log?.('‚ö† Rate wait exceeded 90s; resetting shared bucket to avoid deadlock.');
						continue;
					}
					if (!lastLogAt || (now - lastLogAt) > 1500) {
						lastLogAt = now;
						arch?.log?.(
							`‚è≥ Rate bucket full (rpm=${state.rpm}/${rpmLimit || '‚àû'}, tpm‚âà${state.tpm}/${tpmLimit || '‚àû'}). ` +
							`Waiting ${(waitMs / 1000).toFixed(1)}s...`
						);
					}
					await __waitInterruptible(Math.min(Math.max(0, waitMs), 800));
				}
			}).finally(() => {
				if (state.chainOwner === lockId) {
					state.chainLockedAt = 0;
					state.chainOwner = null;
					state.chainCreatedAt = 0;
				}
			});

			await state.chain;
		}

		function __reconcileTokens(apiKey, estTokens, actualTokens) {
			const enabled = document.getElementById('enableRateLimit')?.checked;
			if (!enabled) return;

			const key = apiKey || '__NO_KEY__';
			const state = __rateState.get(key);
			if (!state) return;

			// Reconcile only if in same window
			if (state.windowStart !== __minuteStart(Date.now())) return;

			const delta = (actualTokens || 0) - (estTokens || 0);
			if (delta > 0) state.tpm += delta;
		}
		// ===== END GLOBAL HELPERS =====

		// --- CORE AGENT CLASS ---
		// --- Persistence / log trimming (keeps autosave + save files small) ---
		const __PERSIST_CFG = {
			agentLogsMaxEntries: 120,
			agentLogLineMaxChars: 700,
			agentApiResponseMaxChars: 7000,
			agentGenericBlockMaxChars: 2200,
		};

		function __persistClampInt(v, fallback, min = 1, max = 999999) {
			const n = parseInt(v, 10);
			if (!Number.isFinite(n)) return fallback;
			return Math.min(max, Math.max(min, n));
		}

		function __persistTrunc(str, maxChars = 2000) {
			const s = (str ?? '').toString();
			const max = __persistClampInt(maxChars, 2000, 20, 500000);
			if (s.length <= max) return s;
			return s.slice(0, Math.max(0, max - 1)) + '‚Ä¶';
		}

		function __persistCompactAgentLogBlock(block) {
			const s = (block ?? '').toString();
			if (!s) return '';
			if (s.startsWith('‚Üí API Request')) {
				const idx = s.indexOf('\n[');
				if (idx >= 0) return s.slice(0, idx) + '\n[...messages omitted to keep state small...]';
				return __persistTrunc(s, __PERSIST_CFG.agentGenericBlockMaxChars);
			}
			if (s.startsWith('‚Üê API Response Received')) {
				const header = '‚Üê API Response Received\n';
				const rest = s.startsWith(header) ? s.slice(header.length) : s;
				return header + __persistTrunc(rest, __PERSIST_CFG.agentApiResponseMaxChars);
			}
			if (s.startsWith('‚Üê API Error')) return __persistTrunc(s, __PERSIST_CFG.agentGenericBlockMaxChars);
			return __persistTrunc(s, __PERSIST_CFG.agentGenericBlockMaxChars);
		}

		function __persistTrimLogArray(logs) {
			if (!Array.isArray(logs)) return;
			const max = __persistClampInt(__PERSIST_CFG.agentLogsMaxEntries, 120, 0, 5000);
			if (logs.length > max) logs.splice(0, logs.length - max);
		}

		function __persistSanitizeAgentStateForSave(state) {
			if (!state || typeof state !== 'object') return state;
			const s = { ...state };
			if (Array.isArray(s.logs)) {
				const max = __persistClampInt(__PERSIST_CFG.agentLogsMaxEntries, 120, 0, 5000);
				s.logs = s.logs.slice(-max).map((entry) => {
					const txt = (entry ?? '').toString();
					if (txt.startsWith('‚Üí API Request') || txt.startsWith('‚Üê API Response Received') || txt.startsWith('‚Üê API Error')) {
						return __persistCompactAgentLogBlock(txt);
					}
					return __persistTrunc(txt, __PERSIST_CFG.agentLogLineMaxChars);
				});
			}
			if (Array.isArray(s.globalMemory) && s.globalMemory.length > 300) s.globalMemory = s.globalMemory.slice(-300);
			return s;
		}
		class AgentSystem {
			constructor(config, instanceId) {
				this.config = config;
				this.instanceId = instanceId;
				this.uniqueId = `${config.id}-${instanceId}`;

				this.state = {
					initialQuery: null,
					globalMemory: [],
					runIdx: 1,
					logs: [],
					status: 'Ready',
					finalResult: null,
					rr: { solver: 0, verifier: 0 },
					metrics: {
						startTime: 0,
						elapsedSec: 0,
						calls: 0,
						tokens: 0
					}
				};

				this.consecutiveApiErrors = 0;
				this.stopFlag = false;
				this._inFlightAbortController = null;
				this.timer = null;
				this._activeRun = false;
				this._liveReq = { rawKey: null, keyIndex: null, masked: '-', estTokens: null, retryCount: 0, retryUntil: null };
			}

				restore(savedState) {
					const incoming = (savedState && typeof savedState === 'object') ? savedState : {};
					const next = { ...(incoming || {}) };

					if (!Array.isArray(next.logs)) next.logs = [];
					if (!Array.isArray(next.globalMemory)) next.globalMemory = [];
					if (!Number.isFinite(next.runIdx)) {
						const n = parseInt(next.runIdx ?? '1', 10);
						next.runIdx = Number.isFinite(n) ? n : 1;
					}
					next.status = (next.status ?? 'Ready').toString();
					if (next.finalResult != null && typeof next.finalResult !== 'string') next.finalResult = (next.finalResult ?? '').toString();

					const m0 = (next.metrics && typeof next.metrics === 'object') ? next.metrics : {};
					if (!next.metrics || typeof next.metrics !== 'object') next.metrics = {};
					if (!Number.isFinite(next.metrics.startTime)) next.metrics.startTime = Number.isFinite(m0.startTime) ? m0.startTime : 0;
					if (next.metrics.elapsedSec == null) next.metrics.elapsedSec = (m0.elapsedSec != null) ? m0.elapsedSec : 0;
					if (!Number.isFinite(next.metrics.calls)) {
						const n = parseInt(m0.calls ?? next.metrics.calls ?? '0', 10);
						next.metrics.calls = Number.isFinite(n) ? n : 0;
					}
					if (!Number.isFinite(next.metrics.tokens)) {
						const n = parseInt(m0.tokens ?? next.metrics.tokens ?? '0', 10);
						next.metrics.tokens = Number.isFinite(n) ? n : 0;
					}

					this.state = next;
					this.ensureRoundRobinState();
					if (this.state.status.includes('FATAL') || this.state.status.includes('quota')) {
						this.state.status = 'Paused (Resumed)';
						this.consecutiveApiErrors = 0;
					}
					this.updateStatusUI(this.state.status);
					try { this.updateMetricsUI(); } catch { }
					if (this.state.finalResult) {
						const resEl = document.getElementById(`result-area-${this.uniqueId}`);
						if (resEl) resEl.value = this.state.finalResult;
					}
					this.refreshWhiteboardUI();
					this.updateLiveRequestInfo({ rawKey: null, estTokens: null, retryCount: 0, retryUntil: null });
					const el = document.getElementById(`last-action-${this.uniqueId}`);
					if (el && this.state.logs.length > 0) {
						const last = (this.state.logs[this.state.logs.length - 1] ?? '').toString();
						el.innerText = last.substring(0, 70) + "...";
					}
				}

			ensureRoundRobinState() {
				const rr = this.state?.rr;
				if (!rr || typeof rr !== 'object') {
					this.state.rr = { solver: 0, verifier: 0 };
					return;
				}
				if (!Number.isFinite(rr.solver)) rr.solver = 0;
				if (!Number.isFinite(rr.verifier)) rr.verifier = 0;
			}

			resetRoundRobinState() {
				this.ensureRoundRobinState();
				this.state.rr.solver = 0;
				this.state.rr.verifier = 0;
			}

			getRr3Personas(kind) {
				const k = (kind || '').toString().trim().toLowerCase();
				if (k === 'solver') {
					return [
						{ name: 'Formalist', note: 'Track definitions/quantifiers carefully; keep obligations explicit; avoid leaps.' },
						{ name: 'Logicist', note: 'Build a clean chain of implications; justify every step; label steps/lemmas.' },
						{ name: 'Intuitionist', note: 'Use sanity checks, counterexamples, edge cases, and invariants; then write a fully rigorous proof.' },
					];
				}
				return [
					{ name: 'Formalist', note: 'Track definitions/quantifiers carefully; ensure no hidden assumptions.' },
					{ name: 'Logicist', note: 'Check step-by-step validity and explicit justification of each implication.' },
					{ name: 'Intuitionist', note: 'Use sanity checks, counterexamples, edge cases, and invariants.' },
				];
			}

			nextRoundRobinPersona(kind) {
				this.ensureRoundRobinState();
				const k = (kind || '').toString().trim().toLowerCase();
				const personas = this.getRr3Personas(k);
				const idx = this.state.rr[k] || 0;
				this.state.rr[k] = idx + 1;
				return personas[idx % personas.length];
			}

			applyPersonaToSystemPrompt(systemPrompt, persona, extraRule = '') {
				const sys = (systemPrompt || '').toString();
				if (!persona || !persona.name) return sys;
				const note = (persona.note || '').toString().trim();
				const rule = (extraRule || '').toString().trim();
				const ruleBlock = rule ? `\n\n${rule}` : '';
				return `${sys}\n\nPersona: ${persona.name}\nGuidance: ${note}${ruleBlock}`.trim();
			}

			startTimer() {
				if (!this.state.metrics.startTime) this.state.metrics.startTime = Date.now();
				if (this.timer) clearInterval(this.timer);
				this.timer = setInterval(() => {
					if (this.state.status === 'Running') {
						this.state.metrics.elapsedSec = ((Date.now() - this.state.metrics.startTime) / 1000).toFixed(1);
						this.updateMetricsUI();
					}
				}, 200);
			}

			stopTimer() {
				if (this.timer) clearInterval(this.timer);
			}

			updateMetricsUI() {
				const m = this.state.metrics;
				const cardEl = document.getElementById(`agent-card-${this.uniqueId}`);
				if (!cardEl) {
					// Card was removed (e.g., clear/rebuild). Stop orphaned timer updates.
					this.stopTimer();
					return;
				}
				const tEl = document.getElementById(`time-${this.uniqueId}`);
				if (tEl) tEl.innerText = m.elapsedSec + 's';
				const cEl = document.getElementById(`calls-${this.uniqueId}`);
				if (cEl) cEl.innerText = m.calls;
				const tokEl = document.getElementById(`tokens-${this.uniqueId}`);
				if (tokEl) tokEl.innerText = m.tokens;
			}

			updateLiveRequestInfo(patch = {}) {
				const prev = this._liveReq || { rawKey: null, keyIndex: null, masked: '-', estTokens: null, retryCount: 0, retryUntil: null };
				const next = { ...prev, ...(patch || {}) };
				if (next.rawKey) {
					const order = getApiKeyListFromInput();
					const idx = order.indexOf(next.rawKey);
					next.keyIndex = idx >= 0 ? idx + 1 : null;
					next.masked = maskKey(next.rawKey);
				} else {
					next.keyIndex = null;
					next.masked = '-';
				}
				next.estTokens = Number.isFinite(next.estTokens) ? next.estTokens : null;
				next.retryCount = Number.isFinite(next.retryCount) ? next.retryCount : 0;
				next.retryUntil = Number.isFinite(next.retryUntil) ? next.retryUntil : null;
				this._liveReq = next;
				this.refreshLiveRequestInfoUI();
			}

			resolveLockedQuery(incomingQuery) {
				const locked = (this.state?.initialQuery || this.jobQuery || '').toString();
				if (locked) {
					if (!this.state.initialQuery) this.state.initialQuery = locked;
					return locked;
				}
				const next = (incomingQuery ?? '').toString();
				if (next.trim()) {
					this.state.initialQuery = next;
					this.jobQuery = next;
				}
				return next;
			}

			refreshLiveRequestInfoUI() {
				const info = this._liveReq;
				if (!info) return;
				const keyEl = document.getElementById(`agent-key-${this.uniqueId}`);
				if (keyEl) {
					if (info.rawKey) {
						const prefix = info.keyIndex ? `#${info.keyIndex} ` : '';
						keyEl.innerText = `${prefix}${info.masked}`;
					} else {
						keyEl.innerText = '-';
					}
				}
				const tokEl = document.getElementById(`agent-esttok-${this.uniqueId}`);
				if (tokEl) tokEl.innerText = Number.isFinite(info.estTokens) ? String(info.estTokens) : '-';
				const retryEl = document.getElementById(`agent-retry-${this.uniqueId}`);
				if (retryEl) retryEl.innerText = info.retryCount > 0 ? `x${info.retryCount}` : '-';
				const waitEl = document.getElementById(`agent-wait-${this.uniqueId}`);
				if (waitEl) {
					const now = Date.now();
					if (Number.isFinite(info.retryUntil) && now < info.retryUntil) {
						const left = Math.max(0, Math.ceil((info.retryUntil - now) / 1000));
						waitEl.innerText = `${left}s`;
					} else {
						waitEl.innerText = '-';
					}
				}
			}

			log(msg) {
				const ts = new Date().toTimeString().split(' ')[0];
				const line = __persistTrunc(`[${ts}] ${msg}`, __PERSIST_CFG.agentLogLineMaxChars);
				this.state.logs.push(line);
				__persistTrimLogArray(this.state.logs);

				const el = document.getElementById(`last-action-${this.uniqueId}`);
				if (el) {
					el.innerText = msg.length > 70 ? msg.substring(0, 70) + "..." : msg;
					el.title = msg;
				}
			}

			logBlock(block) {
				this.state.logs.push(__persistCompactAgentLogBlock(block));
				__persistTrimLogArray(this.state.logs);
				const el = document.getElementById(`last-action-${this.uniqueId}`);
				if (el) {
					if (block.includes('API Request')) el.innerText = "Sending API Request...";
					else if (block.includes('API Response')) el.innerText = "Received API Response.";
				}
			}

			updateStatusUI(status, color = null) {
				this.state.status = status;
				const el = document.getElementById(`status-${this.uniqueId}`);
				if (!el) return;

				el.innerText = status;

				const s = (status || '').toString().toLowerCase();
				const isSuccess = s.includes('success');
				const isRunning = s.includes('running');
				const isFailed = s.includes('failed') || s.includes('fatal') || s.includes('error');
				const isPaused = s.includes('paused') || s.includes('pause');

				let finalColor = color;
				if (isSuccess) finalColor = finalColor || 'var(--status-success)';
				else if (isRunning) finalColor = 'var(--status-running)';
				else if (!finalColor || finalColor === 'black' || finalColor === '#000' || finalColor === '#000000') {
					if (isFailed) finalColor = 'var(--log-error)';
					else if (isPaused) finalColor = 'orange';
					else finalColor = 'var(--text-2)';
				} else if (finalColor === 'blue' && isRunning) {
					finalColor = 'var(--status-running)';
				}

				el.style.color = finalColor;
			}

			showRetryOverlay(show) {
				const el = document.getElementById(`retry-${this.uniqueId}`);
				if (el) el.style.display = show ? 'block' : 'none';
			}

			async sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

			async sleepInterruptible(ms) {
				const total = Math.max(0, Number(ms) || 0);
				const end = Date.now() + total;
				while (Date.now() < end) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) return;
					const slice = Math.min(200, end - Date.now());
					await this.sleep(slice);
				}
			}

			abortInFlight() {
				try { this._inFlightAbortController?.abort(); } catch { }
				this._inFlightAbortController = null;
			}

			async callAPI(messages, validator = null, options = {}) {
				// Optional per-round call cap (used by some multi-round architectures).
				// Enforced here so *all* API calls within the round respect the cap.
				const __roundStopPrefix = '__ROUND_STOP__';
				const __roundCapRaw = this.state ? this.state._roundCallCap : null;
				const __roundCap = (typeof __roundCapRaw === 'number' && Number.isFinite(__roundCapRaw)) ? __roundCapRaw : 0;
				if (__roundCap > 0) {
					const start = (this.state && typeof this.state._roundCallStartCalls === 'number' && Number.isFinite(this.state._roundCallStartCalls))
						? this.state._roundCallStartCalls
						: (this.state?.metrics?.calls || 0);
					const used = (this.state?.metrics?.calls || 0) - start;
					if (used >= __roundCap) {
						throw new Error(`${__roundStopPrefix}:${used}/${__roundCap}`);
					}
				}
				const __roundTokCapRaw = this.state ? this.state._roundTokenCap : null;
				const __roundTokCap = (typeof __roundTokCapRaw === 'number' && Number.isFinite(__roundTokCapRaw)) ? __roundTokCapRaw : 0;
				if (__roundTokCap > 0) {
					const startT = (this.state && typeof this.state._roundTokenStartTokens === 'number' && Number.isFinite(this.state._roundTokenStartTokens))
						? this.state._roundTokenStartTokens
						: (this.state?.metrics?.tokens || 0);
					const usedT = (this.state?.metrics?.tokens || 0) - startT;
					if (usedT >= __roundTokCap) {
						throw new Error(`${__roundStopPrefix}:tok:${usedT}/${__roundTokCap}`);
					}
				}

					if (document.getElementById('mockModeChk') && document.getElementById('mockModeChk').checked) {
						while (true) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped by User");
							const mockResp = await this.mockApiCall(messages, validator, options);
						if (!validator) return mockResp;
						const validationResult = validator(mockResp);
						if (validationResult === true) return mockResp;
						const reason = typeof validationResult === 'string' ? validationResult : 'Invalid output';
						this.log(`‚ö† Mock validator reject: ${reason}. Retrying...`);
							await this.sleepInterruptible(50);
						}
					}
					// In attached job windows, API execution is proxied by the main window.
					// Mirror main API inputs here so logs/telemetry don't show empty model/url.
					try { __syncProxyApiInputsFromMain({ force: true, includeKeys: false }); } catch { }
					const rawUrl = (document.getElementById('apiUrl').value || '').trim();
					const modelInput = (document.getElementById('modelName').value || '').trim();
				const model = modelInput.replace(/^models\//i, '').trim();
				const url = rawUrl
					.replaceAll('{model}', model)
					.replaceAll('{{MODEL}}', model);
				const requestOptions = { ...(options || {}) };
				const baseTemperature = typeof requestOptions.temperature === 'number' ? requestOptions.temperature : 0.7;
				let currentTemperature = baseTemperature;
				const apiMode = (() => {
					const lower = (url || '').toLowerCase();
					if (lower.includes('/ai/run/')) return 'cf_ai_run';
					if (lower.includes('/ai/v1/responses')) return 'cf_responses';
					if (lower.includes('/openai/')) return 'openai_chat_completions';
					if (lower.includes(':generatecontent') || lower.includes(':streamgeneratecontent')) return 'gemini_generatecontent';
					return 'openai_chat_completions';
				})();

				const __withKeyParam = (u, key) => {
					try {
						const parsed = new URL(u);
						parsed.searchParams.set('key', key);
						return parsed.toString();
					} catch {
						if (!u) return u;
						const sep = u.includes('?') ? '&' : '?';
						return `${u}${sep}key=${encodeURIComponent(key)}`;
					}
				};

				const __toGeminiPayload = (msgs) => {
					const systemParts = [];
					const contents = [];
					for (const m of (msgs || [])) {
						const role = (m?.role || '').toLowerCase();
						const text = (m?.content ?? '').toString();
						if (!text) continue;
						if (role === 'system') {
							systemParts.push(text);
							continue;
						}
						const gemRole = (role === 'assistant' || role === 'model') ? 'model' : 'user';
						contents.push({ role: gemRole, parts: [{ text }] });
					}
					const systemInstruction = systemParts.length ? { parts: [{ text: systemParts.join('\n\n') }] } : null;
					if (!contents.length && systemInstruction) {
						// Safety fallback: keep at least 1 user content message.
						contents.push({ role: 'user', parts: [{ text: systemParts.join('\n\n') }] });
						return { contents, systemInstruction: null };
					}
					return { contents, systemInstruction };
				};

				// [1] System role bypass option
				let finalMessages = [...messages];
				const bypass = document.getElementById('bypassSystemRole')?.checked;
				if (bypass) {
					finalMessages = __adaptMessagesNoSystem(finalMessages);
				}

				const baseMessages = [...finalMessages];
				let attemptMessages = baseMessages;
				let attemptMode = 'generate'; // generate | repair
				let repairContext = null; // { kind, originalText, fingerprint }
				let lastValidationOutputHash = '';
				let noProgressStreak = 0;
				let sameValidationReasonStreak = 0;
				let lastValidationReason = '';
				let apiAttemptSeq = 0;

				const __buildValidationFeedback = (reasonText, streak) => {
					const reason = (reasonText || '').toString().trim() || 'Invalid output';
					const r = reason.toLowerCase();
					const strong = streak >= 2;
					const veryStrong = streak >= 3;

					const tips = [];
					tips.push(`Reason: ${reason}`);
					tips.push(`Fix the output so it satisfies the validator EXACTLY.`);
					tips.push(`Do NOT add extra tags or commentary beyond what the original prompt requires.`);
					tips.push(`Before sending, self-check: required tags exist, tags are properly closed, and counts/constraints match.`);

					if (r.includes('<pass>') || r.includes('<fail>')) {
						tips.push(`The VERY LAST token must be exactly <pass> or <fail> (nothing after it).`);
					}
					if (r.includes('<checklist>')) {
						tips.push(`Checklist format reminder:\n<checklist>\n1. Must: ...\n2. Must: ...\n...\n</checklist>`);
					}
					if (r.includes('<meta_report>') || r.includes('<fixes>')) {
						tips.push(`Meta-verifier format reminder:\n<meta_report>...</meta_report>\n<fixes>...</fixes>\n<pass|fail>`);
					}
					if (r.includes('<methodology>') || r.includes('<commitments>')) {
						tips.push(`Methodology format reminder:\n<methodology>\n- Define ...\n- Check ...\n...\n</methodology>\n<commitments>\n1) Must detect/avoid: ...\n2) ...\n3) ...\n</commitments>`);
					}
					if (r.includes('<working_memory>') || r.includes('<wm')) {
						tips.push(`Working memory XML reminder:\n<working_memory>\n  <wm id=\"wm1\" type=\"KEEP\">\n    Statement: ...\n    Evidence: ...\n  </wm>\n</working_memory>`);
					}

					if (strong) tips.push(`Retry using ONLY the required output blocks; do not include any preface.`);
					if (veryStrong) tips.push(`You repeated the same mistake multiple times: rewrite from scratch and follow the format literally.`);

					return `[VALIDATION FEEDBACK ‚Äî AUTO-PARSER]\n${tips.join('\n')}\n\nRetry now.`;
				};

				const __inferValidationKind = (msgs) => {
					const sys = (Array.isArray(msgs) ? msgs : [])
						.filter(m => (m?.role || '').toLowerCase() === 'system')
						.map(m => (m?.content || '').toString())
						.join('\n');
					if (sys.includes('Checklist Writer')) return 'checklist_writer';
					if (sys.includes('Checklist Verifier')) return 'checklist_verifier';
					if (sys.includes('Red Team Verifier')) return 'rt2_checklist';
					if (sys.includes('Methodology Designer')) return 'methodology_pack';
					if (sys.includes('Methodology Debate Speaker')) return 'debate_turn';
					if (sys.includes('Task-Type Classifier')) return 'task_type';
					if (sys.includes('Memory Purifier')) return 'memory_purifier';
					if (sys.includes('You are the Solver')) return 'solver';
					return 'generic';
				};

				const validationKind = requestOptions.validationKind || __inferValidationKind(baseMessages);

				const __outputSpecForKind = (kind) => {
					if (kind === 'checklist_writer') {
						return `<checklist>\n1. Must: ...\n2. Must: ...\n...\n</checklist>\n(6‚Äì12 items, 1 sentence each)`;
					}
					if (kind === 'checklist_verifier') {
						return `<meta_report>\nMC1: PASS/FAIL - ...\n...\nMC8: PASS/FAIL - ...\n</meta_report>\n<fixes>\n- ...\n</fixes>\n<pass|fail>  (final tag at the very end)`;
					}
					if (kind === 'methodology_pack') {
						return `<methodology>\n- Define ...\n- Check ...\n...\n</methodology>\n<commitments>\n1) Must detect/avoid: ...\n2) ...\n3) ...\n</commitments>`;
					}
					if (kind === 'rt2_checklist') {
						return `<checklist_report>...</checklist_report>\n<attack_report>...</attack_report>\n<pass|fail> (final tag at the very end)`;
					}
					if (kind === 'task_type') {
						return `<TaskType>OPTIMIZATION_BOUND|EXISTENCE|CONSTRUCTION|DEBUGGING|EXPLANATION|PLANNING|OTHER</TaskType> (at the very end)`;
					}
					if (kind === 'solver' || kind === 'memory_purifier') {
						return `<working_memory>...</working_memory> (at the very end; may be empty)`;
					}
					return `Follow the exact output format required by the prompt and close all required tags.`;
				};

				const outputSpec = requestOptions.outputSpec || __outputSpecForKind(validationKind);

				const __sanitizeModelText = (raw) => {
					let s = (raw ?? '').toString().replace(/\uFEFF/g, '').trim();
					for (let i = 0; i < 3; i++) {
						const m =
							s.match(/^\s*```[a-zA-Z0-9_-]*\s*\n([\s\S]*?)\n```\s*$/) ||
							s.match(/^\s*```[a-zA-Z0-9_-]*\s*([\s\S]*?)```\s*$/);
						if (!m) break;
						s = (m[1] ?? '').toString().trim();
					}
					return s.trim();
				};

				const __closeIfOpenOnly = (text, tag) => {
					const t = (text || '').toString();
					if (this.hasTagBlock(t, tag)) return t;
					const openRe = new RegExp(`<${tag}>`, 'i');
					const closeRe = new RegExp(`</${tag}>`, 'i');
					if (openRe.test(t) && !closeRe.test(t)) return `${t}\n</${tag}>`;
					if (!openRe.test(t) && closeRe.test(t)) return `<${tag}>\n${t}`;
					return t;
				};

				const __ensureFinalPassFailAtEnd = (text) => {
					let t = (text || '').toString().trim();
					const final = this.extractFinalSingleTag(t, ['pass', 'fail']);
					if (final) return t;

					const all = [...t.matchAll(/<\s*(pass|fail)\s*\/?>/gi)].map(m => (m[1] || '').toLowerCase());
					let chosen = all.length ? all[all.length - 1] : null;
					if (!chosen) {
						const v = (this.extractTag(t, 'verdict') || '').trim().toLowerCase();
						if (v === 'pass' || v === 'fail') chosen = v;
					}
					if (!chosen) return t;

					t = t.replace(/<\s*\/?\s*(pass|fail)\s*\/?>\s*/gi, '').trim();
					return `${t}\n<${chosen}>`.trim();
				};

				const __extractChecklistMustItemsLoose = (text) => {
					const inner = this.extractTag(text, 'checklist');
					const src = (inner !== null && inner !== undefined) ? inner : (text || '');
					const lines = src.split(/\r?\n/g).map(l => l.trim()).filter(Boolean);
					const items = [];
					for (const line of lines) {
						const m =
							line.match(/^(?:\d+[\.\)\]]\s*)?Must\s*[:\-]\s*(.+)\s*$/i) ||
							line.match(/^[-*]\s*Must\s*[:\-]\s*(.+)\s*$/i) ||
							line.match(/\bMust\s*[:\-]\s*(.+)\s*$/i);
						if (m && m[1] && m[1].trim()) items.push(m[1].trim());
					}
					return items;
				};

				const __canonicalChecklistBlock = (items) => {
					const arr = Array.isArray(items) ? items.map(x => (x || '').toString().trim()).filter(Boolean) : [];
					const lines = arr.map((it, idx) => `${idx + 1}. Must: ${it}`);
					return `<checklist>\n${lines.join('\n')}\n</checklist>`;
				};

				const __extractMethodologyPackLoose = (text) => {
					const methInner = this.extractTag(text, 'methodology');
					const comInner = this.extractTag(text, 'commitments');

					const methSrc = (methInner !== null && methInner !== undefined) ? methInner : (text || '');
					const comSrc = (comInner !== null && comInner !== undefined) ? comInner : (text || '');

					const bullets = methSrc
						.split(/\r?\n/g)
						.map(l => l.trim())
						.filter(l => /^[-*‚Ä¢]\s+/.test(l) || /^\d+[\.\)\]]\s+/.test(l))
						.map(l => l.replace(/^[-*‚Ä¢]\s+/, '').replace(/^\d+[\.\)\]]\s+/, '').trim())
						.filter(Boolean);

					const commits = [];
					for (const line of comSrc.split(/\r?\n/g).map(l => l.trim()).filter(Boolean)) {
						const m = line.match(/^\d+[\.\)\]]\s*(.+)$/);
						if (m && m[1] && m[1].trim()) commits.push(m[1].trim());
					}

					return {
						bullets,
						commitments: commits,
						hasMethodologyTag: (methInner !== null && methInner !== undefined),
						hasCommitmentsTag: (comInner !== null && comInner !== undefined),
					};
				};

				const __normalizeMethodBullet = (bulletText) => {
					return (bulletText || '').toString().trim();
				};

				const __canonicalMethodologyPack = (bullets, commitments) => {
					const bs = (Array.isArray(bullets) ? bullets : []).map(__normalizeMethodBullet).filter(Boolean);
					const cs = (Array.isArray(commitments) ? commitments : []).map(x => (x || '').toString().trim()).filter(Boolean);
					const methLines = bs.map(b => `- ${b}`);
					const comLines = cs.map((c, idx) => `${idx + 1}) ${c}`);
					return `<methodology>\n${methLines.join('\n')}\n</methodology>\n<commitments>\n${comLines.join('\n')}\n</commitments>`;
				};

				const __regularizeOutput = (kind, text, reasonText) => {
					let t = __sanitizeModelText(text);
					const r = (reasonText || '').toString().toLowerCase();

					// Common "missing closing tag" fixups
					for (const tag of ['checklist', 'meta_report', 'fixes', 'methodology', 'commitments', 'checklist_report', 'attack_report', 'verdict', 'working_memory']) {
						t = __closeIfOpenOnly(t, tag);
					}

					if (kind === 'checklist_writer') {
						const items = __extractChecklistMustItemsLoose(t);
						if (items.length >= 6 && items.length <= 12) return __canonicalChecklistBlock(items);
						return t;
					}

					if (kind === 'methodology_pack') {
						const pack = __extractMethodologyPackLoose(t);
						if (pack.bullets.length >= 6 && pack.bullets.length <= 12 && pack.commitments.length >= 3) {
							return __canonicalMethodologyPack(pack.bullets, pack.commitments);
						}
						return t;
					}

					// For <pass>/<fail>-terminated artifacts, move/normalize the final tag deterministically.
					if (kind === 'checklist_verifier' || kind === 'rt2_checklist') {
						t = __ensureFinalPassFailAtEnd(t);
					}

					// RT2: if we have the required blocks, rebuild into a canonical flat structure to avoid nesting/placement issues.
					if (kind === 'rt2_checklist') {
						const finalTag = this.extractFinalSingleTag(t, ['pass', 'fail']);
						const checklistInner = this.extractTag(t, 'checklist_report');
						const attackInner = this.extractTag(t, 'attack_report');
						if (finalTag && checklistInner !== null && attackInner !== null) {
							const stripPassFail = (s) => (s || '').toString().replace(/<\s*\/?\s*(pass|fail)\s*\/?>\s*/gi, '').trim();
							let c = stripPassFail(checklistInner);
							let a = stripPassFail(attackInner);
							a = a.replace(/<checklist_report>[\s\S]*?<\/checklist_report>/gi, '').trim();
							c = c.replace(/<attack_report>[\s\S]*?<\/attack_report>/gi, '').trim();
							t = `<checklist_report>\n${c}\n</checklist_report>\n\n<attack_report>\n${a}\n</attack_report>\n\n<${finalTag}>`.trim();
						}
					}

					if (kind === 'solver' || kind === 'memory_purifier') {
						if (!this.hasTagBlock(t, 'working_memory')) {
							if (/<working_memory>/i.test(t) && !/<\/working_memory>/i.test(t)) {
								t = `${t}\n</working_memory>`;
							} else {
								t = `${t}\n\n<working_memory>\n</working_memory>`;
							}
						}

						// Cheap schema regularization (id + ttl="2" for HYP/TODO) without changing meaning.
						if (this.hasTagBlock(t, 'working_memory')) {
							const inner = this.extractTag(t, 'working_memory') || '';
							let wmIdx = 0;
							const fixedInner = inner.replace(/<wm\b([^>]*)>/gi, (m, attrsRaw) => {
								wmIdx += 1;
								let attrs = (attrsRaw || '').toString();
								if (!/\bid\s*=\s*"/i.test(attrs)) attrs = ` id="wm${wmIdx}"${attrs}`;
								const typeMatch = attrs.match(/\btype\s*=\s*"([^"]+)"/i);
								const type = typeMatch ? (typeMatch[1] || '').trim().toUpperCase() : '';
								if (type === 'HYP' || type === 'TODO') {
									if (/\bttl\s*=\s*"/i.test(attrs)) attrs = attrs.replace(/\bttl\s*=\s*"[^"]*"/i, 'ttl="2"');
									else attrs = `${attrs} ttl="2"`;
								}
								return `<wm${attrs}>`;
							});
							t = t.replace(/<working_memory>[\s\S]*?<\/working_memory>/i, `<working_memory>\n${fixedInner.trim()}\n</working_memory>`);
						}
						return t.trim();
					}

					return t;
				};

				const __semanticFingerprint = (kind, text) => {
					const t = (text || '').toString();
					if (kind === 'checklist_writer') {
						const items = __extractChecklistMustItemsLoose(t);
						if (items.length < 6 || items.length > 12) return null;
						return JSON.stringify(items.map(x => x.trim()));
					}
					if (kind === 'methodology_pack') {
						const pack = __extractMethodologyPackLoose(t);
						if (pack.bullets.length < 6 || pack.bullets.length > 12) return null;
						if (pack.commitments.length < 3) return null;
						return JSON.stringify({
							bullets: pack.bullets.map(b => (b || '').toString().trim()),
							commitments: pack.commitments.map(x => x.trim()),
						});
					}
					return null;
				};

				const __meaningPreserved = (kind, beforeText, afterText) => {
					const a = __semanticFingerprint(kind, beforeText);
					const b = __semanticFingerprint(kind, afterText);
					if (!a || !b) return false;
					return a === b;
				};

				const __buildRepairMessages = (kind, originalText, reasonText) => {
					const sys = `You are a Format Corrector.
Your ONLY job is to fix surface formatting so the text passes the validator.

	                    Hard rules:
	                    - Do NOT change meaning.
	                    - Do NOT add new items or remove items.
	                    - Do NOT rewrite sentences except for minimal structural fixes (tags, numbering, bullet markers).
	                    - Do NOT wrap the output in code fences.
	                    - Output ONLY the corrected text (no explanation).`;

					const allowedEdits = kind === 'methodology_pack'
						? `Allowed edits: add/close required tags, normalize bullets to "- ", normalize numbering.`
						: (kind === 'rt2_checklist'
							? `Allowed edits: ensure exactly two top-level blocks <checklist_report>...</checklist_report> and <attack_report>...</attack_report> (no nesting), close tags, move final <pass> or <fail> to the very end, remove code fences.`
							: `Allowed edits: add/close required tags, normalize numbering/bullets, move required final tags to the end, remove code fences.`);

					const user = `[OUTPUT SPEC]\n${outputSpec}\n\n[VALIDATOR ERROR]\n${(reasonText || '').toString().trim()}\n\n[ORIGINAL TEXT]\n${(originalText || '').toString().trim()}\n\n${allowedEdits}\n\nReturn ONLY the corrected text.`;

					const msgs = [{ role: 'system', content: sys }, { role: 'user', content: user }];
					return bypass ? __adaptMessagesNoSystem(msgs) : msgs;
				};

				const __classifyValidationFailure = (kind, candidateText, reasonText) => {
					const r = (reasonText || '').toString().toLowerCase();

					// For artifacts where "meaning lock" matters, only repair if content is already sufficient.
					if (kind === 'checklist_writer' || kind === 'methodology_pack') {
						const fp = __semanticFingerprint(kind, candidateText);
						return fp ? 'repair' : 'regenerate';
					}

					// For working_memory-style validators: we only do safe regularization; if still failing, regenerate.
					if (kind === 'solver' || kind === 'memory_purifier') return 'regenerate';

					// Generic format issues ‚Üí repair; otherwise regenerate.
					if (r.includes('missing') || r.includes('tag') || r.includes('final') || r.includes('code fence') || r.includes('format')) return 'repair';
					return 'regenerate';
				};

				const __buildGeneratorRetryNote = (reasonText, streak) => {
					const base = __buildValidationFeedback(reasonText, streak);
					return `${base}\n\n[OUTPUT SPEC]\n${outputSpec}\n\nDo NOT wrap in code fences. Output ONLY what the format requires.`;
				};

				while (true) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped by User");
					let keyToUse = "";
					let telemetryId = null;
					let telemetryDone = false;
					let __globalStatsSent = false;
					let keyLiveDone = false;
					let actualTokens = 0;
					const useProxy = __useMainApiProxy() && !!__apiProxyClient.request;
					try {
						if (!apiKeyManager.hasKeys()) {
							apiKeyManager.setKeys(getApiKeyListFromInput());
						}
						// [2] Estimate request tokens + pick best key (cooldown + per-key rate readiness)
						apiAttemptSeq += 1;
						const estTokens = __estimateTokensFromMessages(attemptMessages);
						if (!useProxy) {
							keyToUse = await __pickApiKeyWithBackoff(this, { estTokens });
							try { this.updateLiveRequestInfo({ rawKey: keyToUse, estTokens, retryCount: 0, retryUntil: null }); } catch { }
							this.showRetryOverlay(false);
						} else {
							keyToUse = '__PROXY__';
							try { this.updateLiveRequestInfo({ rawKey: null, estTokens, retryCount: 0, retryUntil: null }); } catch { }
							this.showRetryOverlay(false);
						}

						// [3] Create telemetry record
						telemetryId = __apiTelemetry.start({
							seq: apiAttemptSeq,
							archId: this.config?.id,
							archName: this.config?.name,
							instanceId: this.instanceId,
							uniqueId: this.uniqueId,
							apiMode,
							model,
							url,
							key: useProxy ? 'proxy' : maskKey(keyToUse),
							estTokens,
						});
						if (!useProxy) {
							try { __apiKeyLive.onPrepare(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, estTokens }); } catch { }
							try { this.updateLiveRequestInfo({ rawKey: keyToUse, estTokens }); } catch { }
						}

						// [4] Rate limit (per key) - Acquire Slot
						const rateWaitStart = Date.now();
						if (!useProxy) {
							await __acquireRateSlot(this, keyToUse, estTokens);
							__apiTelemetry.markRateWait(telemetryId, Date.now() - rateWaitStart);
						}
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) {
							if (telemetryId && !telemetryDone) {
								__apiTelemetry.markResponse(telemetryId, { ok: false, errorType: 'stopped', errorMessage: 'Stopped by User' });
								telemetryDone = true;
							}
							if (!useProxy) {
								try { __apiKeyLive.onDone(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, message: 'Stopped by User' }); keyLiveDone = true; } catch { }
							}
							throw new Error("Stopped by User");
						}

						try {
							const prettyMessages = attemptMessages.map((m, idx) => {
								return `#${idx} (${m.role}):\n${m.content}`;
							}).join('\n\n');
							const optLine = `API: ${apiMode}  Temp: ${currentTemperature}` +
								(Number.isFinite(requestOptions.top_p) ? `  top_p: ${requestOptions.top_p}` : '') +
								(Number.isFinite(requestOptions.top_k) ? `  top_k: ${requestOptions.top_k}` : '');
							this.logBlock(`‚Üí API Request\nModel: ${model}\nKey: ${maskKey(keyToUse)}\n${optLine}\n${prettyMessages}`);
						} catch (logErr) { console.warn(logErr); }

						let requestUrl = url;
						let headers = { 'Content-Type': 'application/json' };
						let body = null;
						if (!useProxy) {
							if (apiMode === 'gemini_generatecontent') {
								requestUrl = __withKeyParam(requestUrl, keyToUse);
								const payload = __toGeminiPayload(attemptMessages);
								const generationConfig = { temperature: currentTemperature };
								if (Number.isFinite(requestOptions.top_p)) generationConfig.topP = requestOptions.top_p;
								if (Number.isFinite(requestOptions.top_k)) generationConfig.topK = requestOptions.top_k;
								if (Number.isFinite(requestOptions.max_tokens)) generationConfig.maxOutputTokens = requestOptions.max_tokens;
								body = { contents: payload.contents, generationConfig };
								if (payload.systemInstruction) body.systemInstruction = payload.systemInstruction;
							} else if (apiMode === 'cf_ai_run') {
								const cf = __toCfResponsesPayload(attemptMessages);
								headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
								body = { input: cf.inputText || '' };
								if (Number.isFinite(currentTemperature)) body.temperature = currentTemperature;
							} else if (apiMode === 'cf_responses') {
								const cf = __toCfResponsesPayload(attemptMessages);
								headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
								body = { model: model, input: cf.inputText || '', stream: false };
								if (Number.isFinite(currentTemperature)) body.temperature = currentTemperature;
							} else {
								headers = { ...headers, 'Authorization': `Bearer ${keyToUse}` };
								body = { model: model, messages: attemptMessages, temperature: currentTemperature, stream: false };
								if (Number.isFinite(requestOptions.top_p)) body.top_p = requestOptions.top_p;
								if (Number.isFinite(requestOptions.max_tokens)) {
									body.max_tokens = requestOptions.max_tokens;
									body.max_completion_tokens = requestOptions.max_tokens;
									body.max_output_tokens = requestOptions.max_tokens;
								}
							}
						}

						const cfProxyUrl = (document.getElementById('apiProxyUrl')?.value || '').toString().trim();
						if (!useProxy && cfProxyUrl && (apiMode === 'cf_ai_run' || apiMode === 'cf_responses')) {
							const targetUrl = requestUrl;
							const encodedTarget = encodeURIComponent(targetUrl);
							if (cfProxyUrl.includes('{url}') || cfProxyUrl.includes('{{URL}}')) {
								requestUrl = cfProxyUrl.replaceAll('{url}', encodedTarget).replaceAll('{{URL}}', encodedTarget);
							} else {
								const targetHeaders = { ...headers };
								requestUrl = cfProxyUrl;
								headers = { 'Content-Type': 'application/json' };
								body = {
									url: targetUrl,
									method: 'POST',
									headers: targetHeaders,
									body
								};
							}
						}

						const abortController = new AbortController();
						this._inFlightAbortController = abortController;

						const timeoutMs = 10 * 60 * 1000;
						const proxyTimeoutMs = 10 * 60 * 1000; // prevent stuck inflight if proxy messages are lost
						let timeoutId = null;
						let didTimeout = false;
						const timeoutPromise = timeoutMs > 0
							? new Promise((_, reject) => {
								timeoutId = setTimeout(() => {
									didTimeout = true;
									try { abortController.abort(); } catch { }
									reject(new Error(`Timeout (${Math.round(timeoutMs / 1000)}s)`));
								}, timeoutMs);
							})
							: new Promise(() => { });

						let proxyOut = null;
						let resp = null;
						let data = null;
						let fetchStartAt = 0;
						let fetchPromise = null;
						let bodyPromise = null;
						let inflightRelease = null;
						try {
							__apiTelemetry.markSent(telemetryId, { url: requestUrl });
							if (!useProxy) {
								const gate = await __perKeyInflightGate.acquire(this, keyToUse);
								inflightRelease = gate?.release || null;
								try { __globalCallStats.onSent({ ts: Date.now() }); __globalStatsSent = true; } catch { }
								try { __apiKeyLive.onSent(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, estTokens }); } catch { }
								try { this.updateLiveRequestInfo({ rawKey: keyToUse, estTokens }); } catch { }
								try { inflightRelease?.(); inflightRelease = null; } catch { }
								fetchStartAt = Date.now();
								fetchPromise = fetch(requestUrl, {
									method: 'POST',
									headers,
									body: JSON.stringify(body),
									signal: abortController.signal
								});
								resp = await Promise.race([fetchPromise, timeoutPromise]);
							} else {
								fetchStartAt = Date.now();
								const proxyResp = await __apiProxyClient.request({
									signal: abortController.signal,
									messages: attemptMessages,
									requestOptions,
									temperature: currentTemperature,
									estTokens,
									timeoutMs: proxyTimeoutMs,
									meta: {
										uniqueId: this.uniqueId,
										archId: this.config?.id,
										archName: this.config?.name,
										instanceId: this.instanceId,
										estTokens,
									}
								});
								proxyOut = proxyResp;
								if (Number.isFinite(proxyResp?.rateWaitMs)) {
									__apiTelemetry.markRateWait(telemetryId, proxyResp.rateWaitMs);
								}
								resp = {
									ok: !!proxyResp?.ok,
									status: Number(proxyResp?.status) || (proxyResp?.ok ? 200 : 0),
									text: async () => (proxyResp?.bodyText || proxyResp?.errorBody || ''),
									json: async () => proxyResp?.data,
								};
							}

							if (!resp.ok) {
								let errBody = "";
								try {
									bodyPromise = resp.text();
									errBody = await Promise.race([bodyPromise, timeoutPromise]);
								} catch { }
								if (errBody) this.logBlock(`‚Üê API Error ${resp.status}\n${errBody}`);
								if (telemetryId && !telemetryDone) {
									__apiTelemetry.markResponse(telemetryId, {
										ok: false,
										httpStatus: resp.status,
										errorType: 'http',
										errorMessage: `HTTP ${resp.status}`,
										errorBody: errBody,
										latencyMs: Date.now() - fetchStartAt,
									});
									telemetryDone = true;
									if (!useProxy) {
										try { if (__globalStatsSent) __globalCallStats.onFinal('fail', { ts: Date.now() }); } catch { }
									}
								}
								if (!keyLiveDone && !useProxy) {
									try { __apiKeyLive.onDone(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, httpStatus: resp.status, message: `HTTP ${resp.status}` }); } catch { }
									keyLiveDone = true;
								}
								const errLower = (errBody || '').toLowerCase();
								if (resp.status === 400) {
									const mentionsTopK = errLower.includes('topk') || errLower.includes('top_k');
									const mentionsTopP = errLower.includes('topp') || errLower.includes('top_p');
									const mentionsMax = errLower.includes('maxoutputtokens') || errLower.includes('max_output_tokens') || errLower.includes('max_tokens');

									if (Number.isFinite(requestOptions.top_k) && mentionsTopK) {
										this.log(`‚ö† API rejected topK/top_k; retrying without top_k.`);
										delete requestOptions.top_k;
										continue;
									}
									if (Number.isFinite(requestOptions.top_p) && mentionsTopP) {
										this.log(`‚ö† API rejected topP/top_p; retrying without top_p.`);
										delete requestOptions.top_p;
										continue;
									}
									if (Number.isFinite(requestOptions.max_tokens) && mentionsMax) {
										this.log(`‚ö† API rejected max tokens field; retrying without max_tokens.`);
										delete requestOptions.max_tokens;
										continue;
									}
								}
								throw new Error(`HTTP ${resp.status}`);
							}

							bodyPromise = resp.json();
							data = await Promise.race([bodyPromise, timeoutPromise]);
							if (telemetryId && !telemetryDone) {
								__apiTelemetry.markResponse(telemetryId, {
									ok: true,
									httpStatus: resp.status,
									latencyMs: Date.now() - fetchStartAt,
								});
								telemetryDone = true;
							}
							if (!keyLiveDone && !useProxy) {
								try { __apiKeyLive.onDone(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, httpStatus: resp.status, message: 'OK' }); } catch { }
								keyLiveDone = true;
							}
						} catch (e) {
							if (telemetryId && !telemetryDone) {
								const latencyMs = fetchStartAt ? (Date.now() - fetchStartAt) : null;
								const isAbort = (e && (e.name === 'AbortError' || e.code === 'ABORT_ERR'));
								const errorType = didTimeout ? 'timeout' : (isAbort ? 'aborted' : 'exception');
								const errorMessage = didTimeout
									? `Timeout (${Math.round(timeoutMs / 1000)}s)`
									: ((e && e.message) ? e.message : (e ? e.toString() : 'Error'));
								__apiTelemetry.markResponse(telemetryId, { ok: false, errorType, errorMessage, latencyMs });
								telemetryDone = true;
								if (!useProxy) {
									try { if (__globalStatsSent) __globalCallStats.onFinal('fail', { ts: Date.now() }); } catch { }
								}
							}
							if (!keyLiveDone && !useProxy) {
								try {
									const msg = didTimeout
										? `Timeout (${Math.round(timeoutMs / 1000)}s)`
										: ((e && e.message) ? e.message : (e ? e.toString() : 'Error'));
									__apiKeyLive.onDone(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, message: msg });
								} catch { }
								keyLiveDone = true;
							}
							if (didTimeout) {
								try { fetchPromise?.catch?.(() => { }); } catch { }
								try { bodyPromise?.catch?.(() => { }); } catch { }
							}
							throw e;
						} finally {
							try { inflightRelease?.(); } catch { }
							if (timeoutId) clearTimeout(timeoutId);
							if (this._inFlightAbortController === abortController) this._inFlightAbortController = null;
						}

						// [3] Reconcile tokens (rate-limit only on direct key usage)
						actualTokens = __extractActualTokens(data);
						if (!useProxy) {
							__reconcileTokens(keyToUse, estTokens, actualTokens);
						}

						this.consecutiveApiErrors = 0;

						let content = "";
						if (useProxy && proxyOut && typeof proxyOut.contentText === 'string') {
							content = proxyOut.contentText || "";
						} else if (apiMode === 'gemini_generatecontent') {
							const parts = data?.candidates?.[0]?.content?.parts || [];
							content = parts.map(p => p?.text || '').filter(Boolean).join('') || "";
						} else if (apiMode === 'cf_ai_run' || apiMode === 'cf_responses') {
							content = __extractCfResponseText(data, apiMode);
						} else {
							content = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) || "";
						}

						// Sanitize before any validation/return
						content = __sanitizeModelText(content);
						this.logBlock(`‚Üê API Response Received\n${content}`);

						if (validator) {
							let candidate = content;
							let validationResult = validator(candidate);
							if (validationResult !== true) {
								let reason = typeof validationResult === 'string' ? validationResult : 'Invalid output';

								// Regularize (cheap) ‚Üí re-validate
								const regularized = __regularizeOutput(validationKind, candidate, reason);
								if (regularized !== candidate) {
									candidate = regularized;
									validationResult = validator(candidate);
									if (validationResult === true) {
										content = candidate;
									} else {
										reason = typeof validationResult === 'string' ? validationResult : reason;
									}
								}

								if (validationResult !== true) {
									const reasonNorm = (reason || '').toString().trim() || 'Invalid output';

									if (reasonNorm === lastValidationReason) sameValidationReasonStreak += 1;
									else {
										lastValidationReason = reasonNorm;
										sameValidationReasonStreak = 1;
									}

									const outHash = this.normalizeForHash(candidate);
									if (outHash && outHash === lastValidationOutputHash && reasonNorm === lastValidationReason) noProgressStreak += 1;
									else {
										lastValidationOutputHash = outHash;
										noProgressStreak = 0;
									}

									let strategy = __classifyValidationFailure(validationKind, candidate, reasonNorm);
									if (strategy === 'repair' && noProgressStreak >= 3) {
										this.log(`‚ö† Validation stuck (no progress). Switching from repair ‚Üí regenerate.`);
										strategy = 'regenerate';
									}

									if (strategy === 'repair') {
										attemptMode = 'repair';
										repairContext = {
											kind: validationKind,
											originalText: candidate,
											fingerprint: __semanticFingerprint(validationKind, candidate),
										};
										attemptMessages = __buildRepairMessages(validationKind, candidate, reasonNorm);
										currentTemperature = 0;
									} else {
										attemptMode = 'generate';
										repairContext = null;
										const feedback = __buildGeneratorRetryNote(reasonNorm, sameValidationReasonStreak);
										attemptMessages = [...baseMessages, { role: 'user', content: feedback }];
										currentTemperature = Math.min(baseTemperature, sameValidationReasonStreak >= 2 ? 0.2 : 0.4);
									}

									__apiTelemetry.markValidation(telemetryId, { passed: false, reason: reasonNorm });
									try { if (__globalStatsSent) __globalCallStats.onFinal('reject', { ts: Date.now() }); } catch { }
									this.log(`‚ö† Validator Reject (${strategy}): ${reasonNorm}. Retrying...`);
									await this.sleepInterruptible(0);
									continue;
								}
							}

							// If we passed in repair mode, enforce "meaning lock" where applicable.
							if (attemptMode === 'repair' && repairContext && (validationKind === 'checklist_writer' || validationKind === 'methodology_pack')) {
								if (!__meaningPreserved(validationKind, repairContext.originalText, candidate)) {
									__apiTelemetry.markValidation(telemetryId, { passed: false, reason: 'Repair changed meaning' });
									try { if (__globalStatsSent) __globalCallStats.onFinal('reject', { ts: Date.now() }); } catch { }
									this.log(`‚ö† Repair passed format but changed meaning ‚Üí regenerate instead.`);
									attemptMode = 'generate';
									repairContext = null;
									const feedback = __buildGeneratorRetryNote('Repair changed meaning; regenerate with correct content and exact format.', 1);
									attemptMessages = [...baseMessages, { role: 'user', content: feedback }];
									currentTemperature = Math.min(baseTemperature, 0.2);
									await this.sleepInterruptible(0);
									continue;
								}
							}

							content = candidate;
							attemptMode = 'generate';
							repairContext = null;
							noProgressStreak = 0;
						}

						__apiTelemetry.markValidation(telemetryId, { passed: true });
						try { if (__globalStatsSent) __globalCallStats.onFinal('success', { ts: Date.now() }); } catch { }
						// Count only accepted calls (validator passed or absent)
						this.state.metrics.calls++;
						if (Number.isFinite(actualTokens) && actualTokens > 0) this.state.metrics.tokens += actualTokens;
						this.updateMetricsUI();

						try { this.updateLiveRequestInfo({ retryCount: 0, retryUntil: null }); } catch { }
						return content;

					} catch (e) {
						if ((this.stopFlag || GLOBAL_EMERGENCY_STOP) && telemetryId && !telemetryDone) {
							__apiTelemetry.markResponse(telemetryId, { ok: false, errorType: 'stopped', errorMessage: 'Stopped by User' });
							telemetryDone = true;
						}
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped by User");

						const msg = e.message || "";
						const isValidationError = msg.startsWith("Validation Failed");

						const isProxyTimeout = useProxy && (
							msg.startsWith("Main-window proxy timeout") ||
							msg.startsWith("Proxy timeout")
						);

						if (!isValidationError && isProxyTimeout) {
							if (telemetryId && !telemetryDone) {
								try {
									__apiTelemetry.markResponse(telemetryId, { ok: false, errorType: 'proxy_timeout', errorMessage: msg || 'Proxy timeout' });
								} catch { }
								telemetryDone = true;
							}
							this.log(`‚ö† Main-window API proxy timed out. Keeping proxy enabled and retrying (no direct-key fallback in job windows).`);
							this.showRetryOverlay(true);
							const retryEl = document.getElementById(`retry-${this.uniqueId}`);
							if (retryEl) retryEl.innerText = `Proxy timeout ‚Üí retry`;
							await this.sleepInterruptible(1000);
							continue;
						}

						if (!isValidationError) {
							if (telemetryId && !telemetryDone) {
								__apiTelemetry.markResponse(telemetryId, { ok: false, errorType: 'exception', errorMessage: msg || 'Error' });
								telemetryDone = true;
							}
							if (!keyLiveDone) {
								try { __apiKeyLive.onDone(keyToUse, { uniqueId: this.uniqueId, archId: this.config?.id, instanceId: this.instanceId, message: msg || 'Error' }); } catch { }
								keyLiveDone = true;
							}
							const m = (msg || '').match(/HTTP\\s+(\\d{3})/i);
							const httpStatus = m ? parseInt(m[1], 10) : null;
							let backoff = null;
							try { backoff = __apiKeyLive.onRetry(keyToUse, { httpStatus }); } catch { }
							const delayMs = Number.isFinite(backoff?.delayMs) ? backoff.delayMs : 0;
							const retryCount = Number.isFinite(backoff?.retryCount) ? backoff.retryCount : null;
							try { this.updateLiveRequestInfo({ rawKey: keyToUse, retryCount: retryCount || 0, retryUntil: backoff?.retryUntil ?? null }); } catch { }

							this.log(`‚ö† API Error: ${msg}. Key ${maskKey(keyToUse)} cooldown${retryCount ? ` x${retryCount}` : ''} ${(delayMs / 1000).toFixed(1)}s. Retrying with another key (if available).`);
							this.showRetryOverlay(true);
							const retryEl = document.getElementById(`retry-${this.uniqueId}`);
							if (retryEl) {
								retryEl.innerText = `Key cooldown${retryCount ? ` x${retryCount}` : ''} ${(delayMs / 1000).toFixed(0)}s`;
							}
							await this.sleepInterruptible(80);
						} else {
							// Validation error usually means bad response, retry immediately/shortly?
							// Treat as minor error
							const delayMs = 0;
							this.log(`‚ö† Validator Reject: ${msg}. Retry now.`);
							await this.sleepInterruptible(delayMs);
						}
					}
				}
			}

			async mockApiCall(messages, validator, options = {}) {
				await this.sleepInterruptible(50);
				const lastMsg = messages[messages.length - 1]?.content || '';
				const systemMsg = messages.find(m => m.role === 'system')?.content || '';
				let response = "";

				// Task-type classifier
				if (systemMsg.includes('Task-Type Classifier')) {
					response = `Heuristic: treat as OTHER.\n\n<TaskType>OTHER</TaskType>`;
					this.logBlock(`[MOCK-TaskType] OTHER`);
				}
				// Checklist writer
				else if (systemMsg.includes('Checklist Writer')) {
					response = `<checklist>\n1. Must: Restate the task requirements and what is being asked.\n2. Must: Track the required quantifiers (e.g., for all vs exists) and not weaken them.\n3. Must: Use the given definitions/specs correctly and state any assumptions.\n4. Must: Provide a complete argument covering all required parts.\n5. Must: Justify each non-trivial step with a reason or reference to earlier steps.\n6. Must: Provide an explicit final answer/output in the requested form.\n</checklist>`;
					this.logBlock(`[MOCK-ChecklistWriter] OK`);
				}
				// Checklist verifier (meta)
				else if (systemMsg.includes('Checklist Verifier')) {
					response = `<meta_report>\nMC1: PASS - Covers task type.\nMC2: PASS - Includes quantifier mismatch check.\nMC3: PASS - Includes definition/spec compliance.\nMC4: PASS - Includes completeness.\nMC5: PASS - Evidence-friendly wording.\nMC6: PASS - Universal language.\nMC7: PASS - 6 items, one sentence each.\nMC8: PASS - Not overly specific.\n</meta_report>\n<fixes>\n- (none)\n</fixes>\n<pass>`;
					this.logBlock(`[MOCK-ChecklistVerifier] PASS`);
				}
				// Main Branch Router
				else if (systemMsg.includes('Main Branch Router')) {
					response = `Mock: run a proof branch first.\n\n<route>PROOF_THEN_SOLUTION</route>\n<rationale>Mock: prove a reusable constraint first.</rationale>\n<subproblem>Prove a small reusable lemma needed for the main solution.</subproblem>`;
					this.logBlock(`[MOCK-ROUTER] PROOF_THEN_SOLUTION`);
				}
				// Subproblem designer (structured candidate)
				else if (systemMsg.includes('Subproblem Designer')) {
					response = `Mock justification.\n\n<candidate>\n<subproblem>Prove a reusable lemma that simplifies the main task.</subproblem>\n<scope>GLOBAL</scope>\n<payoff>Reduces uncertainty by establishing a general reusable constraint.</payoff>\n<reuse_hook>Cite this lemma directly in the final solution.</reuse_hook>\n<verification_test>Check the lemma against at least one simple case and verify each implication.</verification_test>\n</candidate>`;
					this.logBlock(`[MOCK-SubproblemDesigner] OK`);
				}
				// Methodology designer (methodology + commitments)
				else if (systemMsg.includes('Methodology Designer')) {
					response = `Mock plan.\n\n<methodology>\n- Restate the task precisely.\n- Define all terms from the prompt.\n- Enumerate the required obligations and outputs.\n- Check the quantifier structure and goal type.\n- Construct a step-by-step argument aligned with the obligations.\n- Validate each step against the definitions/spec.\n</methodology>\n<commitments>\n1) Must detect/avoid: quantifier mismatch by explicitly restating \"for all\" vs \"exists\".\n2) Must detect/avoid: missing obligations by listing required deliverables before solving.\n3) Must detect/avoid: definition misuse by re-checking each use against the prompt.\n</commitments>`;
					this.logBlock(`[MOCK-MethodologyDesigner] OK`);
				}
				// Methodology debate speaker (tests + patches)
				else if (systemMsg.includes('Methodology Debate Speaker')) {
					response = `<debate_turn>\n  <tests>\n    <test id=\"T1\">Quantifier check: confirm the solution proves the required for-all statements. Expected failure if wrong: it proves only an existence claim.</test>\n    <test id=\"T2\">Goal check: confirm every requested output is present. Expected failure if wrong: missing minimality or missing final output.</test>\n  </tests>\n  <patches>\n    <patch id=\"P1\">If T1 fails, add an explicit \"obligations\" step and rewrite the missing universal argument.</patch>\n  </patches>\n</debate_turn>`;
					this.logBlock(`[MOCK-MethodologyDebate] OK`);
				}
				// Methodology selector (final plan + tests)
				else if (systemMsg.includes('Red Team Methodology Selector')) {
					response = `Mock selection.\n\n<choice>A</choice>\n<final_methodology>\n- Restate the task precisely.\n- Define all terms from the prompt.\n- Enumerate the required obligations and outputs.\n- Check the quantifier structure and goal type.\n- Construct a step-by-step argument aligned with the obligations.\n- Validate each step against the definitions/spec.\n</final_methodology>\n<commitments>\n1) Must detect/avoid: quantifier mismatch by explicitly restating \"for all\" vs \"exists\".\n2) Must detect/avoid: missing obligations by listing required deliverables before solving.\n3) Must detect/avoid: definition misuse by re-checking each use against the prompt.\n</commitments>\n<merged_tests>\n<test id=\"T1\">Quantifier check: confirm the solution proves the required for-all statements.</test>\n<test id=\"T2\">Goal check: confirm every requested output is present.</test>\n</merged_tests>`;
					this.logBlock(`[MOCK-MethodologySelect] A`);
				}
				// Memory preservation auditor
				else if (systemMsg.includes('Memory Preservation Auditor')) {
					response = `Mock keep.\n\n<keep>1</keep>`;
					this.logBlock(`[MOCK-MEM-GATE] KEEP`);
				}
				// Memory purifier
				else if (systemMsg.includes('Memory Purifier')) {
					response = `<working_memory>\n  <wm id=\"wmP1\" type=\"KEEP\">\n    Statement: Keep only verified essentials.\n    Evidence: Verified by prior steps.\n  </wm>\n</working_memory>`;
					this.logBlock(`[MOCK-MemoryPurifier] OK`);
				}
				// Proof conclusion extractor
				else if (systemMsg.includes('Conclusion Extractor')) {
					response = `Mock reusable conclusion.\n\n<conclusion>Reusable conclusion: the key lemma holds.</conclusion>`;
					this.logBlock(`[MOCK-Conclusion] OK`);
				}
				// Trial prosecutor (v12)
				else if (systemMsg.includes('You are the Prosecutor (Red Team)') || systemMsg.includes('You are the Prosecutor (Red Team).') || systemMsg.includes('You are the Prosecutor')) {
					response = `<issues>\n- [MINOR] Clarify one step with an explicit justification reference.\n</issues>`;
					this.logBlock(`[MOCK-Trial-Prosecutor] ISSUES`);
				}
				// Trial defense
				else if (systemMsg.includes('You are the Defense Counsel')) {
					response = `Mock defense: added the missing justification and confirmed all obligations.`;
					this.logBlock(`[MOCK-Trial-Defense] MSG`);
				}
				// Judge final verdict (v12 or v11)
				else if (systemMsg.includes('delivering your FINAL VERDICT')) {
					response = `Mock reasoning: no fatal gap remains.\n\n<obligations>\nTaskType: OTHER\nQuantifiersRequired: for all required cases\nMustShowOptimality: NO\nMustProvideWitnessOrLowerBound: NO\n</obligations>\n<issues>\n- [MINOR] Improve clarity of one step reference.\n</issues>\n<verdict>PASS</verdict>\n<rationale>Mock: obligations satisfied; no fatal issues found.</rationale>`;
					this.logBlock(`[MOCK-TRIAL-VERDICT] PASS`);
				}
				// Checklist-driven RT2 verifier
				else if (systemMsg.includes('Red Team Verifier')) {
					response = `<checklist_report>\n1. PASS - Evidence: Step 1 - Note: Restates task.\n2. PASS - Evidence: Step 2 - Note: Tracks quantifiers.\n3. PASS - Evidence: Step 3 - Note: Uses definitions.\n4. PASS - Evidence: Step 4 - Note: Completeness.\n5. PASS - Evidence: Step 5 - Note: Justifications.\n6. PASS - Evidence: Final Answer - Note: Final output present.\n</checklist_report>\n\n<attack_report>\nQuantifier: No mismatch found.\nGoal: Matches the prompt.\nDefinition: Compliant.\nEdge-cases: Checked two simple cases.\nConsistency: No circularity.\n</attack_report>\n\n<verdict>pass</verdict>\n<pass>`;
					this.logBlock(`[MOCK-RT2-Checklist] PASS`);
				}
				// Standard verifier (legacy)
				else if (lastMsg.includes("Solution to Verify") || lastMsg.includes("Problem:") || lastMsg.includes("Solution Attempt")) {
					response = `All good.\n<pass>`;
					if (this.config.clueEnabled && Math.random() < 0.05) response = `Need a value.\n<clue>Value of k</clue>`;
					this.logBlock(`[MOCK-Verifier] ${response.includes('<pass>') ? 'PASS' : (response.includes('<fail>') ? 'FAIL' : 'CLUE')}`);
				}
				// Clue validation
				else if (lastMsg.includes("Verify if the following CLUE")) {
					response = `Looks specific.\n<valid>`;
					this.logBlock(`[MOCK-ClueValid] VALID`);
				}
				// Clue sub-problem
				else if (lastMsg.includes("[Sub-Problem from Clue]")) {
					response = "Mock Answer to Clue";
					this.logBlock(`[MOCK-ClueSolve] OK`);
				}
				// Intermediary (principle extractor)
				else if (lastMsg.includes("Principle Extractor") || systemMsg.includes('Principle Extractor')) {
					response = `Mock.\n\n<summary>Mock principle: explicitly track obligations and quantifiers.</summary>`;
					this.logBlock(`[MOCK-Intermediary] SUMMARY`);
				}
				// Default: Solver
				else {
					response = `Step 1: Claim: Restate the task. Reason: This identifies obligations.\nStep 2: Claim: Provide a simple correct argument. Reason: Follows from definitions.\nFinal Answer: Mock final answer.\n\n<working_memory>\n</working_memory>`;
					if (systemMsg.includes('Working Memory (RUN-only; tentative)') || lastMsg.includes('<workmem>')) {
						response = "Mock Solution.\n\n<workmem>none</workmem>";
					}
					this.logBlock(`[MOCK-Solver] OK`);
				}

				return response;
			}

			extractTag(text, tag) {
				const regex = new RegExp(`<${tag}>([\\s\\S]*?)<\\/${tag}>`, 'i');
				const match = text.match(regex);
				return match ? match[1].trim() : null;
			}

			countTagBlocks(text, tag) {
				const regex = new RegExp(`<${tag}>[\\s\\S]*?<\\/${tag}>`, 'ig');
				const matches = (text || '').match(regex);
				return matches ? matches.length : 0;
			}

			hasTagBlock(text, tag) {
				return this.countTagBlocks(text, tag) > 0;
			}

			extractFinalSingleTag(text, allowedTags = []) {
				const trimmed = (text || '').trim();
				const m = trimmed.match(/<\s*([a-zA-Z0-9_-]+)\s*\/?>\s*$/);
				if (!m) return null;
				const tag = m[1].toLowerCase();
				if (Array.isArray(allowedTags) && allowedTags.length > 0) {
					const allow = new Set(allowedTags.map(t => (t || '').toString().toLowerCase()));
					return allow.has(tag) ? tag : null;
				}
				return tag;
			}

			parseNumberedMustList(textBlock) {
				const raw = (textBlock || '').toString();
				const lines = raw.split(/\r?\n/g).map(l => l.trim()).filter(Boolean);
				const items = [];
				for (const line of lines) {
					const m = line.match(/^\d+\.\s+Must:\s*(.+)$/i);
					if (m && m[1] && m[1].trim()) items.push(m[1].trim());
				}
				return items;
			}

			validateChecklistWriterOutput(text) {
				if (!this.hasTagBlock(text, 'checklist')) return 'Missing <checklist>...</checklist> block';
				const inner = this.extractTag(text, 'checklist');
				if (!inner) return 'Empty <checklist> block';
				const items = this.parseNumberedMustList(inner);
				if (items.length < 6 || items.length > 12) return 'Checklist must have 6‚Äì12 numbered "Must:" items';
				return true;
			}

			validateChecklistVerifierOutput(text) {
				if (!this.hasTagBlock(text, 'meta_report')) return 'Missing <meta_report>...</meta_report>';
				if (!this.hasTagBlock(text, 'fixes')) return 'Missing <fixes>...</fixes>';
				const finalTag = this.extractFinalSingleTag(text, ['pass', 'fail']);
				if (!finalTag) return 'Missing final <pass> or <fail> tag at end';
				return true;
			}

			async generateFinalChecklist(problemText) {
				const problem = (problemText || '').toString().trim();
				if (!problem) throw new Error('generateFinalChecklist: empty problem text');

				const writerSystem = `You are Checklist Writer.
Produce a grading checklist for a Red Team.

Hard rules:
- Do NOT solve the problem.
- Do NOT include any problem-specific constants, explicit numeric case values, or special-case instantiations (e.g., "x=0", "b=1", "f(1)=1", "empty string").
- Do NOT prescribe a solution algorithm; each item must be a grading criterion checkable by reading the solution (the verifier must be able to point to specific steps/claims as evidence).

If you need edge-case coverage, express it GENERICALLY (e.g., "boundary/degenerate cases implied by the domain", "minimal/maximal allowed values", "equality/degenerate cases") without naming concrete values.`;
				const baseWriterUser = `[PROBLEM]\n${problem}\n\n[OUTPUT REQUIREMENTS]\n- Output a checklist of 6‚Äì12 items.\n- Each item must be 1 sentence, starting with \"Must:\".\n- Items must be universally worded and must not rely on any problem-specific trick or constant.\n- Items must be checkable by reading the solution (not \"be correct\").\n- Do NOT include solutions, hints, or any concrete constant-value cases.\n- Include completeness in a GENERIC way: require coverage of boundary/degenerate cases implied by the domain, without specifying any particular value.\n\n[OUTPUT FORMAT]\n<checklist>\n1. Must: ...\n2. Must: ...\n...\n</checklist>\n`;

				this.log(`[Checklist] Drafting checklist...`);
				const first = await this.callAPI(
					[{ role: 'system', content: writerSystem }, { role: 'user', content: baseWriterUser }],
					(txt) => this.validateChecklistWriterOutput(txt),
					{ temperature: 0.7 }
				);
				let checklist = `<checklist>\n${this.extractTag(first, 'checklist')}\n</checklist>`;

				const verifierConfigs = [
					{
						id: 'Formalist',
						temperature: 0.2,
						top_k: 40,
						persona: 'Formalist Meta-Auditor: focus on quantifiers and completeness via generic obligations (no concrete constants/case values).',
					},
					{
						id: 'Adversarial',
						temperature: 0.7,
						top_k: 80,
						persona: 'Adversarial Meta-Auditor: try to find loopholes, but require only universally stated grading checks (no solver algorithm, no concrete constants).',
					},
					{
						id: 'Minimalist',
						temperature: 0.4,
						top_k: 50,
						persona: 'Minimalist Meta-Auditor: reduce redundancy while keeping generic edge/boundary coverage (no concrete constants/case values).',
					},
				];

				const metaCriteria = `MC1: Covers question type (include optimality/uniqueness only if the task demands it)\nMC2: Detects quantifier mismatch (for all/exists, domain restrictions)\nMC3: Definition/spec compliance\nMC4: Completeness via universal failure modes (including a GENERIC boundary/degenerate-case check; do NOT require concrete case values)\nMC5: Evidence-friendly (each item can be checked by citing specific steps/claims in the solution)\nMC6: Universal language (no problem-specific constants or instantiated cases)\nMC7: Not overly complex (6‚Äì12 items, 1 sentence each, minimal redundancy)\nMC8: Not overly specific (no concrete constants/case splits; edge cases must be stated generically)`;

				let criteriaPassStreak = 0;
				let verifierIdx = 0;
				let lastStreakVerifierIdx = -1;
				const MAX_META_VERIFY_ATTEMPTS = 30;
				let metaVerifyAttempts = 0;

				while (criteriaPassStreak < 3) {
					metaVerifyAttempts += 1;
					if (metaVerifyAttempts > MAX_META_VERIFY_ATTEMPTS) {
						this.log(`[Checklist] ‚ö† Meta-verify exceeded ${MAX_META_VERIFY_ATTEMPTS} attempts; using best-effort checklist.`);
						break;
					}
					const cfg = verifierConfigs[verifierIdx];
					this.log(`[Checklist] Meta-verify (${cfg.id}) streak=${criteriaPassStreak}/3...`);

					const currentItems = this.parseNumberedMustList(this.extractTag(checklist, 'checklist') || '');
					const currentCount = currentItems.length;

					const verifierSystem = `You are Checklist Verifier. Grade the checklist strictly using the META-CRITERIA. Do not solve the problem.\nPersona: ${cfg.persona}\n\nStability rules:\n- MC4 (Completeness) and MC8 (Not overly specific) MUST NOT conflict.\n- If you think edge/boundary cases are missing, require a GENERIC boundary/degenerate-case check. Do NOT demand concrete values.\n- Never request solver-like algorithms; only require universally stated grading checks that can be verified by reading the solution.`;
					const verifierUser = `[PROBLEM]\n${problem}\n\n[META-CRITERIA ‚Äî HARD STANDARD]\n${metaCriteria}\n\n[CANDIDATE CHECKLIST]\n${checklist}\n\n[CHECKLIST COUNT ‚Äî HARD CONSTRAINT]\nCurrent checklist item count: ${currentCount}\n- The revised checklist MUST remain 6‚Äì12 items.\n- If item count is already 12, you MUST NOT propose adding new items; use Replace/Merge/Remove instead.\n\n[FIX POLICY]\n- Prefer Replace/Merge over Add, even when count < 12.\n- NEVER propose fixes that introduce problem-specific constants or concrete case values.\n- If you add a new requirement, fold it into an existing item if possible.\n\n[YOUR TASK]\n1) For each meta-criterion MC1‚ÄìMC8, mark PASS or FAIL with 1‚Äì2 sentences why.\n2) If ANY FAIL, propose the MINIMUM edits needed. Your fixes MUST keep the checklist within 6‚Äì12 items (no contradictions).\n3) Finish with EXACTLY one tag: <pass> or <fail>.\n\n[OUTPUT FORMAT]\n<meta_report>\nMC1: PASS/FAIL - ...\n...\nMC8: PASS/FAIL - ...\n</meta_report>\n<fixes>\n- Replace item 3 with: \"Must: ...\"\n- Merge items 5 and 6 into: \"Must: ...\"\n- Remove item 9.\n- Add item 7: \"Must: ...\" (ONLY if current item count < 12)\n</fixes>\n<pass or fail tag at very end>`;

					const verifierResp = await this.callAPI(
						[{ role: 'system', content: verifierSystem }, { role: 'user', content: verifierUser }],
						(txt) => this.validateChecklistVerifierOutput(txt),
						{ temperature: cfg.temperature, top_k: cfg.top_k }
					);

					const verdict = this.extractFinalSingleTag(verifierResp, ['pass', 'fail']) || 'fail';
					if (verdict === 'pass') {
						if (verifierIdx !== lastStreakVerifierIdx) {
							criteriaPassStreak += 1;
							lastStreakVerifierIdx = verifierIdx;
						}
						verifierIdx = (verifierIdx + 1) % verifierConfigs.length;
						continue;
					}

					criteriaPassStreak = 0;
					lastStreakVerifierIdx = -1;
					verifierIdx = 0;

					const fixes = this.extractTag(verifierResp, 'fixes') || '';
					this.log(`[Checklist] FAIL ‚Üí applying fixes and regenerating checklist...`);
					const currentItems2 = this.parseNumberedMustList(this.extractTag(checklist, 'checklist') || '');
					const currentCount2 = currentItems2.length;
					const guard = currentCount2 >= 12
						? `\n\n[COUNT GUARD]\nThe current checklist already has 12 items.\nIf the fixes say \"Add item ...\", implement that requirement by REPLACING or MERGING items so the total stays at 12 (do NOT output 13+ items).`
						: '';
					const revisionUser = `[PROBLEM]\n${problem}\n\n[CURRENT CHECKLIST]\n${checklist}\n\n[REQUIRED FIXES FROM META-VERIFIER]\n${fixes}${guard}\n\nRevise the checklist with the MINIMUM changes needed to satisfy the fixes.\nHard constraints:\n- Return ONLY <checklist>...</checklist>\n- 6‚Äì12 numbered items total (never exceed 12)\n- Each item is 1 sentence starting with \"Must:\"\n- Do NOT introduce problem-specific constants or concrete case values; keep edge/boundary coverage generic.`;
					const revised = await this.callAPI(
						[{ role: 'system', content: writerSystem }, { role: 'user', content: revisionUser }],
						(txt) => this.validateChecklistWriterOutput(txt),
						{ temperature: 0.7 }
					);
					checklist = `<checklist>\n${this.extractTag(revised, 'checklist')}\n</checklist>`;
				}

				this.log(`[Checklist] ‚úÖ Final checklist frozen (3-pass streak).`);
				return checklist;
			}

			async generateChecklistPassAt1(problemText) {
				const problem = (problemText || '').toString().trim();
				if (!problem) throw new Error('generateChecklistPassAt1: empty problem text');

				const writerSystem = `You are Checklist Writer.
Produce a grading checklist for a Red Team.

Hard rules:
- Do NOT solve the problem.
- Do NOT include any problem-specific constants, explicit numeric case values, or special-case instantiations (e.g., "x=0", "b=1", "f(1)=1", "empty string").
- Do NOT prescribe a solution algorithm; each item must be a grading criterion checkable by reading the solution (the verifier must be able to point to specific steps/claims as evidence).

If you need edge-case coverage, express it GENERICALLY (e.g., "boundary/degenerate cases implied by the domain", "minimal/maximal allowed values", "equality/degenerate cases") without naming concrete values.`;

				const writerUser = `[PROBLEM]\n${problem}\n\n[OUTPUT REQUIREMENTS]\n- Output a checklist of 6‚Äì12 items.\n- Each item must be 1 sentence, starting with \"Must:\".\n- Items must be universally worded and must not rely on any problem-specific trick or constant.\n- Items must be checkable by reading the solution (not \"be correct\").\n- Do NOT include solutions, hints, or any concrete constant-value cases.\n- Include completeness in a GENERIC way: require coverage of boundary/degenerate cases implied by the domain, without specifying any particular value.\n\n[OUTPUT FORMAT]\n<checklist>\n1. Must: ...\n2. Must: ...\n...\n</checklist>\n`;

				this.log(`[Checklist(pass@1)] Drafting checklist (single-shot)...`);
				const first = await this.callAPI(
					[{ role: 'system', content: writerSystem }, { role: 'user', content: writerUser }],
					(txt) => this.validateChecklistWriterOutput(txt),
					{ temperature: 0.7 }
				);
				return `<checklist>\n${this.extractTag(first, 'checklist')}\n</checklist>`;
			}

			async classifyTaskType(problemText) {
				const problem = (problemText || '').toString().trim();
				if (!problem) return 'OTHER';

				const sys = `You are a Task-Type Classifier. Do NOT solve the task.

Classify the user's request into exactly ONE of:
OPTIMIZATION_BOUND | EXISTENCE | CONSTRUCTION | DEBUGGING | EXPLANATION | PLANNING | OTHER

Guidance:
- OPTIMIZATION_BOUND: asks for smallest/largest/best/tight/optimal value or bound.
- DEBUGGING: asks to fix/diagnose a bug based on code/logs/errors.
- PLANNING: asks for a plan/design/proposal/tradeoffs.
- EXPLANATION: asks to explain/teach/summarize.

At the VERY END output EXACTLY:
<TaskType>ONE_LABEL</TaskType>

Do not output <TaskType> until the end.`;

				const allowed = new Set(['OPTIMIZATION_BOUND', 'EXISTENCE', 'CONSTRUCTION', 'DEBUGGING', 'EXPLANATION', 'PLANNING', 'OTHER']);
				const validate = (txt) => {
					if (!this.hasTagBlock(txt, 'TaskType')) return 'Missing <TaskType>...</TaskType>';
					const v = (this.extractTag(txt, 'TaskType') || '').trim().toUpperCase();
					if (!allowed.has(v)) return `Invalid TaskType: ${v || 'EMPTY'}`;
					return true;
				};

				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: problem }],
					validate,
					{ temperature: 0.2 }
				);

				return ((this.extractTag(resp, 'TaskType') || '').trim().toUpperCase() || 'OTHER');
			}

			validateRT2ChecklistOutput(text) {
				if (!this.hasTagBlock(text, 'checklist_report')) return 'Missing <checklist_report>...</checklist_report>';
				if (!this.hasTagBlock(text, 'attack_report')) return 'Missing <attack_report>...</attack_report>';
				const finalTag = this.extractFinalSingleTag(text, ['pass', 'fail']);
				if (!finalTag) return 'Missing final <pass> or <fail> tag at end';
				return true;
			}

			extractRT2FailureFeedback(rt2Text) {
				const report = (rt2Text || '').toString();
				const checklistReport = (this.extractTag(report, 'checklist_report') || '').trim();
				const attackReport = (this.extractTag(report, 'attack_report') || '').trim();

				const failLines = checklistReport
					? checklistReport.split(/\r?\n/g).map(l => l.trim()).filter(l => /\bFAIL\b/i.test(l))
					: [];

				const summaryParts = [];
				if (failLines.length) summaryParts.push('[Checklist FAIL items]\n' + failLines.join('\n'));
				if (attackReport) summaryParts.push('[Attack report]\n' + attackReport);

				const summary = summaryParts.join('\n\n').trim() || '[No structured failure extracted]';
				return { summary, raw: report };
			}

			async runRT2ChecklistVerifierV12(problemText, checklistBlock, solutionText, personaConfig, extraTestsXml = '') {
				const problem = (problemText || '').toString().trim();
				const checklist = (checklistBlock || '').toString().trim();
				const sol = (solutionText || '').toString().trim();
				const persona = personaConfig || {};

				const sys = `You are the Red Team Verifier.
You must strictly grade the solution against the checklist and attempt attacks to find errors.
Output <pass> only if every checklist item passes and no critical logical error is found.

Persona: ${persona.id || 'RT2'}
Focus: ${(persona.focus || '').trim()}`;

				const extraTests = extraTestsXml ? `\n\n[EXTRA TESTS FROM DEBATE]\n${extraTestsXml}\n(Use these as additional attacks where relevant.)` : '';

				const user = `[PROBLEM]\n${problem}\n\n[GRADING CHECKLIST ‚Äî DO NOT MODIFY]\n${checklist}\n\n[SOLUTION TO VERIFY]\n${sol}\n\n[YOUR TASK]\nPart A ‚Äî Checklist grading:\nFor each checklist item, mark PASS or FAIL.\n- If PASS: point to the exact Step number(s) that satisfy it.\n- If FAIL: explain what is missing or wrong, and name the exact step where the gap occurs.\n\nPart B ‚Äî Attack methods (must do all, briefly):\n1) Quantifier attack: look for \"exists\" vs \"for all\" mistakes.\n2) Goal attack: verify the answer actually solves what the question asks (e.g., \"smallest\").\n3) Definition/spec attack: verify each use of the provided definition/spec is correct.\n4) Edge-case attack: test at least 2 small/special cases or boundary interpretations.\n5) Consistency attack: look for any step that assumes what it needs to prove.${extraTests}\n\n[OUTPUT FORMAT ‚Äî REQUIRED]\n- Output MUST be flat: do NOT nest these tags inside each other.\n- Close both blocks before the final tag.\n- The VERY LAST token must be exactly <pass> or <fail> (nothing after it).\n\n<checklist_report>\n1. PASS/FAIL - Evidence: Step ... - Note: ...\n...\n</checklist_report>\n\n<attack_report>\nQuantifier: ...\nGoal: ...\nDefinition: ...\nEdge-cases: ...\nConsistency: ...\n</attack_report>\n\n<pass>  OR  <fail>  (choose one; it must be the final token).`;

				return await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					(txt) => this.validateRT2ChecklistOutput(txt),
					{ temperature: persona.temperature, top_k: persona.top_k }
				);
			}

			normalizeRT2FailKey(line) {
				const raw = (line || '').toString().trim();
				if (!raw) return '';
				const note = (raw.match(/-\s*note\s*:\s*(.+)$/i) || [])[1];
				const core = (note || raw)
					.replace(/^\s*\d+\.\s*/g, '')
					.replace(/\b(pass|fail)\b/gi, '')
					.replace(/evidence\s*:\s*.*$/i, '')
					.replace(/step\s*\d+[\s\-\u2013\u2014]*?/gi, '')
					.trim();
				return this.normalizeForHash(core).slice(0, 800);
			}

			extractRT2FailLines(rt2Text) {
				const report = (rt2Text || '').toString();
				const checklistReport = (this.extractTag(report, 'checklist_report') || '').trim();
				if (!checklistReport) return [];
				return checklistReport
					.split(/\r?\n/g)
					.map(l => l.trim())
					.filter(l => /\bFAIL\b/i.test(l));
			}

			buildRT2EnsembleStableSummary(failTexts, totalSamples) {
				const counts = new Map();
				const examples = new Map();
				for (const t of (failTexts || [])) {
					const lines = this.extractRT2FailLines(t);
					const seen = new Set();
					for (const line of lines) {
						const key = this.normalizeRT2FailKey(line);
						if (!key || seen.has(key)) continue;
						seen.add(key);
						counts.set(key, (counts.get(key) || 0) + 1);
						if (!examples.has(key)) examples.set(key, line);
					}
				}

				const stable = [...counts.entries()]
					.filter(([, c]) => c >= 2)
					.sort((a, b) => b[1] - a[1])
					.map(([k, c]) => ({ key: k, count: c, line: examples.get(k) || k }));

				if (!stable.length) return '';
				const header = `[Ensemble verifier] Stable FAIL signals (>=2/${totalSamples}):`;
				const body = stable.slice(0, 8).map(s => `- (${s.count}) ${s.line}`).join('\n');
				return `${header}\n${body}`.trim();
			}

			async runRT2ChecklistVerifierV12Ensemble(problemText, checklistBlock, solutionText, personaConfig, extraTestsXml = '', options = {}) {
				const clampInt = (v, min, max) => {
					const n = parseInt(v, 10);
					if (!Number.isFinite(n)) return null;
					return Math.min(max, Math.max(min, n));
				};

				const samples = clampInt(options.samples, 1, 10) ?? 1;
				const passThreshold = clampInt(options.passThreshold, 1, samples) ?? (Math.floor(samples / 2) + 1);
				if (samples <= 1) {
					const text = await this.runRT2ChecklistVerifierV12(problemText, checklistBlock, solutionText, personaConfig, extraTestsXml);
					const verdictTag = this.extractFinalSingleTag(text, ['pass', 'fail']) || 'fail';
					return { text, verdictTag, passCount: verdictTag === 'pass' ? 1 : 0, failCount: verdictTag === 'fail' ? 1 : 0, stableSummary: '' };
				}

				const passTexts = [];
				const failTexts = [];
				for (let i = 1; i <= samples; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const t = await this.runRT2ChecklistVerifierV12(problemText, checklistBlock, solutionText, personaConfig, extraTestsXml);
					const tag = this.extractFinalSingleTag(t, ['pass', 'fail']) || 'fail';
					if (tag === 'pass') passTexts.push(t);
					else failTexts.push(t);
				}

				const passCount = passTexts.length;
				const failCount = failTexts.length;
				const verdictTag = passCount >= passThreshold ? 'pass' : 'fail';
				const text = verdictTag === 'pass'
					? (passTexts[0] || failTexts[0] || '')
					: (failTexts[0] || passTexts[0] || '');

				const stableSummary = verdictTag === 'fail'
					? (this.buildRT2EnsembleStableSummary(failTexts, samples) || '')
					: '';

				return { text, verdictTag, passCount, failCount, stableSummary };
			}

			getSolverPrompt() {
				return `### Core Instructions ###
	*   **Rigor is Paramount:** Produce a complete and rigorously justified solution.
	*   **Honesty:** If incomplete, admit it. Do not guess.
	*   **Format:** Use TeX for math.

### Output Format ###
**1. Summary** (Verdict, Method Sketch)
**2. Detailed Solution** (Full rigorous solution/argument)

	### Self-Correction ###
	Review for rigor before finalizing.`;
			}

			getSolverPromptV12(taskType = 'OTHER') {
				const type = (taskType || 'OTHER').toString().trim().toUpperCase();
				let typeGuidance = '';
				if (type === 'DEBUGGING') {
					typeGuidance = `\nTask guidance (DEBUGGING): include reproduction, root cause, minimal fix, and how to validate (tests/logs).`;
				} else if (type === 'PLANNING') {
					typeGuidance = `\nTask guidance (PLANNING): include constraints, tradeoffs, risks, and a fallback plan.`;
				} else if (type === 'EXPLANATION') {
					typeGuidance = `\nTask guidance (EXPLANATION): state assumptions about the audience, give a concrete example, and address common misconceptions.`;
				} else if (type === 'OPTIMIZATION_BOUND') {
					typeGuidance = `\nTask guidance (OPTIMIZATION): include both (i) why your proposed value/choice works under all required quantifiers and (ii) why it cannot be improved.`;
				}

				return `You are the Solver. Provide a rigorous answer with explicit step-by-step justification.${typeGuidance}

Rules:
- Do not mention any hidden grading criteria.
- Avoid leaps like "clearly" unless you explain.
- Track the task's obligation type (for all vs exists; optimization vs existence).

Output format (required):
Step 1: Claim ... Reason ...
Step 2: Claim ... Reason ...
...
Final Answer: ...`;
			}

			getSolverPromptV12Basis(taskType = 'OTHER') {
				const type = (taskType || 'OTHER').toString().trim().toUpperCase();
				const base = this.getSolverPromptV12(type);
				return `${base}

Extra requirement (basis per step):
- Every Step must explicitly include a "Basis:" line stating what justifies the claim (definition / prior step / theorem / invariant / case split), then a short "Reason:" line connecting the basis to the claim.

Output format (required):
Step 1: Claim ...
Basis: ...
Reason: ...
Step 2: Claim ...
Basis: ...
Reason: ...
...
Final Answer: ...`;
			}

			getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, branchLabel, taskType) {
				const base = this.getSolverPromptV12(taskType);
				const meth = (methodologyText || '').trim();
				const commits = (commitmentsText || '').trim();
				if (!meth && !commits) return base;

				const methBlock = meth ? `<methodology>\n${meth}\n</methodology>` : '';
				const commitBlock = commits ? `<commitments>\n${commits}\n</commitments>` : '';

				return `${base}

[MANDATORY METHOD PLAN ‚Äî FOLLOW THIS ORDER]
Branch: ${branchLabel}
${methBlock}
${commitBlock}

Follow this plan while writing your steps.`;
			}

			getIntermediaryPrompt(bugReport) {
				return `You are a Principle Extractor.
Read this report:
"""${bugReport}"""
**TASK:** Extract ONE fundamental rule/principle to prevent this mistake.
First write a brief explanation (1-3 sentences) of what went wrong and how to prevent it.
Then, at the VERY END, output EXACTLY one tag:
<summary>ONE short principle (single sentence)</summary>

Do not output <summary> until the end.`;
			}

			async validateClue(clueContent, originalProblemText = '') {
				const exp = this.config.exp || {};
				const clue = (clueContent || '').toString().trim();
				const original = (originalProblemText || '').toString().trim();

				const validationPrompt = exp.clueV2
					? `You are a Red Team Validator.
Your job is to validate whether a proposed CLUE is appropriate for the CLUE LOOP.

[ORIGINAL PROBLEM]
${original || '[Not provided]'}

[PROPOSED CLUE QUESTION]
"${clue}"

CRITERIA (all must pass):
1) Specific: asks for a concrete missing fact/value/formula/definition detail that can be answered directly.
2) Necessary: materially helps solve the original problem (not a tangential curiosity).
3) Not placeholder: reject vague/boilerplate clues (e.g., "Need a value", "Give a hint", "More info", "Next step", "Provide details").
4) Not peripheral: reject clues that are too far from the core obligations of the original problem.

OUTPUT:
- First provide brief reasoning (2‚Äì6 sentences).
- Then output EXACTLY one tag: <valid> or <invalid>.`
					: `You are a Red Team Validator.
Verify if the following CLUE request is specific and necessary.

CLUE: "${clue}"

CRITERIA:
1. Specificity: Must ask for a specific variable value, formula, or proof step (e.g., "Value of X", "Formula for Y").
2. Necessity: Must be critical for solving the problem.
3. Rejection: Vague requests like "more info", "hint", or "next step" must be REJECTED.

OUTPUT:
Response with <valid> if it meets all criteria.
Response with <invalid> if it fails any criterion.
First provide reasoning, then the tag.`;

				const resp = await this.callAPI([
					{ role: 'user', content: validationPrompt }
				], text => text.includes('<valid>') || text.includes('<invalid>'));

				return resp.includes('<valid>');
			}

			async resolveClue(clueContent, originalProblemText = '') {
				const subConfig = { ...this.config, clueEnabled: false, id: this.config.id + '-SUB' };
				const subAgent = new AgentSystem(subConfig, this.instanceId + '-CLUE');
				subAgent.state.globalMemory = [...this.state.globalMemory];

				const exp = this.config.exp || {};
				const clue = (clueContent || '').toString().trim();
				const original = (originalProblemText || '').toString().trim();

				const clueQuery = exp.clueV2
					? `[Clue Branch ‚Äî IMPORTANT]
You are in the CLUE BRANCH. Your goal is to solve the CLUE QUESTION (NOT the original problem).

[ORIGINAL PROBLEM ‚Äî CONTEXT ONLY]
${original || '[Not provided]'}

[CLUE QUESTION ‚Äî SOLVE THIS]
${clue}

Provide the answer to the CLUE QUESTION only.`
					: `[Sub-Problem from Clue]
The main problem requires this specific information:
"${clue}"

Provide the answer to this sub-question only.`;

				this.log(`>> Resolving Clue: ${clueContent}`);
				await subAgent.run(clueQuery);
				return subAgent.state.status === 'Success' ? subAgent.state.finalResult : null;
			}

			formatQueryWithClues(originalQuery) {
				if (!this.state.verifiedClues || this.state.verifiedClues.length === 0) return originalQuery;

				let clueSection = '\n\n[Verified Clues - HIGH PRIORITY]\n';
				this.state.verifiedClues.forEach((vc, idx) => {
					clueSection += `${idx + 1}. Q: ${vc.clue}\n   A: ${vc.answer}\n`;
				});
				return originalQuery + clueSection;
			}

			getVerifierPrompt(includeSummaryInstruction) {
				let summaryInstr = "";
				if (includeSummaryInstruction) {
					summaryInstr = `
3) **Summary Generation:**
   You must provide a concise summary of the critical failure reason wrapped in <summary> tags.
   Example: <summary>Assumption X is unjustified.</summary>`;
				}

				let clueInstr = "";
				if (this.config.clueEnabled) {
					clueInstr = `
4) **Clue Generation (Optional):**
   If the problem is unsolvable without specific missing info:
   - Provide distinct reasoning.
   - End with <clue>SPECIFIC_QUESTION</clue>.
   - Clue must be specific (e.g., "Value of X"). Vague clues will be rejected.
   - Use <clue> tag instead of <pass> or <fail> ONLY if absolutely necessary.`;
				}

				return `You are an expert verifier. Verify rigor across any domain.
Instructions:
1) Act strictly as a verifier. Provide Summary + Detailed Log.
2) Classify issues as Critical Error or Justification Gap.
${summaryInstr}
${clueInstr}
At the very end, include EXACTLY one tag: <pass>, <fail>${this.config.clueEnabled ? ', or <clue>...' : ''}. Do not include multiple.`;
			}

			getVerifierPromptStepLogic(includeSummaryInstruction, options = {}) {
				const contradictionStrict = !!options.contradictionStrict;

				let summaryInstr = "";
				if (includeSummaryInstruction) {
					summaryInstr = `\n\nYou MUST include exactly one <summary>...</summary> capturing the single most critical issue (or "No issues found").`;
				}

				const strictLine = contradictionStrict
					? `\n- CONTRADICTION RULE: If you find even a single contradiction or inconsistency between steps/claims, you MUST output <fail> (even if the final answer looks plausible).`
					: '';

				return `You are a Red Team Verifier. Verify the solution step-by-step.

Your task:
1) Parse the solution into "Step k" blocks and a "Final Answer".
2) For EACH Step k:
   - Check the Claim is well-defined.
   - Check the Reason/Basis actually implies the Claim (no gaps).
   - Check it does not assume what it needs to prove.
3) Cross-step consistency: check that later steps do not contradict earlier steps, and that the Final Answer follows from the steps.${strictLine}${summaryInstr}

Output rules:
- If ANY step is invalid OR the Final Answer is not supported, output <fail>.
- Only output <pass> if every step is logically valid and the final answer fully solves the problem.
- At the very end, output EXACTLY one tag: <pass> or <fail>.`;
			}

			getCorrectionPrompt(bugReport, principles) {
				let principleInstr = "";
				if (this.config.who === 'solver') {
					principleInstr = `
**CRITICAL:** After your revised solution, you MUST add a <summary> tag.
Inside this tag, write ONE fundamental lesson learned from this specific failure.
Example: <summary>Check base cases.</summary>`;
				}
				let context = this.config.fullText ? `Bug Report:\n${bugReport}` : `Critique Summary:\n${bugReport}`;
				let memoryBlock = principles.length > 0 ? `\n\n### Key Principles ###\n${principles.map(p => `- ${p}`).join('\n')}\n\nAdhere to these.` : "";

				return `Below is feedback on your previous attempt.
${context}
${memoryBlock}
Improve your solution to be complete and rigorous.
${principleInstr}`;
			}

			async handleFailure(solution, feedbackContent, effectiveQuery, runMemory, options = {}) {
				let effectivePrinciples = [];
				if (this.config.accCross) effectivePrinciples = [...this.state.globalMemory];
				if (this.config.accRun) effectivePrinciples = [...effectivePrinciples, ...runMemory];
				effectivePrinciples = [...new Set(effectivePrinciples)];

				const exp = this.config.exp || {};
				const injectionMode = (exp.methodologyInjection || '').toString().trim().toLowerCase();
				const mustFollowMethod = injectionMode === 'mandatory' || !!options.forceMethodology;
				const methodologyText = (options.methodologyText || '').toString();
				const commitmentsText = (options.commitmentsText || '').toString();

				const baseCorrection = this.getCorrectionPrompt(feedbackContent, effectivePrinciples);
				const methodBlock = (methodologyText || commitmentsText)
					? `\n\n### Selected Methodology / Commitments (${mustFollowMethod ? 'MANDATORY' : 'HIGH PRIORITY'})\nThese are instructions, not output format. Do NOT output <methodology> or <commitments> tags in your final answer.\n${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}\n\n${mustFollowMethod ? 'You MUST follow the methodology order and honor the commitments while revising.' : 'Follow these while revising.'}`
					: '';

				let solverSys = this.getSolverPrompt();
				if (exp.solverPrompt === 'v12') {
					solverSys = this.getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, 'Baseline', 'OTHER');
				} else if (exp.solverPrompt === 'v12_basis') {
					solverSys = this.getSolverPromptV12Basis('OTHER');
					if (methodologyText || commitmentsText) {
						solverSys = `${solverSys}\n\n[Methodology / Commitments]\n${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}\n\nFollow these while writing your steps.`;
					}
				} else if (methodologyText || commitmentsText) {
					// Baseline prompt + method anchoring.
					solverSys = `${solverSys}
	
	### Selected Methodology / Commitments (${mustFollowMethod ? 'MANDATORY' : 'HIGH PRIORITY'})
	These are instructions, not output format. Do NOT output <methodology> or <commitments> tags in your final answer.
	${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}
	${mustFollowMethod ? 'You MUST follow the methodology order and honor the commitments.' : 'Follow these while solving.'}`;
				}

				if (exp.rrSolver) {
					const persona = this.nextRoundRobinPersona('solver');
					solverSys = this.applyPersonaToSystemPrompt(solverSys, persona, 'Do NOT mention the persona in your output.');
					this.log(`[Solver] Persona: ${persona.name}`);
				}

				const correctionResp = await this.callAPI([
					{ role: 'system', content: solverSys },
					{ role: 'user', content: effectiveQuery },
					{ role: 'assistant', content: solution },
					{ role: 'user', content: baseCorrection + methodBlock }
				]);

				let newPrinciple = null;
				let newSolution = solution;

				if (this.config.who === 'solver' && !this.config.fullText) {
					newPrinciple = this.extractTag(correctionResp, 'summary');
					newSolution = correctionResp.replace(/<summary>[\s\S]*?<\/summary>/gi, "").trim();
				} else if (!this.config.fullText) {
					newPrinciple = this.extractTag(correctionResp, 'summary') || feedbackContent;
					newSolution = correctionResp;
				} else {
					newSolution = correctionResp;
				}

				if (newPrinciple) {
					this.log(`+ Principle: ${newPrinciple}`);
					if (this.config.accRun) runMemory.push(newPrinciple);
					if (this.config.accCross) this.state.globalMemory.push(newPrinciple);
				}
				return newSolution;
			}

			async handleFailureWithWorkingMemoryV12(solution, feedbackContent, rawFeedback, effectiveQuery, runMemory, runWorkingMemoryEntries, options = {}) {
				let effectivePrinciples = [];
				if (this.config.accCross) effectivePrinciples = [...this.state.globalMemory];
				if (this.config.accRun) effectivePrinciples = [...effectivePrinciples, ...runMemory];
				effectivePrinciples = [...new Set(effectivePrinciples)];

				const exp = this.config.exp || {};
				const injectionMode = (exp.methodologyInjection || '').toString().trim().toLowerCase();
				const mustFollowMethod = injectionMode === 'mandatory' || !!options.forceMethodology;
				const methodologyText = (options.methodologyText || '').toString();
				const commitmentsText = (options.commitmentsText || '').toString();

				const wmDecayed = this.decrementWorkingMemoryTtl(runWorkingMemoryEntries);

				const baseCorrection = this.getCorrectionPrompt(feedbackContent, effectivePrinciples);
				const rawBlock = rawFeedback
					? `\n\n### Verbatim Verifier Feedback (most recent)\n${(rawFeedback || '').toString().trim()}\n`
					: '';
				const methodBlock = (methodologyText || commitmentsText)
					? `\n\n### Selected Methodology / Commitments (${mustFollowMethod ? 'MANDATORY' : 'HIGH PRIORITY'})\nThese are instructions, not output format. Do NOT output <methodology> or <commitments> tags in your final answer.\n${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}\n\n${mustFollowMethod ? 'You MUST follow the methodology order and honor the commitments while revising.' : 'Follow these while revising.'}`
					: '';

				let solverSys = this.getSolverPrompt();
				if (exp.solverPrompt === 'v12') {
					solverSys = this.getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, 'Baseline', 'OTHER');
				} else if (exp.solverPrompt === 'v12_basis') {
					solverSys = this.getSolverPromptV12Basis('OTHER');
					if (methodologyText || commitmentsText) {
						solverSys = `${solverSys}\n\n[Methodology / Commitments]\n${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}\n\nFollow these while writing your steps.`;
					}
				} else if (methodologyText || commitmentsText) {
					solverSys = `${solverSys}
	
	### Selected Methodology / Commitments (${mustFollowMethod ? 'MANDATORY' : 'HIGH PRIORITY'})
	These are instructions, not output format. Do NOT output <methodology> or <commitments> tags in your final answer.
	${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}
	${mustFollowMethod ? 'You MUST follow the methodology order and honor the commitments.' : 'Follow these while solving.'}`;
				}

				if (exp.rrSolver) {
					const persona = this.nextRoundRobinPersona('solver');
					solverSys = this.applyPersonaToSystemPrompt(solverSys, persona, 'Do NOT mention the persona in your output.');
					this.log(`[Solver] Persona: ${persona.name}`);
				}

				const correctionResp = await this.callAPI(
					[
						{ role: 'system', content: solverSys },
						{ role: 'user', content: this.buildQueryWithWorkingMemoryV12(effectiveQuery, wmDecayed) },
						{ role: 'assistant', content: solution },
						{ role: 'user', content: baseCorrection + rawBlock + methodBlock }
					],
					(txt) => this.validateWorkingMemoryXmlBlock(txt),
					{ temperature: 0.7 }
				);

				const parsed = this.parseWorkingMemoryFromResponseV12(correctionResp, wmDecayed);
				let merged = this.mergeWorkingMemory(wmDecayed, parsed.newEntries);

				if (merged.length > 7) {
					this.log(`[WorkingMemory] > 7 entries ‚Üí purifier...`);
					merged = await this.runMemoryPurifierV12(effectiveQuery, merged);
				}

				const respNoWm = parsed.cleanText;
				let newPrinciple = null;
				let newSolution = respNoWm;

				if (this.config.who === 'solver' && !this.config.fullText) {
					newPrinciple = this.extractTag(respNoWm, 'summary');
					newSolution = respNoWm.replace(/<summary>[\s\S]*?<\/summary>/gi, "").trim();
				} else if (!this.config.fullText) {
					newPrinciple = this.extractTag(respNoWm, 'summary') || feedbackContent;
					newSolution = respNoWm;
				} else {
					newSolution = respNoWm;
				}

				if (newPrinciple) {
					this.log(`+ Principle: ${newPrinciple}`);
					if (this.config.accRun) runMemory.push(newPrinciple);
					if (this.config.accCross) this.state.globalMemory.push(newPrinciple);
				}
				return { solution: newSolution, workingMemory: merged };
			}

			// --- RT Constants for Mini-MainLoop ---
			async runRedTeamLoop(solutionText, type) {
				if (this.config.rtLogic === 'old') {
					this.log(`[RedTeam-old] Starting ${type} consensus loop...`);
					const MAX_RT_ROUNDS = 5;
					const RT_STREAK_TARGET = 3;

					// V1: Prompt to find Error. V2: Standard Eval.
					let rtPromptSystem = "";
					if (type === 'V1') {
						rtPromptSystem = "You are a Red Team Expert. Your Goal: Find a FATAL FLAW in the user's solution.\nIf Flaw Found -> Output <fail> and explain.\nIf ABSOLUTELY NO Flaw -> Output <pass>.";
					} else {
						rtPromptSystem = "You are a Verifier. Check the solution.\nCorrect -> <pass>.\nIncorrect -> <fail>.\n\nIMPORTANT: Judge correctness/completeness, not stylistic preferences.";
					}

					let currentRtStreak = 0;
					let currentRtVerdict = null; // 'pass' or 'fail'
					let lastFailFeedback = null;

					for (let r = 1; r <= MAX_RT_ROUNDS; r++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						let roundPrompt = rtPromptSystem;
						if (type === 'V2') {
							const exp = this.config.exp || {};
							const forceRr = this.config.rtTrigger === 'T2' && !!exp.rrRt2T2Old;
							const useUi = !forceRr && document.getElementById('expDiverseRt2Personas')?.checked;
							if (forceRr || useUi) {
								const personas = forceRr
									? this.getRr3Personas('verifier') // Formalist‚ÜíLogicist‚ÜíIntuitionist
									: [
										{ name: 'Intuitionist', note: 'Use sanity checks, counterexamples, edge cases, and invariants.' },
										{ name: 'Logicist', note: 'Check step-by-step validity and explicit justification of each implication.' },
										{ name: 'Formalist', note: 'Track definitions/quantifiers carefully; ensure no hidden assumptions.' },
									];
								const persona = personas[(r - 1) % personas.length];
								roundPrompt = this.applyPersonaToSystemPrompt(
									rtPromptSystem,
									persona,
									'Do NOT reject a correct solution just because it is not in your preferred style.'
								);
								this.log(`[RedTeam-old] Persona Round ${r}: ${persona.name}${forceRr ? ' (forced RR)' : ''}`);
							}
						}

						const rtResp = await this.callAPI([
							{ role: 'system', content: roundPrompt },
							{ role: 'user', content: `Solution to Verify:\n${solutionText}` }
						], txt => txt.includes('<pass>') || txt.includes('<fail>'));

						const isRtPass = rtResp.includes('<pass>');
						const verdict = isRtPass ? 'pass' : 'fail';
						if (!isRtPass) lastFailFeedback = rtResp;

						this.log(`[RedTeam-old] R${r} Verdict: ${verdict.toUpperCase()}`);

						// Streak Logic
						if (currentRtVerdict === verdict) {
							currentRtStreak++;
						} else {
							currentRtVerdict = verdict;
							currentRtStreak = 1;
						}

						if (currentRtStreak >= RT_STREAK_TARGET) {
							this.log(`[RedTeam-old] Consensus Reached: ${currentRtVerdict.toUpperCase()}`);
							if (currentRtVerdict === 'fail') return { verdict: 'fail', feedback: lastFailFeedback || rtResp };
							return { verdict: 'pass' };
						}
					}

					this.log(`[RedTeam-old] Max Rounds (${MAX_RT_ROUNDS}) Reached. Defaulting to PASS.`);
					return { verdict: 'pass' };
				}

				this.log(`[RedTeam] Starting ${type} Mini-MainLoop...`);
				const RT_MAX_RUNS = 5;
				const RT_MAX_ITER_PER_RUN = 30;
				const RT_MAX_FAIL_STREAK = 10;
				const RT_PASS_STREAK_TARGET = 3;

				if (type === 'V1') {
					const finderPrompt = `You are a Red Team Expert. Your ONLY goal is to find FATAL FLAWS in the solution.
CRITICAL: You are an ATTACKER. Your job is to FIND problems, not to validate correctness.

If you find a critical flaw:
- First explain your reasoning briefly.
- Then, at the VERY END, output EXACTLY one tag: <flaw>concise fatal flaw</flaw>

If after thorough analysis you genuinely cannot find any fatal flaw:
- First explain what you checked and why it seems correct.
- Then, at the VERY END, output EXACTLY: <none/>
- But remember: your job is to FIND flaws. Try harder before concluding none exist.

DO NOT output <pass> or <fail>.
Do NOT output <flaw> or <none/> until the end.`;

					const claimCheckPrompt = `You are a Claim Validator. Your job is to verify if a reported flaw is ACTUALLY a real error.

The following flaw was reported:
"""
{FLAW_CONTENT}
"""

Against this solution:
"""
{SOLUTION}
"""

Analyze carefully:
1. Is this flaw description accurate?
2. Does the solution actually contain this error?
3. Is this a CRITICAL flaw that invalidates the solution?

First provide your reasoning.
Then, at the VERY END, output EXACTLY one tag:
- <valid> if this is a REAL, CRITICAL flaw
- <invalid> if this flaw is incorrect, minor, or non-existent`;

					let validFlawPassStreak = 0;
					let lastValidFlaw = null;

					for (let runIdx = 1; runIdx <= RT_MAX_RUNS; runIdx++) {
						this.log(`[RT1] === Run ${runIdx}/${RT_MAX_RUNS} ===`);
						let failStreak = 0;
						let iterCount = 0;

						while (iterCount < RT_MAX_ITER_PER_RUN && failStreak < RT_MAX_FAIL_STREAK) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							iterCount++;

							// Stage 1: FINDER
							const finderResp = await this.callAPI([
								{ role: 'system', content: finderPrompt },
								{ role: 'user', content: `Solution to Attack:\n${solutionText}` }
							], txt => txt.includes('<flaw>') || txt.includes('<none/>'));

							if (finderResp.includes('<none/>')) {
								failStreak++;
								this.log(`[RT1-Finder] Iter ${iterCount}: <none/> ‚Üí Internal FAIL (${failStreak}/${RT_MAX_FAIL_STREAK})`);
								continue;
							}

							const flawMatch = finderResp.match(/<flaw>([\s\S]*?)<\/flaw>/i);
							if (!flawMatch) {
								failStreak++;
								this.log(`[RT1-Finder] Iter ${iterCount}: No valid tag ‚Üí FAIL (${failStreak}/${RT_MAX_FAIL_STREAK})`);
								continue;
							}

							const flawContent = flawMatch[1].trim();
							this.log(`[RT1-Finder] Iter ${iterCount}: <flaw> found ‚Üí Claim-checking...`);

							// Stage 2: CLAIM-CHECKER
							const checkPrompt = claimCheckPrompt
								.replace('{FLAW_CONTENT}', flawContent)
								.replace('{SOLUTION}', solutionText);

							const checkResp = await this.callAPI([
								{ role: 'user', content: checkPrompt }
							], txt => txt.includes('<valid>') || txt.includes('<invalid>'));

							if (checkResp.includes('<valid>')) {
								failStreak = 0;
								if (lastValidFlaw === flawContent) {
									validFlawPassStreak++;
								} else {
									lastValidFlaw = flawContent;
									validFlawPassStreak = 1;
								}
								this.log(`[RT1-ClaimCheck] <valid> ‚Üí passStreak ${validFlawPassStreak}/${RT_PASS_STREAK_TARGET}`);

								if (validFlawPassStreak >= RT_PASS_STREAK_TARGET) {
									this.log(`[RT1] VALID FLAW CONFIRMED (${RT_PASS_STREAK_TARGET} streak) ‚Üí Main FAIL`);
									return {
										verdict: 'fail',
										feedback: `Critical Flaw Found:\n${flawContent}\n\nFull Response:\n${finderResp}`
									};
								}
							} else {
								failStreak++;
								validFlawPassStreak = 0;
								lastValidFlaw = null;
								this.log(`[RT1-ClaimCheck] <invalid> ‚Üí Flaw rejected, FAIL (${failStreak}/${RT_MAX_FAIL_STREAK})`);
							}
						}
						this.log(`[RT1] Run ${runIdx} exhausted (iter: ${iterCount}, failStreak: ${failStreak})`);
					}
					this.log(`[RT1] Budget exhausted. No valid flaw found ‚Üí Main PASS`);
					return { verdict: 'pass' };

				} else {
					// RT2
					const evalPrompt = `You are a rigorous Solution Verifier.
Evaluate the solution for correctness and completeness.

If the solution is CORRECT and COMPLETE:
- Output <pass> after your analysis

If the solution has ERRORS or is INCOMPLETE:
- Output <fail> after your analysis
- Explain the specific issues found`;

					let passStreak = 0;
					let failStreak = 0;
					let lastVerdict = null;
					let lastFeedback = null;

					for (let runIdx = 1; runIdx <= RT_MAX_RUNS; runIdx++) {
						this.log(`[RT2] === Run ${runIdx}/${RT_MAX_RUNS} ===`);
						let localFailStreak = 0;
						let iterCount = 0;

						while (iterCount < RT_MAX_ITER_PER_RUN && localFailStreak < RT_MAX_FAIL_STREAK) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							iterCount++;

							const evalResp = await this.callAPI([
								{ role: 'system', content: evalPrompt },
								{ role: 'user', content: `Solution to Evaluate:\n${solutionText}` }
							], txt => txt.includes('<pass>') || txt.includes('<fail>'));

							const isPass = evalResp.includes('<pass>');
							const verdict = isPass ? 'pass' : 'fail';
							this.log(`[RT2] R${runIdx}-I${iterCount}: ${verdict.toUpperCase()}`);

							if (verdict === lastVerdict) {
								if (isPass) { passStreak++; failStreak = 0; }
								else { failStreak++; passStreak = 0; lastFeedback = evalResp; }
							} else {
								lastVerdict = verdict;
								passStreak = isPass ? 1 : 0;
								failStreak = isPass ? 0 : 1;
								if (!isPass) lastFeedback = evalResp;
							}

							if (passStreak >= RT_PASS_STREAK_TARGET) {
								this.log(`[RT2] Stable PASS (${passStreak} streak) ‚Üí Main PASS`);
								return { verdict: 'pass' };
							}
							if (failStreak >= RT_PASS_STREAK_TARGET) {
								this.log(`[RT2] Stable FAIL (${failStreak} streak) ‚Üí Main FAIL`);
								return { verdict: 'fail', feedback: lastFeedback };
							}

							if (!isPass) localFailStreak++;
							else localFailStreak = 0;
						}
						this.log(`[RT2] Run ${runIdx} exhausted (iter: ${iterCount})`);
					}

					if (passStreak > failStreak) return { verdict: 'pass' };
					else if (failStreak > passStreak) return { verdict: 'fail', feedback: lastFeedback };
					else return { verdict: 'pass' };
				}
			}

			updateWhiteboardUI(text) {
				const el = document.getElementById(`whiteboard-area-${this.uniqueId}`);
				if (el) el.value = text || '';
			}

			initWhiteboard(problem) {
				return {
					problem: problem || '',
					main: { route: '', rationale: '', subproblem: '' },
					proof: {
						subproblem: '',
						methodVote: null,
						conclusion: '',
						candidateMemories: [],
						preservedMemories: [],
					},
					solution: {
						methodVote: null,
					},
				};
			}

			renderWhiteboardMarkdown() {
				const wb = this.state.whiteboard;
				if (!wb) return '';

				const listOrNone = (items) => {
					const arr = Array.isArray(items) ? items.filter(Boolean) : [];
					return arr.length ? arr.map(s => `- ${s}`).join('\n') : '- [None]';
				};

				const methodVoteSummary = (mv) => {
					if (!mv) return '[Not selected]';
					const choice = mv.choice ? `Choice: ${mv.choice}` : 'Choice: [unknown]';
					const meth = mv.finalMethodology ? mv.finalMethodology : '[no methodology text]';
					return `${choice}\n\n${meth}`;
				};

				return `### Unchanging Problem Statement
${wb.problem || '[Not set]'}

### Main Branch Decision
- Route: ${wb.main?.route || '[Not decided]'}
- Rationale: ${(wb.main?.rationale || '[None]').trim()}
${wb.main?.subproblem ? `- Subproblem: ${wb.main.subproblem.trim()}` : ''}

### Proof Branch (Subproblem)
${wb.proof?.subproblem ? `- Subproblem: ${wb.proof.subproblem.trim()}` : '- Subproblem: [Not used]'}
- Selected Methodology:
${methodVoteSummary(wb.proof?.methodVote)}

- Conclusion (to reuse):
${(wb.proof?.conclusion || '[None]').trim()}

- Candidate Memories:
${listOrNone(wb.proof?.candidateMemories)}

- Preserved Memories (3-way overlap):
${listOrNone(wb.proof?.preservedMemories)}

### Solution Branch
- Selected Methodology:
	${methodVoteSummary(wb.solution?.methodVote)}
	`;
			}

			initWhiteboardV11(problem) {
				return {
					problem: problem || '',
					routerHistory: [],
					proofs: [],
					aggregate: {
						conclusions: [],
						preservedMemories: [],
						quarantinedMemories: [],
						preservedWorkingMemories: [],
						quarantinedWorkingMemories: [],
						taskType: '',
						finalChecklist: '',
					},
					live: {
						stage: '',
						branch: '',
						runIdx: 0,
						methodology: '',
						workingMemory: [],
						lastSummaryFeedback: '',
						lastRawFeedback: '',
					},
					solution: {
						methodHistory: [],
						finalSolution: '',
						trial: null,
					},
				};
			}

			renderWhiteboardMarkdownV11() {
				const wb = this.state.whiteboard;
				if (!wb) return '';

				const listOrNone = (items) => {
					const arr = Array.isArray(items) ? items.filter(Boolean) : [];
					return arr.length ? arr.map(s => `- ${s}`).join('\n') : '- [None]';
				};

				const truncate = (s, max = 900) => {
					const t = (s || '').toString().trim();
					if (!t) return '';
					if (t.length <= max) return t;
					return t.slice(0, max) + '‚Ä¶';
				};

				const routerHistory = Array.isArray(wb.routerHistory) ? wb.routerHistory : [];
				const proofs = Array.isArray(wb.proofs) ? wb.proofs : [];
				const agg = wb.aggregate || {};

				const routerBlock = routerHistory.length
					? routerHistory.map((h, idx) => {
						const phase = h.phase ? ` (${h.phase})` : '';
						const decidedBy = h.decidedBy ? `; decidedBy=${h.decidedBy}` : '';
						const sub = h.subproblem ? `; subproblem=${truncate(h.subproblem, 200)}` : '';
						return `- [${idx + 1}] route=${h.route || '[?]'}${phase}${sub}${decidedBy}\n  rationale: ${truncate(h.rationale, 220) || '[None]'}`;
					}).join('\n')
					: '- [None]';

				const proofsBlock = proofs.length
					? proofs.map((p, idx) => {
						const qMem = Array.isArray(p.quarantinedMemories) ? p.quarantinedMemories : [];
						const qWm = Array.isArray(p.quarantinedWorkingMemories) ? p.quarantinedWorkingMemories : [];
						return `#### Proof #${idx + 1}
		- Subproblem: ${truncate(p.subproblem, 260) || '[None]'}
		- Conclusion: ${truncate(p.conclusion, 260) || '[None]'}
		- SAFE Preserved Memories:
		${listOrNone(p.preservedMemories)}
		- QUARANTINED Memories:
		${listOrNone(qMem)}
		- SAFE Preserved Working Memory (audited):
		${listOrNone(p.preservedWorkingMemories)}
		- QUARANTINED Working Memory:
		${listOrNone(qWm)}
		`;
					}).join('\n')
					: '- [None]';

				const checklistBlock = agg.finalChecklist ? `\n\n### Frozen Grading Checklist (for Red Team)\n${truncate(agg.finalChecklist, 900)}` : '';

				return `### Unchanging Problem Statement
		${wb.problem || '[Not set]'}

		### Task Type
		- ${(agg.taskType || '').trim() || '[Unknown]'}${checklistBlock}

		### Router History
		${routerBlock}

	### Proof Cycles
	${proofsBlock}

		### Aggregate (Safe to reuse)
		- Conclusions:
		${listOrNone(agg.conclusions)}
		- SAFE Preserved Memories:
		${listOrNone(agg.preservedMemories)}
		- QUARANTINED Memories:
		${listOrNone(agg.quarantinedMemories)}
		- SAFE Preserved Working Memory:
		${listOrNone(agg.preservedWorkingMemories)}
		- QUARANTINED Working Memory:
		${listOrNone(agg.quarantinedWorkingMemories)}

	### Live (RUN-only; tentative)
	- Stage: ${(wb.live?.stage || '').trim() || '[Unknown]'}
	- Branch: ${(wb.live?.branch || '').trim() || '[None]'}
	- Run: ${wb.live?.runIdx || 0}
	- Current Methodology (snippet):
	${truncate(wb.live?.methodology || '[None]', 420)}

	- Working Memory:
	${listOrNone(wb.live?.workingMemory)}

	- Last Feedback Summary:
	${truncate(wb.live?.lastSummaryFeedback || '[None]', 420)}

	- Last Raw Feedback (most recent):
	${truncate(wb.live?.lastRawFeedback || '[None]', 600)}
	`;
			}

			refreshWhiteboardUI() {
				if (!this.config.whiteboard) return;
				if (this.config.special === 'system-1.1' || this.config.special === 'system-1.2') {
					this.updateWhiteboardUI(this.renderWhiteboardMarkdownV11());
				} else {
					this.updateWhiteboardUI(this.renderWhiteboardMarkdown());
				}
			}

			normalizeMemories(memories, maxItems = 30) {
				const cleaned = (Array.isArray(memories) ? memories : [])
					.map(m => (m || '').toString().trim())
					.filter(Boolean)
					.map(m => m.replace(/\s+/g, ' ').trim());
				const uniq = [...new Set(cleaned)];
				return uniq.slice(0, maxItems);
			}

			parseWorkmemItems(content, maxItems = 20) {
				const raw = (content || '').toString().trim();
				if (!raw || raw.toLowerCase() === 'none') return [];
				const lines = raw.split(/\r?\n/g).map(l => l.trim()).filter(Boolean);
				const cleaned = lines.map(l => l.replace(/^(\d+[\).\]]\s+|[-*]\s+)/, '').trim()).filter(Boolean);
				return this.normalizeMemories(cleaned, maxItems);
			}

			parseWorkmemFromResponse(responseText, prevWorkingMemory = []) {
				const text = (responseText || '').toString();
				const tags = ['workmem', 'working_memory'];

				let usedTag = null;
				let extracted = null;
				for (const t of tags) {
					const v = this.extractTag(text, t);
					if (v !== null && v !== undefined) {
						usedTag = t;
						extracted = v;
						break;
					}
				}

				const workingMemory = usedTag ? this.parseWorkmemItems(extracted) : [...(prevWorkingMemory || [])];
				let cleanText = text;
				for (const t of tags) {
					cleanText = cleanText.replace(new RegExp(`<${t}>[\\s\\S]*?<\\/${t}>`, 'gi'), '').trim();
				}
				return { cleanText, workingMemory, usedTag };
			}

			formatWorkmemForPrompt(items) {
				const arr = Array.isArray(items) ? items.filter(Boolean) : [];
				return arr.length ? arr.map(x => `- ${x}`).join('\n') : '- [None]';
			}

			buildQueryWithWorkmem(queryText, runWorkingMemory) {
				return `${queryText}\n\n[Working Memory (RUN-only; tentative)]\n${this.formatWorkmemForPrompt(runWorkingMemory)}\n\nAt the VERY END of your response, output:\n<workmem>none OR up to 8 short items, one per line</workmem>\nDo not output <workmem> until the end.`;
			}

			normalizeForHash(s) {
				return (s || '').toString().toLowerCase().replace(/\s+/g, ' ').trim();
			}

			extractLabeledLine(body, label) {
				const re = new RegExp(`^\\s*${label}\\s*:\\s*(.+)\\s*$`, 'im');
				const m = (body || '').match(re);
				return m ? m[1].trim() : '';
			}

			validateWorkingMemoryXmlBlock(text) {
				if (!this.hasTagBlock(text, 'working_memory')) return 'Missing <working_memory>...</working_memory>';
				const inner = this.extractTag(text, 'working_memory');
				if (inner === null || inner === undefined) return 'Missing <working_memory> inner text';

				const wmMatches = [...inner.matchAll(/<wm\b[^>]*>[\s\S]*?<\/wm>/gi)];
				if (wmMatches.length > 8) return 'Too many <wm> entries (max 8)';

				for (const m of wmMatches) {
					const wmBlock = m[0];
					const attrMatch = wmBlock.match(/<wm\b([^>]*)>/i);
					const attrs = attrMatch ? attrMatch[1] : '';
					const idMatch = attrs.match(/\bid\s*=\s*"([^"]+)"/i);
					const typeMatch = attrs.match(/\btype\s*=\s*"([^"]+)"/i);
					const ttlMatch = attrs.match(/\bttl\s*=\s*"([^"]+)"/i);
					const id = idMatch ? idMatch[1].trim() : '';
					const type = typeMatch ? typeMatch[1].trim().toUpperCase() : '';
					const body = (wmBlock.replace(/^\s*<wm\b[^>]*>/i, '').replace(/<\/wm>\s*$/i, '') || '').trim();

					if (!id) return 'Each <wm> must include id="..."';
					if (!['KEEP', 'HYP', 'TODO'].includes(type)) return `Invalid wm type "${type || 'EMPTY'}"`;

					if (type === 'KEEP') {
						if (!/\bStatement\s*:\s*\S+/i.test(body)) return 'KEEP wm must include "Statement:"';
						if (!/\bEvidence\s*:\s*\S+/i.test(body)) return 'KEEP wm must include "Evidence:"';
					} else if (type === 'HYP') {
						if (!ttlMatch) return 'HYP wm must include ttl="2"';
						if ((ttlMatch[1] || '').trim() !== '2') return 'HYP wm ttl must be "2" (system-managed)';
						if (!/\bStatement\s*:\s*\S+/i.test(body)) return 'HYP wm must include "Statement:"';
						if (!/\bWhy_plausible\s*:\s*\S+/i.test(body)) return 'HYP wm must include "Why_plausible:"';
					} else if (type === 'TODO') {
						if (!ttlMatch) return 'TODO wm must include ttl="2"';
						if ((ttlMatch[1] || '').trim() !== '2') return 'TODO wm ttl must be "2" (system-managed)';
						if (!/\bNext_check\s*:\s*\S+/i.test(body)) return 'TODO wm must include "Next_check:"';
					}
				}

				return true;
			}

			parseWorkingMemoryXmlEntries(innerText) {
				const inner = (innerText || '').toString();
				const entries = [];
				const re = /<wm\b([^>]*)>([\s\S]*?)<\/wm>/gi;
				let m;
				while ((m = re.exec(inner)) !== null) {
					const attrsRaw = m[1] || '';
					const body = (m[2] || '').trim();
					const idMatch = attrsRaw.match(/\bid\s*=\s*"([^"]+)"/i);
					const typeMatch = attrsRaw.match(/\btype\s*=\s*"([^"]+)"/i);
					const ttlMatch = attrsRaw.match(/\bttl\s*=\s*"([^"]+)"/i);
					const id = idMatch ? idMatch[1].trim() : '';
					const type = typeMatch ? typeMatch[1].trim().toUpperCase() : '';
					const ttl = ttlMatch ? parseInt(ttlMatch[1], 10) : null;

					const keyText =
						type === 'TODO'
							? (this.extractLabeledLine(body, 'Next_check') || body)
							: (this.extractLabeledLine(body, 'Statement') || body);
					const hash = `${type}:${this.normalizeForHash(keyText)}`;

					entries.push({ id, type, ttl: Number.isFinite(ttl) ? ttl : null, body, hash });
				}
				return entries;
			}

			decrementWorkingMemoryTtl(prevEntries) {
				const out = [];
				for (const e of (Array.isArray(prevEntries) ? prevEntries : [])) {
					if (!e || !e.type) continue;
					if (e.type === 'HYP' || e.type === 'TODO') {
						const ttl = Number.isFinite(e.ttl) ? e.ttl - 1 : 0;
						if (ttl <= 0) continue;
						out.push({ ...e, ttl });
					} else {
						out.push({ ...e, ttl: null });
					}
				}
				return out;
			}

			mergeWorkingMemory(prevEntries, newEntries) {
				const prev = Array.isArray(prevEntries) ? prevEntries : [];
				const next = Array.isArray(newEntries) ? newEntries : [];

				const byHash = new Map();
				for (const e of prev) {
					if (!e || !e.hash) continue;
					byHash.set(e.hash, { ...e });
				}

				for (const e of next) {
					if (!e || !e.hash) continue;
					const existing = byHash.get(e.hash);

					// Never downgrade KEEP.
					if (existing && existing.type === 'KEEP' && e.type !== 'KEEP') continue;

					if (e.type === 'KEEP') {
						byHash.set(e.hash, { ...e, ttl: null });
						continue;
					}

					// HYP/TODO: preserve TTL if repeating; otherwise accept ttl=2.
					if (existing && (existing.type === 'HYP' || existing.type === 'TODO')) {
						byHash.set(e.hash, { ...e, ttl: existing.ttl });
					} else {
						byHash.set(e.hash, { ...e, ttl: 2 });
					}
				}

				return [...byHash.values()];
			}

			workingMemoryToDisplayLines(entries) {
				const arr = Array.isArray(entries) ? entries : [];
				const out = [];
				for (const e of arr) {
					if (!e || !e.type) continue;
					if (e.type === 'KEEP') {
						const st = this.extractLabeledLine(e.body, 'Statement') || '(no statement)';
						const ev = this.extractLabeledLine(e.body, 'Evidence') || '(no evidence)';
						out.push(`KEEP: ${st} | Evidence: ${ev}`);
					} else if (e.type === 'HYP') {
						const st = this.extractLabeledLine(e.body, 'Statement') || '(no statement)';
						out.push(`HYP(ttl=${e.ttl ?? '?'}): ${st}`);
					} else if (e.type === 'TODO') {
						const st = this.extractLabeledLine(e.body, 'Next_check') || '(no next check)';
						out.push(`TODO(ttl=${e.ttl ?? '?'}): ${st}`);
					}
				}
				return this.normalizeMemories(out, 20);
			}

			buildQueryWithWorkingMemoryV12(queryText, workingMemoryEntries) {
				const lines = this.workingMemoryToDisplayLines(workingMemoryEntries);
				const wmBlock = lines.length ? lines.map(l => `- ${l}`).join('\n') : '- [None]';

				return `${queryText}\n\n[Working Memory Policy]\n- KEEP entries persist unless a purifier compresses them.\n- HYP and TODO entries expire after 2 solver turns unless explicitly upgraded to KEEP.\n- Repeating the same HYP/TODO does NOT reset its TTL.\n\n[Current Working Memory]\n${wmBlock}\n\nAt the VERY END of your response, output EXACTLY one block:\n<working_memory>\n  <wm id=\"wm1\" type=\"KEEP\">\n    Statement: ...\n    Evidence: ...\n  </wm>\n  <wm id=\"wm2\" type=\"HYP\" ttl=\"2\">\n    Statement: ...\n    Why_plausible: ...\n  </wm>\n  <wm id=\"wm3\" type=\"TODO\" ttl=\"2\">\n    Next_check: ...\n  </wm>\n</working_memory>\n\nRules:\n- Output <working_memory> only at the end.\n- You may output ZERO <wm> entries (empty <working_memory> block) if there are no updates.\n- Max 8 <wm> entries in the block.\n- For HYP/TODO you MUST write ttl=\"2\" (system-managed).`;
			}

			parseWorkingMemoryFromResponseV12(responseText, prevEntries = []) {
				const text = (responseText || '').toString();
				const wmInner = this.extractTag(text, 'working_memory');
				const had = this.hasTagBlock(text, 'working_memory');
				const newEntries = had ? this.parseWorkingMemoryXmlEntries(wmInner || '') : [];
				const cleanText = text.replace(/<working_memory>[\s\S]*?<\/working_memory>/gi, '').trim();
				return { cleanText, newEntries };
			}

			async runMemoryPurifierV12(whiteboardText, currentEntries) {
				const wb = (whiteboardText || '').toString();
				const sys = `You are Memory Purifier. Do not solve; only compress working memory.

Rewrite working memory into 4 or fewer entries that are:
- Essential (high utility for finishing correctly)
- Non-redundant
- Verified (KEEP only; no HYP/TODO)
- Self-contained (no pronouns like "this/that")

Each entry must include:
- Statement:
- Evidence: (reference a Step number, a verified checklist item, or a concrete verified fact from the whiteboard)

Output ONLY:
<working_memory>
  <wm id="wmP1" type="KEEP">
    Statement: ...
    Evidence: ...
  </wm>
  ...
</working_memory>`;

				const user = `[WHITEBOARD]\n${wb}\n\n[CURRENT WORKING MEMORY]\n${this.workingMemoryToDisplayLines(currentEntries).map(l => `- ${l}`).join('\n') || '- [None]'}\n`;

				const validatePurifier = (txt) => {
					const ok = this.validateWorkingMemoryXmlBlock(txt);
					if (ok !== true) return ok;
					const inner = this.extractTag(txt, 'working_memory') || '';
					const entries = this.parseWorkingMemoryXmlEntries(inner);
					if (entries.length > 4) return 'Purified working memory must be 4 or fewer <wm> entries';
					for (const e of entries) {
						if (e.type !== 'KEEP') return 'Purified working memory must contain KEEP entries only';
						if (!/\bStatement\s*:\s*\S+/i.test(e.body)) return 'Purified KEEP missing Statement';
						if (!/\bEvidence\s*:\s*\S+/i.test(e.body)) return 'Purified KEEP missing Evidence';
					}
					return true;
				};

				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					validatePurifier,
					{ temperature: 0.2 }
				);

				const inner = this.extractTag(resp, 'working_memory') || '';
				return this.parseWorkingMemoryXmlEntries(inner);
			}

			buildProofBranchPrompt(originalQuery, subproblem) {
				return `[Unchanging Problem Statement]
	${originalQuery}

[Proof Branch ‚Äî IMPORTANT]
You are in the PROOF BRANCH. Do NOT solve the original problem.
Your ONLY objective is to solve the following subproblem so it can be reused later:

SUBPROBLEM:
${subproblem}

Deliver a rigorous, standalone solution to the SUBPROBLEM.`;
			}

			buildSolutionBranchPrompt(originalQuery, proofConclusion, preservedMemories) {
				const memoriesBlock = (preservedMemories && preservedMemories.length)
					? preservedMemories.map(m => `- ${m}`).join('\n')
					: '- [None]';

				const conclusionBlock = proofConclusion ? proofConclusion.trim() : '[None]';

				return `[Unchanging Problem Statement]
${originalQuery}

[Whiteboard ‚Äî HIGH PRIORITY]
Proven subproblem conclusion (if any):
${conclusionBlock}

Preserved memories (safe, non-distracting heuristics/principles):
${memoriesBlock}

[Solution Branch Task]
	Solve the ORIGINAL problem using the Whiteboard.`;
			}

			buildSolutionBranchPromptV11(originalQuery, proofConclusions, preservedMemories, preservedWorkingMemories) {
				const conclusionsArr = Array.isArray(proofConclusions) ? proofConclusions.filter(Boolean) : [];
				const conclusionsBlock = conclusionsArr.length
					? conclusionsArr.map((c, i) => `${i + 1}. ${c}`).join('\n')
					: '[None]';

				const memArr = Array.isArray(preservedMemories) ? preservedMemories.filter(Boolean) : [];
				const memoriesBlock = memArr.length ? memArr.map(m => `- ${m}`).join('\n') : '- [None]';

				const wmArr = Array.isArray(preservedWorkingMemories) ? preservedWorkingMemories.filter(Boolean) : [];
				const workingMemoriesBlock = wmArr.length ? wmArr.map(m => `- ${m}`).join('\n') : '- [None]';

				return `[Unchanging Problem Statement]
${originalQuery}

[Whiteboard ‚Äî HIGH PRIORITY]
Proven subproblem conclusions (if any):
${conclusionsBlock}

Preserved memories (audited; safe heuristics/principles):
${memoriesBlock}

Preserved working memory (audited; safe notes):
${workingMemoriesBlock}

	[Solution Branch Task]
	Solve the ORIGINAL problem using the Whiteboard.`;
			}

			buildSolutionBranchPromptV12(originalQuery, proofConclusions, safeMemories, quarantinedMemories, safeWorkingMemories, quarantinedWorkingMemories) {
				const conclusionsArr = Array.isArray(proofConclusions) ? proofConclusions.filter(Boolean) : [];
				const conclusionsBlock = conclusionsArr.length
					? conclusionsArr.map((c, i) => `${i + 1}. ${c}`).join('\n')
					: '[None]';

				const safeArr = Array.isArray(safeMemories) ? safeMemories.filter(Boolean) : [];
				const safeBlock = safeArr.length ? safeArr.map(m => `- ${m}`).join('\n') : '- [None]';

				const qArr = Array.isArray(quarantinedMemories) ? quarantinedMemories.filter(Boolean) : [];
				const qBlock = qArr.length ? qArr.map(m => `- ${m}`).join('\n') : '- [None]';

				const wmSafeArr = Array.isArray(safeWorkingMemories) ? safeWorkingMemories.filter(Boolean) : [];
				const wmSafeBlock = wmSafeArr.length ? wmSafeArr.map(m => `- ${m}`).join('\n') : '- [None]';

				const wmQArr = Array.isArray(quarantinedWorkingMemories) ? quarantinedWorkingMemories.filter(Boolean) : [];
				const wmQBlock = wmQArr.length ? wmQArr.map(m => `- ${m}`).join('\n') : '- [None]';

				return `[Unchanging Problem Statement]
${originalQuery}

[Whiteboard ‚Äî HIGH PRIORITY]
Proven subproblem conclusions (if any):
${conclusionsBlock}

SAFE preserved memories (audited; treat as reliable):
${safeBlock}

QUARANTINED memories (hypotheses; DO NOT assume true without checking):
${qBlock}

SAFE preserved working memory (audited; reliable notes):
${wmSafeBlock}

QUARANTINED working memory (hypotheses; verify before use):
${wmQBlock}

[Solution Branch Task]
Solve the ORIGINAL problem using the Whiteboard.`;
			}

			async routeProblem(query) {
				const routerSystem = `You are the Main Branch Router.

Given a problem, decide whether to:
- solve directly (DIRECT), OR
- first solve a helpful subproblem in a Proof Branch, then solve the original (PROOF_THEN_SOLUTION).

First explain your reasoning briefly (2-6 sentences). Do NOT solve anything.
Then, at the VERY END, output EXACTLY one of the following tag blocks (and do not output these tags earlier):

<route>DIRECT</route>
<rationale>...</rationale>

OR

<route>PROOF_THEN_SOLUTION</route>
<rationale>...</rationale>
<subproblem>...</subproblem>

Rules:
- Do NOT solve anything.
- If PROOF_THEN_SOLUTION: subproblem must be single, self-contained, and produce a reusable conclusion (lemma/value).
- Keep the subproblem concise and unambiguous.`;

				const resp = await this.callAPI(
					[
						{ role: 'system', content: routerSystem },
						{ role: 'user', content: query }
					],
					(txt) => txt.includes('<route>') && txt.includes('</route>')
				);

				const route = (this.extractTag(resp, 'route') || '').trim().toUpperCase();
				const rationale = (this.extractTag(resp, 'rationale') || '').trim();
				const subproblem = (this.extractTag(resp, 'subproblem') || '').trim();

				if (route !== 'DIRECT' && route !== 'PROOF_THEN_SOLUTION') {
					throw new Error(`Router produced invalid route: "${route || 'EMPTY'}"`);
				}
				if (route === 'PROOF_THEN_SOLUTION' && !subproblem) {
					throw new Error(`Router chose PROOF_THEN_SOLUTION but no <subproblem> was provided.`);
				}
				return { route, rationale, subproblem };
			}

			async routeProblemV11(query, whiteboardContextText = '', phaseLabel = 'INIT') {
				const routerSystem = `You are the Main Branch Router (system 1.1).

Given a problem AND the current whiteboard, decide whether to:
- proceed to the Solution Branch now (DIRECT), OR
- run another Proof Branch first (PROOF_THEN_SOLUTION), OR
- run a Proof Branch but you are NOT confident what the best subproblem is (PROOF_THEN_SOLUTION_UNDECIDED).

First explain your reasoning briefly (2-6 sentences). Do NOT solve anything.
Then, at the VERY END, output EXACTLY one of the following tag blocks (and do not output these tags earlier):

<route>DIRECT</route>
<rationale>...</rationale>

OR

<route>PROOF_THEN_SOLUTION</route>
<rationale>...</rationale>
<subproblem>...</subproblem>

OR

<route>PROOF_THEN_SOLUTION_UNDECIDED</route>
<rationale>...</rationale>

Rules:
- Do NOT solve anything.
- If PROOF_THEN_SOLUTION: subproblem must be single, self-contained, and produce a reusable conclusion.
- Prefer GLOBAL/BROAD subproblems over narrow/local cases; aim for high information gain and a reusable constraint/lemma.
- If UNDECIDED: omit <subproblem>; the system will run a subproblem-selection vote.
- Keep the subproblem concise and unambiguous.`;

				const user = `${whiteboardContextText ? `[WHITEBOARD]\n${whiteboardContextText}\n\n` : ''}[PHASE]\n${phaseLabel}\n\n[PROBLEM]\n${query}`;

				const validateRouter = (txt) => {
					if (!this.hasTagBlock(txt, 'route')) return 'Missing <route>...</route>';
					if (!this.hasTagBlock(txt, 'rationale')) return 'Missing <rationale>...</rationale>';
					const route = (this.extractTag(txt, 'route') || '').trim().toUpperCase();
					const allowed = new Set(['DIRECT', 'PROOF_THEN_SOLUTION', 'PROOF_THEN_SOLUTION_UNDECIDED']);
					if (!allowed.has(route)) return `Invalid <route>: ${route || 'EMPTY'}`;
					if (route === 'PROOF_THEN_SOLUTION' && !this.hasTagBlock(txt, 'subproblem')) return 'Missing <subproblem> for PROOF_THEN_SOLUTION';
					if (route === 'PROOF_THEN_SOLUTION_UNDECIDED' && this.hasTagBlock(txt, 'subproblem')) return 'UNDECIDED must omit <subproblem>';
					return true;
				};

				const resp = await this.callAPI(
					[
						{ role: 'system', content: routerSystem },
						{ role: 'user', content: user }
					],
					validateRouter
				);

				const routeRaw = (this.extractTag(resp, 'route') || '').trim().toUpperCase();
				const rationale = (this.extractTag(resp, 'rationale') || '').trim();
				const subproblem = (this.extractTag(resp, 'subproblem') || '').trim();

				let route = routeRaw;
				if (route === 'PROOF_THEN_SOLUTION' && !subproblem) route = 'PROOF_THEN_SOLUTION_UNDECIDED';

				const allowed = new Set(['DIRECT', 'PROOF_THEN_SOLUTION', 'PROOF_THEN_SOLUTION_UNDECIDED']);
				if (!allowed.has(route)) {
					throw new Error(`Router produced invalid route: "${route || 'EMPTY'}"`);
				}
				if (route === 'PROOF_THEN_SOLUTION' && !subproblem) {
					throw new Error(`Router chose PROOF_THEN_SOLUTION but no <subproblem> was provided.`);
				}
				return { route, rationale, subproblem };
			}

			async runSubproblemVoteV11(originalQuery, extraContextText = '') {
				const personas = [
					{ id: 'A', title: 'Decomposer', note: 'Suggest a reusable lemma/subproblem that unlocks the main proof.' },
					{ id: 'B', title: 'Verifier', note: 'Propose a subproblem that removes ambiguity and makes verification easy.' },
					{ id: 'C', title: 'Adversary', note: 'Pick a subproblem that targets likely failure modes/edge cases.' },
				];

				const validateCandidate = (txt) => {
					if (!this.hasTagBlock(txt, 'candidate')) return 'Missing <candidate>...</candidate>';
					for (const tag of ['subproblem', 'scope', 'payoff', 'reuse_hook', 'verification_test']) {
						if (!this.hasTagBlock(txt, tag)) return `Missing <${tag}>...</${tag}>`;
					}
					const scope = (this.extractTag(txt, 'scope') || '').trim().toUpperCase();
					if (!['GLOBAL', 'BROAD', 'LOCAL'].includes(scope)) return 'Invalid <scope> (must be GLOBAL|BROAD|LOCAL)';
					if (scope === 'LOCAL' && !this.hasTagBlock(txt, 'local_justification')) return 'LOCAL scope requires <local_justification>';
					const sub = (this.extractTag(txt, 'subproblem') || '').trim();
					if (sub.length < 12) return 'Subproblem too short';
					return true;
				};

				const proposals = {};
				for (const p of personas) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[SubproblemVote] Drafting candidate (${p.id}:${p.title})...`);
					const sys = `You are Subproblem Designer ${p.id} (${p.title}).

Task: Propose ONE candidate subproblem to solve first in a Proof Branch.
This subproblem should be reusable and high-impact for the original problem.

Rules:
- Do NOT solve anything.
- The subproblem must be single, self-contained, and yield a reusable conclusion.
- Prefer GLOBAL relevance over narrow/local cases.
- Avoid reliance on specific numeric examples unless unavoidable.

At the VERY END output EXACTLY one <candidate> block:
<candidate>
<subproblem>...</subproblem>
<scope>GLOBAL|BROAD|LOCAL</scope>
<payoff>What uncertainty this removes</payoff>
<reuse_hook>Where it plugs into the final solution</reuse_hook>
<verification_test>How a verifier could falsify/check this quickly</verification_test>
<!-- if scope=LOCAL also include: <local_justification>...</local_justification> -->
</candidate>

Do not output <candidate> until the end.`;

					const user = `${extraContextText ? extraContextText + '\n\n' : ''}ORIGINAL PROBLEM:\n${originalQuery}`;
					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
						validateCandidate
					);

					proposals[p.id] = {
						subproblem: (this.extractTag(resp, 'subproblem') || '').trim(),
						scope: (this.extractTag(resp, 'scope') || '').trim().toUpperCase(),
						payoff: (this.extractTag(resp, 'payoff') || '').trim(),
						reuseHook: (this.extractTag(resp, 'reuse_hook') || '').trim(),
						verificationTest: (this.extractTag(resp, 'verification_test') || '').trim(),
						localJustification: (this.extractTag(resp, 'local_justification') || '').trim(),
					};
				}

				const scoreReusabilityWeight = (c) => {
					const text = `${c.subproblem || ''} ${c.payoff || ''} ${c.reuseHook || ''}`.trim();
					let score = 0;
					if (/(for\s+(any|all|every|each)\b|in\s+all\s+cases\b)/i.test(text)) score += 2;
					if (!/[0-9]/.test(text)) score += 1;
					if (/^(prove|show|derive|establish|demonstrate|find|determine|construct)\b/i.test((c.subproblem || '').trim())) score += 1;
					if ((c.verificationTest || '').trim().length >= 10) score += 1;
					return score; // 0‚Äì5
				};
				const scopeRank = (scope) => (scope === 'GLOBAL' ? 2 : scope === 'BROAD' ? 1 : 0);
				const scored = {};
				for (const k of ['A', 'B', 'C']) {
					const c = proposals[k] || {};
					scored[k] = {
						scope: c.scope || 'LOCAL',
						scopeRank: scopeRank(c.scope),
						reusabilityWeight: scoreReusabilityWeight(c),
					};
				}

				const scoreLine = `A:${scored.A.reusabilityWeight} B:${scored.B.reusabilityWeight} C:${scored.C.reusabilityWeight}`;
				this.log(`[SubproblemVote] ReusabilityWeight (0‚Äì5): ${scoreLine}`);

				const pickBest = () => {
					const keys = ['A', 'B', 'C'];
					keys.sort((x, y) => {
						const ax = scored[x], ay = scored[y];
						if (ay.scopeRank !== ax.scopeRank) return ay.scopeRank - ax.scopeRank;
						if (ay.reusabilityWeight !== ax.reusabilityWeight) return ay.reusabilityWeight - ax.reusabilityWeight;
						const px = ((proposals[x]?.payoff || '').length + (proposals[x]?.reuseHook || '').length);
						const py = ((proposals[y]?.payoff || '').length + (proposals[y]?.reuseHook || '').length);
						return py - px;
					});
					return keys[0];
				};

				const choice = pickBest();
				const chosen = proposals[choice] || proposals.A || {};
				const fallback = chosen.subproblem || proposals.A?.subproblem || '';

				return {
					proposals,
					choice,
					subproblem: fallback,
					score: scoreLine,
					scored,
				};
			}

			async runMethodologyVote(branchLabel, objectiveText, extraContextText = '') {
				const personas = [
					{ id: 'A', title: 'Decomposer', note: 'Decompose into lemmas; prove reusable facts first.' },
					{ id: 'B', title: 'Verifier', note: 'Formalize definitions; check each inference step-by-step.' },
					{ id: 'C', title: 'Adversary', note: 'Search for counterexamples/edge cases; patch weak points.' },
				];

				const validateMethodologyPack = (txt, tag = 'methodology') => {
					if (!this.hasTagBlock(txt, tag)) return `Missing <${tag}>...</${tag}>`;
					if (!this.hasTagBlock(txt, 'commitments')) return 'Missing <commitments>...</commitments>';

					const inner = this.extractTag(txt, tag) || '';
					const bullets = inner.split(/\r?\n/g).map(l => l.trim()).filter(l => l.startsWith('- '));
					if (bullets.length < 6 || bullets.length > 12) return `Inside <${tag}> must contain 6‚Äì12 lines starting with "- "`;

					const lowerInner = inner.toLowerCase();
					if (lowerInner.includes('bullet list')) return `Inside <${tag}> must not contain placeholder text`;
					if (/^\s*(final\s+answer|answer)\s*:/im.test(inner)) return `Inside <${tag}> must not include a solution-style "Final Answer:"/ "Answer:" line`;
					if (/^\s*(therefore|thus|hence)\b/im.test(inner)) return `Inside <${tag}> must not include conclusion-style lines ("Therefore/Thus/Hence ...")`;

					const commits = (this.extractTag(txt, 'commitments') || '').trim();
					const commitLines = commits.split(/\r?\n/g).map(l => l.trim()).filter(Boolean);
					const nCommit = commitLines.filter(l => /^\d+[\).\]]\s*/.test(l)).length;
					if (nCommit < 3) return 'Commitments must include at least 3 numbered items';
					return true;
				};

				const proposals = {};
				for (const p of personas) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${branchLabel}] Drafting methodology (${p.id}:${p.title})...`);
					const sys = `You are Methodology Designer ${p.id} (${p.title}).

Task: Propose a method plan to solve the objective.

Rules:
- Do NOT solve the objective.
- Output a real methodology (no placeholders).
- 6‚Äì12 bullets, each begins with a verb (e.g., "Define", "Check", "Test", "Validate").
- Bullets must be check-oriented (no declarative conclusions like "Therefore X").

At the VERY END output EXACTLY these two blocks:

<methodology>
- Define ...
- Check ...
...
</methodology>
<commitments>
1) Must detect/avoid: [failure mode] by doing [specific check].
2) Must detect/avoid: ...
3) Must detect/avoid: ...
</commitments>

Do not output <methodology> or <commitments> until the end.`;

					const user = `${extraContextText ? extraContextText + '\n\n' : ''}OBJECTIVE:\n${objectiveText}`;
					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
						(txt) => validateMethodologyPack(txt, 'methodology')
					);

					proposals[p.id] = {
						methodology: (this.extractTag(resp, 'methodology') || '').trim(),
						commitments: (this.extractTag(resp, 'commitments') || '').trim(),
					};
				}

				const validateDebateTurn = (txt) => {
					if (!this.hasTagBlock(txt, 'debate_turn')) return 'Missing <debate_turn>...</debate_turn>';
					if (!this.hasTagBlock(txt, 'tests')) return 'Missing <tests>...</tests>';
					if (!this.hasTagBlock(txt, 'patches')) return 'Missing <patches>...</patches>';
					const testsBlock = this.extractTag(txt, 'tests') || '';
					const patchesBlock = this.extractTag(txt, 'patches') || '';
					const testCount = (testsBlock.match(/<test\b/gi) || []).length;
					const patchCount = (patchesBlock.match(/<patch\b/gi) || []).length;
					if (testCount < 2) return 'Debate turn must include at least 2 <test> items';
					if (patchCount < 1) return 'Debate turn must include at least 1 <patch> item';
					return true;
				};

				const debate = [];
				for (const p of personas) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const sys = `You are Methodology Debate Speaker ${p.id} (${p.title}).
You advocate for Methodology ${p.id}.

Rules:
- Do NOT solve the objective.
- Provide testable checks and concrete patches only (no rhetoric).

Output EXACTLY this structure:
<debate_turn>
  <tests>
    <test id="T1">Run this specific check against the solution: ... Expected failure if wrong: ...</test>
    <test id="T2">...</test>
  </tests>
  <patches>
    <patch id="P1">If T1 fails, modify the method plan by doing: ...</patch>
  </patches>
</debate_turn>`;

					const user = `OBJECTIVE:\n${objectiveText}

${extraContextText ? extraContextText + '\n\n' : ''}--- Methodologies ---
A) <methodology>\n${proposals.A.methodology}\n</methodology>\n<commitments>\n${proposals.A.commitments}\n</commitments>

B) <methodology>\n${proposals.B.methodology}\n</methodology>\n<commitments>\n${proposals.B.commitments}\n</commitments>

C) <methodology>\n${proposals.C.methodology}\n</methodology>\n<commitments>\n${proposals.C.commitments}\n</commitments>

Write Speaker ${p.id}'s debate turn now.`;

					const msg = (await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
						validateDebateTurn
					)).trim();
					debate.push({ speaker: p.id, turn: msg });
				}

				const validateSelector = (txt) => {
					if (!this.hasTagBlock(txt, 'choice')) return 'Missing <choice>...</choice>';
					if (!this.hasTagBlock(txt, 'final_methodology')) return 'Missing <final_methodology>...</final_methodology>';
					if (!this.hasTagBlock(txt, 'commitments')) return 'Missing <commitments>...</commitments>';
					if (!this.hasTagBlock(txt, 'merged_tests')) return 'Missing <merged_tests>...</merged_tests>';

					const finalMeth = this.extractTag(txt, 'final_methodology') || '';
					const bullets = finalMeth.split(/\r?\n/g).map(l => l.trim()).filter(l => l.startsWith('- '));
					if (bullets.length < 6 || bullets.length > 12) return 'final_methodology must have 6‚Äì12 "- " bullets';

					const merged = this.extractTag(txt, 'merged_tests') || '';
					if ((merged.match(/<test\b/gi) || []).length < 2) return 'merged_tests must include at least 2 <test> items';
					return true;
				};

				this.log(`[${branchLabel}] RedTeam selecting methodology...`);
				const selectorSystem = `You are a Red Team Methodology Selector.

Pick the best methodology to maximize correctness and robustness.

Hard rules:
- Do NOT solve the objective.
- Prefer plans with testable checks and explicit failure-mode coverage.
- Ensure the final plan is not empty and not placeholder text.

At the VERY END output EXACTLY:
<choice>A|B|C</choice>
<final_methodology>
- Define ...
- Check ...
...
</final_methodology>
<commitments>
1) Must detect/avoid: ...
2) ...
3) ...
</commitments>
<merged_tests>
<test id="T1">...</test>
<test id="T2">...</test>
</merged_tests>

Do not output these tags until the end.`;

				const selectorUser = `OBJECTIVE:\n${objectiveText}

${extraContextText ? extraContextText + '\n\n' : ''}--- Proposals ---
A)
<methodology>
${proposals.A.methodology}
</methodology>
<commitments>
${proposals.A.commitments}
</commitments>

B)
<methodology>
${proposals.B.methodology}
</methodology>
<commitments>
${proposals.B.commitments}
</commitments>

C)
<methodology>
${proposals.C.methodology}
</methodology>
<commitments>
${proposals.C.commitments}
</commitments>

--- Debate Turns (tests + patches) ---
${debate.map(d => `Speaker ${d.speaker}:\n${d.turn}`).join('\n\n')}
`;

				const selectorResp = await this.callAPI(
					[{ role: 'system', content: selectorSystem }, { role: 'user', content: selectorUser }],
					validateSelector
				);

				const choiceRaw = (this.extractTag(selectorResp, 'choice') || '').trim().toUpperCase();
				const safeChoice = ['A', 'B', 'C'].includes(choiceRaw) ? choiceRaw : 'A';

				let finalMethodology = (this.extractTag(selectorResp, 'final_methodology') || '').trim();
				let finalCommitments = (this.extractTag(selectorResp, 'commitments') || '').trim();
				let mergedTests = (this.extractTag(selectorResp, 'merged_tests') || '').trim();

				if (!finalMethodology) finalMethodology = proposals[safeChoice]?.methodology || proposals.A?.methodology || '';
				if (!finalCommitments) finalCommitments = proposals[safeChoice]?.commitments || proposals.A?.commitments || '';

				// Optional anchoring scrub: enforce check-oriented, non-declarative plan.
				const scrubSystem = `You are Methodology Scrubber. Do NOT solve. Remove any declarative conclusions; rewrite bullets as imperative checks/tests.\n\nAt the VERY END output EXACTLY:\n<methodology>...</methodology>\n<commitments>...</commitments>\nDo not output the tags until the end.`;
				const scrubUser = `OBJECTIVE:\n${objectiveText}\n\n<CURRENT_METHOD_PLAN>\n<methodology>\n${finalMethodology}\n</methodology>\n<commitments>\n${finalCommitments}\n</commitments>\n\nRewrite with MINIMUM changes needed to ensure: 6‚Äì12 verb-starting bullets; no conclusion language; commitments remain numbered and checkable.`;
				const scrubResp = await this.callAPI(
					[{ role: 'system', content: scrubSystem }, { role: 'user', content: scrubUser }],
					(txt) => validateMethodologyPack(txt, 'methodology')
				);

				finalMethodology = (this.extractTag(scrubResp, 'methodology') || '').trim() || finalMethodology;
				finalCommitments = (this.extractTag(scrubResp, 'commitments') || '').trim() || finalCommitments;

				return {
					proposals,
					debate,
					choice: safeChoice,
					finalMethodology,
					finalCommitments,
					mergedTests,
				};
			}

			getSolverPromptWithMethodology(methodologyText, branchLabel) {
				const meth = (methodologyText || '').trim();
				if (!meth) return this.getSolverPrompt();
				return `${this.getSolverPrompt()}

### Selected Methodology (HIGH PRIORITY)
Branch: ${branchLabel}
${meth}

Follow this methodology.`;
			}

			getCorrectionPromptWithMethodology(bugReport, principles, methodologyText, branchLabel) {
				const base = this.getCorrectionPrompt(bugReport, principles);
				const meth = (methodologyText || '').trim();
				if (!meth) return base;
				return `${base}

### Selected Methodology (HIGH PRIORITY)
Branch: ${branchLabel}
${meth}

Follow this methodology while revising.`;
			}

			async handleFailureWithMethodology(solution, feedbackContent, effectiveQuery, runMemory, methodologyText, branchLabel) {
				let effectivePrinciples = [];
				if (this.config.accCross) effectivePrinciples = [...this.state.globalMemory];
				if (this.config.accRun) effectivePrinciples = [...effectivePrinciples, ...runMemory];
				effectivePrinciples = [...new Set(effectivePrinciples)];

				const correctionResp = await this.callAPI([
					{ role: 'system', content: this.getSolverPromptWithMethodology(methodologyText, branchLabel) },
					{ role: 'user', content: effectiveQuery },
					{ role: 'assistant', content: solution },
					{ role: 'user', content: this.getCorrectionPromptWithMethodology(feedbackContent, effectivePrinciples, methodologyText, branchLabel) }
				]);

				let newPrinciple = null;
				let newSolution = solution;

				if (this.config.who === 'solver' && !this.config.fullText) {
					newPrinciple = this.extractTag(correctionResp, 'summary');
					newSolution = correctionResp.replace(/<summary>[\s\S]*?<\/summary>/gi, "").trim();
				} else if (!this.config.fullText) {
					newPrinciple = this.extractTag(correctionResp, 'summary') || feedbackContent;
					newSolution = correctionResp;
				} else {
					newSolution = correctionResp;
				}

				if (newPrinciple) {
					this.log(`[${branchLabel}] + Memory: ${newPrinciple}`);
					if (this.config.accRun) runMemory.push(newPrinciple);
					if (this.config.accCross) this.state.globalMemory.push(newPrinciple);
				}
				return newSolution;
			}

			getSolverPromptWithMethodologyV11(methodologyText, branchLabel) {
				const base = this.getSolverPromptWithMethodology(methodologyText, branchLabel);
				return `${base}

### Working Memory (RUN-only; tentative)
At the VERY END of your response, output EXACTLY one tag:
<workmem>none OR up to 8 short items, one per line</workmem>

Rules:
- Do not output <workmem> until the end.
- Items may be uncertain; keep them short.
- Outside <workmem>, write ONLY your solution attempt.`;
			}

			getCorrectionPromptWithMethodologyV11(summaryFeedback, rawFeedback, principles, runWorkingMemory, methodologyText, branchLabel) {
				const base = this.getCorrectionPromptWithMethodology(summaryFeedback, principles, methodologyText, branchLabel);
				const rawBlock = rawFeedback
					? `\n\n### Raw Red-Team Feedback (most recent)\n${rawFeedback}\n\nUse this to pinpoint the exact error.`
					: '';
				const wmBlock = `\n\n### Working Memory (RUN-only; tentative)\n${this.formatWorkmemForPrompt(runWorkingMemory)}\n\nUpdate it at the VERY END with:\n<workmem>none OR up to 8 short items, one per line</workmem>\nDo not output <workmem> until the end.`;
				return `${base}${rawBlock}${wmBlock}`;
			}

			async handleFailureWithMethodologyV11(solution, summaryFeedback, rawFeedback, effectiveQuery, runMemory, runWorkingMemory, methodologyText, branchLabel) {
				let effectivePrinciples = [];
				if (this.config.accCross) effectivePrinciples = [...this.state.globalMemory];
				if (this.config.accRun) effectivePrinciples = [...effectivePrinciples, ...runMemory];
				effectivePrinciples = [...new Set(effectivePrinciples)];

				const correctionResp = await this.callAPI([
					{ role: 'system', content: this.getSolverPromptWithMethodologyV11(methodologyText, branchLabel) },
					{ role: 'user', content: this.buildQueryWithWorkmem(effectiveQuery, runWorkingMemory) },
					{ role: 'assistant', content: solution },
					{ role: 'user', content: this.getCorrectionPromptWithMethodologyV11(summaryFeedback, rawFeedback, effectivePrinciples, runWorkingMemory, methodologyText, branchLabel) }
				]);

				const parsed = this.parseWorkmemFromResponse(correctionResp, runWorkingMemory);
				runWorkingMemory = parsed.workingMemory;

				let newPrinciple = null;
				let newSolution = solution;
				const respNoWorkmem = parsed.cleanText;

				if (this.config.who === 'solver' && !this.config.fullText) {
					newPrinciple = this.extractTag(respNoWorkmem, 'summary');
					newSolution = respNoWorkmem.replace(/<summary>[\s\S]*?<\/summary>/gi, "").trim();
				} else if (!this.config.fullText) {
					newPrinciple = this.extractTag(respNoWorkmem, 'summary') || summaryFeedback;
					newSolution = respNoWorkmem;
				} else {
					newSolution = respNoWorkmem;
				}

				if (newPrinciple) {
					this.log(`[${branchLabel}] + Memory: ${newPrinciple}`);
					if (this.config.accRun) runMemory.push(newPrinciple);
					if (this.config.accCross) this.state.globalMemory.push(newPrinciple);
				}

				return { solution: newSolution, workingMemory: runWorkingMemory };
			}

			getCorrectionPromptWithMethodologyV12(summaryFeedback, rawFeedback, principles, methodologyText, commitmentsText, branchLabel, taskType) {
				const base = `Below is Red Team feedback on your previous attempt.

[Summary of what failed]
${(summaryFeedback || '').trim() || '[None]'}

${rawFeedback ? `[Raw Red Team report]\n${rawFeedback}\n` : ''}`;

				const principleBlock = Array.isArray(principles) && principles.length
					? `\n[Principles to follow]\n${principles.map(p => `- ${p}`).join('\n')}\n`
					: '';

				const methBlock = (methodologyText || commitmentsText)
					? `\n[MANDATORY METHOD PLAN]\n${this.getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, branchLabel, taskType)}\n`
					: '';

				return `${base}${principleBlock}\nRevise the solution now.\n- Fix the specific failures.\n- Keep the output in the required step-by-step format.\n- Do not mention any hidden grading criteria.${methBlock}`;
			}

			async handleFailureWithMethodologyV12(solution, summaryFeedback, rawFeedback, effectiveQuery, runMemory, runWorkingMemoryEntries, methodologyText, commitmentsText, branchLabel, taskType) {
				let effectivePrinciples = [];
				if (this.config.accCross) effectivePrinciples = [...this.state.globalMemory];
				if (this.config.accRun) effectivePrinciples = [...effectivePrinciples, ...runMemory];
				effectivePrinciples = [...new Set(effectivePrinciples)];

				const wmDecayed = this.decrementWorkingMemoryTtl(runWorkingMemoryEntries);

				const correctionResp = await this.callAPI(
					[
						{ role: 'system', content: this.getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, branchLabel, taskType) },
						{ role: 'user', content: this.buildQueryWithWorkingMemoryV12(effectiveQuery, wmDecayed) },
						{ role: 'assistant', content: solution },
						{ role: 'user', content: this.getCorrectionPromptWithMethodologyV12(summaryFeedback, rawFeedback, effectivePrinciples, methodologyText, commitmentsText, branchLabel, taskType) }
					],
					(txt) => this.validateWorkingMemoryXmlBlock(txt),
					{ temperature: 0.7 }
				);

				const parsed = this.parseWorkingMemoryFromResponseV12(correctionResp, wmDecayed);
				let merged = this.mergeWorkingMemory(wmDecayed, parsed.newEntries);

				if (merged.length > 7) {
					this.log(`[${branchLabel}] Working memory > 7 ‚Üí purifier...`);
					const wbText = (this.config.whiteboard ? this.renderWhiteboardMarkdownV11() : effectiveQuery);
					merged = await this.runMemoryPurifierV12(wbText, merged);
				}

				const respNoWm = parsed.cleanText;
				let newPrinciple = null;
				let newSolution = respNoWm;

				if (!this.config.fullText) {
					newPrinciple = this.extractTag(respNoWm, 'summary') || (summaryFeedback || '').trim();
					newSolution = respNoWm.replace(/<summary>[\s\S]*?<\/summary>/gi, "").trim();
				}

				if (newPrinciple) {
					this.log(`[${branchLabel}] + Memory: ${newPrinciple}`);
					if (this.config.accRun) runMemory.push(newPrinciple);
					if (this.config.accCross) this.state.globalMemory.push(newPrinciple);
				}

				return { solution: newSolution, workingMemory: merged };
			}

			async runIOO_RT2_T2_old(branchLabel, branchQuery, methodologyText) {
				const MAX_RUNS = 10;
				const PASS_STREAK_TARGET = 5;
				const MAX_FAIL_STREAK = 10;
				const MAX_ITER_PER_RUN = 30;

				if (!this.state.verifiedClues) this.state.verifiedClues = [];

				// Ensure we use old RT loop for the branch.
				this.config.rtLogic = 'old';

				for (let runIdx = 1; runIdx <= MAX_RUNS; runIdx++) {
					this.log(`[${branchLabel}] === Run ${runIdx}/${MAX_RUNS} ===`);
					let runMemory = [];

					const effectiveQuery = branchQuery;
					let solution = await this.callAPI([
						{ role: 'system', content: this.getSolverPromptWithMethodology(methodologyText, branchLabel) },
						{ role: 'user', content: effectiveQuery }
					]);

					let passStreak = 0;
					let failStreak = 0;
					let totalIter = 0;

					while (true) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						totalIter++;

						const verifierResp = await this.callAPI(
							[
								{ role: 'system', content: this.getVerifierPrompt(false) },
								{ role: 'user', content: `Problem:\n${effectiveQuery}\n\nSolution Attempt:\n${solution}\n\nReturn <pass> or <fail> at the end.` }
							],
							(txt) => txt.includes('<pass>') || txt.includes('<fail>')
						);

						let isPass = verifierResp.includes('<pass>');
						const rawSummary = this.extractTag(verifierResp, 'summary');
						let feedbackContent = "";

						if (this.config.fullText) {
							feedbackContent = verifierResp.replace(/<\/?(pass|fail|summary)>/g, "").trim();
						} else {
							if (this.config.who === 'red') {
								feedbackContent = rawSummary || "No summary provided.";
							} else if (this.config.who === 'mid') {
								const midResp = await this.callAPI(
									[{ role: 'user', content: this.getIntermediaryPrompt(verifierResp) }],
									(text) => text.includes('<summary>')
								);
								feedbackContent = this.extractTag(midResp, 'summary') || midResp;
							} else {
								feedbackContent = verifierResp.replace(/<\/?(pass|fail)>/g, "").trim();
							}
						}

						if (isPass) {
							passStreak++;
							if (passStreak === 3) {
								this.log(`[${branchLabel}] [RedTeam] T2 Trigger (Streak 3). Verifying (RT2-T2-old)...`);
								const rtRes = await this.runRedTeamLoop(solution, 'V2');
								if (rtRes.verdict === 'fail') {
									isPass = false;
									passStreak = 0;
									feedbackContent = "Red Team Rejected: " + (rtRes.feedback || "No Feedback");
									this.log(`[${branchLabel}] [RedTeam] Rejected Solution.`);
								} else {
									this.log(`[${branchLabel}] [RedTeam] Passed. Continuing streak...`);
								}
							}
						}

						if (isPass) {
							failStreak = 0;
							this.log(`[${branchLabel}] PASS (${passStreak}/${PASS_STREAK_TARGET})`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.log(`[${branchLabel}] ‚úÖ Branch Success`);
								return solution;
							}
						} else {
							passStreak = 0;
							failStreak++;
							this.log(`[${branchLabel}] FAIL (${failStreak})`);
							if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
								this.log(`[${branchLabel}] Run Failed (Max Streak/Iter). Next Run...`);
								break;
							}
							solution = await this.handleFailureWithMethodology(solution, feedbackContent, effectiveQuery, runMemory, methodologyText, branchLabel);
						}
						saveToLocalStorage();
					}
				}

				throw new Error(`[${branchLabel}] Failed (Max Runs)`);
			}

			async runTrialV11(originalQuery, candidateSolution) {
				const debateTurns = 10;
				const debate = [];

				for (let t = 1; t <= debateTurns; t++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const isProsecutor = (t % 2) === 1;
					const roleLabel = isProsecutor ? 'Prosecutor' : 'Defense';
					const prefix = isProsecutor ? 'P:' : 'D:';

					const sys = isProsecutor
						? `You are the Prosecutor (Red Team) in a trial of a proposed final solution.

	Goal: Find a real flaw (logical gap, missing case, invalid inference). If you cannot find one, press on the weakest point.

	Rules:
	- Write ONE short message (<= 140 words).
	- Be concrete: quote the exact step/claim you challenge.
	- You must stay adversarial: do NOT agree, do NOT concede, and do NOT declare the defense has ‚Äúfixed it‚Äù.
	- If the defense patches a gap, pivot: demand stricter justification, probe a new edge case, or argue the patch is insufficient/unproven.
	- You may acknowledge facts (e.g., ‚Äúthey added step X‚Äù), but keep your stance: ‚Äúthe solution is still not proven correct‚Äù.
	- Prefix your message with "P:".`
						: `You are the Defense Counsel for the proposed final solution.

	Goal: Defend correctness and completeness. Address objections precisely.

	Rules:
	- Write ONE short message (<= 140 words).
	- You must stay defensive: do NOT agree, do NOT concede, and do NOT accept the prosecution‚Äôs framing.
	- If there is a gap, patch it rigorously, but frame it as clarification/strengthening (not an admission of invalidity).
	- If the prosecutor raises a valid point, respond by closing the gap and immediately reasserting that the overall solution is correct and complete.
	- Prefix your message with "D:".`;

					const user = `ORIGINAL PROBLEM:\n${originalQuery}

PROPOSED FINAL SOLUTION:\n${candidateSolution}

--- Debate so far ---
${debate.join('\n') || '[None yet]'}

Write the next message as ${roleLabel} and prefix with "${prefix}".`;

					const msg = (await this.callAPI([{ role: 'system', content: sys }, { role: 'user', content: user }])).trim();
					debate.push(msg);
				}

				const judges = [
					{ id: 'J1', title: 'Formalist', note: 'Obsess over definitions, quantifiers, and missing justifications.' },
					{ id: 'J2', title: 'Counterexample Hunter', note: 'Try edge cases and adversarial interpretations.' },
					{ id: 'J3', title: 'Pragmatic Verifier', note: 'Focus on whether the core argument is correct and complete.' },
				];

				const judgeDebateTurns = 10;
				const judgeDebate = [];
				for (let t = 1; t <= judgeDebateTurns; t++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const j = judges[(t - 1) % judges.length];

					const sys = `You are ${j.id} (${j.title}), a judge reviewing a defense-vs-prosecution transcript.
Persona guidance: ${j.note}

Rules:
- Write ONE short message (<= 140 words).
- Do NOT give the final verdict yet.
- Prefix your message with "${j.id}:".`;

					const user = `ORIGINAL PROBLEM:\n${originalQuery}

PROPOSED FINAL SOLUTION:\n${candidateSolution}

--- Defense/Prosecution Transcript ---
${debate.join('\n')}

--- Judges' discussion so far ---
${judgeDebate.join('\n') || '[None yet]'}

Write the next message as ${j.id} and prefix with "${j.id}:".`;

					const msg = (await this.callAPI([{ role: 'system', content: sys }, { role: 'user', content: user }])).trim();
					judgeDebate.push(msg);
				}

				const verdicts = [];
				for (const j of judges) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const sys = `You are ${j.id} (${j.title}), delivering your FINAL VERDICT.
Persona guidance: ${j.note}

Output rules:
- First write brief reasoning (2-6 sentences).
- Then, at the VERY END, output EXACTLY:
<verdict>PASS|FAIL</verdict>
<rationale>...</rationale>

Do not output the tags until the end.`;

					const user = `ORIGINAL PROBLEM:\n${originalQuery}

PROPOSED FINAL SOLUTION:\n${candidateSolution}

--- Defense/Prosecution Transcript ---
${debate.join('\n')}

--- Judges' discussion transcript ---
${judgeDebate.join('\n')}
`;

					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
						(txt) => txt.includes('<verdict>') && txt.includes('</verdict>') && txt.includes('<rationale>') && txt.includes('</rationale>')
					);
					const v = (this.extractTag(resp, 'verdict') || '').trim().toUpperCase();
					const rationale = (this.extractTag(resp, 'rationale') || '').trim();
					verdicts.push({ judge: j.id, verdict: (v === 'PASS' ? 'PASS' : 'FAIL'), rationale });
				}

				const passCount = verdicts.filter(v => v.verdict === 'PASS').length;
				const finalVerdict = passCount >= 2 ? 'PASS' : 'FAIL';
				const feedback = verdicts.map(v => `- ${v.judge}: ${v.verdict}\n  ${v.rationale || '[No rationale]'}`).join('\n');

				return {
					verdict: finalVerdict,
					debate,
					judgeDebate,
					verdicts,
					feedback,
				};
			}

			async runTrialV12(originalQuery, candidateSolution, checklistBlock = '', taskType = 'OTHER') {
				const problem = (originalQuery || '').toString();
				const sol = (candidateSolution || '').toString();
				const checklist = (checklistBlock || '').toString().trim();
				const type = (taskType || 'OTHER').toString().trim().toUpperCase();

				const parseIssues = (issuesText, sourceLabel) => {
					const lines = (issuesText || '').split(/\r?\n/g).map(l => l.trim()).filter(Boolean);
					const out = [];
					for (const line of lines) {
						const m = line.match(/^\-\s*\[(FATAL|MAJOR|MINOR)\]\s*(.+)$/i);
						if (!m) continue;
						out.push({ severity: m[1].toUpperCase(), text: m[2].trim(), source: sourceLabel });
					}
					return out;
				};

				// Prosecutor issues (single-shot, structured)
				const prosecutorSys = `You are the Prosecutor (Red Team).
Goal: Find real flaws and missing obligations. Do NOT be rhetorical.

Output EXACTLY:
<issues>
- [FATAL] ...
- [MAJOR] ...
- [MINOR] ...
</issues>

Rules:
- If you find a quantifier/goal mismatch (e.g., proving "exists" when "for all" is required), label it [FATAL].
- If the problem asks for smallest/largest/best and minimality is not proven, label it [FATAL].`;

				const prosecutorUser = `ORIGINAL PROBLEM:\n${problem}\n\n${checklist ? `CHECKLIST (for verification only):\n${checklist}\n\n` : ''}PROPOSED FINAL SOLUTION:\n${sol}`;

				const validateIssuesOnly = (txt) => {
					if (!this.hasTagBlock(txt, 'issues')) return 'Missing <issues>...</issues>';
					return true;
				};

				const prosecutorResp = await this.callAPI(
					[{ role: 'system', content: prosecutorSys }, { role: 'user', content: prosecutorUser }],
					validateIssuesOnly,
					{ temperature: 0.4 }
				);
				const prosecutorIssuesText = (this.extractTag(prosecutorResp, 'issues') || '').trim();

				const defenseSys = `You are the Defense Counsel.
Goal: Address each [FATAL] and [MAJOR] issue precisely. Do NOT add new claims unless justified by the solution text.
If a [FATAL] issue cannot be fixed without changing the solution, say so.`;
				const defenseUser = `ORIGINAL PROBLEM:\n${problem}\n\nPROPOSED FINAL SOLUTION:\n${sol}\n\nPROSECUTOR ISSUES:\n<issues>\n${prosecutorIssuesText}\n</issues>`;
				const defenseResp = await this.callAPI([{ role: 'system', content: defenseSys }, { role: 'user', content: defenseUser }], null, { temperature: 0.4 });

				const judges = [
					{ id: 'J1', title: 'Formalist', note: 'Obsess over definitions, quantifiers, and completeness.', temperature: 0.2, top_k: 40 },
					{ id: 'J2', title: 'Counterexample Hunter', note: 'Try adversarial interpretations and edge cases.', temperature: 0.7, top_k: 80 },
					{ id: 'J3', title: 'Spec Auditor', note: 'Check spec/definition compliance line-by-line.', temperature: 0.4, top_k: 50 },
				];

				const validateJudgeVerdict = (txt) => {
					for (const tag of ['obligations', 'issues', 'verdict', 'rationale']) {
						if (!this.hasTagBlock(txt, tag)) return `Missing <${tag}>...</${tag}>`;
					}
					const v = (this.extractTag(txt, 'verdict') || '').trim().toUpperCase();
					if (!['PASS', 'FAIL'].includes(v)) return 'Invalid <verdict> (must be PASS|FAIL)';
					const ob = (this.extractTag(txt, 'obligations') || '').trim();
					for (const field of ['TaskType:', 'QuantifiersRequired:', 'MustShowOptimality:', 'MustProvideWitnessOrLowerBound:']) {
						if (!ob.includes(field)) return `Obligations missing field: ${field}`;
					}
					return true;
				};

				const verdicts = [];
				let allIssues = [];
				allIssues = allIssues.concat(parseIssues(prosecutorIssuesText, 'Prosecutor'));

				for (const j of judges) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

					const sys = `You are ${j.id} (${j.title}), delivering your FINAL VERDICT.
Persona guidance: ${j.note}

Before judging, fill obligations explicitly.

Output rules:
- First write brief reasoning (2‚Äì6 sentences).
- Then output EXACTLY these blocks at the end:
<obligations>
TaskType: ${type}
QuantifiersRequired: ...
MustShowOptimality: YES/NO
MustProvideWitnessOrLowerBound: YES/NO
</obligations>
<issues>
- [FATAL] ...
- [MAJOR] ...
- [MINOR] ...
</issues>
<verdict>PASS|FAIL</verdict>
<rationale>...</rationale>

Do not output the tags until the end.`;

					const user = `ORIGINAL PROBLEM:\n${problem}\n\n${checklist ? `CHECKLIST (for verification only):\n${checklist}\n\n` : ''}PROPOSED FINAL SOLUTION:\n${sol}\n\nPROSECUTOR ISSUES:\n<issues>\n${prosecutorIssuesText}\n</issues>\n\nDEFENSE RESPONSE:\n${defenseResp}`;

					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
						validateJudgeVerdict,
						{ temperature: j.temperature, top_k: j.top_k }
					);

					const v = (this.extractTag(resp, 'verdict') || '').trim().toUpperCase();
					const rationale = (this.extractTag(resp, 'rationale') || '').trim();
					const issuesText = (this.extractTag(resp, 'issues') || '').trim();
					allIssues = allIssues.concat(parseIssues(issuesText, j.id));
					verdicts.push({ judge: j.id, verdict: v, rationale, raw: resp });
				}

				const fatalIssues = allIssues.filter(i => i.severity === 'FATAL');
				const majorIssues = allIssues.filter(i => i.severity === 'MAJOR');

				let finalVerdict = 'FAIL';
				if (fatalIssues.length > 0) {
					finalVerdict = 'FAIL';
				} else {
					const passCount = verdicts.filter(v => v.verdict === 'PASS').length;
					finalVerdict = passCount >= 2 ? 'PASS' : 'FAIL';
				}

				const feedbackParts = [];
				if (fatalIssues.length) {
					feedbackParts.push('[FATAL ISSUES]');
					fatalIssues.forEach(i => feedbackParts.push(`- (${i.source}) ${i.text}`));
				}
				if (majorIssues.length) {
					feedbackParts.push('[MAJOR ISSUES]');
					majorIssues.forEach(i => feedbackParts.push(`- (${i.source}) ${i.text}`));
				}
				feedbackParts.push('[Judge Verdicts]');
				verdicts.forEach(v => feedbackParts.push(`- ${v.judge}: ${v.verdict}\n  ${v.rationale || '[No rationale]'}`));

				return {
					verdict: finalVerdict,
					prosecutor: prosecutorIssuesText,
					defense: defenseResp,
					verdicts,
					issues: allIssues,
					feedback: feedbackParts.join('\n'),
				};
			}

			async runIOO_RT2_T2_v11(branchLabel, branchQuery, objectiveText, extraContextBase = '', options = {}) {
				const { enableTrial = false } = options;

				const MAX_RUNS = 10;
				const PASS_STREAK_TARGET = 5;
				const MAX_FAIL_STREAK = 10;
				const MAX_ITER_PER_RUN = 30;

				// Ensure we use old RT loop for the branch.
				this.config.rtLogic = 'old';

				const methodHistory = [];

				for (let runIdx = 1; runIdx <= MAX_RUNS; runIdx++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

					this.log(`[${branchLabel}] === Run ${runIdx}/${MAX_RUNS} ===`);

					let runMemory = [];
					let runWorkingMemory = [];

					if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
						this.state.whiteboard.live.stage = `${branchLabel}:method_vote`;
						this.state.whiteboard.live.branch = branchLabel;
						this.state.whiteboard.live.runIdx = runIdx;
						this.state.whiteboard.live.workingMemory = [];
						this.state.whiteboard.live.lastSummaryFeedback = '';
						this.state.whiteboard.live.lastRawFeedback = '';
					}
					this.refreshWhiteboardUI();

					let extraContextText = extraContextBase || '';
					if (runIdx >= 3 && methodHistory.length) {
						const hist = methodHistory.map((h) => `Run ${h.runIdx}: [Choice ${h.choice}]\n${h.finalMethodology}`).join('\n\n');
						extraContextText = `${extraContextText ? extraContextText + '\n\n' : ''}[Previous Run Methodologies]\n${hist}\n\nNote: previous runs did NOT reach success.\nTry not to repeat the exact same methodology unless you have a concrete reason; adapt based on prior failure modes.`;
					}

					const mv = await this.runMethodologyVote(`${branchLabel} Run ${runIdx}`, objectiveText, extraContextText);
					const methodologyText = (mv.finalMethodology || '').trim();
					methodHistory.push({ runIdx, choice: mv.choice || '?', finalMethodology: methodologyText });

					if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
						this.state.whiteboard.live.stage = `${branchLabel}:run`;
						this.state.whiteboard.live.methodology = methodologyText;
					}
					this.refreshWhiteboardUI();

					const effectiveQuery = branchQuery;
					const solverResp = await this.callAPI([
						{ role: 'system', content: this.getSolverPromptWithMethodologyV11(methodologyText, branchLabel) },
						{ role: 'user', content: this.buildQueryWithWorkmem(effectiveQuery, runWorkingMemory) }
					]);

					const parsed0 = this.parseWorkmemFromResponse(solverResp, runWorkingMemory);
					runWorkingMemory = parsed0.workingMemory;
					let solution = parsed0.cleanText;

					if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
						this.state.whiteboard.live.workingMemory = [...runWorkingMemory];
					}
					this.refreshWhiteboardUI();

					let passStreak = 0;
					let failStreak = 0;
					let totalIter = 0;

					while (true) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						totalIter++;

						const verifierResp = await this.callAPI(
							[
								{ role: 'system', content: this.getVerifierPrompt(false) },
								{ role: 'user', content: `Problem:\n${effectiveQuery}\n\nSolution Attempt:\n${solution}\n\nReturn <pass> or <fail> at the end.` }
							],
							(txt) => txt.includes('<pass>') || txt.includes('<fail>')
						);

						let isPass = verifierResp.includes('<pass>');
						let rawFeedbackForSolver = verifierResp;

						const rawSummary = this.extractTag(verifierResp, 'summary');
						let summaryFeedback = "";
						if (this.config.fullText) {
							summaryFeedback = verifierResp.replace(/<\/?(pass|fail|summary)>/g, "").trim();
						} else {
							if (this.config.who === 'red') {
								summaryFeedback = rawSummary || "No summary provided.";
							} else if (this.config.who === 'mid') {
								const midResp = await this.callAPI(
									[{ role: 'user', content: this.getIntermediaryPrompt(verifierResp) }],
									(text) => text.includes('<summary>')
								);
								summaryFeedback = this.extractTag(midResp, 'summary') || midResp;
							} else {
								summaryFeedback = verifierResp.replace(/<\/?(pass|fail)>/g, "").trim();
							}
						}

						if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
							this.state.whiteboard.live.lastSummaryFeedback = summaryFeedback || '';
							this.state.whiteboard.live.lastRawFeedback = rawFeedbackForSolver || '';
						}
						this.refreshWhiteboardUI();

						if (isPass) {
							passStreak++;
							if (passStreak === 3) {
								this.log(`[${branchLabel}] [RedTeam] T2 Trigger (Streak 3). Verifying (RT2-T2-old)...`);
								const rtRes = await this.runRedTeamLoop(solution, 'V2');
								if (rtRes.verdict === 'fail') {
									isPass = false;
									passStreak = 0;
									summaryFeedback = "Red Team Rejected: " + (rtRes.feedback || "No Feedback");
									const rawRt = rtRes.feedback || '';
									rawFeedbackForSolver = rawRt;
									if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
										this.state.whiteboard.live.lastSummaryFeedback = summaryFeedback;
										this.state.whiteboard.live.lastRawFeedback = rawRt;
									}
									this.refreshWhiteboardUI();
									this.log(`[${branchLabel}] [RedTeam] Rejected Solution.`);
								} else {
									this.log(`[${branchLabel}] [RedTeam] Passed. Continuing streak...`);
								}
							}
						}

						if (isPass) {
							failStreak = 0;
							this.log(`[${branchLabel}] PASS (${passStreak}/${PASS_STREAK_TARGET})`);

							if (passStreak >= PASS_STREAK_TARGET) {
								if (enableTrial) {
									this.log(`[${branchLabel}] üßë‚Äç‚öñÔ∏è Triggering final trial...`);
									const trial = await this.runTrialV11(objectiveText, solution);
									if (trial.verdict === 'PASS') {
										this.log(`[${branchLabel}] ‚úÖ Trial PASS ‚Üí Branch Success`);
										return { solution, methodHistory, successfulRunWorkingMemory: runWorkingMemory };
									}

									// Trial failed ‚Üí treat as a fail and feed verdicts back.
									const trialSummary = `Trial Rejected (Judges majority FAIL).`;
									const trialRaw = `Judges' Final Verdicts:\n${trial.feedback}`;
									if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
										this.state.whiteboard.live.lastSummaryFeedback = trialSummary;
										this.state.whiteboard.live.lastRawFeedback = trialRaw;
									}
									this.refreshWhiteboardUI();

									passStreak = 0;
									failStreak++;
									this.log(`[${branchLabel}] FAIL (Trial) (${failStreak})`);
									if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
										this.log(`[${branchLabel}] Run Failed (Max Streak/Iter). Next Run...`);
										break;
									}

									const fixed = await this.handleFailureWithMethodologyV11(
										solution,
										trialSummary,
										trialRaw,
										effectiveQuery,
										runMemory,
										runWorkingMemory,
										methodologyText,
										branchLabel
									);
									solution = fixed.solution;
									runWorkingMemory = fixed.workingMemory;
									if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
										this.state.whiteboard.live.workingMemory = [...runWorkingMemory];
									}
									this.refreshWhiteboardUI();
									saveToLocalStorage();
									continue;
								}

								this.log(`[${branchLabel}] ‚úÖ Branch Success`);
								return { solution, methodHistory, successfulRunWorkingMemory: runWorkingMemory };
							}

						} else {
							passStreak = 0;
							failStreak++;
							this.log(`[${branchLabel}] FAIL (${failStreak})`);
							if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
								this.log(`[${branchLabel}] Run Failed (Max Streak/Iter). Next Run...`);
								break;
							}

							const fixed = await this.handleFailureWithMethodologyV11(
								solution,
								summaryFeedback,
								rawFeedbackForSolver,
								effectiveQuery,
								runMemory,
								runWorkingMemory,
								methodologyText,
								branchLabel
							);
							solution = fixed.solution;
							runWorkingMemory = fixed.workingMemory;

							if (this.config.special === 'system-1.1' && this.state.whiteboard?.live) {
								this.state.whiteboard.live.workingMemory = [...runWorkingMemory];
							}
							this.refreshWhiteboardUI();
						}

						saveToLocalStorage();
					}
				}

				throw new Error(`[${branchLabel}] Failed (Max Runs)`);
			}

			async runIOO_RT2_Checklist_v12(branchLabel, branchQuery, objectiveText, extraContextBase = '', options = {}) {
				const { enableTrial = false, checklistBlock = '', taskType = 'OTHER' } = options;

				const clampInt = (v, min, max) => {
					const n = parseInt(v, 10);
					if (!Number.isFinite(n)) return null;
					return Math.min(max, Math.max(min, n));
				};

				const MAX_RUNS = clampInt(options.maxRuns, 1, 50) ?? 10;
				const PASS_STREAK_TARGET = clampInt(options.passStreakTarget, 1, 5) ?? 3; // diversified RT2 pass streak
				const MAX_FAIL_STREAK = clampInt(options.maxFailStreak, 1, 50) ?? 10;
				const MAX_ITER_PER_RUN = clampInt(options.maxIterPerRun, 1, 200) ?? 30;
				const VERIFIER_SAMPLES = clampInt(options.verifierSamples, 1, 10) ?? 1;
				const VERIFIER_PASS_THRESHOLD = clampInt(options.verifierPassThreshold, 1, VERIFIER_SAMPLES) ?? (Math.floor(VERIFIER_SAMPLES / 2) + 1);

				const rt2Configs = [
					{ id: 'RT2-Formalist', focus: 'Quantifiers & completeness', temperature: 0.2, top_k: 40 },
					{ id: 'RT2-Adversary', focus: 'Break it', temperature: 0.7, top_k: 80 },
					{ id: 'RT2-SpecAuditor', focus: 'Definition/spec compliance', temperature: 0.4, top_k: 50 },
				];

				const methodHistory = [];
				let lastKnownSolution = '';
				const isLive = () => (this.config.special === 'system-1.2' && this.state.whiteboard?.live);

				for (let runIdx = 1; runIdx <= MAX_RUNS; runIdx++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

					this.log(`[${branchLabel}] === Run ${runIdx}/${MAX_RUNS} ===`);

					let runMemory = [];
					let runWorkingMemoryEntries = [];

					if (isLive()) {
						this.state.whiteboard.live.stage = `${branchLabel}:method_vote`;
						this.state.whiteboard.live.branch = branchLabel;
						this.state.whiteboard.live.runIdx = runIdx;
						this.state.whiteboard.live.workingMemory = [];
						this.state.whiteboard.live.lastSummaryFeedback = '';
						this.state.whiteboard.live.lastRawFeedback = '';
					}
					this.refreshWhiteboardUI();

					let extraContextText = extraContextBase || '';
					if (runIdx >= 3 && methodHistory.length) {
						const hist = methodHistory.map((h) => {
							const parts = [];
							parts.push(`Run ${h.runIdx}: [Choice ${h.choice}]`);
							if (h.finalMethodology) parts.push(h.finalMethodology);
							if (h.finalCommitments) parts.push('[Commitments]\n' + h.finalCommitments);
							return parts.join('\n');
						}).join('\n\n');
						extraContextText = `${extraContextText ? extraContextText + '\n\n' : ''}[Previous Run Methodologies]\n${hist}\n\nNote: previous runs did NOT reach success.\nAvoid repeating the same plan unless you have a concrete reason; adapt based on prior failure modes.`;
					}

					let mv = null;
					if (options.methodologyOverride) {
						const o = options.methodologyOverride || {};
						mv = {
							choice: o.choice || 'OVERRIDE',
							finalMethodology: (o.finalMethodology || o.methodology || '').toString(),
							finalCommitments: (o.finalCommitments || o.commitments || '').toString(),
							mergedTests: (o.mergedTests || '').toString(),
						};
					} else {
						mv = await this.runMethodologyVote(`${branchLabel} Run ${runIdx}`, objectiveText, extraContextText);
					}
					const methodologyText = (mv.finalMethodology || '').trim();
					const commitmentsText = (mv.finalCommitments || '').trim();
					const mergedTests = (mv.mergedTests || '').trim();

					methodHistory.push({
						runIdx,
						choice: mv.choice || '?',
						finalMethodology: methodologyText,
						finalCommitments: commitmentsText,
					});

					if (isLive()) {
						this.state.whiteboard.live.stage = `${branchLabel}:run`;
						this.state.whiteboard.live.methodology = methodologyText;
					}
					this.refreshWhiteboardUI();

					const effectiveQuery = branchQuery;
					const solverResp = await this.callAPI(
						[
							{ role: 'system', content: this.getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, branchLabel, taskType) },
							{ role: 'user', content: this.buildQueryWithWorkingMemoryV12(effectiveQuery, runWorkingMemoryEntries) }
						],
						(txt) => this.validateWorkingMemoryXmlBlock(txt),
						{ temperature: 0.7 }
					);

					const parsed0 = this.parseWorkingMemoryFromResponseV12(solverResp, runWorkingMemoryEntries);
					runWorkingMemoryEntries = this.mergeWorkingMemory(runWorkingMemoryEntries, parsed0.newEntries);
					if (runWorkingMemoryEntries.length > 7) {
						this.log(`[${branchLabel}] Working memory > 7 ‚Üí purifier...`);
						const wbText = (this.config.whiteboard ? this.renderWhiteboardMarkdownV11() : effectiveQuery);
						runWorkingMemoryEntries = await this.runMemoryPurifierV12(wbText, runWorkingMemoryEntries);
					}
					let solution = parsed0.cleanText;
					lastKnownSolution = solution || lastKnownSolution;

					if (isLive()) {
						this.state.whiteboard.live.workingMemory = this.workingMemoryToDisplayLines(runWorkingMemoryEntries);
					}
					this.refreshWhiteboardUI();

					let passStreak = 0;
					let failStreak = 0;
					let totalIter = 0;
					let rt2Idx = 0;
					let lastStreakPersonaId = '';

					while (true) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						totalIter++;

						const cfg = rt2Configs[rt2Idx % rt2Configs.length];
						rt2Idx++;

						let rt2Resp = '';
						let ensembleStableSummary = '';
						if (VERIFIER_SAMPLES > 1) {
							const ens = await this.runRT2ChecklistVerifierV12Ensemble(
								objectiveText,
								checklistBlock,
								solution,
								cfg,
								mergedTests,
								{ samples: VERIFIER_SAMPLES, passThreshold: VERIFIER_PASS_THRESHOLD }
							);
							rt2Resp = ens.text || '';
							if (ens.verdictTag === 'fail') ensembleStableSummary = ens.stableSummary || '';
						} else {
							rt2Resp = await this.runRT2ChecklistVerifierV12(
								objectiveText,
								checklistBlock,
								solution,
								cfg,
								mergedTests
							);
						}

						const finalTag = this.extractFinalSingleTag(rt2Resp, ['pass', 'fail']) || 'fail';
						const isPass = finalTag === 'pass';

						if (isPass) {
							failStreak = 0;
							if (cfg.id !== lastStreakPersonaId) {
								passStreak += 1;
								lastStreakPersonaId = cfg.id;
							}
							this.log(`[${branchLabel}] RT2 PASS (${passStreak}/${PASS_STREAK_TARGET}) [${cfg.id}]`);

							if (passStreak >= PASS_STREAK_TARGET) {
								if (enableTrial) {
									this.log(`[${branchLabel}] üßë‚Äç‚öñÔ∏è Triggering final trial...`);
									const trial = await this.runTrialV12(objectiveText, solution, checklistBlock, taskType);
									if (trial.verdict === 'PASS') {
										this.log(`[${branchLabel}] ‚úÖ Trial PASS ‚Üí Branch Success`);
										return { solution, methodHistory, successfulRunWorkingMemoryEntries: runWorkingMemoryEntries, trial };
									}

									// Trial failed -> treat as failure and continue fixing.
									const trialSummary = `Trial Rejected (veto/majority FAIL).`;
									const trialRaw = `Trial feedback:\n${trial.feedback}`;
									if (isLive()) {
										this.state.whiteboard.live.lastSummaryFeedback = trialSummary;
										this.state.whiteboard.live.lastRawFeedback = trialRaw;
									}
									this.refreshWhiteboardUI();

									passStreak = 0;
									lastStreakPersonaId = '';
									failStreak += 1;
									this.log(`[${branchLabel}] FAIL (Trial) (${failStreak})`);
									if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
										this.log(`[${branchLabel}] Run Failed (Max Streak/Iter). Next Run...`);
										break;
									}

									const fixed = await this.handleFailureWithMethodologyV12(
										solution,
										trialSummary,
										trialRaw,
										effectiveQuery,
										runMemory,
										runWorkingMemoryEntries,
										methodologyText,
										commitmentsText,
										branchLabel,
										taskType
									);
									solution = fixed.solution;
									lastKnownSolution = solution || lastKnownSolution;
									runWorkingMemoryEntries = fixed.workingMemory;
									if (isLive()) {
										this.state.whiteboard.live.workingMemory = this.workingMemoryToDisplayLines(runWorkingMemoryEntries);
									}
									this.refreshWhiteboardUI();
									saveToLocalStorage();
									continue;
								}

								this.log(`[${branchLabel}] ‚úÖ Branch Success`);
								return { solution, methodHistory, successfulRunWorkingMemoryEntries: runWorkingMemoryEntries };
							}

						} else {
							passStreak = 0;
							lastStreakPersonaId = '';
							failStreak += 1;

							const fb = this.extractRT2FailureFeedback(rt2Resp);
							let summaryForSolver = fb.summary;
							if (ensembleStableSummary) {
								summaryForSolver = ensembleStableSummary;
							}
							if (this.config.who === 'mid') {
								const midResp = await this.callAPI(
									[{ role: 'user', content: this.getIntermediaryPrompt(fb.raw || rt2Resp) }],
									(t) => (this.hasTagBlock(t, 'summary') ? true : 'Missing <summary>...</summary>'),
									{ temperature: 0.2 }
								);
								if (!ensembleStableSummary) summaryForSolver = this.extractTag(midResp, 'summary') || summaryForSolver;
							}
							if (isLive()) {
								this.state.whiteboard.live.lastSummaryFeedback = summaryForSolver || '';
								this.state.whiteboard.live.lastRawFeedback = fb.raw || '';
							}
							this.refreshWhiteboardUI();

							this.log(`[${branchLabel}] RT2 FAIL (${failStreak}) [${cfg.id}]`);
							if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
								this.log(`[${branchLabel}] Run Failed (Max Streak/Iter). Next Run...`);
								break;
							}

							const fixed = await this.handleFailureWithMethodologyV12(
								solution,
								summaryForSolver,
								fb.raw,
								effectiveQuery,
								runMemory,
								runWorkingMemoryEntries,
								methodologyText,
								commitmentsText,
								branchLabel,
								taskType
							);
							solution = fixed.solution;
							lastKnownSolution = solution || lastKnownSolution;
							runWorkingMemoryEntries = fixed.workingMemory;
							if (isLive()) {
								this.state.whiteboard.live.workingMemory = this.workingMemoryToDisplayLines(runWorkingMemoryEntries);
							}
							this.refreshWhiteboardUI();
						}

						saveToLocalStorage();
					}
				}

				const err = new Error(`[${branchLabel}] Failed (Max Runs)`);
				if (lastKnownSolution) err.lastSolution = lastKnownSolution;
				err.methodHistory = methodHistory;
				throw err;
			}

			parseKeepIndices(content, maxIdx) {
				const raw = (content || '').trim().toLowerCase();
				if (!raw || raw === 'none') return new Set();
				const parts = raw.split(/[,\\s]+/g).map(s => s.trim()).filter(Boolean);
				const out = new Set();
				for (const p of parts) {
					const n = parseInt(p, 10);
					if (!Number.isFinite(n)) continue;
					if (n >= 1 && n <= maxIdx) out.add(n);
				}
				return out;
			}

			parseKeepIndicesOrdered(content, maxIdx) {
				const raw = (content || '').trim().toLowerCase();
				if (!raw || raw === 'none') return [];
				const parts = raw.split(/[,\\s]+/g).map(s => s.trim()).filter(Boolean);
				const out = [];
				const seen = new Set();
				for (const p of parts) {
					const n = parseInt(p, 10);
					if (!Number.isFinite(n)) continue;
					if (n < 1 || n > maxIdx) continue;
					if (seen.has(n)) continue;
					seen.add(n);
					out.push(n);
				}
				return out;
			}

			async memoryPreservationGate(originalQuery, subproblem, candidateMemories) {
				const memories = this.normalizeMemories(candidateMemories, 30);
				if (memories.length === 0) return [];

				const list = memories.map((m, i) => `${i + 1}. ${m}`).join('\n');
				const sysBase = (i) => `You are Memory Preservation Auditor #${i} (independent).

Given an original problem and candidate memory items (heuristics/principles), select ONLY items that:
- are broadly applicable and helpful for the original problem,
- are unlikely to be false or misleading,
- are not overly specific/narrow (could distract),
- and reduce the chance of errors.

First write your reasoning briefly (you may mention why specific items are kept/dropped).
Then, at the VERY END, output EXACTLY one tag (and do not output <keep> until the end):
<keep>none</keep>
OR
<keep>comma-separated indices</keep>

Inside <keep> use ONLY "none" or a comma-separated list of integers.`;

				const user = `ORIGINAL PROBLEM:\n${originalQuery}\n\n${subproblem ? `SUBPROBLEM (already solved):\n${subproblem}\n\n` : ''}CANDIDATE MEMORIES:\n${list}`;

				const selections = [];
				for (let i = 1; i <= 3; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[Proof] Memory gate audit ${i}/3...`);
					const resp = await this.callAPI(
						[{ role: 'system', content: sysBase(i) }, { role: 'user', content: user }],
						(txt) => txt.includes('<keep>') && txt.includes('</keep>')
					);
					const keepTag = this.extractTag(resp, 'keep') || 'none';
					selections.push(this.parseKeepIndices(keepTag, memories.length));
				}

				// Intersection of all three sets.
				let intersection = selections[0];
				for (let i = 1; i < selections.length; i++) {
					const next = selections[i];
					intersection = new Set([...intersection].filter(x => next.has(x)));
				}

				if (intersection.size === 0) return [];
				return [...intersection].sort((a, b) => a - b).map(idx => memories[idx - 1]);
			}

			async memoryPreservationGateV12(originalQuery, subproblem, candidateMemories) {
				const memories = this.normalizeMemories(candidateMemories, 50);
				if (memories.length === 0) return { safe: [], quarantined: [] };

				const list = memories.map((m, i) => `${i + 1}. ${m}`).join('\n');

				const sysBase = (i) => `You are Memory Preservation Auditor #${i} (independent).

Select items to preserve. Criteria:
- Self-contained (no pronouns like "this/that" without a referent)
- Checkable (states a claim/check and what evidence supports it)
- Broadly applicable (not just one tiny case)
- Low risk of being false/misleading

First write brief reasoning.
Then at the VERY END output EXACTLY one tag:
<keep>none</keep>
OR
<keep>comma-separated indices</keep>

Inside <keep>, order indices by importance (most important first).`;

				const user = `ORIGINAL PROBLEM:\n${originalQuery}\n\n${subproblem ? `SUBPROBLEM (already solved):\n${subproblem}\n\n` : ''}CANDIDATE ITEMS:\n${list}`;

				const selections = [];
				for (let i = 1; i <= 3; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[MemoryGate] Audit ${i}/3...`);
					const resp = await this.callAPI(
						[{ role: 'system', content: sysBase(i) }, { role: 'user', content: user }],
						(txt) => (this.hasTagBlock(txt, 'keep') ? true : 'Missing <keep>...</keep>')
					);
					const keepTag = this.extractTag(resp, 'keep') || 'none';
					selections.push(this.parseKeepIndicesOrdered(keepTag, memories.length));
				}

				const counts = new Map();
				for (const arr of selections) {
					for (const idx of arr) counts.set(idx, (counts.get(idx) || 0) + 1);
				}

				const safeIdx = [...counts.entries()].filter(([, c]) => c >= 2).map(([idx]) => idx).sort((a, b) => a - b);
				const quarantinedIdx = [...counts.entries()].filter(([, c]) => c === 1).map(([idx]) => idx).sort((a, b) => a - b);

				let quarantined = quarantinedIdx.map(idx => memories[idx - 1]);
				const safe = safeIdx.map(idx => memories[idx - 1]);

				// If safe is empty, quarantine up to 1 top pick from each auditor (max 3), deduped.
				if (safe.length === 0) {
					const fallback = [];
					const seen = new Set();
					for (const arr of selections) {
						const first = arr[0];
						if (!first) continue;
						if (seen.has(first)) continue;
						seen.add(first);
						fallback.push(memories[first - 1]);
					}
					quarantined = this.normalizeMemories([...fallback, ...quarantined], 10);
				}

				return { safe, quarantined };
			}

			async extractProofConclusion(originalQuery, subproblem, proofSolution) {
				const sys = `You are a Conclusion Extractor.

Given a subproblem and its solution, write a short conclusion that can be reused later.

First write a brief explanation (1-3 sentences) of what the reusable conclusion is.
Then, at the VERY END, output EXACTLY one tag (and do not output <conclusion> until the end):
<conclusion>single, self-contained statement (lemma/result/value)</conclusion>

Rules:
- Must be a single, self-contained statement (lemma/result/value).
- Keep the conclusion itself free of extra commentary.`;

				const user = `ORIGINAL PROBLEM:\n${originalQuery}\n\nSUBPROBLEM:\n${subproblem}\n\nSUBPROBLEM SOLUTION:\n${proofSolution}`;
				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					(txt) => txt.includes('<conclusion>') && txt.includes('</conclusion>')
				);
				return (this.extractTag(resp, 'conclusion') || '').trim();
			}

			async runMainBranchArchitecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				if (!this.state.branchingState) {
					this.state.branchingState = { stage: 'init', routeDecision: null, proof: {}, solution: {} };
				}
				const bs = this.state.branchingState;

				if (!this.state.whiteboard) this.state.whiteboard = this.initWhiteboard(query);
				if (!this.state.whiteboard.problem) this.state.whiteboard.problem = query;
				this.refreshWhiteboardUI();

				try {
					while (bs.stage !== 'complete') {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						if (bs.stage === 'init') {
							this.log('[Main] Routing problem...');
							const decision = await this.routeProblem(query);
							bs.routeDecision = decision;
							this.state.whiteboard.main = { ...decision };
							if (decision.route === 'PROOF_THEN_SOLUTION') {
								this.state.whiteboard.proof.subproblem = decision.subproblem;
								bs.stage = 'proof_method';
							} else {
								bs.stage = 'solution_method';
							}
						} else if (bs.stage === 'proof_method') {
							this.log('[Proof] Selecting methodology...');
							this.state.globalMemory = [];
							const mv = await this.runMethodologyVote('Proof', bs.routeDecision.subproblem, `[Original Problem]\n${query}`);
							bs.proof.methodVote = mv;
							this.state.whiteboard.proof.methodVote = mv;
							bs.stage = 'proof_run';
						} else if (bs.stage === 'proof_run') {
							this.log('[Proof] Running I-OO + RT2-T2-old on subproblem...');
							this.state.globalMemory = [];
							const proofQuery = this.buildProofBranchPrompt(query, bs.routeDecision.subproblem);
							const proofSolution = await this.runIOO_RT2_T2_old('Proof', proofQuery, bs.proof.methodVote?.finalMethodology || '');
							bs.proof.solution = proofSolution;
							bs.proof.candidateMemories = this.normalizeMemories(this.state.globalMemory, 30);
							this.state.whiteboard.proof.candidateMemories = bs.proof.candidateMemories;
							bs.stage = 'proof_conclusion';
						} else if (bs.stage === 'proof_conclusion') {
							this.log('[Proof] Extracting reusable conclusion...');
							const conclusion = await this.extractProofConclusion(query, bs.routeDecision.subproblem, bs.proof.solution);
							bs.proof.conclusion = conclusion;
							this.state.whiteboard.proof.conclusion = conclusion;
							bs.stage = 'memory_gate';
						} else if (bs.stage === 'memory_gate') {
							this.log('[Proof] Running memory preservation gate...');
							const preserved = await this.memoryPreservationGate(query, bs.routeDecision.subproblem, bs.proof.candidateMemories || []);
							bs.proof.preservedMemories = preserved;
							this.state.whiteboard.proof.preservedMemories = preserved;
							this.state.globalMemory = [...preserved];
							bs.stage = 'solution_method';
						} else if (bs.stage === 'solution_method') {
							this.log('[Solution] Selecting methodology...');
							this.state.globalMemory = [...(bs.proof?.preservedMemories || [])];
							const extra = this.buildSolutionBranchPrompt(query, bs.proof?.conclusion || '', bs.proof?.preservedMemories || []);
							const mv = await this.runMethodologyVote('Solution', query, extra);
							bs.solution.methodVote = mv;
							this.state.whiteboard.solution.methodVote = mv;
							bs.stage = 'solution_run';
						} else if (bs.stage === 'solution_run') {
							this.log('[Solution] Running I-OO + RT2-T2-old on original problem...');
							const solQuery = this.buildSolutionBranchPrompt(query, bs.proof?.conclusion || '', bs.proof?.preservedMemories || []);
							const sol = await this.runIOO_RT2_T2_old('Solution', solQuery, bs.solution.methodVote?.finalMethodology || '');
							bs.solution.solution = sol;
							bs.stage = 'complete';
						} else {
							throw new Error(`Unknown branching stage: ${bs.stage}`);
						}

						this.refreshWhiteboardUI();
						saveToLocalStorage();
					}

					this.state.status = 'Success';
					this.state.finalResult = bs.solution.solution || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
					return;

				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runSystem11Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				if (!this.state.system11State) {
					this.state.system11State = {
						stage: 'route',
						proofCycles: 0,
						pendingSubproblem: '',
						pendingSubproblemDecidedBy: '',
						lastRouteDecision: null,
					};
				}
				const s = this.state.system11State;

				// Whiteboard for system 1.1
				if (!this.state.whiteboard || !this.state.whiteboard.routerHistory || !this.state.whiteboard.aggregate) {
					this.state.whiteboard = this.initWhiteboardV11(query);
				}
				if (!this.state.whiteboard.problem) this.state.whiteboard.problem = query;

				const wb = this.state.whiteboard;
				const MAX_PROOF_CYCLES = 3;

				try {
					while (s.stage !== 'complete') {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						if (s.stage === 'route') {
							const phaseLabel = s.proofCycles === 0 ? 'INIT' : `POST_PROOF_${s.proofCycles}`;
							this.log(`[System 1.1] Routing (${phaseLabel})...`);
							wb.live.stage = 'route';
							wb.live.branch = 'Router';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							this.refreshWhiteboardUI();

							const decision = await this.routeProblemV11(query, this.renderWhiteboardMarkdownV11(), phaseLabel);
							s.lastRouteDecision = decision;
							wb.routerHistory.push({ phase: phaseLabel, ...decision, decidedBy: 'router' });

							if (decision.route === 'DIRECT') {
								s.stage = 'solution';
							} else if (decision.route === 'PROOF_THEN_SOLUTION') {
								s.pendingSubproblem = decision.subproblem;
								s.pendingSubproblemDecidedBy = 'router';
								s.stage = 'proof';
							} else {
								s.pendingSubproblem = '';
								s.pendingSubproblemDecidedBy = '';
								s.stage = 'subproblem_vote';
							}

						} else if (s.stage === 'subproblem_vote') {
							if (s.proofCycles >= MAX_PROOF_CYCLES) {
								this.log(`[System 1.1] Max proof cycles reached (${MAX_PROOF_CYCLES}); proceeding to solution.`);
								s.stage = 'solution';
								continue;
							}

							this.log(`[System 1.1] Selecting subproblem via vote...`);
							wb.live.stage = 'subproblem_vote';
							wb.live.branch = 'Router';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							this.refreshWhiteboardUI();

							const vote = await this.runSubproblemVoteV11(query, this.renderWhiteboardMarkdownV11());
							s.pendingSubproblem = vote.subproblem;
							s.pendingSubproblemDecidedBy = `vote(${vote.choice})`;
							wb.routerHistory.push({
								phase: `SUBPROBLEM_VOTE_${s.proofCycles + 1}`,
								route: 'PROOF_THEN_SOLUTION',
								rationale: `Chosen by vote (${vote.choice}).`,
								subproblem: vote.subproblem,
								decidedBy: 'vote'
							});
							s.stage = 'proof';

						} else if (s.stage === 'proof') {
							if (s.proofCycles >= MAX_PROOF_CYCLES) {
								this.log(`[System 1.1] Max proof cycles reached (${MAX_PROOF_CYCLES}); proceeding to solution.`);
								s.stage = 'solution';
								continue;
							}

							const subproblem = (s.pendingSubproblem || '').trim();
							if (!subproblem) throw new Error(`[Proof] No subproblem available (router/vote produced empty).`);

							this.log(`[Proof] Starting proof cycle #${s.proofCycles + 1}...`);

							// Fresh memory for this proof cycle; only preserved items will be carried forward.
							this.state.globalMemory = [];

							const proofQuery = this.buildProofBranchPrompt(query, subproblem);
							const proofRes = await this.runIOO_RT2_T2_v11(
								'Proof',
								proofQuery,
								subproblem,
								`[Original Problem]\n${query}`,
								{ enableTrial: false }
							);

							const proofSolution = proofRes.solution;
							const candidateMemories = this.normalizeMemories(this.state.globalMemory, 30);

							this.log('[Proof] Extracting reusable conclusion...');
							const conclusion = await this.extractProofConclusion(query, subproblem, proofSolution);

							this.log('[Proof] Running memory preservation gate (principles)...');
							const preservedMemories = await this.memoryPreservationGate(query, subproblem, candidateMemories);

							this.log('[Proof] Running memory preservation gate (working memory)...');
							const preservedWorkingMemories = await this.memoryPreservationGate(
								query,
								subproblem,
								proofRes.successfulRunWorkingMemory || []
							);

							wb.proofs.push({
								subproblem,
								decidedBy: s.pendingSubproblemDecidedBy || 'router',
								conclusion,
								preservedMemories,
								preservedWorkingMemories,
							});

							wb.aggregate.conclusions = this.normalizeMemories([...(wb.aggregate.conclusions || []), conclusion].filter(Boolean), 20);
							wb.aggregate.preservedMemories = this.normalizeMemories([...(wb.aggregate.preservedMemories || []), ...preservedMemories], 50);
							wb.aggregate.preservedWorkingMemories = this.normalizeMemories([...(wb.aggregate.preservedWorkingMemories || []), ...preservedWorkingMemories], 50);

							// Carry forward only audited safe memories.
							this.state.globalMemory = [...(wb.aggregate.preservedMemories || [])];

							s.proofCycles += 1;
							s.pendingSubproblem = '';
							s.pendingSubproblemDecidedBy = '';

							// After each proof cycle, re-route with the updated whiteboard.
							s.stage = 'route';

						} else if (s.stage === 'solution') {
							this.log(`[Solution] Running solution branch...`);
							wb.live.stage = 'solution';
							wb.live.branch = 'Solution';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							this.refreshWhiteboardUI();

							const solQuery = this.buildSolutionBranchPromptV11(
								query,
								wb.aggregate.conclusions || [],
								wb.aggregate.preservedMemories || [],
								wb.aggregate.preservedWorkingMemories || []
							);

							// Seed cross-run memory with audited safe memories only.
							this.state.globalMemory = [...(wb.aggregate.preservedMemories || [])];

							const solRes = await this.runIOO_RT2_T2_v11(
								'Solution',
								solQuery,
								query,
								solQuery,
								{ enableTrial: true }
							);

							wb.solution.methodHistory = solRes.methodHistory || [];
							wb.solution.finalSolution = solRes.solution || '';
							s.stage = 'complete';
						} else {
							throw new Error(`Unknown system-1.1 stage: ${s.stage}`);
						}

						this.refreshWhiteboardUI();
						saveToLocalStorage();
					}

					this.state.status = 'Success';
					this.state.finalResult = wb.solution?.finalSolution || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
					return;

				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runSystem12Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				if (!this.state.system12State) {
					this.state.system12State = {
						stage: 'bootstrap',
						proofCycles: 0,
						pendingSubproblem: '',
						pendingSubproblemDecidedBy: '',
						lastRouteDecision: null,
						taskType: '',
						checklistCache: {},
					};
				}
				const s = this.state.system12State;

				if (!this.state.whiteboard || !this.state.whiteboard.routerHistory || !this.state.whiteboard.aggregate) {
					this.state.whiteboard = this.initWhiteboardV11(query);
				}
				if (!this.state.whiteboard.problem) this.state.whiteboard.problem = query;
				const wb = this.state.whiteboard;

				// Ensure aggregate shape for new fields.
				wb.aggregate = wb.aggregate || {};
				if (!Array.isArray(wb.aggregate.conclusions)) wb.aggregate.conclusions = [];
				if (!Array.isArray(wb.aggregate.preservedMemories)) wb.aggregate.preservedMemories = [];
				if (!Array.isArray(wb.aggregate.quarantinedMemories)) wb.aggregate.quarantinedMemories = [];
				if (!Array.isArray(wb.aggregate.preservedWorkingMemories)) wb.aggregate.preservedWorkingMemories = [];
				if (!Array.isArray(wb.aggregate.quarantinedWorkingMemories)) wb.aggregate.quarantinedWorkingMemories = [];
				if (typeof wb.aggregate.taskType !== 'string') wb.aggregate.taskType = '';
				if (typeof wb.aggregate.finalChecklist !== 'string') wb.aggregate.finalChecklist = '';

				const MAX_PROOF_CYCLES = 3;

				const getChecklistForObjective = async (objectiveText) => {
					const key = this.normalizeForHash(objectiveText).slice(0, 1800);
					if (s.checklistCache && s.checklistCache[key]) return s.checklistCache[key];
					const checklist = await this.generateFinalChecklist(objectiveText);
					s.checklistCache[key] = checklist;
					return checklist;
				};

				try {
					while (s.stage !== 'complete') {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						if (s.stage === 'bootstrap') {
							this.log('[System 1.2] Bootstrapping (task type + checklist)...');
							wb.live.stage = 'bootstrap';
							wb.live.branch = 'System';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							wb.live.lastSummaryFeedback = '';
							wb.live.lastRawFeedback = '';
							this.refreshWhiteboardUI();

							if (!s.taskType) {
								s.taskType = await this.classifyTaskType(query);
								wb.aggregate.taskType = s.taskType;
							}
							if (!wb.aggregate.finalChecklist) {
								wb.aggregate.finalChecklist = await getChecklistForObjective(query);
							}
							s.stage = 'route';

						} else if (s.stage === 'route') {
							const phaseLabel = s.proofCycles === 0 ? 'INIT' : `POST_PROOF_${s.proofCycles}`;
							this.log(`[System 1.2] Routing (${phaseLabel})...`);
							wb.live.stage = 'route';
							wb.live.branch = 'Router';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							this.refreshWhiteboardUI();

							const decision = await this.routeProblemV11(query, this.renderWhiteboardMarkdownV11(), phaseLabel);
							s.lastRouteDecision = decision;
							wb.routerHistory.push({ phase: phaseLabel, ...decision, decidedBy: 'router' });

							if (decision.route === 'DIRECT') {
								s.stage = 'solution';
							} else if (decision.route === 'PROOF_THEN_SOLUTION') {
								s.pendingSubproblem = decision.subproblem;
								s.pendingSubproblemDecidedBy = 'router';
								s.stage = 'proof';
							} else {
								s.pendingSubproblem = '';
								s.pendingSubproblemDecidedBy = '';
								s.stage = 'subproblem_vote';
							}

						} else if (s.stage === 'subproblem_vote') {
							if (s.proofCycles >= MAX_PROOF_CYCLES) {
								this.log(`[System 1.2] Max proof cycles reached (${MAX_PROOF_CYCLES}); proceeding to solution.`);
								s.stage = 'solution';
								continue;
							}

							this.log(`[System 1.2] Selecting subproblem via vote...`);
							wb.live.stage = 'subproblem_vote';
							wb.live.branch = 'Router';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							this.refreshWhiteboardUI();

							const vote = await this.runSubproblemVoteV11(query, this.renderWhiteboardMarkdownV11());
							s.pendingSubproblem = vote.subproblem;
							s.pendingSubproblemDecidedBy = `vote(${vote.choice})`;
							wb.routerHistory.push({
								phase: `SUBPROBLEM_VOTE_${s.proofCycles + 1}`,
								route: 'PROOF_THEN_SOLUTION',
								rationale: `Chosen by vote (${vote.choice}).`,
								subproblem: vote.subproblem,
								decidedBy: 'vote'
							});
							s.stage = 'proof';

						} else if (s.stage === 'proof') {
							if (s.proofCycles >= MAX_PROOF_CYCLES) {
								this.log(`[System 1.2] Max proof cycles reached (${MAX_PROOF_CYCLES}); proceeding to solution.`);
								s.stage = 'solution';
								continue;
							}

							const subproblem = (s.pendingSubproblem || '').trim();
							if (!subproblem) throw new Error(`[Proof] No subproblem available (router/vote produced empty).`);

							this.log(`[Proof] Starting proof cycle #${s.proofCycles + 1}...`);

							// Fresh memory for this proof cycle; only preserved SAFE items are carried forward.
							this.state.globalMemory = [];

							const proofChecklist = await getChecklistForObjective(subproblem);
							const proofQuery = this.buildProofBranchPrompt(query, subproblem);
							const proofRes = await this.runIOO_RT2_Checklist_v12(
								'Proof',
								proofQuery,
								subproblem,
								`[Original Problem]\n${query}`,
								{ enableTrial: false, checklistBlock: proofChecklist, taskType: s.taskType }
							);

							const proofSolution = proofRes.solution;
							const candidateMemories = this.normalizeMemories(this.state.globalMemory, 30);

							this.log('[Proof] Extracting reusable conclusion...');
							const conclusion = await this.extractProofConclusion(query, subproblem, proofSolution);

							this.log('[Proof] Memory gate (principles): quorum + quarantine...');
							const memGate = await this.memoryPreservationGateV12(query, subproblem, candidateMemories);

							const keepWm = (proofRes.successfulRunWorkingMemoryEntries || [])
								.filter(e => e && e.type === 'KEEP')
								.map(e => {
									const st = this.extractLabeledLine(e.body, 'Statement') || '';
									const ev = this.extractLabeledLine(e.body, 'Evidence') || '';
									return `Statement: ${st} | Evidence: ${ev}`.trim();
								})
								.filter(Boolean);
							this.log('[Proof] Memory gate (working memory): quorum + quarantine...');
							const wmGate = await this.memoryPreservationGateV12(query, subproblem, keepWm);

							wb.proofs.push({
								subproblem,
								decidedBy: s.pendingSubproblemDecidedBy || 'router',
								checklist: proofChecklist,
								conclusion,
								preservedMemories: memGate.safe,
								quarantinedMemories: memGate.quarantined,
								preservedWorkingMemories: wmGate.safe,
								quarantinedWorkingMemories: wmGate.quarantined,
							});

							wb.aggregate.conclusions = this.normalizeMemories([...(wb.aggregate.conclusions || []), conclusion].filter(Boolean), 20);
							wb.aggregate.preservedMemories = this.normalizeMemories([...(wb.aggregate.preservedMemories || []), ...memGate.safe], 50);
							wb.aggregate.quarantinedMemories = this.normalizeMemories([...(wb.aggregate.quarantinedMemories || []), ...memGate.quarantined], 50);
							wb.aggregate.preservedWorkingMemories = this.normalizeMemories([...(wb.aggregate.preservedWorkingMemories || []), ...wmGate.safe], 50);
							wb.aggregate.quarantinedWorkingMemories = this.normalizeMemories([...(wb.aggregate.quarantinedWorkingMemories || []), ...wmGate.quarantined], 50);

							// Carry forward SAFE memories only.
							this.state.globalMemory = [...(wb.aggregate.preservedMemories || [])];

							s.proofCycles += 1;
							s.pendingSubproblem = '';
							s.pendingSubproblemDecidedBy = '';
							s.stage = 'route';

						} else if (s.stage === 'solution') {
							this.log(`[Solution] Running solution branch...`);
							wb.live.stage = 'solution';
							wb.live.branch = 'Solution';
							wb.live.runIdx = 0;
							wb.live.methodology = '';
							wb.live.workingMemory = [];
							this.refreshWhiteboardUI();

							const solQuery = this.buildSolutionBranchPromptV12(
								query,
								wb.aggregate.conclusions || [],
								wb.aggregate.preservedMemories || [],
								wb.aggregate.quarantinedMemories || [],
								wb.aggregate.preservedWorkingMemories || [],
								wb.aggregate.quarantinedWorkingMemories || []
							);

							// Seed cross-run memory with SAFE preserved memories only.
							this.state.globalMemory = [...(wb.aggregate.preservedMemories || [])];

							const solChecklist = wb.aggregate.finalChecklist || await getChecklistForObjective(query);
							const solRes = await this.runIOO_RT2_Checklist_v12(
								'Solution',
								solQuery,
								query,
								solQuery,
								{ enableTrial: true, checklistBlock: solChecklist, taskType: s.taskType }
							);

							wb.solution.methodHistory = solRes.methodHistory || [];
							wb.solution.finalSolution = solRes.solution || '';
							wb.solution.trial = solRes.trial || null;
							s.stage = 'complete';
						} else {
							throw new Error(`Unknown system-1.2 stage: ${s.stage}`);
						}

						this.refreshWhiteboardUI();
						saveToLocalStorage();
					}

					this.state.status = 'Success';
					this.state.finalResult = wb.solution?.finalSolution || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
					return;

				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			getAgentPyStep1Prompt() {
				return `### Core Instructions ###

*   **Rigor is Paramount:** Your primary goal is to produce a complete and rigorously justified solution. Every step in your solution must be logically sound and clearly explained. A correct final answer derived from flawed or incomplete reasoning is considered a failure.
*   **Honesty About Completeness:** If you cannot find a complete solution, you must **not** guess or create a solution that appears correct but contains hidden flaws or justification gaps. Instead, you should present only significant partial results that you can rigorously prove. A partial result is considered significant if it represents a substantial advancement toward a full solution. Examples include:
    *   Proving a key lemma.
    *   Fully resolving one or more cases within a logically sound case-based proof.
    *   Establishing a critical property of the core objects/assumptions in the problem.
    *   For an optimization problem, proving an upper or lower bound without proving that this bound is achievable.
*   **Math formatting (when relevant):** If you use mathematical variables, expressions, or relations, enclose them in TeX delimiters (e.g., \`Let $n$ be an integer.\`).

### Output Format ###

Your response MUST be structured into the following sections, in this exact order.

**1. Summary**

Provide a concise overview of your findings. This section must contain two parts:

*   **a. Verdict:** State clearly whether you have found a complete solution or a partial solution.
    *   **For a complete solution:** State the final answer, e.g., "I have successfully solved the problem. The final answer is..."
    *   **For a partial solution:** State the main rigorous conclusion(s) you were able to prove, e.g., "I have not found a complete solution, but I have rigorously proven that..."
*   **b. Method Sketch:** Present a high-level, conceptual outline of your solution. This sketch should allow an expert to understand the logical flow of your argument without reading the full detail. It should include:
    *   A narrative of your overall strategy.
    *   The full and precise statements of any key lemmas or major intermediate results (mathematical when relevant).
    *   If applicable, describe any key constructions or case splits that form the backbone of your argument.

**2. Detailed Solution**

Present the full, step-by-step solution/argument. Each step must be logically justified and clearly explained. The level of detail should be sufficient for an expert to verify the correctness of your reasoning without needing to fill in any gaps. This section must contain ONLY the complete, rigorous solution/argument, free of any internal commentary, alternative approaches, or failed attempts.

### Self-Correction Instruction ###

Before finalizing your output, carefully review your "Method Sketch" and "Detailed Solution" to ensure they are clean, rigorous, and strictly adhere to all instructions provided above. Verify that every statement contributes directly to the final, coherent logical argument.`;
			}

			getAgentPySelfImprovementPrompt() {
				return `You have an opportunity to improve your solution. Please review your solution carefully. Correct errors and fill justification gaps if any. Your second round of output should strictly follow the instructions in the system prompt.`;
			}

			getAgentPyCorrectionPrompt() {
				return `Below is the bug report. If you agree with certain item in it, can you improve your solution so that it is complete and rigorous? Note that the evaluator who generates the bug report can misunderstand your solution and thus make mistakes. If you do not agree with certain item in the bug report, please add some detailed explanations to avoid such misunderstanding. Your new solution should strictly follow the instructions in the system prompt.`;
			}

			getAgentPyVerificationSystemPrompt() {
				return `You are an expert verifier and a meticulous grader for an expert-level exam in the relevant domain. Your primary task is to rigorously verify the provided solution. A solution is to be judged correct **only if every step is rigorously justified.** A solution that arrives at a correct final answer through flawed reasoning, educated guesses, or with gaps in its arguments must be flagged as incorrect or incomplete.

### Instructions ###

**1. Core Instructions**
*   Your sole task is to find and report all issues in the provided solution. You must act as a **verifier**, NOT a solver. **Do NOT attempt to correct the errors or fill the gaps you find.**
*   You must perform a **step-by-step** check of the entire solution. This analysis will be presented in a **Detailed Verification Log**, where you justify your assessment of each step: for correct steps, a brief justification suffices; for steps with errors or gaps, you must provide a detailed explanation.

**2. How to Handle Issues in the Solution**
When you identify an issue in a step, you MUST first classify it into one of the following two categories and then follow the specified procedure.

*   **a. Critical Error:**
    This is any error that breaks the logical chain of the proof. This includes both **logical fallacies** (e.g., claiming that \`A>B, C>D\` implies \`A-C>B-D\`) and **factual errors** (e.g., a calculation error like \`2+3=6\`).
    *   **Procedure:**
        *   Explain the specific error and state that it **invalidates the current line of reasoning**.
        *   Do NOT check any further steps that rely on this error.
        *   You MUST, however, scan the rest of the solution to identify and verify any fully independent parts. For example, if a proof is split into multiple cases, an error in one case does not prevent you from checking the other cases.

*   **b. Justification Gap:**
    This is for steps where the conclusion may be correct, but the provided argument is incomplete, hand-wavy, or lacks sufficient rigor.
    *   **Procedure:**
        *   Explain the gap in the justification.
        *   State that you will **assume the step's conclusion is true** for the sake of argument.
        *   Then, proceed to verify all subsequent steps to check if the remainder of the argument is sound.

**3. Output Format**
Your response MUST be structured into two main sections: a **Summary** followed by the **Detailed Verification Log**.

*   **a. Summary**
    This section MUST be at the very beginning of your response. It must contain two components:
    *   **Final Verdict**: A single, clear sentence declaring the overall validity of the solution. For example: "The solution is correct," "The solution contains a Critical Error and is therefore invalid," or "The solution's approach is viable but contains several Justification Gaps."
    *   **List of Findings**: A bulleted list that summarizes **every** issue you discovered. For each finding, you must provide:
        *   **Location:** A direct quote of the key phrase or equation where the issue occurs.
        *   **Issue:** A brief description of the problem and its classification (**Critical Error** or **Justification Gap**).

*   **b. Detailed Verification Log**
    Following the summary, provide the full, step-by-step verification log as defined in the Core Instructions. When you refer to a specific part of the solution, **quote the relevant text** to make your reference clear before providing your detailed analysis of that part.

**Example of the Required Summary Format**
*This is a generic example to illustrate the required format. Your findings must be based on the actual solution provided below.*

**Final Verdict:** The solution is **invalid** because it contains a Critical Error.

**List of Findings:**
*   **Location:** "By interchanging the limit and the integral, we get..."
    *   **Issue:** Justification Gap - The solution interchanges a limit and an integral without providing justification, such as proving uniform convergence.
*   **Location:** "From $A > B$ and $C > D$, it follows that $A-C > B-D$"
    *   **Issue:** Critical Error - This step is a logical fallacy. Subtracting inequalities in this manner is not a valid mathematical operation.`;
			}

			getAgentPyVerificationReminder() {
				return `### Verification Task Reminder ###

Your task is to act as a meticulous verifier. Now, generate the **summary** and the **step-by-step verification log** for the solution above. In your log, justify each correct step and explain in detail any errors or justification gaps you find, as specified in the instructions above.`;
			}

			extractAgentPyByMarker(text, marker, after = true) {
				const s = (text || '').toString();
				const m = (marker || '').toString();
				const idx = s.indexOf(m);
				if (idx === -1) return '';
				return after ? s.slice(idx + m.length).trim() : s.slice(0, idx).trim();
			}

			async agentPyInitExplorations(problemStatement) {
				const sys = this.getAgentPyStep1Prompt();
				this.log('[test20] Initial prompt...');
				const first = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement }
					],
					null,
					{ temperature: 0.1 }
				);

				this.log('[test20] Self-improvement...');
				const solution = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: first },
						{ role: 'user', content: this.getAgentPySelfImprovementPrompt() }
					],
					null,
					{ temperature: 0.1 }
				);

				const verify = await this.agentPyVerifySolution(problemStatement, solution);
				return { solution, verify };
			}

			async agentPyVerifySolution(problemStatement, solutionText) {
				const dsol = this.extractAgentPyByMarker(solutionText, 'Detailed Solution', true);
				const verificationInput = `
======================================================================
### Problem ###

${problemStatement}

======================================================================
### Solution ###

${dsol}

${this.getAgentPyVerificationReminder()}
`.trim();

				this.log('[test20] Verifying...');
				const verificationOut = await this.callAPI(
					[
						{ role: 'system', content: this.getAgentPyVerificationSystemPrompt() },
						{ role: 'user', content: verificationInput }
					],
					null,
					{ temperature: 0.1 }
				);

				const checkCorrectness = `Response in exactly "yes" or "no". No other words. Is the following statement saying the solution is correct, or does not contain critical error or a major justification gap?\n\n${verificationOut}`.trim();
				const validateYesNo = (txt) => {
					const t = (txt || '').toString().trim().toLowerCase();
					if (t === 'yes' || t === 'no') return true;
					return `Expected exactly \"yes\" or \"no\", got: ${t.slice(0, 40) || '[empty]'}`;
				};
				const yesNo = await this.callAPI(
					[{ role: 'user', content: checkCorrectness }],
					validateYesNo,
					{ temperature: 0.0 }
				);

				const good = (yesNo || '').toString().trim().toLowerCase() === 'yes';
				const bugReport = good
					? ''
					: (this.extractAgentPyByMarker(verificationOut, 'Detailed Verification', false) || verificationOut || '');

				return { verificationOut, yesNo, good, bugReport };
			}

			async agentPyCorrectSolution(problemStatement, solutionText, bugReport) {
				const sys = this.getAgentPyStep1Prompt();
				const user = `${this.getAgentPyCorrectionPrompt()}\n\n${(bugReport || '').toString().trim()}`.trim();
				this.log('[test20] Correcting...');
				return await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: solutionText },
						{ role: 'user', content: user }
					],
					null,
					{ temperature: 0.1 }
				);
			}

			async runTest20Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_RUNS = 10;
				const MAX_ITERS = 30;

				try {
					for (let runIdx = this.state.runIdx; runIdx <= MAX_RUNS; runIdx++) {
						this.state.runIdx = runIdx;
						this.log(`=== Run ${runIdx}/${MAX_RUNS} (test20 / agent.py) ===`);

						const init = await this.agentPyInitExplorations(query);
						let solution = init.solution || '';
						let verify = init.verify || { good: false, bugReport: '' };

						let correctCount = 1;
						let errorCount = 0;

						for (let iter = 0; iter < MAX_ITERS; iter++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test20] Iter ${iter}: correct=${correctCount}, errors=${errorCount}, verify=${verify.good ? 'yes' : 'no'}`);

							if (!verify.good) {
								correctCount = 0;
								errorCount += 1;
								solution = await this.agentPyCorrectSolution(query, solution, verify.bugReport || '');
							}

							verify = await this.agentPyVerifySolution(query, solution);
							if (verify.good) {
								correctCount += 1;
								errorCount = 0;
							}

							if (correctCount >= 5) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
											this.updateStatusUI('Success', 'var(--log-success)');
											const resEl = document.getElementById(`result-area-${this.uniqueId}`);
											if (resEl) resEl.value = this.state.finalResult;
											try { saveToLocalStorage(); } catch { }
										this.stopTimer();
										return;
									}
							if (errorCount >= 10) {
								this.log(`[test20] Run failed (error_count >= 10). Next run...`);
								break;
							}
						}
					}

					this.state.status = 'Failed';
					this.updateStatusUI('Failed (Max Runs)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			getTest21Step1PromptXML() {
				return `
### Core Instructions ###

*   **Rigor is Paramount:** Your primary goal is to produce a complete and rigorously justified solution. Every step in your solution must be logically sound and clearly explained. A correct final answer derived from flawed or incomplete reasoning is considered a failure.
*   **Honesty About Completeness:** If you cannot find a complete solution, you must **not** guess or create a solution that appears correct but contains hidden flaws or justification gaps. Instead, you should present only significant partial results that you can rigorously prove.
*   **Math formatting (when relevant):** If you use mathematical variables, expressions, or relations, enclose them in TeX delimiters (e.g., \`Let $n$ be an integer.\`).

### Output Format ###
Your response MUST be structured into the following sections, in this exact order:

**1. Summary**
Provide:
* Verdict (complete / partial)
* Method Sketch (high-level outline)

**2. Detailed Solution**
Present the full, step-by-step rigorous proof/solution.

### Self-Correction Instruction ###
Before finalizing, review your output for rigor and completeness.

WRAP THE ENTIRE RESPONSE IN A SINGLE XML ROOT: <solution> ... </solution>
Do not include any content outside the <solution> root.`.trim();
			}

			getTest21SelfImprovementPromptXML() {
				return `You have an opportunity to improve your solution. Please review your solution carefully. Correct errors and fill justification gaps if any. Your second round of output should strictly follow the instructions in the system prompt. Re-output only as <solution>...</solution>.`;
			}

			getTest21CorrectionPromptXML(bugReport) {
				return `
Below is the bug report. If you agree with certain items, improve your solution so it is complete and rigorous. The evaluator can misunderstand; if you disagree, add clarifications to avoid misunderstanding. Your new solution must strictly follow the system instructions. Re-output only as <solution>...</solution>.

Bug Report:
${(bugReport || '').toString().trim()}`.trim();
			}

			getTest21VerificationSystemPromptXML() {
				return `
You are an expert verifier and a meticulous grader for an expert-level exam in the relevant domain. Verify rigor; do not fix the solution.

Instructions:
1) Act strictly as a verifier. Provide a Summary (Final Verdict + List of Findings) and then a Detailed Verification Log.
2) Classify issues as Critical Error or Justification Gap and follow the appropriate procedure.

Wrap your entire response in <verification> ... </verification> and do not add text outside this root.`.trim();
			}

			getTest21VerificationReminder() {
				return `### Verification Task Reminder ###

Your task is to act as a meticulous verifier. Now, generate the **summary** and the **step-by-step verification log** for the solution above as specified.`;
			}

			getTest21CheckCorrectnessPromptXML(verificationXml) {
				return `
Is the following statement saying the solution is correct, or does not contain a critical error or a major justification gap?

${verificationXml}

Respond strictly as one of:
<decision>yes</decision>
or
<decision>no</decision>`.trim();
			}

			test21ExtractUntilMarker(text, marker) {
				const s = (text || '').toString();
				const m = (marker || '').toString();
				const idx = s.indexOf(m);
				if (idx === -1) return s.trim();
				return s.slice(0, idx).trim();
			}

			test21ExtractDetailedFromSolution(solutionXml) {
				const inner = this.extractTag(solutionXml || '', 'solution') || (solutionXml || '');
				const marker = 'Detailed Solution';
				const idx = inner.indexOf(marker);
				if (idx === -1) return inner.trim();
				return inner.slice(idx + marker.length).trim();
			}

			validateTest21SolutionXml(text) {
				const t = (text || '').toString().trim();
				if (!this.hasTagBlock(t, 'solution')) return 'Missing <solution>...</solution>';
				if (this.countTagBlocks(t, 'solution') !== 1) return 'Must contain exactly one <solution>...</solution> root';
				if (!/^\s*<solution>[\s\S]*<\/solution>\s*$/i.test(t)) return 'Output must be ONLY the <solution>...</solution> block';
				return true;
			}

			validateTest21VerificationXml(text) {
				const t = (text || '').toString().trim();
				if (!this.hasTagBlock(t, 'verification')) return 'Missing <verification>...</verification>';
				if (this.countTagBlocks(t, 'verification') !== 1) return 'Must contain exactly one <verification>...</verification> root';
				if (!/^\s*<verification>[\s\S]*<\/verification>\s*$/i.test(t)) return 'Output must be ONLY the <verification>...</verification> block';
				return true;
			}

			validateTest21DecisionXml(text) {
				const t = (text || '').toString().trim();
				if (!this.hasTagBlock(t, 'decision')) return 'Missing <decision>...</decision>';
				if (this.countTagBlocks(t, 'decision') !== 1) return 'Must contain exactly one <decision>...</decision> block';
				if (!/^\s*<decision>[\s\S]*<\/decision>\s*$/i.test(t)) return 'Output must be ONLY the <decision>...</decision> block';
				const v = (this.extractTag(t, 'decision') || '').trim().toLowerCase();
				if (v !== 'yes' && v !== 'no') return `Decision must be yes/no, got: ${v || 'EMPTY'}`;
				return true;
			}

			async test21VerifyMathSolution(problemStatement, solutionXml) {
				const dsol = this.test21ExtractDetailedFromSolution(solutionXml);
				const verificationInput = `
======================================================================
### Problem ###

${problemStatement}

======================================================================
### Solution ###

${dsol}

${this.getTest21VerificationReminder()}
`.trim();

				this.log('[test21] Verifying...');
				const verificationXml = await this.callAPI(
					[
						{ role: 'system', content: this.getTest21VerificationSystemPromptXML() },
						{ role: 'user', content: verificationInput }
					],
					(txt) => this.validateTest21VerificationXml(txt),
					{ temperature: 0.1 }
				);

				const decisionPrompt = this.getTest21CheckCorrectnessPromptXML(verificationXml);
				const decisionXml = await this.callAPI(
					[{ role: 'user', content: decisionPrompt }],
					(txt) => this.validateTest21DecisionXml(txt),
					{ temperature: 0.0 }
				);

				const decision = (this.extractTag(decisionXml, 'decision') || '').trim().toLowerCase();
				const isGood = decision === 'yes';
				const bugReport = isGood ? '' : this.test21ExtractUntilMarker(verificationXml, 'Detailed Verification');

				return { isGood, bugReport, fullVerification: verificationXml, decisionXml };
			}

			async test21InitExplorations(problemStatement) {
				const sys = this.getTest21Step1PromptXML();

				this.log('[test21] Initial prompt...');
				const first = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement }
					],
					(txt) => this.validateTest21SolutionXml(txt),
					{ temperature: 0.1 }
				);

				this.log('[test21] Self-improvement...');
				const solution = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: first },
						{ role: 'user', content: this.getTest21SelfImprovementPromptXML() }
					],
					(txt) => this.validateTest21SolutionXml(txt),
					{ temperature: 0.1 }
				);

				const verify = await this.test21VerifyMathSolution(problemStatement, solution);
				return { solution, verify };
			}

			async test21CorrectSolution(problemStatement, solutionXml, bugReport) {
				const sys = this.getTest21Step1PromptXML();
				this.log('[test21] Correcting...');
				return await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: solutionXml },
						{ role: 'user', content: this.getTest21CorrectionPromptXML(bugReport) }
					],
					(txt) => this.validateTest21SolutionXml(txt),
					{ temperature: 0.1 }
				);
			}

			async runTest21Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ROUNDS = 10;
				const REDTEAM_CALL_BUDGET_PER_ROUND = 10;
				const FAIL_STREAK_LIMIT = 10;
				const PASS_STREAK_TARGET = 5;
				const ITER_HARD_CAP = 200;

				let lastSolution = '';

				try {
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`=== Round ${round}/${MAX_ROUNDS} (test21 / ÎàÑ2 Arch9 XML) ===`);

						const init = await this.test21InitExplorations(query);
						let solution = init.solution || '';
						lastSolution = solution;
						let verification = init.verify || { isGood: false, bugReport: '' };
						let redTeamCallsUsed = 1; // test21InitExplorations() runs exactly one red-team verification pass

						let passStreak = verification.isGood ? 1 : 0;
						let failStreak = verification.isGood ? 0 : 1;

						for (let iter = 0; iter < ITER_HARD_CAP; iter++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test21] Iter ${iter}: pass=${passStreak}/${PASS_STREAK_TARGET}, failStreak=${failStreak}/${FAIL_STREAK_LIMIT}, redteam=${redTeamCallsUsed}/${REDTEAM_CALL_BUDGET_PER_ROUND}`);

							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}

							if (failStreak >= FAIL_STREAK_LIMIT) {
								this.log(`[test21] Round ended (fail-streak ${FAIL_STREAK_LIMIT}).`);
								break;
							}

							if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
								this.log(`[test21] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
								break;
							}

							if (!verification.isGood) {
								solution = await this.test21CorrectSolution(query, solution, verification.bugReport || '');
								lastSolution = solution;
							}

							if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
								this.log(`[test21] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
								break;
							}

							verification = await this.test21VerifyMathSolution(query, solution);
							redTeamCallsUsed += 1;
							if (verification.isGood) {
								passStreak += 1;
								failStreak = 0;
							} else {
								passStreak = 0;
								failStreak += 1;
							}
						}
					}

					this.state.status = 'Failed';
					this.state.finalResult = lastSolution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl && this.state.finalResult) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async test40IcrSolveSolution(problemStatement, state = {}, label = 'test40', opts = {}) {
				const sys = this.getTest21Step1PromptXML();
				const ITERATIONS = (() => {
					const n = parseInt(opts?.iterations ?? '3', 10);
					if (!Number.isFinite(n)) return 3;
					return Math.max(0, Math.min(10, n));
				})();
				const solveTemperature = Number.isFinite(opts?.temperature)
					? Math.max(0, Math.min(1, opts.temperature))
					: 0.1;

				let memory = (state?.memory || '').toString();
				const bugReport = (state?.bugReport || '').toString().trim();
				const prevSolution = (state?.solutionXml || '').toString().trim();
				const seedText = (state?.seedText || '').toString().trim();

				const solutionValidator = (txt) => this.validateTest21SolutionXml(txt);

				const buildSuggestionsUser = (currentSolution) => {
					const parts = [];
					parts.push(`User request:\n${problemStatement}`);
					parts.push(`Memory summary (may be empty):\n${memory || '(none)'}`);
					if (bugReport) parts.push(`Bug report to fix:\n${bugReport}`);
					parts.push(`Current solution:\n${currentSolution || '(empty)'}`);
					parts.push(`Provide concrete suggestions to improve rigor/correctness and fix any reported issues. Do NOT output the final solution.`);
					return parts.join('\n\n');
				};

				const buildReviseUser = (suggestions) => {
					const parts = [];
					parts.push(`Memory summary (may be empty):\n${memory || '(none)'}`);
					if (bugReport) parts.push(`Bug report to fix:\n${bugReport}`);
					parts.push(`Suggestions:\n${suggestions || '(none)'}`);
					parts.push(`Revise the solution accordingly. Output ONLY <solution>...</solution> and nothing else.`);
					return parts.join('\n\n');
				};

				const buildMemoryUser = (currentSolution) => {
					const parts = [];
					parts.push(`User request:\n${problemStatement}`);
					if (bugReport) parts.push(`Bug report:\n${bugReport}`);
					parts.push(`Current solution:\n${currentSolution || '(empty)'}`);
					parts.push(`Previous memory:\n${memory || '(none)'}`);
					parts.push(`Return updated memory summary as max 8 bullets. Keep only persistent constraints, key decisions, and critical pitfalls to avoid.`);
					return parts.join('\n\n');
				};

				let solution = '';
				if (prevSolution && bugReport) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR solver: apply bug report`);
					solution = await this.callAPI(
						[
							{ role: 'system', content: sys },
							{ role: 'user', content: problemStatement },
							{ role: 'assistant', content: prevSolution },
							{ role: 'user', content: `${this.getTest21CorrectionPromptXML(bugReport)}\n\nMemory summary:\n${memory || '(none)'}` },
						],
						solutionValidator,
						{ temperature: solveTemperature }
					);
				} else {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR solver: initial solve`);
					const seededPrompt = seedText
						? `User request:\n${problemStatement}\n\nSeed draft (may be imperfect):\n${seedText}\n\nConvert the seed into a correct, rigorous final solution in the required <solution> XML format.`
						: problemStatement;
					solution = await this.callAPI(
						[
							{ role: 'system', content: sys },
							{ role: 'user', content: seededPrompt },
						],
						solutionValidator,
						{ temperature: solveTemperature }
					);
				}

				for (let i = 1; i <= ITERATIONS; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR Iteration ${i}/${ITERATIONS}: iterative agent suggestions`);
					const suggestions = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Iterative Agent. Suggest improvements and corrections. Be concrete and rigorous.' },
							{ role: 'user', content: buildSuggestionsUser(solution) },
						],
						null,
						{ temperature: 0.2 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR Iteration ${i}/${ITERATIONS}: main generator revises solution`);
					solution = await this.callAPI(
						[
							{ role: 'system', content: sys },
							{ role: 'user', content: problemStatement },
							{ role: 'assistant', content: solution },
							{ role: 'user', content: buildReviseUser(suggestions) },
						],
						solutionValidator,
						{ temperature: solveTemperature }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR Iteration ${i}/${ITERATIONS}: memory agent update`);
					memory = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Memory Agent. Compress the current state into a short memory summary (max 8 bullets).' },
							{ role: 'user', content: buildMemoryUser(solution) },
						],
						null,
						{ temperature: 0.2 }
					);
				}

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR solver: self-improvement`);
				solution = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: solution },
						{ role: 'user', content: `${this.getTest21SelfImprovementPromptXML()}\n\nMemory summary:\n${memory || '(none)'}` },
					],
					solutionValidator,
					{ temperature: solveTemperature }
				);

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR solver: memory agent update (post SI)`);
				memory = await this.callAPI(
					[
						{ role: 'system', content: 'You are the Memory Agent. Compress the current state into a short memory summary (max 8 bullets).' },
						{ role: 'user', content: buildMemoryUser(solution) },
					],
					null,
					{ temperature: 0.2 }
				);

				return { solution, memory };
			}

			test21CoerceFreeformToSolutionXml(draftText) {
				const raw = String(draftText || '').trim();
				const stripped = raw.replace(/<\s*\/?\s*solution\b[^>]*>/gi, '').trim();
				const xml = `<solution>\n${stripped}\n</solution>`;
				const ok = this.validateTest21SolutionXml(xml);
				if (ok === true) return xml;
				const stripped2 = raw
					.replace(/<\s*\/?\s*solution\b[^>]*>/gi, '')
					.replace(/<\/?\s*solution\s*>/gi, '')
					.trim();
				return `<solution>\n${stripped2}\n</solution>`;
			}

			async test48SolveOnceSolutionXml(problemStatement, options = {}) {
				const sys = this.getTest21Step1PromptXML();
				const solveTemperature = Number.isFinite(options?.temperature)
					? Math.max(0, Math.min(1, options.temperature))
					: 0.2;
				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				return await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: (problemStatement || '').toString() }
					],
					(txt) => this.validateTest21SolutionXml(txt),
					{ temperature: solveTemperature }
				);
			}

				async test48CorrectOnceSolutionXml(problemStatement, prevSolutionXml, bugReport, memorySummary = '', options = {}) {
					const sys = this.getTest21Step1PromptXML();
					const solveTemperature = Number.isFinite(options?.temperature)
						? Math.max(0, Math.min(1, options.temperature))
						: 0.2;
				const mem = (memorySummary || '').toString().trim();
				const corrUser = `${this.getTest21CorrectionPromptXML(bugReport)}\n\nMemory summary:\n${mem || '(none)'}`;
				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				return await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: (problemStatement || '').toString() },
						{ role: 'assistant', content: (prevSolutionXml || '').toString() },
						{ role: 'user', content: corrUser },
					],
					(txt) => this.validateTest21SolutionXml(txt),
						{ temperature: solveTemperature }
					);
				}

				async testSoTCouncilSolveSolutionXml(problemStatement, options = {}) {
					const k = Math.max(2, Math.min(6, parseInt(options?.k ?? '3', 10) || 3));
					const lite = !!options?.lite;
					const critique = !!options?.critique;
					const markers = !!options?.markers;
					const baseTemp = Number.isFinite(options?.temperature)
						? Math.max(0, Math.min(1, options.temperature))
						: 0.35;
					const sysBase = this.getTest21Step1PromptXML();
					const validator = (txt) => this.validateTest21SolutionXml(txt);
					const markerInst = markers
						? `Discourse-marker rule: when you doubt a step, start the sentence with "Wait," or "But," (or Korean: "Ïû†Íπê", "ÌïòÏßÄÎßå") and re-check. Use this at least twice.`
						: '';
					const draftStyle = lite
						? `Write a SHORT but logically complete solution outline. Prefer 8‚Äì14 bullets and minimal algebra. Still output <solution>...</solution> with a clear final answer.`
						: `Write a full rigorous solution. Still output <solution>...</solution> with a clear final answer.`;
					const MAX_DRAFT_CHARS = 9000;
					const clip = (s) => {
						const t = String(s || '');
						return t.length <= MAX_DRAFT_CHARS ? t : `${t.slice(0, MAX_DRAFT_CHARS)}\n\n[...TRUNCATED...]`;
					};
					const roles = [
						{
							name: 'Methodical Analyst',
							temperature: Math.max(0.12, Math.min(0.35, baseTemp - 0.10)),
							instruction: `Be skeptical and precise. Prioritize definitions, invariants, and edge cases. Do not assume the intended answer; derive it.`,
						},
						{
							name: 'Creative Strategist',
							temperature: Math.max(0.25, Math.min(0.85, baseTemp + 0.25)),
							instruction: `Propose a materially different approach than standard. Use alternative viewpoints (symmetry, bounding, probabilistic method, construction, etc.).`,
						},
							{
								name: "Devil's Advocate",
								temperature: Math.max(0.20, Math.min(0.80, baseTemp + 0.10)),
								instruction: `Assume the first idea is wrong. Try to find the most plausible way the common answer could be false. If you can, produce a counterexample or a missing-justification critique, then propose a corrected path.`,
							},
						{
							name: 'Formalist',
							temperature: Math.max(0.10, Math.min(0.30, baseTemp - 0.15)),
							instruction: `Obsess over quantifiers, hidden assumptions, and proof gaps. If something is not proven, call it out and patch it.`,
						},
						{
							name: 'Counterexample Hunter',
							temperature: Math.max(0.20, Math.min(0.70, baseTemp + 0.05)),
							instruction: `Try extreme cases and adversarial interpretations. If the problem is multiple-choice, test each option mentally for consistency.`,
						},
					].slice(0, k);
					const drafts = [];
					for (const role of roles) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const sys = `${sysBase}\n\n[SOCIETY OF THOUGHT ‚Äî ROLE]\nYou are: ${role.name}.\n${role.instruction}\n${markerInst}\n\n${draftStyle}`.trim();
						const sol = await this.callAPI(
							[
								{ role: 'system', content: sys },
								{ role: 'user', content: String(problemStatement || '') },
							],
							validator,
							{ temperature: role.temperature }
						);
						drafts.push({ name: role.name, solution: sol });
					}
					let conflictNotes = '';
					if (critique) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const sys = `You are an adversarial auditor. Extract real disagreements and likely failure points across drafts. Do not be polite.`;
						const user = `PROBLEM:\n${String(problemStatement || '')}\n\nDRAFTS:\n${drafts.map((d, i) => `#${i + 1} (${d.name}):\n${clip(d.solution)}`).join('\n\n')}\n\nOutput 4‚Äì8 bullets:\n- conflicts (where drafts disagree)\n- potential fatal gaps\n- what must be checked to be sure`;
						conflictNotes = await this.callAPI(
							[{ role: 'system', content: sys }, { role: 'user', content: user }],
							null,
							{ temperature: 0.2 }
						);
						conflictNotes = (conflictNotes || '').toString().trim();
					}
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const sysMed = `${sysBase}\n\n[SOCIETY OF THOUGHT ‚Äî MEDIATOR]\nYou must reconcile the drafts into ONE best solution.\nRules:\n- Do not assume the majority is right.\n- If there are conflicts, resolve them explicitly.\n- If a step is uncertain, start with "Wait," or "But," and fix it.\n- Produce a single final <solution> with a clear final answer.\n${markerInst}`.trim();
					const userMed = `PROBLEM:\n${String(problemStatement || '')}\n\n${conflictNotes ? `CONFLICT NOTES:\n${conflictNotes}\n\n` : ''}DRAFTS:\n${drafts.map((d, i) => `#${i + 1} (${d.name}):\n${clip(d.solution)}`).join('\n\n')}\n\nNow produce the final reconciled solution.`;
					const finalSolution = await this.callAPI(
						[{ role: 'system', content: sysMed }, { role: 'user', content: userMed }],
						validator,
						{ temperature: 0.15 }
					);
					return { solution: finalSolution, drafts, conflictNotes };
				}

				async test40IcrSolveSolutionFreeform(problemStatement, state = {}, label = 'test40', opts = {}) {
					const sys = `You are an expert problem solver.

Write a rigorous, complete solution.

Output format:
1) Summary
2) Detailed Solution

Rules:
- Output plain text only (no XML/JSON/tags).
- Do not add meta commentary about being an AI.
- End with a clear final answer line.`;

				const ITERATIONS = (() => {
					const n = parseInt(opts?.iterations ?? '3', 10);
					if (!Number.isFinite(n)) return 3;
					return Math.max(0, Math.min(10, n));
				})();
				const solveTemperature = Number.isFinite(opts?.temperature)
					? Math.max(0, Math.min(1, opts.temperature))
					: 0.1;

				let memory = (state?.memory || '').toString();
				const bugReport = (state?.bugReport || '').toString().trim();
				const prevSolutionXml = (state?.solutionXml || '').toString().trim();
				const prevDraft = prevSolutionXml ? this.test21ExtractDetailedFromSolution(prevSolutionXml) : '';
				const seedText = (state?.seedText || '').toString().trim();

				const buildSuggestionsUser = (currentDraft) => {
					const parts = [];
					parts.push(`User request:\n${problemStatement}`);
					parts.push(`Memory summary (may be empty):\n${memory || '(none)'}`);
					if (bugReport) parts.push(`Bug report to fix:\n${bugReport}`);
					parts.push(`Current draft:\n${currentDraft || '(empty)'}`);
					parts.push(`Provide concrete suggestions to improve rigor/correctness and fix any reported issues. Do NOT output the revised solution.`);
					return parts.join('\n\n');
				};

				const buildReviseUser = (suggestions) => {
					const parts = [];
					parts.push(`Memory summary (may be empty):\n${memory || '(none)'}`);
					if (bugReport) parts.push(`Bug report to fix:\n${bugReport}`);
					parts.push(`Suggestions:\n${suggestions || '(none)'}`);
					parts.push(`Revise the solution accordingly. Output ONLY the revised full solution in plain text (no XML/JSON/tags).`);
					return parts.join('\n\n');
				};

				const buildMemoryUser = (currentDraft) => {
					const parts = [];
					parts.push(`User request:\n${problemStatement}`);
					if (bugReport) parts.push(`Bug report:\n${bugReport}`);
					parts.push(`Current draft:\n${currentDraft || '(empty)'}`);
					parts.push(`Previous memory:\n${memory || '(none)'}`);
					parts.push(`Return updated memory summary as max 8 bullets. Keep only persistent constraints, key decisions, and critical pitfalls to avoid.`);
					return parts.join('\n\n');
				};

				let draft = '';
				if (prevDraft && bugReport) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR solver (freeform): apply bug report`);
					const corrUser = [
						`Below is the bug report. If you agree with certain items, improve your solution so it is complete and rigorous. The evaluator can misunderstand; if you disagree, add clarifications to avoid misunderstanding.`,
						``,
						`Bug Report:`,
						bugReport,
						``,
						`Memory summary:`,
						memory || '(none)',
						``,
						`Output ONLY the revised full solution in plain text (no XML/JSON/tags).`
					].join('\n');
					draft = await this.callAPI(
						[
							{ role: 'system', content: sys },
							{ role: 'user', content: problemStatement },
							{ role: 'assistant', content: prevDraft },
							{ role: 'user', content: corrUser },
						],
						null,
						{ temperature: solveTemperature }
					);
				} else {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR solver (freeform): initial solve`);
					const seededPrompt = seedText
						? `User request:\n${problemStatement}\n\nMemory summary (may be empty):\n${memory || '(none)'}\n\nSeed draft (may be imperfect):\n${seedText}\n\nConvert the seed into a correct, rigorous final solution. Output plain text only.`
						: `User request:\n${problemStatement}\n\nMemory summary (may be empty):\n${memory || '(none)'}\n\nSolve the problem. Output plain text only.`;
					draft = await this.callAPI(
						[
							{ role: 'system', content: sys },
							{ role: 'user', content: seededPrompt },
						],
						null,
						{ temperature: solveTemperature }
					);
				}

				for (let i = 1; i <= ITERATIONS; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR Iteration ${i}/${ITERATIONS} (freeform): iterative agent suggestions`);
					const suggestions = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Iterative Agent. Suggest improvements and corrections. Be concrete and rigorous.' },
							{ role: 'user', content: buildSuggestionsUser(draft) },
						],
						null,
						{ temperature: 0.2 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR Iteration ${i}/${ITERATIONS} (freeform): main generator revises draft`);
					draft = await this.callAPI(
						[
							{ role: 'system', content: sys },
							{ role: 'user', content: problemStatement },
							{ role: 'assistant', content: draft },
							{ role: 'user', content: buildReviseUser(suggestions) },
						],
						null,
						{ temperature: solveTemperature }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[${label}] ICR Iteration ${i}/${ITERATIONS} (freeform): memory agent update`);
					memory = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Memory Agent. Compress the current state into a short memory summary (max 8 bullets).' },
							{ role: 'user', content: buildMemoryUser(draft) },
						],
						null,
						{ temperature: 0.2 }
					);
				}

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR solver (freeform): self-improvement`);
				const siUser = [
					`You have an opportunity to improve your solution. Please review your solution carefully. Correct errors and fill justification gaps if any.`,
					``,
					`Memory summary:`,
					memory || '(none)',
					``,
					`Output ONLY the revised full solution in plain text (no XML/JSON/tags).`
				].join('\n');
				draft = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: draft },
						{ role: 'user', content: siUser },
					],
					null,
					{ temperature: solveTemperature }
				);

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR solver (freeform): memory agent update (post SI)`);
				memory = await this.callAPI(
					[
						{ role: 'system', content: 'You are the Memory Agent. Compress the current state into a short memory summary (max 8 bullets).' },
						{ role: 'user', content: buildMemoryUser(draft) },
					],
					null,
					{ temperature: 0.2 }
				);

				const solution = this.test21CoerceFreeformToSolutionXml(draft);
				return { solution, memory, draft };
			}

			validateTest40RedTeamVerdictXml(text) {
				const t = (text || '').toString().trim();
				if (!this.hasTagBlock(t, 'redteam')) return 'Missing <redteam>...</redteam>';
				if (this.countTagBlocks(t, 'redteam') !== 1) return 'Must contain exactly one <redteam>...</redteam> root';
				if (!/^\s*<redteam>[\s\S]*<\/redteam>\s*$/i.test(t)) return 'Output must be ONLY the <redteam>...</redteam> block';

				const d = (this.extractTag(t, 'decision') || '').trim().toLowerCase();
				if (d !== 'yes' && d !== 'no') return `Decision must be yes/no, got: ${d || 'EMPTY'}`;
				return true;
			}

			async test40IcrRedTeamVerdict(problemStatement, solutionXml, state = {}, label = 'test44') {
				const memoryIn = (state?.memory || '').toString();
				let memory = memoryIn;

				const dsol = this.test21ExtractDetailedFromSolution(solutionXml || '');

				const attack = (() => {
					const parts = [];
					parts.push(`Problem:\n${problemStatement}`);
					parts.push(`Solution (detailed):\n${dsol || '(empty)'}`);
					parts.push(`Memory summary (may be empty):\n${memory || '(none)'}`);
					parts.push(`Find flaws, missing justifications, edge cases, and potential counterexamples. Be strict.`);
					return parts.join('\n\n');
				})();

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR redteam: attack notes`);
				const attackNotes = await this.callAPI(
					[
						{ role: 'system', content: 'You are the Iterative Agent acting as a Red Team. Produce attack notes and potential flaws. Output notes only.' },
						{ role: 'user', content: attack },
					],
					null,
					{ temperature: 0.2 }
				);

				const verdictPrompt = (() => {
					const parts = [];
					parts.push(`Problem:\n${problemStatement}`);
					parts.push(`Solution (detailed):\n${dsol || '(empty)'}`);
					parts.push(`Memory summary (may be empty):\n${memory || '(none)'}`);
					parts.push(`Attack notes:\n${attackNotes || '(none)'}`);
					parts.push(`Return ONLY XML:\n<redteam>\n  <decision>yes|no</decision>\n  <bug_report>...</bug_report>\n</redteam>\nRules:\n- If decision=yes, bug_report must be empty or very short.\n- If decision=no, bug_report must be concise and actionable.`);
					return parts.join('\n\n');
				})();

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR redteam: final verdict`);
				const verdictXml = await this.callAPI(
					[
						{ role: 'system', content: 'You are the Red Team Final Judge. Be strict. Output ONLY <redteam>...</redteam>.' },
						{ role: 'user', content: verdictPrompt },
					],
					(txt) => this.validateTest40RedTeamVerdictXml(txt),
					{ temperature: 0.1 }
				);

				const decision = (this.extractTag(verdictXml, 'decision') || '').trim().toLowerCase();
				const isGood = decision === 'yes';
				const bugReport = (this.extractTag(verdictXml, 'bug_report') || '').toString().trim();

				const memUser = (() => {
					const parts = [];
					parts.push(`Problem:\n${problemStatement}`);
					parts.push(`Solution (detailed):\n${dsol || '(empty)'}`);
					parts.push(`Redteam verdict:\n${verdictXml}`);
					parts.push(`Previous memory:\n${memory || '(none)'}`);
					parts.push(`Update memory summary (max 8 bullets). Keep only recurring pitfalls, critical checks, and open issues.`);
					return parts.join('\n\n');
				})();

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
				this.log(`[${label}] ICR redteam: memory agent update`);
				memory = await this.callAPI(
					[
						{ role: 'system', content: 'You are the Memory Agent. Compress the red-team state into a short memory summary (max 8 bullets).' },
						{ role: 'user', content: memUser },
					],
					null,
					{ temperature: 0.2 }
				);

				return { isGood, bugReport, memory, verdictXml };
			}

			async runTest40LikeArchitecture(query, redteamBudgetPerRound, label = 'test40', solverIterations = 3, passStreakTarget = 5, redTeamMode = 'external') {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ROUNDS = 10;
				const REDTEAM_CALL_BUDGET_PER_ROUND = Math.max(1, parseInt(redteamBudgetPerRound || '10', 10) || 10);
				const FAIL_STREAK_LIMIT = 10;
				const PASS_STREAK_TARGET = (() => {
					const n = parseInt(passStreakTarget || '5', 10);
					if (!Number.isFinite(n)) return 5;
					return Math.max(1, Math.min(10, n));
				})();
				const ITER_HARD_CAP = 200;
				const RT_MODE = (redTeamMode || 'external').toString();

				let lastSolution = '';

				try {
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`=== Round ${round}/${MAX_ROUNDS} (${label}: test21 + test37 solver) ===`);

						let solverMemory = '';
						let redTeamMemory = '';
						let redTeamCallsUsed = 0;

						const init = await this.test40IcrSolveSolution(query, { memory: solverMemory }, label, { iterations: solverIterations });
						let solution = init.solution || '';
						solverMemory = init.memory || '';
						lastSolution = solution;

						if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
							this.log(`[${label}] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
							continue;
						}

						let verification = null;
						if (RT_MODE === 'icr') {
							const rt = await this.test40IcrRedTeamVerdict(query, solution, { memory: redTeamMemory }, label);
							redTeamMemory = rt.memory || '';
							verification = { isGood: !!rt.isGood, bugReport: rt.bugReport || '', fullVerification: rt.verdictXml || '', decisionXml: '' };
						} else {
							verification = await this.test21VerifyMathSolution(query, solution);
						}
						redTeamCallsUsed += 1;

						let passStreak = verification.isGood ? 1 : 0;
						let failStreak = verification.isGood ? 0 : 1;

						for (let iter = 0; iter < ITER_HARD_CAP; iter++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[${label}] Iter ${iter}: pass=${passStreak}/${PASS_STREAK_TARGET}, failStreak=${failStreak}/${FAIL_STREAK_LIMIT}, redteam=${redTeamCallsUsed}/${REDTEAM_CALL_BUDGET_PER_ROUND}`);

							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}

							if (failStreak >= FAIL_STREAK_LIMIT) {
								this.log(`[${label}] Round ended (fail-streak ${FAIL_STREAK_LIMIT}).`);
								break;
							}

							if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
								this.log(`[${label}] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
								break;
							}

							if (!verification.isGood) {
								const corrected = await this.test40IcrSolveSolution(
									query,
									{ memory: solverMemory, solutionXml: solution, bugReport: verification.bugReport || '' },
									label,
									{ iterations: solverIterations }
								);
								solution = corrected.solution || '';
								solverMemory = corrected.memory || '';
								lastSolution = solution;
							}

							if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
								this.log(`[${label}] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
								break;
							}

							if (RT_MODE === 'icr') {
								const rt = await this.test40IcrRedTeamVerdict(query, solution, { memory: redTeamMemory }, label);
								redTeamMemory = rt.memory || '';
								verification = { isGood: !!rt.isGood, bugReport: rt.bugReport || '', fullVerification: rt.verdictXml || '', decisionXml: '' };
							} else {
								verification = await this.test21VerifyMathSolution(query, solution);
							}
							redTeamCallsUsed += 1;
							if (verification.isGood) {
								passStreak += 1;
								failStreak = 0;
							} else {
								passStreak = 0;
								failStreak += 1;
							}
						}
					}

					this.state.status = 'Failed';
					this.state.finalResult = lastSolution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl && this.state.finalResult) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest40Architecture(query) {
				return await this.runTest40LikeArchitecture(query, 10, 'test40', 3, 5, 'external');
			}

			async runTest41Architecture(query) {
				return await this.runTest40LikeArchitecture(query, 30, 'test41', 3, 5, 'external');
			}

			async runTest42Architecture(query) {
				return await this.runTest40LikeArchitecture(query, 10, 'test42', 1, 5, 'external');
			}

			async runTest43Architecture(query) {
				return await this.runTest40LikeArchitecture(query, 30, 'test43', 3, 3, 'external');
			}

			parseTest43VariantFlags(label) {
				const base = (label || '').toString();
				if (!base.startsWith('test43-')) {
					return { useGrade: false, useOverlap: false, useOutlier: false };
				}
				const parts = base.replace(/^test43-/, '').split('-').map(p => parseInt(p, 10)).filter(n => Number.isFinite(n));
				return {
					useGrade: parts.includes(1),
					useOverlap: parts.includes(2),
					useOutlier: parts.includes(3),
				};
			}

			test43MergeOutlierMemory(memory, outliers) {
				const items = Array.isArray(outliers) ? outliers.filter(Boolean) : [];
				if (!items.length) return (memory || '').toString();
				const header = `Outlier insights (high-signal patterns to reuse):\n- ${items.join('\n- ')}`;
				const base = (memory || '').toString().trim();
				return base ? `${header}\n\n${base}` : header;
			}

			async test43SelfImproveSolutionXml(problemStatement, solutionXml, memory) {
				const sys = this.getTest21Step1PromptXML();
				const mem = (memory || '').toString().trim();
				const user = `${this.getTest21SelfImprovementPromptXML()}${mem ? `\n\nMemory summary:\n${mem}` : ''}`;
				return await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: problemStatement },
						{ role: 'assistant', content: solutionXml },
						{ role: 'user', content: user },
					],
					(txt) => this.validateTest21SolutionXml(txt),
					{ temperature: 0.1 }
				);
			}

			test43WordSetForDiversity(text) {
				const s = String(text || '')
					.toLowerCase()
					.replace(/<[^>]+>/g, ' ')
					.replace(/[^a-z0-9Í∞Ä-Ìû£]+/gi, ' ')
					.replace(/\s+/g, ' ')
					.trim();
				if (!s) return new Set();
				const words = s.split(' ').filter(w => w.length >= 2);
				return new Set(words.slice(0, 220));
			}

			test43JaccardSimilarity(setA, setB) {
				if (!(setA instanceof Set) || !(setB instanceof Set)) return 1;
				if (setA.size === 0 && setB.size === 0) return 1;
				let inter = 0;
				const small = setA.size <= setB.size ? setA : setB;
				const large = setA.size <= setB.size ? setB : setA;
				for (const x of small) if (large.has(x)) inter++;
				const union = setA.size + setB.size - inter;
				return union ? (inter / union) : 1;
			}

			parseTest48VerbalizedTextProbabilityList(rawText, maxItems = 10, textKeys = ['text']) {
				const raw = (rawText || '').toString().trim();
				if (!raw) return [];
				const cleaned = raw.replace(/```(?:json)?/gi, '').replace(/```/g, '').trim();

				const tryParseJson = (s) => {
					const start = s.indexOf('{');
					const end = s.lastIndexOf('}');
					if (start < 0 || end <= start) return null;
					try { return JSON.parse(s.slice(start, end + 1)); } catch { return null; }
				};

				const obj = tryParseJson(cleaned);
				const arr = obj && (Array.isArray(obj.responses) ? obj.responses : (Array.isArray(obj.items) ? obj.items : null));
				if (!arr) return [];

				const keys = Array.isArray(textKeys) && textKeys.length ? textKeys : ['text'];
				const out = [];
				for (const item of arr) {
					if (!item) continue;
					let text = '';
					for (const k of keys) {
						const v = (item[k] ?? '').toString().trim();
						if (v) { text = v; break; }
					}
					if (!text) continue;
					const probRaw = (item.probability ?? item.prob ?? item.p ?? item.confidence);
					const probability = Number.isFinite(probRaw) ? probRaw : parseFloat(probRaw);
					out.push({
						text,
						probability: Number.isFinite(probability) ? Math.max(0, Math.min(1, probability)) : null,
					});
					if (out.length >= maxItems) break;
				}

				const probs = out.map(o => (o.probability ?? NaN)).filter(Number.isFinite);
				const fallbackProb = probs.length ? null : (out.length ? (1 / out.length) : null);
				for (const o of out) {
					let p = Number.isFinite(o.probability) ? o.probability : fallbackProb;
					if (!Number.isFinite(p)) p = 0;
					o.probability = p;
				}

				const dedup = [];
				const seen = new Set();
				for (const o of out) {
					const key = this.normalizeForHash(o.text).slice(0, 900);
					if (!key || seen.has(key)) continue;
					seen.add(key);
					dedup.push(o);
					if (dedup.length >= maxItems) break;
				}

				dedup.sort((a, b) => (b.probability - a.probability));
				return dedup;
			}

			async test48GetHiddenStateSummary(query) {
				const q = (query || '').toString();
				const key = this.normalizeForHash(q).slice(0, 1800);
				if (!this.state.test48HiddenStateCache) this.state.test48HiddenStateCache = {};
				if (this.state.test48HiddenStateCache[key]) return this.state.test48HiddenStateCache[key];

				const sys = `You compress a problem into a compact, decision-relevant "hidden state" for solving.

Rules:
- Max 10 bullets.
- Include: what is asked, givens, constraints, likely traps/ambiguities, and what must be proved/selected.
- Do NOT solve. Do NOT propose a plan. Do NOT output an answer.`;
				const user = `Problem:\n${q}\n\nReturn only the bullet list.`;
				const resp = await this.callAPI(
					[
						{ role: 'system', content: sys },
						{ role: 'user', content: user },
					],
					null,
					{ temperature: 0.2 }
				);
				const summary = (resp || '').toString().trim();
				this.state.test48HiddenStateCache[key] = summary;
				return summary;
			}

			// --- SciIdea Survey Methods ---
			getSciIdeaPersonas() {
				return [
					{ name: 'Scientist', note: 'Focus on empirical evidence, testable hypotheses, and methodological rigor.' },
					{ name: 'Critic', note: 'Challenge assumptions, find edge cases, demand justification for each step.' },
					{ name: 'Synthesizer', note: 'Connect ideas across domains, find novel combinations, resolve contradictions.' },
				];
			}

			async sciIdeaGenerateCoIContext(query) {
				const q = (query || '').toString().trim();
				if (!q) return '';
				const key = this.normalizeForHash(q).slice(0, 1200);
				if (!this.state.sciIdeaCoICache) this.state.sciIdeaCoICache = {};
				if (this.state.sciIdeaCoICache[key]) return this.state.sciIdeaCoICache[key];

				const sys = `You extract knowledge chains and conceptual connections for problem-solving.`;
				const user = `Analyze this problem and create a Chain-of-Ideas context:

Problem: ${q}

Generate:
1. Core concepts (3-5 key terms/ideas)
2. Related prior knowledge chains (what do we know that connects?)
3. Potential gaps or unexplored connections

Format as a concise context block (max 200 words). Do NOT solve the problem.`;
				const resp = await this.callAPI([{ role: 'system', content: sys }, { role: 'user', content: user }], null, { temperature: 0.3 });
				const ctx = (resp || '').toString().trim();
				this.state.sciIdeaCoICache[key] = ctx;
				return ctx;
			}

			async sciIdeaDebateRound(query, solution, k = 3) {
				const criticisms = [];
				for (let i = 0; i < k; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) break;
					const critiquePrompt = `As a critical reviewer, examine this solution:

Problem: ${query}
Solution: ${solution}

Identify the most significant weakness, gap, or potential error.
Be specific and constructive. Output in <critique>...</critique> tags.`;
					const critique = await this.callAPI(
						[{ role: 'system', content: 'You are a rigorous scientific reviewer.' }, { role: 'user', content: critiquePrompt }],
						(txt) => txt.includes('<critique>'),
						{ temperature: 0.4 + i * 0.1 }
					);
					criticisms.push(critique);
				}
				if (!criticisms.length) return '';
				const synthesisPrompt = `Multiple reviewers critiqued a solution:

${criticisms.map((c, i) => `Reviewer ${i + 1}: ${c}`).join('\n\n')}

Summarize the consensus issues (if any) into a single actionable feedback.
Output in <feedback>...</feedback> tags.`;
				return await this.callAPI(
					[{ role: 'system', content: 'You synthesize multiple critiques into actionable feedback.' }, { role: 'user', content: synthesisPrompt }],
					(txt) => txt.includes('<feedback>'),
					{ temperature: 0.2 }
				);
			}

			parseTest48BeliefSets(rawText, maxItems = 8) {
				const raw = (rawText || '').toString().trim();
				if (!raw) return [];
				const cleaned = raw.replace(/```(?:json)?/gi, '').replace(/```/g, '').trim();
				const tryParseJson = (s) => {
					const start = s.indexOf('{');
					const end = s.lastIndexOf('}');
					if (start < 0 || end <= start) return null;
					try { return JSON.parse(s.slice(start, end + 1)); } catch { return null; }
				};
				const obj = tryParseJson(cleaned);
				const arr = obj && (Array.isArray(obj.beliefs) ? obj.beliefs : (Array.isArray(obj.responses) ? obj.responses : null));
				if (!arr) return [];
				const out = [];
				for (const item of arr) {
					if (!item) continue;
					const scenario = (item.scenario || item.text || item.belief || '').toString().trim();
					if (!scenario) continue;
					const probRaw = (item.probability ?? item.prob ?? item.p ?? item.confidence);
					const probability = Number.isFinite(probRaw) ? probRaw : parseFloat(probRaw);
					out.push({ scenario, probability: Number.isFinite(probability) ? Math.max(0, Math.min(1, probability)) : null });
					if (out.length >= maxItems) break;
				}
				const probs = out.map(o => (o.probability ?? NaN)).filter(Number.isFinite);
				const fallbackProb = probs.length ? null : (out.length ? (1 / out.length) : null);
				for (const o of out) {
					let p = Number.isFinite(o.probability) ? o.probability : fallbackProb;
					if (!Number.isFinite(p)) p = 0;
					o.probability = p;
				}
				out.sort((a, b) => (b.probability - a.probability));
				return out;
			}

			async test48GenerateBeliefSets(query, k, extraContextText = '') {
				const n = Math.max(1, Math.min(8, parseInt(k, 10) || 3));
				const sys = `You generate Obscuro-style belief sets (plausible interpretations / missing-information scenarios).

Return ONLY JSON:
{
  "beliefs": [
    { "scenario": "string", "probability": 0.0 }
  ]
}

Rules:
- Output exactly ${n} belief sets.
- Each scenario must be short (2‚Äì6 bullets) and materially different.
- Focus on ambiguities, hidden assumptions, edge-case readings, and what could change the answer.
- probability is your estimate (0.0‚Äì1.0) that this scenario matches the intended problem setting.
- Do NOT solve. Do NOT output an answer.`;
				const user = `PROBLEM:\n${query}\n\n${extraContextText ? `EXTRA CONTEXT:\n${extraContextText}\n\n` : ''}Generate the belief sets now.`;
				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.8 }
				);
				return this.parseTest48BeliefSets(resp, n);
			}

				async test48GenerateVerbalizedSolutions(query, k, extraContextText = '', options = {}) {
					const n = Math.max(1, Math.min(10, parseInt(k, 10) || 5));
					const tune = Number.isFinite(options?.probabilityTuning)
						? Math.max(0, Math.min(1, options.probabilityTuning))
						: null;
					const hard = !!options?.hard;
					const sys = `Generate ${n} diverse candidate solutions to the input problem.

	Return ONLY JSON:
	{
	  "responses": [
	    { "text": "string", "probability": 0.0 }
	  ]
	}

	Rules:
	- Each solution must be materially different (different decomposition/checks/angle).
	- "probability" is your estimated probability (0.0‚Äì1.0) that this solution is correct (relative to the full distribution).
	${Number.isFinite(tune)
							? (hard
								? `- Randomly sample the responses from the distribution, with the probability of each response must be below ${tune.toFixed(2)}.`
								: `- At least 1 of the ${n} responses must be a tail response (probability <= ${tune.toFixed(2)}).`)
							: ''}
	- Output plain text only in each "text" (NO XML/JSON/tags inside the text).
	- Do NOT add any extra text outside JSON.`;
					const user = `PROBLEM:\n${query}\n\n${extraContextText ? `EXTRA CONTEXT:\n${extraContextText}\n\n` : ''}Generate the solutions now.`;
					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.8 }
				);
				return this.parseTest48VerbalizedTextProbabilityList(resp, n, ['text']);
			}

				async test48GenerateVerbalizedMethodologies(query, k, extraContextText = '', options = {}) {
					const n = Math.max(1, Math.min(8, parseInt(k, 10) || 3));
					const tune = Number.isFinite(options?.probabilityTuning)
						? Math.max(0, Math.min(1, options.probabilityTuning))
						: null;
					const hard = !!options?.hard;
					const tail = !!options?.tailSampling;
					let tailReq = null;
					if (tail) tailReq = 0.20;
					if (Number.isFinite(tune)) tailReq = (tailReq == null) ? tune : Math.min(tailReq, tune);
					const sys = `Generate ${n} diverse solution methodologies (NOT the final answer).

	Return ONLY JSON:
	{
	  "responses": [
	    { "methodology": "string", "probability": 0.0 }
	  ]
	}

	Rules:
	- Each methodology must be materially different (different decomposition, checks, or angle).
	- Output each methodology as 6‚Äì12 bullets, each starting with "- ".
	- Do NOT solve the problem. Do NOT output an answer.
	- "probability" is your estimated likelihood (0.0‚Äì1.0) this methodology yields the correct final answer.
	${Number.isFinite(tune) && hard ? `- Randomly sample the methodologies from the distribution, with the probability of each methodology must be below ${tune.toFixed(2)}.` : ''}
	${Number.isFinite(tailReq) && !(Number.isFinite(tune) && hard) ? `- At least 1 of the ${n} methodologies must be a tail approach (probability <= ${tailReq.toFixed(2)}).` : ''}`;
					const user = `PROBLEM:\n${query}\n\n${extraContextText ? `EXTRA CONTEXT:\n${extraContextText}\n\n` : ''}Generate the methodologies now.`;
					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.8 }
				);
				return this.parseTest48VerbalizedTextProbabilityList(resp, n, ['methodology', 'text']);
			}

				async test48GenerateVerbalizedCorrections(query, currentSolutionXml, bugReport, k, extraContextText = '', options = {}) {
					const n = Math.max(1, Math.min(8, parseInt(k, 10) || 3));
					const dsol = this.test21ExtractDetailedFromSolution(currentSolutionXml || '');
					const tune = Number.isFinite(options?.probabilityTuning)
						? Math.max(0, Math.min(1, options.probabilityTuning))
						: null;
					const hard = !!options?.hard;
					const sys = `Generate ${n} diverse corrected revisions of the solution to address the bug report.

	Return ONLY JSON:
	{
	  "responses": [
	    { "text": "string", "probability": 0.0 }
	  ]
	}

	Rules:
	- Each revision must be materially different (different fix strategy).
	- Keep good parts; fix the reported issues.
	${Number.isFinite(tune)
							? (hard
								? `- Randomly sample the revisions from the distribution, with the probability of each revision must be below ${tune.toFixed(2)}.`
								: `- At least 1 of the ${n} revisions must be a tail revision (probability <= ${tune.toFixed(2)}).`)
							: ''}
	- Output plain text only in each "text" (NO XML/JSON/tags inside the text).
	- Do NOT add any extra text outside JSON.`;
					const user = `PROBLEM:\n${query}\n\nSOLUTION (detailed):\n${dsol}\n\nBUG REPORT:\n${bugReport || '(none)'}\n\n${extraContextText ? `EXTRA CONTEXT:\n${extraContextText}\n\n` : ''}Generate the revised solutions now.`;
					const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.8 }
				);
				return this.parseTest48VerbalizedTextProbabilityList(resp, n, ['text']);
			}

				async test48GenerateVerbalizedRedTeamNotes(query, solutionXml, k, options = {}) {
					const n = Math.max(1, Math.min(8, parseInt(k, 10) || 3));
					const dsol = this.test21ExtractDetailedFromSolution(solutionXml || '');
					const tune = Number.isFinite(options?.probabilityTuning)
						? Math.max(0, Math.min(1, options.probabilityTuning))
						: null;
					const hard = !!options?.hard;
					const sys = `You are an adversarial red-team critic.

	Generate ${n} materially different critiques of the solution (potential flaws, missing justifications, edge cases).

	Return ONLY JSON:
	{
	  "responses": [
	    { "text": "string", "probability": 0.0 }
	  ]
	}

	Rules:
	- Each critique must focus on a different likely failure mode.
	- Each critique must be short (2‚Äì6 bullets) and concrete.
	${Number.isFinite(tune)
							? (hard
								? `- Randomly sample the critiques from the distribution, with the probability of each critique must be below ${tune.toFixed(2)}.`
								: `- At least 1 of the ${n} critiques must be a tail critique (probability <= ${tune.toFixed(2)}).`)
							: ''}
	- Do NOT propose a full rewrite; critiques only.
	- Do NOT add any extra text outside JSON.`;
					const user = `PROBLEM:\n${query}\n\nSOLUTION (detailed):\n${dsol}\n\nGenerate the critiques now.`;
					const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.8 }
				);
				return this.parseTest48VerbalizedTextProbabilityList(resp, n, ['text']);
			}

			async test48ProcessSupervisorBugReport(query, solutionXml, existingBugReport = '') {
				const dsol = this.test21ExtractDetailedFromSolution(solutionXml || '');
				const sys = `You are a process supervisor. You find the earliest incorrect or unjustified step in a solution.

Rules:
- Identify the first failing step (quote it).
- Explain precisely what is wrong or missing.
- Propose the minimal fix.
- Output plain text only (no XML/JSON/tags).`;
				const user = `PROBLEM:\n${query}\n\nSOLUTION (detailed):\n${dsol}\n\nEXISTING VERIFIER BUG REPORT (may be imperfect):\n${existingBugReport || '(none)'}\n\nWrite the process-supervision bug report now.`;
				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.2 }
				);
				return (resp || '').toString().trim();
			}

			async test48SummarizeBugReportDelta(bugReport) {
				const text = (bugReport || '').toString().trim();
				if (!text) return '';
				const sys = `You compress bug reports into a short "delta" checklist.

Rules:
- Output 3‚Äì6 bullets.
- Each bullet must be an actionable fix item.
- Output plain text only.`;
				const user = `BUG REPORT:\n${text}\n\nReturn the delta checklist now.`;
				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.2 }
				);
				return (resp || '').toString().trim();
			}

			async test48QuietPositionCheck(query, solutionXml) {
				const dsol = this.test21ExtractDetailedFromSolution(solutionXml || '');
				const prompt = `Assume the solution is WRONG. Try to find a concrete flaw, missing justification, or counterexample.

Rules:
- If you find a specific credible flaw, output:
<unstable>yes</unstable>
<note>...</note>
- If you cannot find any credible flaw, output:
<unstable>no</unstable>
<note>briefly what you checked</note>

PROBLEM:
${query}

SOLUTION (detailed):
${dsol}`;
				const resp = await this.callAPI(
					[
						{ role: 'system', content: 'You are a strict adversarial checker. Do not be lenient. Do not hallucinate; require specificity.' },
						{ role: 'user', content: prompt }
					],
					(txt) => txt.includes('<unstable>yes</unstable>') || txt.includes('<unstable>no</unstable>'),
					{ temperature: 0.2 }
				);
				const unstable = resp.includes('<unstable>yes</unstable>');
				const note = (this.extractTag(resp, 'note') || '').toString().trim();
				return { unstable, note };
			}

			async test48ScoreCandidatesValueNet(query, candidateSolutionXmls) {
				const cands = Array.isArray(candidateSolutionXmls) ? candidateSolutionXmls.filter(Boolean) : [];
				const MAX = 8;
				const sliced = cands.slice(0, MAX);
				if (!sliced.length) return [];
				const blocks = sliced.map((s, i) => `#${i + 1}\n${this.test21ExtractDetailedFromSolution(s || '')}`).join('\n\n');
				const sys = `You are a "value network" scoring candidate solutions.

Return ONLY JSON:
{
  "scores": [
    { "idx": 1, "score": 0.0, "note": "short" }
  ]
}

Rules:
- idx is 1-based.
- score is in [-1.0, 1.0] where 1.0 means highly likely correct/rigorous, -1.0 means very likely wrong.
- Be conservative; penalize missing justification.
- Do NOT solve the problem. Do NOT output an answer.`;
				const user = `PROBLEM:\n${query}\n\nCANDIDATES:\n${blocks}\n\nScore each candidate now.`;
				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.2 }
				);
				const cleaned = (resp || '').toString().replace(/```(?:json)?/gi, '').replace(/```/g, '').trim();
				const start = cleaned.indexOf('{');
				const end = cleaned.lastIndexOf('}');
				if (start < 0 || end <= start) return [];
				let obj = null;
				try { obj = JSON.parse(cleaned.slice(start, end + 1)); } catch { obj = null; }
				const arr = obj && Array.isArray(obj.scores) ? obj.scores : null;
				if (!arr) return [];
				const out = [];
				for (const item of arr) {
					if (!item) continue;
					const idx = parseInt(item.idx, 10);
					const score = Number(item.score);
					if (!Number.isFinite(idx) || idx < 1 || idx > sliced.length) continue;
					out.push({
						idx,
						score: Number.isFinite(score) ? Math.max(-1, Math.min(1, score)) : 0,
						note: (item.note || '').toString().trim(),
					});
				}
				out.sort((a, b) => b.score - a.score);
				return out;
			}

			// === AgeMem: Agentic Memory (Unified LTM/STM Management) ===
			// Reference: "Agentic Memory: Learning Unified Long-Term and Short-Term Memory Management"
			// https://arxiv.org/abs/2601.01885
			//
			// AgeMem framework:
			// - LTM Tools: ADD_MEMORY, UPDATE_MEMORY, DELETE_MEMORY (persistent knowledge storage)
			// - STM Tools: RETRIEVE_MEMORY, SUMMARY_CONTEXT, FILTER_CONTEXT (context management)
			// - Unified tool-based interface for autonomous memory management

			ageMemEnsureState() {
				if (!this.state.agemem_ltm) this.state.agemem_ltm = [];
				if (!this.state.agemem_stm) this.state.agemem_stm = { summaries: [], filteredParts: [] };
			}

			// LTM Tool: Add new knowledge
			ageMemLtmAdd(content, tag = 'fact') {
				this.ageMemEnsureState();
				const id = `ltm_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
				const entry = { id, content: (content || '').toString().trim(), tag, createdAt: Date.now() };
				this.state.agemem_ltm.push(entry);
				this.log(`[AgeMem] LTM_ADD: id=${id}, tag=${tag}, len=${entry.content.length}`);
				return entry;
			}

			// LTM Tool: Update existing entry
			ageMemLtmUpdate(id, newContent) {
				this.ageMemEnsureState();
				const entry = this.state.agemem_ltm.find(e => e.id === id);
				if (!entry) {
					this.log(`[AgeMem] LTM_UPDATE: id=${id} not found`);
					return null;
				}
				entry.content = (newContent || '').toString().trim();
				entry.updatedAt = Date.now();
				this.log(`[AgeMem] LTM_UPDATE: id=${id}, new_len=${entry.content.length}`);
				return entry;
			}

			// LTM Tool: Delete entry
			ageMemLtmDelete(id) {
				this.ageMemEnsureState();
				const idx = this.state.agemem_ltm.findIndex(e => e.id === id);
				if (idx < 0) {
					this.log(`[AgeMem] LTM_DELETE: id=${id} not found`);
					return false;
				}
				this.state.agemem_ltm.splice(idx, 1);
				this.log(`[AgeMem] LTM_DELETE: id=${id} removed`);
				return true;
			}

			// STM Tool: Retrieve relevant memories from LTM
			ageMemStmRetrieve(query, topK = 3) {
				this.ageMemEnsureState();
				const q = (query || '').toString().toLowerCase();
				const scored = this.state.agemem_ltm.map(entry => {
					const c = (entry.content || '').toLowerCase();
					const words = q.split(/\s+/).filter(w => w.length > 2);
					const matchCount = words.filter(w => c.includes(w)).length;
					return { entry, score: matchCount / Math.max(1, words.length) };
				});
				scored.sort((a, b) => b.score - a.score);
				const results = scored.slice(0, topK).filter(s => s.score > 0).map(s => s.entry);
				this.log(`[AgeMem] STM_RETRIEVE: query_len=${q.length}, found=${results.length}/${topK}`);
				return results;
			}

			// STM Tool: Summarize context
			async ageMemStmSummary(context, query) {
				this.ageMemEnsureState();
				const contextStr = (context || '').toString().trim();
				if (contextStr.length < 100) return contextStr;

				const sysPrompt = `You are a Context Summarizer. Extract only the information relevant to answering the query. Be extremely concise. Output just the summary, no explanation.`;
				const userPrompt = `Query: ${query}\n\nContext to summarize:\n${contextStr.slice(0, 8000)}\n\nProvide a concise summary (max 500 chars) focusing on query-relevant information.`;

				try {
					const summary = await this.callAPI(
						[{ role: 'system', content: sysPrompt }, { role: 'user', content: userPrompt }],
						null,
						{ temperature: 0.2 }
					);
					const result = (summary || '').toString().trim().slice(0, 600);
					this.state.agemem_stm.summaries.push({ original_len: contextStr.length, summary_len: result.length, timestamp: Date.now() });
					this.log(`[AgeMem] STM_SUMMARY: ${contextStr.length} ‚Üí ${result.length} chars`);
					return result;
				} catch (e) {
					this.log(`[AgeMem] STM_SUMMARY error: ${e.message}`);
					return contextStr.slice(0, 600);
				}
			}

			// STM Tool: Filter irrelevant content
			async ageMemStmFilter(context, query) {
				this.ageMemEnsureState();
				const contextStr = (context || '').toString().trim();
				if (contextStr.length < 200) return contextStr;

				const sysPrompt = `You are a Context Filter. Remove irrelevant, redundant, or distracting information. Keep only what's needed to answer the query. Output the filtered text directly.`;
				const userPrompt = `Query: ${query}\n\nContext to filter:\n${contextStr.slice(0, 8000)}\n\nOutput only the relevant portions.`;

				try {
					const filtered = await this.callAPI(
						[{ role: 'system', content: sysPrompt }, { role: 'user', content: userPrompt }],
						null,
						{ temperature: 0.1 }
					);
					const result = (filtered || '').toString().trim();
					this.state.agemem_stm.filteredParts.push({ original_len: contextStr.length, filtered_len: result.length, timestamp: Date.now() });
					this.log(`[AgeMem] STM_FILTER: ${contextStr.length} ‚Üí ${result.length} chars`);
					return result;
				} catch (e) {
					this.log(`[AgeMem] STM_FILTER error: ${e.message}`);
					return contextStr;
				}
			}

			// Format LTM contents for prompt injection
			ageMemFormatLtmForPrompt() {
				this.ageMemEnsureState();
				if (!this.state.agemem_ltm.length) return '';
				const entries = this.state.agemem_ltm.map((e, i) =>
					`[Memory ${i + 1}] (id: ${e.id}, tag: ${e.tag})\n${e.content}`
				).join('\n\n');
				return `<long_term_memory>\n${entries}\n</long_term_memory>`;
			}

			// Parse tool calls from LLM response
			ageMemParseToolCalls(response) {
				const raw = (response || '').toString();
				const toolCalls = [];

				// Pattern: <tool>TOOL_NAME</tool><args>...</args>
				const toolPattern = /<tool>\s*([\w_]+)\s*<\/tool>\s*<args>([\s\S]*?)<\/args>/gi;
				let match;
				while ((match = toolPattern.exec(raw)) !== null) {
					const toolName = (match[1] || '').trim().toUpperCase();
					const argsRaw = (match[2] || '').trim();
					toolCalls.push({ tool: toolName, args: argsRaw });
				}

				return toolCalls;
			}

			// Execute parsed tool calls
			async ageMemExecuteToolCalls(toolCalls, query) {
				const results = [];
				for (const tc of toolCalls) {
					let result = null;
					try {
						if (tc.tool === 'ADD_MEMORY') {
							const content = tc.args;
							result = this.ageMemLtmAdd(content, 'insight');
						} else if (tc.tool === 'UPDATE_MEMORY') {
							const parts = tc.args.split('|||');
							const id = (parts[0] || '').trim();
							const newContent = (parts[1] || '').trim();
							result = this.ageMemLtmUpdate(id, newContent);
						} else if (tc.tool === 'DELETE_MEMORY') {
							result = this.ageMemLtmDelete(tc.args.trim());
						} else if (tc.tool === 'RETRIEVE_MEMORY') {
							result = this.ageMemStmRetrieve(tc.args || query, 3);
						} else if (tc.tool === 'SUMMARY_CONTEXT') {
							result = await this.ageMemStmSummary(tc.args, query);
						} else if (tc.tool === 'FILTER_CONTEXT') {
							result = await this.ageMemStmFilter(tc.args, query);
						} else {
							this.log(`[AgeMem] Unknown tool: ${tc.tool}`);
						}
					} catch (e) {
						this.log(`[AgeMem] Tool execution error (${tc.tool}): ${e.message}`);
					}
					results.push({ tool: tc.tool, result });
				}
				return results;
			}

			// Main AgeMem solve with memory tools
			async ageMemSolveWithMemoryTools(query, options = {}) {
				this.ageMemEnsureState();
				const maxRounds = options.maxRounds || 3;
				const label = options.label || 'AgeMem';

				// Retrieve relevant prior knowledge
				const retrieved = this.ageMemStmRetrieve(query, 5);
				const ltmContext = this.ageMemFormatLtmForPrompt();

				const memoryToolsSpec = `
Available Memory Tools (use when needed):
- ADD_MEMORY: Store important insight/fact. Format: <tool>ADD_MEMORY</tool><args>content to store</args>
- UPDATE_MEMORY: Update existing memory. Format: <tool>UPDATE_MEMORY</tool><args>memory_id|||new_content</args>
- DELETE_MEMORY: Remove outdated memory. Format: <tool>DELETE_MEMORY</tool><args>memory_id</args>
- RETRIEVE_MEMORY: Search memories. Format: <tool>RETRIEVE_MEMORY</tool><args>search query</args>
- SUMMARY_CONTEXT: Compress text. Format: <tool>SUMMARY_CONTEXT</tool><args>text to summarize</args>
- FILTER_CONTEXT: Remove irrelevant info. Format: <tool>FILTER_CONTEXT</tool><args>text to filter</args>

Use tools sparingly. Focus on solving the problem.`;

				const sysPrompt = `You are a mathematical problem solver with access to memory tools.
${memoryToolsSpec}

${ltmContext}

Solve the problem step by step. Use <solution>...</solution> for your final answer with <detailed>...</detailed> for reasoning.
If you discover important insights worth remembering, use ADD_MEMORY. You may call tools OR provide solution, or both.`;

				let solution = '';
				let conversation = [{ role: 'user', content: query }];

				for (let round = 1; round <= maxRounds; round++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

					this.log(`[${label}] Round ${round}/${maxRounds}`);

					const response = await this.callAPI(
						[{ role: 'system', content: sysPrompt }, ...conversation],
						null,
						{ temperature: 0.5 }
					);

					// Parse and execute any tool calls
					const toolCalls = this.ageMemParseToolCalls(response);
					if (toolCalls.length > 0) {
						this.log(`[${label}] Found ${toolCalls.length} tool calls`);
						const toolResults = await this.ageMemExecuteToolCalls(toolCalls, query);

						// Add tool results to conversation
						const toolResultText = toolResults.map(tr =>
							`Tool ${tr.tool} result: ${typeof tr.result === 'object' ? JSON.stringify(tr.result).slice(0, 200) : tr.result}`
						).join('\n');
						conversation.push({ role: 'assistant', content: response });
						conversation.push({ role: 'user', content: `Tool results:\n${toolResultText}\n\nContinue solving.` });
					}

					// Check if solution is present
					if (response.includes('<solution>')) {
						solution = response;
						this.log(`[${label}] Solution found in round ${round}`);
						break;
					}

					// If no tools and no solution, prompt for solution
					if (toolCalls.length === 0 && !response.includes('<solution>')) {
						conversation.push({ role: 'assistant', content: response });
						conversation.push({ role: 'user', content: 'Please provide your final solution in <solution>...</solution> tags.' });
					}
				}

				// Extract any new insights and store to LTM
				const solutionText = this.extractTag(solution, 'solution') || solution;
				const detailed = this.extractTag(solution, 'detailed') || '';
				if (detailed.length > 100) {
					// Auto-extract key insight
					const keyInsight = detailed.slice(0, 300).trim();
					if (!this.state.agemem_ltm.some(e => e.content.includes(keyInsight.slice(0, 50)))) {
						this.ageMemLtmAdd(keyInsight, 'reasoning_pattern');
					}
				}

				return solution || '(No solution generated)';
			}

			// Standalone AgeMem Architecture
			async runAgeMemArchitecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;
				this.ageMemEnsureState();

				const label = 'AgeMem';
				const MAX_ROUNDS = 8;
				const PASS_STREAK_TARGET = 3;

				this.log(`=== AgeMem (Agentic Memory) Architecture ===`);
				this.log(`[${label}] Unified LTM/STM management with tool-based actions.`);
				this.log(`[${label}] LTM entries: ${this.state.agemem_ltm.length}`);

				try {
					let solution = '';
					let passStreak = 0;

					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						this.log(`=== Round ${round}/${MAX_ROUNDS} ===`);

						// Solve with memory tools
						solution = await this.ageMemSolveWithMemoryTools(query, { maxRounds: 3, label });

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						// Verify solution
						const verifyResult = await this.test43VerifySolutionStrict(query, solution);

						if (verifyResult && verifyResult.isPass) {
							passStreak++;
							this.log(`[${label}] Verification PASS. Streak: ${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.log(`[${label}] Pass streak target reached. Finalizing.`);
								this.finalize(solution, true);
								return;
							}
						} else {
							passStreak = 0;
							const reason = (verifyResult && verifyResult.reason) || 'unknown';
							this.log(`[${label}] Verification FAIL: ${reason}`);

							// Store failure insight to LTM for future avoidance
							if (reason && reason.length > 10) {
								this.ageMemLtmAdd(`Avoid: ${reason.slice(0, 200)}`, 'failure_pattern');
							}
						}
					}

					// Finalize with best effort
					this.log(`[${label}] Max rounds reached. Finalizing best solution.`);
					this.finalize(solution || '(No valid solution)', !!solution);

				} catch (e) {
					if (e.message === 'Stopped') {
						this.updateStatusUI('Stopped', 'orange');
					} else {
						this.log(`[${label}] Error: ${e.message}`);
						this.updateStatusUI('Error', 'red');
					}
					this.stopTimer();
				}
			}

			// === Focus: Active Context Compression (Slime Mold inspiration) ===
			// Reference: Active Context Compression paper
			//
			// Focus framework:
			// 1. Agent autonomously decides when to compress context
			// 2. start_focus(goal) marks checkpoint for exploration
			// 3. complete_focus(summary) consolidates learnings into Knowledge Block
			// 4. Raw history between checkpoint and current is pruned
			// 5. Sawtooth pattern: context grows during exploration, drops during compression

			focusEnsureState() {
				if (!this.state.focus_knowledgeBlock) this.state.focus_knowledgeBlock = [];
				if (!this.state.focus_stack) this.state.focus_stack = [];
				if (!this.state.focus_stepsSinceCompress) this.state.focus_stepsSinceCompress = 0;
				if (!this.state.focus_totalCompressions) this.state.focus_totalCompressions = 0;
				if (!this.state.focus_messagesDropped) this.state.focus_messagesDropped = 0;
			}

			focusStartFocus(goal) {
				// Mark a checkpoint for exploration
				this.focusEnsureState();
				const checkpoint = {
					goal: goal,
					startTime: Date.now(),
					messageIndex: -1, // Will be set when added to conversation
				};
				this.state.focus_stack.push(checkpoint);
				this.log(`[Focus] start_focus: "${goal.slice(0, 80)}..."`);
				return { success: true, focusId: this.state.focus_stack.length - 1, goal };
			}

			focusCompleteFocus(summary, conversation) {
				// Consolidate learnings and prune history
				this.focusEnsureState();
				if (this.state.focus_stack.length === 0) {
					this.log(`[Focus] complete_focus: No active focus phase.`);
					return { success: false, error: 'No active focus phase' };
				}

				const focus = this.state.focus_stack.pop();
				const knowledgeEntry = {
					goal: focus.goal,
					attempted: summary.attempted || '',
					learned: summary.learned || '',
					outcome: summary.outcome || '',
					timestamp: Date.now(),
				};

				// Add to Knowledge Block
				this.state.focus_knowledgeBlock.push(knowledgeEntry);
				this.state.focus_totalCompressions++;

				// Count messages to be dropped (from checkpoint to now)
				let dropped = 0;
				if (focus.messageIndex >= 0 && conversation && conversation.length > focus.messageIndex) {
					dropped = conversation.length - focus.messageIndex - 1;
					// Prune messages (keep only up to checkpoint + 1)
					conversation.splice(focus.messageIndex + 1);
					this.state.focus_messagesDropped += dropped;
				}

				this.state.focus_stepsSinceCompress = 0;
				this.log(`[Focus] complete_focus: Compressed. Dropped ${dropped} messages.`);
				this.log(`[Focus] Knowledge Block now has ${this.state.focus_knowledgeBlock.length} entries.`);
				this.log(`[Focus] Total compressions: ${this.state.focus_totalCompressions}`);

				return { success: true, dropped, knowledgeEntries: this.state.focus_knowledgeBlock.length };
			}

			focusFormatKnowledgeBlock() {
				// Format Knowledge Block for injection into context
				this.focusEnsureState();
				if (this.state.focus_knowledgeBlock.length === 0) return '';

				let block = '=== KNOWLEDGE BLOCK (Compressed Learnings) ===\n';
				this.state.focus_knowledgeBlock.forEach((entry, i) => {
					block += `\n[${i + 1}] Goal: ${entry.goal}\n`;
					if (entry.attempted) block += `    Attempted: ${entry.attempted}\n`;
					if (entry.learned) block += `    Learned: ${entry.learned}\n`;
					if (entry.outcome) block += `    Outcome: ${entry.outcome}\n`;
				});
				block += '\n=== END KNOWLEDGE BLOCK ===\n';
				return block;
			}

			focusParseToolCalls(response) {
				// Parse start_focus and complete_focus calls from response
				const calls = [];
				const raw = (response || '').toString();

				// Match start_focus(goal) or <start_focus>...</start_focus>
				const startMatches = raw.matchAll(/<start_focus>([\s\S]*?)<\/start_focus>/gi);
				for (const m of startMatches) {
					calls.push({ tool: 'start_focus', goal: m[1].trim() });
				}

				// Match complete_focus with summary
				const completeMatches = raw.matchAll(/<complete_focus>([\s\S]*?)<\/complete_focus>/gi);
				for (const m of completeMatches) {
					const content = m[1].trim();
					// Parse structured summary
					const attempted = this.extractTag(content, 'attempted') || '';
					const learned = this.extractTag(content, 'learned') || '';
					const outcome = this.extractTag(content, 'outcome') || '';
					calls.push({
						tool: 'complete_focus',
						summary: { attempted, learned, outcome, raw: content }
					});
				}

				return calls;
			}

			focusGetSystemPromptAddition() {
				return `
## Focus Tools (Active Context Compression)

You have access to Focus tools for autonomous context management:

<start_focus>goal description</start_focus>
- Call before exploring any new sub-problem or investigation
- Marks a checkpoint in your reasoning history

<complete_focus>
<attempted>What you tried</attempted>
<learned>Key facts, file paths, insights discovered</learned>
<outcome>Success/failure/partial result</outcome>
</complete_focus>
- Call after 10-15 steps to compress your context
- Your learnings are preserved in a Knowledge Block
- Raw exploration history is pruned to save tokens

MANDATORY WORKFLOW:
1. ALWAYS call start_focus before ANY exploration phase
2. ALWAYS call complete_focus after 10-15 tool calls or when reaching a conclusion
3. Use structured phases: explore ‚Üí compress ‚Üí implement ‚Üí compress ‚Üí verify

The Knowledge Block persists across compressions and contains your accumulated insights.
`;
			}

			focusGetReminderMessage(stepsSinceCompress) {
				return `
[SYSTEM REMINDER] You have made ${stepsSinceCompress} tool calls since your last compression.
Consider calling complete_focus to compress your context and preserve your learnings.
This helps maintain reasoning quality and reduces token usage.
`;
			}

			// Main Focus solve loop with context compression
			async focusSolveWithCompression(query, options = {}) {
				this.focusEnsureState();
				const label = options.label || 'Focus';
				const maxRounds = options.maxRounds || 30;
				const compressInterval = options.compressInterval || 15;

				const knowledgeBlock = this.focusFormatKnowledgeBlock();
				const focusInstructions = this.focusGetSystemPromptAddition();

				const systemPrompt = `You are a mathematical problem solver with Focus context management.
${focusInstructions}

${knowledgeBlock}

Solve the following problem step by step. Use start_focus before exploration and complete_focus to compress.
Provide your final answer in <solution>...</solution> tags with <detailed>...</detailed> for full reasoning.`;

				const conversation = [
					{ role: 'system', content: systemPrompt },
					{ role: 'user', content: query }
				];

				let solution = '';
				let stepCount = 0;

				for (let round = 1; round <= maxRounds; round++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

					// Insert reminder if needed
					if (this.state.focus_stepsSinceCompress >= compressInterval) {
						const reminder = this.focusGetReminderMessage(this.state.focus_stepsSinceCompress);
						conversation.push({ role: 'user', content: reminder });
						this.log(`[${label}] Compression reminder injected (${this.state.focus_stepsSinceCompress} steps).`);
					}

					const response = await this.callAPI(conversation, (txt) => txt.includes('<solution>'), { temperature: 0.7 });
					stepCount++;
					this.state.focus_stepsSinceCompress++;

					// Check for focus tool calls
					const focusCalls = this.focusParseToolCalls(response);
					for (const fc of focusCalls) {
						if (fc.tool === 'start_focus') {
							const result = this.focusStartFocus(fc.goal);
							// Mark message index for later pruning
							if (this.state.focus_stack.length > 0) {
								this.state.focus_stack[this.state.focus_stack.length - 1].messageIndex = conversation.length;
							}
						} else if (fc.tool === 'complete_focus') {
							this.focusCompleteFocus(fc.summary, conversation);
							// Reinject knowledge block after compression
							const updatedKB = this.focusFormatKnowledgeBlock();
							if (conversation.length > 0 && conversation[0].role === 'system') {
								// Update system prompt with new knowledge block
								conversation[0].content = conversation[0].content.replace(
									/=== KNOWLEDGE BLOCK[\s\S]*?=== END KNOWLEDGE BLOCK ===\n/g, ''
								) + '\n' + updatedKB;
							}
						}
					}

					// Check for solution
					if (response.includes('<solution>')) {
						solution = response;
						this.log(`[${label}] Solution found in round ${round}`);
						break;
					}

					// Continue conversation
					conversation.push({ role: 'assistant', content: response });

					// If no progress, prompt for solution
					if (round === maxRounds - 1) {
						conversation.push({ role: 'user', content: 'Please provide your final solution now in <solution>...</solution> tags.' });
					}
				}

				this.log(`[${label}] Completed. Steps: ${stepCount}, Compressions: ${this.state.focus_totalCompressions}, Messages dropped: ${this.state.focus_messagesDropped}`);
				return solution || '(No solution generated)';
			}

			// Standalone Focus Architecture
			async runFocusArchitecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;
				this.focusEnsureState();

				const label = 'Focus';
				const MAX_ROUNDS = 8;
				const PASS_STREAK_TARGET = 3;

				this.log(`=== Focus (Active Context Compression) Architecture ===`);
				this.log(`[${label}] Slime mold-inspired autonomous context management.`);
				this.log(`[${label}] Knowledge Block entries: ${this.state.focus_knowledgeBlock.length}`);

				try {
					let solution = '';
					let passStreak = 0;

					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						this.log(`=== Round ${round}/${MAX_ROUNDS} ===`);

						// Solve with Focus compression
						solution = await this.focusSolveWithCompression(query, { maxRounds: 20, label, compressInterval: 12 });

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						// Verify solution
						const verifyResult = await this.test43VerifySolutionStrict(query, solution);

						if (verifyResult && verifyResult.isPass) {
							passStreak++;
							this.log(`[${label}] Verification PASS. Streak: ${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.log(`[${label}] Pass streak target reached. Finalizing.`);
								this.finalize(solution, true);
								return;
							}
						} else {
							passStreak = 0;
							const reason = (verifyResult && verifyResult.reason) || 'unknown';
							this.log(`[${label}] Verification FAIL: ${reason}`);

							// Store failure as knowledge
							if (reason && reason.length > 10) {
								this.state.focus_knowledgeBlock.push({
									goal: 'Avoid error pattern',
									attempted: 'Previous solution attempt',
									learned: reason.slice(0, 300),
									outcome: 'FAIL - avoid this approach',
									timestamp: Date.now()
								});
							}
						}
					}

					// Finalize with best effort
					this.log(`[${label}] Max rounds reached. Finalizing best solution.`);
					this.finalize(solution || '(No valid solution)', !!solution);

				} catch (e) {
					if (e.message === 'Stopped') {
						this.updateStatusUI('Stopped', 'orange');
					} else {
						this.log(`[${label}] Error: ${e.message}`);
						this.updateStatusUI('Error', 'red');
					}
					this.stopTimer();
				}
			}

			// === SimpleMem: Efficient Lifelong Memory (Semantic Compression) ===
			// Reference: "SimpleMem: Efficient Lifelong Memory for LLM Agents"
			// https://arxiv.org/abs/2601.02553
			//
			// SimpleMem framework:
			// - Stage 1: Semantic Structured Compression (entropy filter + context normalization)
			// - Stage 2: Recursive Memory Consolidation (multi-view index + clustering)
			// - Stage 3: Adaptive Query-Aware Retrieval (hybrid scoring + dynamic depth)

			simpleMemEnsureState() {
				if (!this.state.simplemem_memory) this.state.simplemem_memory = [];
				if (!this.state.simplemem_abstracts) this.state.simplemem_abstracts = [];
				if (!this.state.simplemem_stats) this.state.simplemem_stats = {
					filtered: 0, stored: 0, consolidated: 0, retrieved: 0
				};
			}

			// Stage 1: Semantic Structured Compression
			// Compute information score (entropy-aware filtering)
			simpleMemComputeInfoScore(newContent, prevContent) {
				const newWords = new Set((newContent || '').toLowerCase().split(/\s+/).filter(w => w.length > 2));
				const prevWords = new Set((prevContent || '').toLowerCase().split(/\s+/).filter(w => w.length > 2));

				// Entity novelty: words in new but not in prev
				const newEntities = [...newWords].filter(w => !prevWords.has(w));
				const entityNovelty = newWords.size > 0 ? newEntities.length / newWords.size : 0;

				// Semantic divergence (simplified cosine distance proxy)
				const intersection = [...newWords].filter(w => prevWords.has(w)).length;
				const union = new Set([...newWords, ...prevWords]).size;
				const similarity = union > 0 ? intersection / union : 1;
				const semanticNovelty = 1 - similarity;

				// Combined score (Œ± = 0.4 as per paper)
				const alpha = 0.4;
				return alpha * entityNovelty + (1 - alpha) * semanticNovelty;
			}

			// Filter low-information content (œÑ = 0.35)
			simpleMemShouldStore(content, context) {
				const score = this.simpleMemComputeInfoScore(content, context);
				const threshold = 0.35;
				return score >= threshold;
			}

			// Context normalization: resolve pronouns and temporal expressions
			async simpleMemNormalizeContext(content, query) {
				// For efficiency, use a single LLM call to normalize
				const prompt = `Normalize the following text by:
1. Replacing pronouns (e.g., "he", "it", "this") with specific entity names
2. Converting relative time expressions (e.g., "yesterday", "next week") to context-aware descriptions
3. Making each statement self-contained and interpretable without prior context

Text to normalize:
${content.slice(0, 2000)}

Output the normalized text directly (max 500 chars).`;

				try {
					const normalized = await this.callAPI(
						[{ role: 'system', content: 'You are a text normalizer. Output only the normalized text.' },
						{ role: 'user', content: prompt }],
						null,
						{ temperature: 0.1 }
					);
					return (normalized || content).toString().trim().slice(0, 600);
				} catch (e) {
					this.log(`[SimpleMem] Normalize error: ${e.message}`);
					return content.slice(0, 600);
				}
			}

			// Decompose into atomic memory units
			async simpleMemDecomposeToUnits(content, query) {
				const prompt = `Decompose the following text into minimal, independent factual statements.
Each statement should be self-contained and understandable without context.
Output one statement per line, no numbering.

Text:
${content.slice(0, 3000)}

Output (one fact per line):`;

				try {
					const result = await this.callAPI(
						[{ role: 'system', content: 'You decompose text into atomic factual statements. Be concise.' },
						{ role: 'user', content: prompt }],
						null,
						{ temperature: 0.1 }
					);
					const lines = (result || '').split('\n').map(l => l.trim()).filter(l => l.length > 10);
					return lines.slice(0, 10); // Limit to 10 units per decomposition
				} catch (e) {
					this.log(`[SimpleMem] Decompose error: ${e.message}`);
					return [content.slice(0, 300)];
				}
			}

			// Add memory unit with multi-view indexing
			simpleMemAddUnit(content, metadata = {}) {
				this.simpleMemEnsureState();
				const id = `sm_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
				const entry = {
					id,
					content: (content || '').toString().trim().slice(0, 500),
					// Lexical layer: keyword extraction
					keywords: (content || '').toLowerCase().match(/\b[a-z]{4,}\b/g)?.slice(0, 10) || [],
					// Symbolic layer: metadata
					tag: metadata.tag || 'fact',
					timestamp: Date.now(),
					round: metadata.round || 0,
					type: metadata.type || 'atomic'
				};
				this.state.simplemem_memory.push(entry);
				this.state.simplemem_stats.stored++;
				this.log(`[SimpleMem] STORE: id=${id}, len=${entry.content.length}, tag=${entry.tag}`);
				return entry;
			}

			// Stage 2: Recursive Memory Consolidation
			// Compute affinity score between two memory units
			simpleMemComputeAffinity(m1, m2) {
				// Semantic similarity (keyword overlap proxy)
				const k1 = new Set(m1.keywords || []);
				const k2 = new Set(m2.keywords || []);
				const intersection = [...k1].filter(k => k2.has(k)).length;
				const union = new Set([...k1, ...k2]).size;
				const semanticSim = union > 0 ? intersection / union : 0;

				// Temporal proximity
				const timeDiff = Math.abs((m1.timestamp || 0) - (m2.timestamp || 0));
				const lambda = 0.0001; // Decay factor
				const temporalSim = Math.exp(-lambda * timeDiff);

				// Combined affinity (Œ≤ = 0.7)
				const beta = 0.7;
				return beta * semanticSim + (1 - beta) * temporalSim;
			}

			// Consolidate related memory units into abstract representation
			async simpleMemConsolidate(clusterThreshold = 0.85) {
				this.simpleMemEnsureState();
				if (this.state.simplemem_memory.length < 3) return;

				// Find dense clusters
				const units = [...this.state.simplemem_memory];
				const clusters = [];
				const used = new Set();

				for (let i = 0; i < units.length; i++) {
					if (used.has(i)) continue;
					const cluster = [units[i]];
					used.add(i);

					for (let j = i + 1; j < units.length; j++) {
						if (used.has(j)) continue;
						const affinity = this.simpleMemComputeAffinity(units[i], units[j]);
						if (affinity >= clusterThreshold) {
							cluster.push(units[j]);
							used.add(j);
						}
					}

					if (cluster.length >= 2) {
						clusters.push(cluster);
					}
				}

				// Synthesize abstracts for clusters
				for (const cluster of clusters) {
					const combined = cluster.map(c => c.content).join('\n');
					const abstractId = `sm_abs_${Date.now()}_${Math.random().toString(36).slice(2, 4)}`;

					try {
						const prompt = `Synthesize these related facts into a single high-level pattern or generalization:

${combined}

Output a single concise statement (max 100 chars) capturing the common pattern.`;

						const abstract = await this.callAPI(
							[{ role: 'system', content: 'You synthesize patterns from facts. Be extremely concise.' },
							{ role: 'user', content: prompt }],
							null,
							{ temperature: 0.2 }
						);

						this.state.simplemem_abstracts.push({
							id: abstractId,
							content: (abstract || '').toString().trim().slice(0, 150),
							sources: cluster.map(c => c.id),
							timestamp: Date.now()
						});

						// Archive original units (remove from active memory)
						for (const m of cluster) {
							const idx = this.state.simplemem_memory.findIndex(x => x.id === m.id);
							if (idx >= 0) this.state.simplemem_memory.splice(idx, 1);
						}

						this.state.simplemem_stats.consolidated++;
						this.log(`[SimpleMem] CONSOLIDATE: ${cluster.length} units ‚Üí abstract ${abstractId}`);
					} catch (e) {
						this.log(`[SimpleMem] Consolidate error: ${e.message}`);
					}
				}
			}

			// Stage 3: Adaptive Query-Aware Retrieval
			// Estimate query complexity
			simpleMemEstimateComplexity(query) {
				const q = (query || '').toString().trim();
				let complexity = 0;

				// Length factor
				if (q.length > 200) complexity += 0.2;
				if (q.length > 500) complexity += 0.1;

				// Multi-step indicators
				if (/\b(and|then|after|before|also|both|all)\b/i.test(q)) complexity += 0.2;
				if (/\b(why|how|explain|analyze|compare)\b/i.test(q)) complexity += 0.2;
				if (/\b(if|when|unless|given that)\b/i.test(q)) complexity += 0.1;

				// Quantifier complexity
				if (/\b(every|all|any|some|none|each)\b/i.test(q)) complexity += 0.15;

				return Math.min(1, Math.max(0, complexity));
			}

			// Hybrid retrieval with adaptive depth
			simpleMemRetrieve(query, options = {}) {
				this.simpleMemEnsureState();
				const q = (query || '').toString().toLowerCase();
				const qWords = q.split(/\s+/).filter(w => w.length > 2);

				// Estimate complexity for adaptive depth
				const complexity = this.simpleMemEstimateComplexity(query);
				const kBase = options.kBase || 5;
				const delta = 3;
				const kDyn = Math.floor(kBase * (1 + delta * complexity));
				const kMin = options.kMin || 3;
				const kMax = options.kMax || 20;
				const k = Math.max(kMin, Math.min(kMax, kDyn));

				// Score all memory units
				const allItems = [
					...this.state.simplemem_abstracts.map(m => ({ ...m, isAbstract: true })),
					...this.state.simplemem_memory.map(m => ({ ...m, isAbstract: false }))
				];

				const scored = allItems.map(item => {
					const content = (item.content || '').toLowerCase();
					const keywords = item.keywords || [];

					// Semantic score (word overlap)
					const semanticScore = qWords.filter(w => content.includes(w)).length / Math.max(1, qWords.length);

					// Lexical score (keyword match)
					const lexicalScore = qWords.filter(w => keywords.includes(w)).length / Math.max(1, qWords.length);

					// Abstract boost (prefer high-level for complex queries)
					const abstractBoost = item.isAbstract ? (complexity * 0.2) : 0;

					// Combined score (Œª1=0.5, Œª2=0.3, Œ≥=0.2)
					const score = 0.5 * semanticScore + 0.3 * lexicalScore + 0.2 * abstractBoost;

					return { item, score };
				});

				// Sort and return top-k
				scored.sort((a, b) => b.score - a.score);
				const results = scored.slice(0, k).filter(s => s.score > 0).map(s => s.item);

				this.state.simplemem_stats.retrieved += results.length;
				this.log(`[SimpleMem] RETRIEVE: complexity=${complexity.toFixed(2)}, k=${k}, found=${results.length}`);

				return results;
			}

			// Format retrieved memory for prompt
			simpleMemFormatForPrompt(retrievedItems) {
				if (!retrievedItems || retrievedItems.length === 0) return '';

				const abstractSection = retrievedItems
					.filter(r => r.isAbstract)
					.map((r, i) => `[Pattern ${i + 1}] ${r.content}`)
					.join('\n');

				const factSection = retrievedItems
					.filter(r => !r.isAbstract)
					.map((r, i) => `[Fact ${i + 1}] ${r.content}`)
					.join('\n');

				const parts = [];
				if (abstractSection) parts.push(`<abstract_patterns>\n${abstractSection}\n</abstract_patterns>`);
				if (factSection) parts.push(`<detailed_facts>\n${factSection}\n</detailed_facts>`);

				return parts.length > 0 ? `<retrieved_memory>\n${parts.join('\n')}\n</retrieved_memory>` : '';
			}

			// Main SimpleMem solve
			async simpleMemSolve(query, options = {}) {
				this.simpleMemEnsureState();
				const maxRounds = options.maxRounds || 5;
				const label = options.label || 'SimpleMem';

				let solution = '';
				let prevContext = '';

				for (let round = 1; round <= maxRounds; round++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

					this.log(`[${label}] Round ${round}/${maxRounds}`);

					// Retrieve relevant memory
					const retrieved = this.simpleMemRetrieve(query);
					const memoryContext = this.simpleMemFormatForPrompt(retrieved);

					// Build prompt with memory
					const sysPrompt = `You are a mathematical problem solver with access to prior knowledge.
${memoryContext}

Solve the problem using your knowledge and the retrieved memory above.
Provide your solution in <solution>...</solution> tags with <detailed>...</detailed> for reasoning.`;

					const response = await this.callAPI(
						[{ role: 'system', content: sysPrompt },
						{ role: 'user', content: query }],
						(txt) => txt.includes('<solution>'),
						{ temperature: 0.3, iterations: 3 }
					);

					// Check if we should store this response
					if (this.simpleMemShouldStore(response, prevContext)) {
						// Normalize and decompose
						const normalized = await this.simpleMemNormalizeContext(response, query);
						const units = await this.simpleMemDecomposeToUnits(normalized, query);

						for (const unit of units) {
							this.simpleMemAddUnit(unit, { tag: 'insight', round });
						}
					} else {
						this.state.simplemem_stats.filtered++;
						this.log(`[${label}] Content filtered (low info score)`);
					}

					prevContext = response;
					solution = response;

					// Periodic consolidation
					if (round % 2 === 0) {
						await this.simpleMemConsolidate(0.85);
					}

					// Check if solution found
					if (response.includes('<solution>')) {
						this.log(`[${label}] Solution found in round ${round}`);
						break;
					}
				}

				return solution || '(No solution generated)';
			}

			// Standalone SimpleMem Architecture
			async runSimpleMemArchitecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;
				this.simpleMemEnsureState();

				const label = 'SimpleMem';
				const MAX_ROUNDS = 8;
				const PASS_STREAK_TARGET = 3;

				this.log(`=== SimpleMem (Semantic Lossless Compression) Architecture ===`);
				this.log(`[${label}] 3-stage pipeline: Compression ‚Üí Consolidation ‚Üí Adaptive Retrieval`);
				this.log(`[${label}] Memory units: ${this.state.simplemem_memory.length}, Abstracts: ${this.state.simplemem_abstracts.length}`);

				try {
					let solution = '';
					let passStreak = 0;

					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						this.log(`=== Round ${round}/${MAX_ROUNDS} ===`);

						// Solve with SimpleMem
						solution = await this.simpleMemSolve(query, { maxRounds: 5, label });

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						// Verify solution
						const verifyResult = await this.test43VerifySolutionStrict(query, solution);

						if (verifyResult && verifyResult.isPass) {
							passStreak++;
							this.log(`[${label}] Verification PASS. Streak: ${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.log(`[${label}] Pass streak target reached. Finalizing.`);
								this.finalize(solution, true);
								return;
							}
						} else {
							passStreak = 0;
							const reason = (verifyResult && verifyResult.reason) || 'unknown';
							this.log(`[${label}] Verification FAIL: ${reason}`);

							// Store failure pattern for avoidance
							if (reason && reason.length > 10) {
								this.simpleMemAddUnit(`Avoid: ${reason.slice(0, 200)}`, { tag: 'failure_pattern', round });
							}
						}
					}

					// Finalize with best effort
					this.log(`[${label}] Max rounds reached. Finalizing best solution.`);
					this.finalize(solution || '(No valid solution)', !!solution);

				} catch (e) {
					if (e.message === 'Stopped') {
						this.updateStatusUI('Stopped', 'orange');
					} else {
						this.log(`[${label}] Error: ${e.message}`);
						this.updateStatusUI('Error', 'red');
					}
					this.stopTimer();
				}
			}

			// === PaCoRe: Parallel Coordinated Reasoning (StepFun paper adaptation) ===
			// Reference: https://arxiv.org/abs/2601.05593
			//
			// PaCoRe framework:
			// 1. Generate K parallel reasoning trajectories
			// 2. Compact each trajectory into a short message (extract conclusion)
			// 3. Synthesize messages into next round (or final answer)

			pacoreExtractCompactMessage(response) {
				// Extract content after </think> (reasoning content compaction)
				const raw = (response || '').toString();
				const thinkEnd = raw.lastIndexOf('</think>');
				if (thinkEnd >= 0) {
					return raw.slice(thinkEnd + 8).trim();
				}
				// Fallback: try to extract detailed solution part
				const detailed = this.test21ExtractDetailedFromSolution(raw);
				if (detailed && detailed.length > 20) return detailed;
				// Last resort: return last 2000 chars
				return raw.slice(-2000).trim();
			}

			pacoreFormatSynthesisPrompt(originalProblem, refResponses) {
				// Format controller prompt as in PaCoRe paper (Appendix Table 6)
				const refBlock = refResponses.map((r, i) =>
					`Reference ${i + 1}:\n${r}`
				).join('\n\n');

				return `You are given a problem and a list of reference responses. Your job is to analyze these references and provide your own response.

Original Problem:
${originalProblem}

Reference Responses:
${refBlock}

Now, based on the original problem and reference responses above, please provide your own comprehensive solution.`;
			}

			async pacoreGenerateParallelTrajectories(query, k, options = {}) {
				const n = Math.max(1, Math.min(32, parseInt(k, 10) || 4));
				const temperature = options.temperature ?? 1.0;
				const label = options.label || 'pacore';

				// Generate K parallel trajectories using Promise.all
				const tasks = [];
				for (let i = 0; i < n; i++) {
					const task = this.test48SolveOnceSolutionXml(query, { temperature });
					tasks.push(task);
				}

				this.log(`[${label}] Generating ${n} parallel trajectories...`);
				const results = await Promise.all(tasks);
				this.log(`[${label}] Generated ${results.filter(r => r).length}/${n} trajectories.`);

				return results;
			}

			// --- SciIdea Standalone Architecture ---
			async runSciIdeaArchitecture(query, label) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const isLite = label === 'sciidea-lite';
				const MAX_ROUNDS = isLite ? 5 : 8;
				const PASS_STREAK_TARGET = 3;

				this.log(`=== SciIdea Architecture (${label}) ===`);
				this.log(`[SciIdea] Mode: ${isLite ? 'Lite (CoI + Persona only)' : 'Full (CoI + Persona + Debate)'}`);

				try {
					// Phase 1: Knowledge Augmentation (Chain-of-Ideas)
					const coiContext = await this.sciIdeaGenerateCoIContext(query);
					this.log(`[SciIdea] CoI context generated (${coiContext.length} chars).`);

					const personas = this.getSciIdeaPersonas();
					let personaIdx = 0;
					let solution = '';
					let passStreak = 0;

					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						// Phase 2: Prompt Steering (Persona rotation)
						const persona = personas[personaIdx % personas.length];
						personaIdx++;

						this.log(`=== Round ${round}/${MAX_ROUNDS} (Persona: ${persona.name}) ===`);

						const memoryBlock = solution ? `Previous attempt:\n${this.test21ExtractDetailedFromSolution(solution) || solution}\n\n` : '';
						const solvePrompt = `Problem: ${query}

Context (Chain-of-Ideas):
${coiContext}

${memoryBlock}Solve this problem following ${persona.name} approach: ${persona.note}

Provide your complete solution in <solution>...</solution> tags with <detailed>...</detailed> for step-by-step reasoning.`;

						solution = await this.callAPI(
							[{ role: 'system', content: `You are a ${persona.name}. ${persona.note}` }, { role: 'user', content: solvePrompt }],
							(txt) => txt.includes('<solution>'),
							{ temperature: 0.3, iterations: 3 }
						);

						// Phase 3: Multi-Agent Debate (full mode only)
						if (!isLite) {
							const feedback = await this.sciIdeaDebateRound(query, solution, 3);
							const hasIssues = feedback && !feedback.toLowerCase().includes('no significant issues') && !feedback.toLowerCase().includes('no major issues');
							if (hasIssues) {
								this.log(`[SciIdea] Debate found issues; refining...`);
								passStreak = 0;
								continue;
							}
						}

						// Verification
						const verifyResult = await this.test43VerifySolutionStrict(query, solution);

						if (verifyResult && verifyResult.isPass) {
							passStreak++;
							this.log(`[SciIdea] Verification passed. Streak: ${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.finalize(solution, true);
								return;
							}
						} else {
							passStreak = 0;
							this.log(`[SciIdea] Verification failed: ${(verifyResult && verifyResult.reason) || 'unknown'}`);
						}
					}

					this.finalize(solution || '(No valid solution)', !!solution);
				} catch (e) {
					if (e.message === 'Stopped') {
						this.updateStatusUI('Stopped', 'orange');
					} else {
						this.log(`[SciIdea] Error: ${e.message}`);
						this.updateStatusUI('Error', 'red');
					}
					this.stopTimer();
				}
			}

			async runPaCoreArchitecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const label = 'pacore';
				const K = 4; // Low setting: 4 parallel trajectories

				this.log(`=== PaCoRe (Parallel Coordinated Reasoning) ===`);
				this.log(`[${label}] Config: K=${K} parallel trajectories ‚Üí compact ‚Üí synthesize.`);

				// Phase 1: Generate K parallel trajectories
				this.log(`[${label}] Phase 1: Parallel exploration (K=${K})...`);
				const trajectories = await this.pacoreGenerateParallelTrajectories(query, K, { label });

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) {
					return this.handleFinalResult('Stopped', '', '');
				}

				// Phase 2: Message compaction (extract conclusions)
				this.log(`[${label}] Phase 2: Message compaction...`);
				const compactedMessages = trajectories.map(t => this.pacoreExtractCompactMessage(t));
				const validMessages = compactedMessages.filter(m => m && m.length > 20);
				this.log(`[${label}] Compacted ${validMessages.length}/${trajectories.length} valid messages.`);

				if (!validMessages.length) {
					this.log(`[${label}] No valid compacted messages. Using first trajectory as fallback.`);
					const solution = trajectories[0] || '';
					const verification = await this.test21VerifyMathSolution(query, solution);
					return this.handleFinalResult(verification.isGood ? 'PASS' : 'FAIL', solution, verification.bugReport || '');
				}

				// Phase 3: Synthesis (final round with K=1)
				this.log(`[${label}] Phase 3: Final synthesis...`);
				const synthesisPrompt = this.pacoreFormatSynthesisPrompt(query, validMessages);
				const finalSolution = await this.test40IcrSolveSolution(synthesisPrompt, {}, label, { iterations: 3 });
				const solution = finalSolution.solution || '';

				if (this.stopFlag || GLOBAL_EMERGENCY_STOP) {
					return this.handleFinalResult('Stopped', '', '');
				}

				// Verify final solution
				this.log(`[${label}] Verifying synthesized solution...`);
				const verification = await this.test21VerifyMathSolution(query, solution);

				const totalTokens = this.state.metrics?.tokens || 0;
				const totalCalls = this.state.metrics?.calls || 0;
				this.log(`[${label}] Final: ${verification.isGood ? 'PASS' : 'FAIL'} (tokens=${totalTokens}, calls=${totalCalls})`);

				return this.handleFinalResult(verification.isGood ? 'PASS' : 'FAIL', solution, verification.bugReport || '');
			}

			parseTest43VerbalizedDiagnoses(rawText, maxItems = 10) {
				const raw = (rawText || '').toString().trim();
				if (!raw) return [];
				const cleaned = raw.replace(/```(?:json)?/gi, '').replace(/```/g, '').trim();

				const tryParseJson = (s) => {
					const start = s.indexOf('{');
					const end = s.lastIndexOf('}');
					if (start < 0 || end <= start) return null;
					try { return JSON.parse(s.slice(start, end + 1)); } catch { return null; }
				};

				const obj = tryParseJson(cleaned);
				const arr = obj && (Array.isArray(obj.diagnoses) ? obj.diagnoses : (Array.isArray(obj.responses) ? obj.responses : null));
				if (!arr) return [];

				const out = [];
				for (const item of arr) {
					if (!item) continue;
					const text = (item.text || item.diagnosis || item.analysis || '').toString().trim();
					if (!text) continue;
					const probRaw = (item.probability ?? item.prob ?? item.p);
					const probability = Number.isFinite(probRaw) ? probRaw : parseFloat(probRaw);
					out.push({
						text,
						probability: Number.isFinite(probability) ? Math.max(0, Math.min(1, probability)) : null,
					});
					if (out.length >= maxItems) break;
				}

				const probs = out.map(o => (o.probability ?? NaN)).filter(Number.isFinite);
				const fallbackProb = probs.length ? null : (out.length ? (1 / out.length) : null);
				for (const o of out) {
					let p = Number.isFinite(o.probability) ? o.probability : fallbackProb;
					if (!Number.isFinite(p)) p = 0;
					o.probability = p;
				}

				const dedup = [];
				const seen = new Set();
				for (const o of out) {
					const key = this.normalizeForHash(o.text).slice(0, 800);
					if (!key || seen.has(key)) continue;
					seen.add(key);
					dedup.push(o);
					if (dedup.length >= maxItems) break;
				}

				dedup.sort((a, b) => (b.probability - a.probability));
				return dedup;
			}

			async generateTest43VerbalizedDiagnoses(query, solutionText, k) {
				const n = Math.max(2, Math.min(10, parseInt(k, 10) || 0));

				const sys = `You are a flaw diagnostician.
Generate ${n} materially different diagnoses of what is wrong/weak/missing in the response (or what ambiguous assumption likely breaks it).
Do NOT propose fixes. Do NOT solve the problem.

Return ONLY a JSON object in this exact schema:
{
  "diagnoses": [
    { "text": "string", "probability": 0.0 }
  ]
}

Rules:
- Produce exactly ${n} diagnoses.
- Each diagnosis must be meaningfully different (different suspected flaw, different ambiguity, different missing step).
- "probability" is your estimated likelihood (0.0‚Äì1.0) this diagnosis is the key failure mode.`;

				const user = `Problem:
${query}

Response to diagnose:
${solutionText}`;

				const resp = await this.callAPI(
					[{ role: 'system', content: sys }, { role: 'user', content: user }],
					null,
					{ temperature: 0.8 }
				);
				return this.parseTest43VerbalizedDiagnoses(resp, 12);
			}

			async test43BuildOverlapDiagnosis(query, solution, options = {}) {
				const clampInt = (v, min, max) => {
					const n = parseInt(v, 10);
					if (!Number.isFinite(n)) return null;
					return Math.min(max, Math.max(min, n));
				};

				const vsDiagK = clampInt(options.vsDiagK, 2, 10) ?? 0;
				if (vsDiagK < 2) {
					const diagA = await this.test31DiagnoseFlaw(query, solution);
					const diagB = await this.test31DiagnoseFlaw(query, solution);
					const overlaps = await this.test31FindOverlapBetweenDiagnoses(diagA, diagB);
					if (!overlaps.length) return null;
					const overlapPart = overlaps[0];
					const isRealFlaw = await this.test31ValidateFlaw(query, solution, overlapPart);
					if (!isRealFlaw) return null;
					const diagnosis = `${diagA}\n\n${diagB}\n\nOverlapping focus:\n${overlapPart}`;
					return { overlapPart, diagnosis };
				}

				let diags = [];
				try {
					diags = await this.generateTest43VerbalizedDiagnoses(query, solution, vsDiagK);
				} catch {
					diags = [];
				}
				if (!Array.isArray(diags) || diags.length < 2) {
					const diagA = await this.test31DiagnoseFlaw(query, solution);
					const diagB = await this.test31DiagnoseFlaw(query, solution);
					const overlaps = await this.test31FindOverlapBetweenDiagnoses(diagA, diagB);
					if (!overlaps.length) return null;
					const overlapPart = overlaps[0];
					const isRealFlaw = await this.test31ValidateFlaw(query, solution, overlapPart);
					if (!isRealFlaw) return null;
					const diagnosis = `${diagA}\n\n${diagB}\n\nOverlapping focus:\n${overlapPart}`;
					return { overlapPart, diagnosis };
				}

				const triedPairs = [];
				const maxA = Math.min(3, diags.length);
				for (let i = 0; i < maxA; i++) {
					const a = diags[i]?.text || '';
					if (!a) continue;
					const setA = this.test43WordSetForDiversity(a);
					let best = null;
					for (let j = 0; j < diags.length; j++) {
						if (j === i) continue;
						const b = diags[j]?.text || '';
						if (!b) continue;
						const sim = this.test43JaccardSimilarity(setA, this.test43WordSetForDiversity(b));
						const pb = Number.isFinite(diags[j]?.probability) ? diags[j].probability : 0;
						if (!best || sim < best.sim - 1e-9 || (Math.abs(sim - best.sim) < 1e-9 && pb > best.p)) {
							best = { text: b, sim, p: pb };
						}
					}
					if (best && best.text) {
						const key = `${this.normalizeForHash(a).slice(0, 300)}|${this.normalizeForHash(best.text).slice(0, 300)}`;
						if (!triedPairs.includes(key)) triedPairs.push(key);

						const overlaps = await this.test31FindOverlapBetweenDiagnoses(a, best.text);
						if (!overlaps.length) continue;
						const overlapPart = overlaps[0];
						const isRealFlaw = await this.test31ValidateFlaw(query, solution, overlapPart);
						if (!isRealFlaw) continue;
						const diagnosis = `${a}\n\n${best.text}\n\nOverlapping focus:\n${overlapPart}`;
						return { overlapPart, diagnosis };
					}
				}

				return null;
			}

			test43IsOverlapStrong(overlap) {
				const part = (overlap && overlap.overlapPart) ? overlap.overlapPart.toString() : '';
				return part.length >= 40;
			}

			test43AdaptiveSolveTemperature(failStreak) {
				const base = 0.12;
				const dec = Math.max(0, Math.min(0.06, (failStreak - 1) * 0.01));
				const t = base - dec;
				return Math.max(0.05, Math.min(0.12, t));
			}

			async runTest43VariantArchitecture(query, label) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const flags = this.parseTest43VariantFlags(label);
				const __label = (label || '').toString();
				const __t43_2_extra = __label.startsWith('test43-2') ? __label.slice('test43-2'.length) : '';
				const __t43_2_match = __t43_2_extra.match(/^([a-z]+)/i);
				const __t43_2_candidate = (__t43_2_match ? __t43_2_match[1] : '').toLowerCase();
				const __t43_2_flags = (/^[a-h]+$/.test(__t43_2_candidate) ? __t43_2_candidate : '');
				const __t43_2_opts = __t43_2_flags ? __t43_2_extra.slice(__t43_2_flags.length) : __t43_2_extra;
				const __optInt = (re, min, max) => {
					try {
						const m = (__t43_2_opts || '').match(re);
						if (!m) return null;
						const n = parseInt(m[1], 10);
						if (!Number.isFinite(n)) return null;
						return Math.min(max, Math.max(min, n));
					} catch { return null; }
				};

				const useOverlapAgreement = __t43_2_flags.includes('a');
				const skipCorrectionWithoutOverlap = __t43_2_flags.includes('b');
				const capCorrectionsPerRound = __t43_2_flags.includes('c');
				const resetOnSameFailure = __t43_2_flags.includes('d');
				const requireSameFailureTwice = __t43_2_flags.includes('e');
				const overlapStrengthGate = __t43_2_flags.includes('f');
				const adaptiveTemperature = __t43_2_flags.includes('g');
				const doubleVerifyGate = __t43_2_flags.includes('h');
				const vsDiagK = __optInt(/(?:^|[^a-z])vsdiag(\d+)/i, 0, 12) ?? 0;
				const freeformInit = /(?:^|[^a-z])nlinit(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const freeformFull = /(?:^|[^a-z])nlfull(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const useFreeformInit = freeformFull || freeformInit;
				const scK = __optInt(/(?:^|[^a-z])sc(\d+)/i, 0, 12) ?? 0;
				const vsscK = __optInt(/(?:^|[^a-z])vssc(\d+)/i, 0, 12) ?? 0;
				const beliefK = __optInt(/(?:^|[^a-z])belief(\d+)/i, 0, 8) ?? 0;
				const method3 = /(?:^|[^a-z])method3(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const mctsK = __optInt(/(?:^|[^a-z])mcts(\d+)/i, 0, 12) ?? 0;
				const valuePickK = __optInt(/(?:^|[^a-z])valuepick(\d+)/i, 0, 12) ?? 0;
				const totCorrK = __optInt(/(?:^|[^a-z])totcorr(\d+)/i, 0, 8) ?? 0;
				const vsRedK = __optInt(/(?:^|[^a-z])vsred(\d+)/i, 0, 8) ?? 0;
				const procsup = /(?:^|[^a-z])procsup(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const deltaSum = /(?:^|[^a-z])deltasum(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const quietPass = /(?:^|[^a-z])quietpass(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const ans2Gate = /(?:^|[^a-z])ans2(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const noMemory = /(?:^|[^a-z])nomem(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const useHiddenState = /(?:^|[^a-z])hstate(?:$|[^a-z])/i.test(__t43_2_opts || '') || /(?:^|[^a-z])hs(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const goalStack = /(?:^|[^a-z])goalstack(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const initAgree = /(?:^|[^a-z])initagree(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const banAns = /(?:^|[^a-z])banans(?:$|[^a-z])/i.test(__t43_2_opts || '');
				const samek = __optInt(/(?:^|[^a-z])samek(\d+)/i, 1, 5) ?? 1;
				const seed37 = /(?:^|[^a-z])seed37/i.test(__t43_2_opts || '');
				const pacoreK = __optInt(/(?:^|[^a-z])pacore(\d+)/i, 0, 32) ?? 0; // PaCoRe parallel init
					// SciIdea Survey flags (Chain-of-Ideas, Persona, Debate)
					const sciideaCoI = /(?:^|[^a-z])coi(?:$|[^a-z])/i.test(__t43_2_opts || '');
					const sciideaPersona3 = /(?:^|[^a-z])persona3(?:$|[^a-z])/i.test(__t43_2_opts || '');
					const sciideaDebateK = __optInt(/(?:^|[^a-z])debate(\d+)/i, 0, 8) ?? 0;
						// Society-of-Thought (SoT) + Verbalized Sampling (VS) labs
						const sotK = __optInt(/(?:^|[^a-z])sot(\d+)/i, 0, 6) ?? 0;
						const sotLite = /(?:^|[^a-z])sotlite(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const sotCrit = /(?:^|[^a-z])sotcrit(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const sotCorr = /(?:^|[^a-z])sotcorr(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const discourseMarkers = /(?:^|[^a-z])markers(?:$|[^a-z])/i.test(__t43_2_opts || '') || /(?:^|[^a-z])dmark(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const optGrid = /(?:^|[^a-z])optgrid(?:$|[^a-z])/i.test(__t43_2_opts || '') || /(?:^|[^a-z])optguard(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const optFirst = /(?:^|[^a-z])optfirst(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const optMix = /(?:^|[^a-z])optmix(?:$|[^a-z])/i.test(__t43_2_opts || '') || /(?:^|[^a-z])optboth(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const refuteK = __optInt(/(?:^|[^a-z])refute(\d+)/i, 0, 12) ?? 0;
						const vsTunePct = __optInt(/(?:^|[^a-z])vstune(\d+)/i, 0, 99) ?? 0;
						const vsTuneHard = /(?:^|[^a-z])vstunehard(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const blindAnsK = __optInt(/(?:^|[^a-z])blindans(\d+)/i, 0, 8) ?? 0;
						const blindRaw = /(?:^|[^a-z])blindraw(?:$|[^a-z])/i.test(__t43_2_opts || '');
						// Prompt Repetition (per Leviathan et al., 2025): repeat the input query in the prefill stage.
						const prepeatN = __optInt(/(?:^|[^a-z])prepeat(\d+)/i, 0, 5) ?? 0;
						const prepeatVerbose = /(?:^|[^a-z])prepeatv(?:$|[^a-z])/i.test(__t43_2_opts || '') || /(?:^|[^a-z])prepeatverbose(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const prepeatFull = /(?:^|[^a-z])prepeatfull(?:$|[^a-z])/i.test(__t43_2_opts || '');
						// Padding control (paper ablation): match length without repeating semantics.
						const ppadN = __optInt(/(?:^|[^a-z])ppad(\d+)/i, 0, 5) ?? 0;
						// Recursive Self-Aggregation (RSA) lab
						const rsaN = __optInt(/(?:^|[^a-z])rsan(\d+)/i, 0, 64) ?? 0;
						const rsaK = __optInt(/(?:^|[^a-z])rsak(\d+)/i, 0, 16) ?? 0;
						const rsaT = __optInt(/(?:^|[^a-z])rsat(\d+)/i, 0, 20) ?? 0;
					const vsDivPick = /(?:^|[^a-z])vsdiv(?:$|[^a-z])/i.test(__t43_2_opts || '');
					const pacoreCap = __optInt(/(?:^|[^a-z])pacorecap(\d+)/i, 200, 20000) ?? 0;
					const useAgeMem = /(?:^|[^a-z])agemem(?:$|[^a-z])/i.test(__t43_2_opts || '');
					const useFocus = /(?:^|[^a-z])focus(?:$|[^a-z])/i.test(__t43_2_opts || '');
					const useSimpleMem = /(?:^|[^a-z])simplemem(?:$|[^a-z])/i.test(__t43_2_opts || '');
					const MAX_ROUNDS = __optInt(/(?:^|[^a-z])m(\d+)/i, 1, 50) ?? 10;
				const REDTEAM_CALL_BUDGET_PER_ROUND = __optInt(/(?:^|[^a-z])r(\d+)/i, 1, 500) ?? 30;
				const FAIL_STREAK_LIMIT = __optInt(/(?:^|[^a-z])fs(\d+)/i, 1, 5000) ?? 10;
						const PASS_STREAK_TARGET = __optInt(/(?:^|[^a-z])ps(\d+)/i, 1, 5000) ?? 3;
						const ITER_HARD_CAP = __optInt(/(?:^|[^a-z])ih(\d+)/i, 1, 5000) ?? 200;
						const MAX_TOTAL_CALLS = __optInt(/(?:^|[^a-z])cap(\d+)/i, 10, 5000) ?? 300;
						const ROUND_CALL_CAP = __optInt(/(?:^|[^a-z])rcap(\d+)/i, 1, 5000) ?? 0;
						const ROUND_TOKEN_CAP = __optInt(/(?:^|[^a-z])tcap(\d+)/i, 1000, 5000000) ?? 0;
						const passVerifyGate = /(?:^|[^a-z])pass2(?:$|[^a-z])/i.test(__t43_2_opts || '');
						const autoBanThreshold = __optInt(/(?:^|[^a-z])autoban(\d+)/i, 2, 10) ?? 0;
						const coolBanRounds = __optInt(/(?:^|[^a-z])coolban(\d+)/i, 1, 10) ?? 0;
						const bugCap = __optInt(/(?:^|[^a-z])bugcap(\d+)/i, 200, 20000) ?? 0;
						const memCap = __optInt(/(?:^|[^a-z])memcap(\d+)/i, 200, 20000) ?? 0;

					const __budgetStopPrefix = '__BUDGET_STOP__';
					const __roundStopPrefix = '__ROUND_STOP__';
					const __runStartCalls = this.state.metrics.calls || 0;
					const __callsUsed = () => (this.state.metrics.calls || 0) - __runStartCalls;
					const __budgetCheck = (where) => {
						if (!MAX_TOTAL_CALLS) return;
					if (__callsUsed() >= MAX_TOTAL_CALLS) {
						const loc = where ? ` @ ${where}` : '';
						this.log(`[${label}] Call cap reached (${__callsUsed()}/${MAX_TOTAL_CALLS})${loc}.`);
						throw new Error(`${__budgetStopPrefix}:${where || ''}`);
					}
				};

				let lastSolution = '';
				let checkpoint = '';
				let goodStreak = 0;
				const outlierInsights = [];
				const __iterBase = __optInt(/(?:^|[^a-z])it(\d+)/i, 0, 10) ?? 3;
				const __iterInit = __optInt(/(?:^|[^a-z])init(\d+)/i, 0, 10) ?? __iterBase;
				const __iterCorr = __optInt(/(?:^|[^a-z])corr(\d+)/i, 0, 10) ?? __iterBase;
				const solveOptsFor = (currentFailStreak, phase = 'corr') => {
					const iterations = (phase === 'init') ? __iterInit : __iterCorr;
					const opts = { iterations };
					if (adaptiveTemperature) opts.temperature = this.test43AdaptiveSolveTemperature(currentFailStreak);
					return opts;
				};
				const __hash32 = (s) => {
					const str = String(s || '');
					let h = 2166136261;
					for (let i = 0; i < str.length; i++) {
						h ^= str.charCodeAt(i);
						h = Math.imul(h, 16777619);
					}
					return (h >>> 0).toString(16);
				};
				const __reasonAgreeCache = new Map();
					const __reasonsAgree = async (reasonA, reasonB) => {
					const a = String(reasonA || '').trim();
					const b = String(reasonB || '').trim();
					if (!a || !b) return false;
					if (a === b) return true;
					const ha = __hash32(a);
					const hb = __hash32(b);
					const key = ha < hb ? `${ha}|${hb}` : `${hb}|${ha}`;
					if (__reasonAgreeCache.has(key)) return __reasonAgreeCache.get(key);
					const MAX_CHARS = 1400;
					const prompt = `Do these two texts describe the SAME underlying failure reason in a math solution verification context?

Rules:
- Focus on the underlying issue, not wording.
- If they refer to the same root mistake, answer YES.
- If they refer to different mistakes, answer NO.
- Output ONLY one tag at the end: <same>yes</same> or <same>no</same>.

Text A:
${a.slice(0, MAX_CHARS)}

Text B:
${b.slice(0, MAX_CHARS)}`;
					const tries = Math.max(1, Math.min(5, parseInt(samek || '1', 10) || 1));
					let yes = 0;
					let no = 0;
					let lastResp = '';
					for (let t = 0; t < tries; t++) {
						lastResp = await this.callAPI(
							[
								{ role: 'system', content: 'You judge semantic equivalence of failure reasons. Be strict and consistent.' },
								{ role: 'user', content: prompt }
							],
							(txt) => txt.includes('<same>yes</same>') || txt.includes('<same>no</same>'),
							{ temperature: 0.1 }
						);
						if (lastResp.includes('<same>yes</same>')) yes++;
						if (lastResp.includes('<same>no</same>')) no++;
					}
					const same = yes > no ? true : (no > yes ? false : lastResp.includes('<same>yes</same>'));
						__reasonAgreeCache.set(key, same);
						return same;
					};
					const __answerAgreeCache = new Map();
					const __answersAgree = async (tokA, tokB) => {
						const a = String(tokA || '').trim();
						const b = String(tokB || '').trim();
						if (!a || !b) return false;
						if (a === b) return true;
						if (a === 'unknown' || b === 'unknown') return false;

						// Fast-path for simple multiple-choice tokens.
						if (/^[1-5]$/.test(a) && /^[1-5]$/.test(b)) return a === b;
						if (/^[a-e]$/i.test(a) && /^[a-e]$/i.test(b)) return a.toUpperCase() === b.toUpperCase();

						const ha = __hash32(a);
						const hb = __hash32(b);
						const key = ha < hb ? `${ha}|${hb}` : `${hb}|${ha}`;
						if (__answerAgreeCache.has(key)) return __answerAgreeCache.get(key);

						// Avoid spending extra calls on very long/garbled tokens.
						if (a.length > 120 || b.length > 120) {
							__answerAgreeCache.set(key, false);
							return false;
						}

						const MAX_PROB_CHARS = 1200;
						const MAX_ANS_CHARS = 220;
						const prompt = `Decide if these two "final answers" are equivalent for the same problem.

Rules:
- If they refer to the same choice (e.g., ‚ë¢ vs 3), answer YES.
- If they are mathematically equivalent expressions (same value), answer YES.
- Otherwise, answer NO.
- Output ONLY one tag at the end: <eq>yes</eq> or <eq>no</eq>.

Problem (truncated):
${String(query || '').slice(0, MAX_PROB_CHARS)}

Answer A:
${a.slice(0, MAX_ANS_CHARS)}

Answer B:
${b.slice(0, MAX_ANS_CHARS)}`;

						const resp = await this.callAPI(
							[
								{ role: 'system', content: 'You judge equivalence of final answers. Be strict. Output only <eq>yes</eq> or <eq>no</eq>.' },
								{ role: 'user', content: prompt }
							],
							(txt) => txt.includes('<eq>yes</eq>') || txt.includes('<eq>no</eq>'),
							{ temperature: 0.1 }
						);
						const eq = resp.includes('<eq>yes</eq>');
						__answerAgreeCache.set(key, eq);
						return eq;
					};
						const __trimText = (text, maxChars, mode = 'tail') => {
							const s = String(text || '');
							const lim = parseInt(maxChars || '0', 10);
							if (!Number.isFinite(lim) || lim <= 0) return s;
							if (s.length <= lim) return s;
							if (mode === 'head') return `${s.slice(0, lim)}\n\n[...TRUNCATED...]`;
							if (mode === 'headtail') {
								const a = Math.max(0, Math.min(lim - 1, Math.floor(lim * 0.60)));
								const b = Math.max(1, lim - a);
								return `${s.slice(0, a)}\n\n[...TRUNCATED...]\n\n${s.slice(-b)}`;
							}
							return `[...TRUNCATED...]\n\n${s.slice(-lim)}`;
						};

						try {
						const hiddenStateSummary = (useHiddenState || beliefK > 0 || method3 || valuePickK > 0)
							? await this.test48GetHiddenStateSummary(query)
							: '';
						const vsOpts = (vsTunePct >= 1)
							? { probabilityTuning: (vsTunePct / 100), hard: !!vsTuneHard }
							: {};
							const bannedAnswerTokens = [];
							const __answerHist = new Map(); // token -> count (across rounds)
							const __coolBans = new Map(); // token -> remainingRounds
							const beliefSets = (beliefK > 0)
								? await this.test48GenerateBeliefSets(query, beliefK, hiddenStateSummary)
								: [];
						const methodPlans = method3
							? await this.test48GenerateVerbalizedMethodologies(query, 3, hiddenStateSummary, { tailSampling: true, ...vsOpts })
							: [];

					// SciIdea: Chain-of-Ideas context and persona state
					const sciideaCoIContext = sciideaCoI ? await this.sciIdeaGenerateCoIContext(query) : '';
					const sciideaPersonas = sciideaPersona3 ? this.getSciIdeaPersonas() : [];
					let sciideaPersonaIdx = 0;

					if (vsDiagK >= 2) this.log(`[${label}] VS overlap diagnoses enabled (k=${vsDiagK}).`);
					if (useFreeformInit) this.log(`[${label}] Freeform solve enabled (${freeformFull ? 'full' : 'init-only'}).`);
					if (samek > 1) this.log(`[${label}] Reason-agreement voting enabled (k=${samek}).`);
					if (noMemory) this.log(`[${label}] Solver memory disabled (nomem).`);
					if (useHiddenState && hiddenStateSummary) this.log(`[${label}] Hidden-state summary enabled (hstate).`);
					if (beliefSets.length) this.log(`[${label}] Belief sets enabled (belief${beliefSets.length}).`);
					if (methodPlans.length) this.log(`[${label}] Multi-method init enabled (method3).`);
					if (scK >= 2) this.log(`[${label}] Self-consistency init enabled (sc${scK}).`);
					if (vsscK >= 2) this.log(`[${label}] Verbalized self-consistency init enabled (vssc${vsscK}).`);
					if (mctsK >= 2) this.log(`[${label}] MCTS visit-count init enabled (mcts${mctsK}).`);
					if (valuePickK >= 2) this.log(`[${label}] Value-network init selection enabled (valuepick${valuePickK}).`);
					if (totCorrK >= 2) this.log(`[${label}] ToT correction branching enabled (totcorr${totCorrK}).`);
					if (vsRedK >= 2) this.log(`[${label}] VS redteam notes enabled (vsred${vsRedK}).`);
					if (procsup) this.log(`[${label}] Process supervision enabled (procsup).`);
						if (deltaSum) this.log(`[${label}] Bug-report delta compression enabled (deltasum).`);
						if (quietPass) this.log(`[${label}] Quiet-position stability check enabled (quietpass).`);
						if (ans2Gate) this.log(`[${label}] Answer-stability gate enabled (ans2).`);
						if (passVerifyGate) this.log(`[${label}] pass2: double-check verifier on success enabled.`);
						if (goalStack) this.log(`[${label}] Goal-stack instructions enabled (goalstack).`);
						if (initAgree) this.log(`[${label}] Init unanimity gate enabled (initagree).`);
						if (banAns) this.log(`[${label}] Banned-answer backprop enabled (banans).`);
						if (autoBanThreshold >= 2) this.log(`[${label}] autoban${autoBanThreshold}: ban repeated answer tokens across rounds.`);
						if (coolBanRounds >= 1) this.log(`[${label}] coolban${coolBanRounds}: ban last-round answer token for a few rounds.`);
						if (ROUND_CALL_CAP > 0) this.log(`[${label}] rcap${ROUND_CALL_CAP}: per-round call cap enabled.`);
						if (ROUND_TOKEN_CAP > 0) this.log(`[${label}] tcap${ROUND_TOKEN_CAP}: per-round token cap enabled.`);
							if (bugCap > 0) this.log(`[${label}] bugcap${bugCap}: truncate bug reports passed to corrector.`);
							if (memCap > 0) this.log(`[${label}] memcap${memCap}: truncate solver memory passed to corrector.`);
							if (pacoreCap > 0) this.log(`[${label}] pacorecap${pacoreCap}: truncate PaCoRe reference messages.`);
							if (vsTunePct >= 1) this.log(`[${label}] vstune${vsTunePct}${vsTuneHard ? 'hard' : ''}: VS probability tuning enabled.`);
							if (vsDivPick) this.log(`[${label}] vsdiv: pick diversity-first among VS candidates.`);
							if (prepeatN >= 2) this.log(`[${label}] prepeat${prepeatN}${prepeatVerbose ? 'v' : ''}${prepeatFull ? 'full' : ''}: prompt repetition enabled.`);
							if (ppadN >= 2) this.log(`[${label}] ppad${ppadN}: padding control enabled${prepeatN >= 2 ? ' (ignored; prepeat active)' : ''}.`);
							if (rsaN >= 2 && rsaT >= 1) this.log(`[${label}] RSA init enabled (rsaN${rsaN}, rsaK${rsaK || 'auto'}, rsaT${rsaT}).`);
							if (pacoreK >= 2) this.log(`[${label}] PaCoRe parallel init enabled (pacore${pacoreK}).`);
							if (sciideaCoI) this.log(`[${label}] SciIdea CoI (Chain-of-Ideas) context enabled.`);
								if (sciideaPersona3) this.log(`[${label}] SciIdea 3-persona rotation enabled (Scientist/Critic/Synthesizer).`);
								if (sciideaDebateK >= 2) this.log(`[${label}] SciIdea debate loop enabled (debate${sciideaDebateK}).`);
								if (sotK >= 2) this.log(`[${label}] SoT council init enabled (sot${sotK}${sotLite ? '-lite' : ''}${sotCrit ? '+crit' : ''}).`);
								if (sotCorr) this.log(`[${label}] SoT council correction enabled (sotcorr).`);
								if (refuteK >= 1) this.log(`[${label}] refute${refuteK}: success refutation gate enabled.`);
								if (discourseMarkers) this.log(`[${label}] markers: discourse-marker prompting enabled.`);
								if (optGrid) this.log(`[${label}] optgrid: optimization/parameter guard enabled.`);
								if (optMix) this.log(`[${label}] optmix: include both question-first and options-first prompt order.`);
								else if (optFirst) this.log(`[${label}] optfirst: move answer options before question/context.`);
								if (blindAnsK >= 1) this.log(`[${label}] blindans${blindAnsK}${blindRaw ? 'raw' : ''}: answer-only stability gate enabled.`);
					if (useAgeMem) {
						this.log(`[${label}] AgeMem unified memory management enabled.`);
						this.ageMemEnsureState();
					}
					if (useSimpleMem) {
						this.log(`[${label}] SimpleMem semantic compression enabled.`);
						this.simpleMemEnsureState();
					}
						for (let round = 1; round <= MAX_ROUNDS; round++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							__budgetCheck(`round ${round} start`);
							this.log(`=== Round ${round}/${MAX_ROUNDS} (${label}: test43 variant) ===`);

							// Must be scoped to the whole round (used in finally for post-round bookkeeping).
							let solution = '';
							let __roundSuccess = false;
							let __roundAbort = '';

							// Round budgets (callAPI enforces caps; we always record per-round start counters for telemetry).
							this.state._roundCallCap = (ROUND_CALL_CAP > 0) ? ROUND_CALL_CAP : 0;
							this.state._roundCallStartCalls = this.state.metrics.calls || 0;
							this.state._roundTokenCap = (ROUND_TOKEN_CAP > 0) ? ROUND_TOKEN_CAP : 0;
							this.state._roundTokenStartTokens = this.state.metrics.tokens || 0;

								try {

							let solverMemory = '';
							let redTeamCallsUsed = 0;
								let initialVerificationOverride = null;
								let correctionsThisRound = 0;
								let lastFailureReason = '';
								let sameFailureStreak = 0;

							const goalStackBlock = goalStack
								? `GOAL STACK (hierarchical objectives; do not treat as extra givens):
- L0 (Final): Identify what the user is asking and the required output format.
- L1 (Constraints): List the key constraints/definitions/conditions that must hold.
- L2 (Current Step): For each move, state what you're trying to prove/check next.

When updating memory, prioritize L0/L1 and recurring pitfalls; drop transient details.`
							: '';

							const formatBannedTokensBlock = () => {
								if (!bannedAnswerTokens.length) return '';
								const tail = bannedAnswerTokens.slice(-12);
								return `REJECTED ANSWER TOKENS (avoid concluding these unless you can prove them):\n- ${tail.join('\n- ')}`;
							};
							const __looksLikeMcq = (text) => {
								const q = (text || '').toString();
								if (!q) return false;
								const __count = (re) => (q.match(re) || []).length;
								const choiceCount =
									__count(/[‚ë†-‚ë§]/g)
									+ __count(/\b[1-5]\s*\)/g)
									+ __count(/\b[1-5]\s*\./g)
									+ __count(/\b[A-E]\s*\)/g)
									+ __count(/\b[A-E]\s*\./g);
								return choiceCount >= 3;
							};
							const __reorderOptionsFirst = (text) => {
								const raw = (text || '').toString();
								if (!__looksLikeMcq(raw)) return raw;
								const lines = raw.split('\n');
								const isOptLine = (line) => {
									const s = (line || '').toString();
									if (!s.trim()) return false;
									return (
										/^\s*[‚ë†‚ë°‚ë¢‚ë£‚ë§]\s+/.test(s)
										|| /^\s*[1-5]\s*[)\.]\s+/.test(s)
										|| /^\s*[A-E]\s*[)\.]\s+/.test(s)
									);
								};
								const idxs = [];
								for (let i = 0; i < lines.length; i++) {
									if (isOptLine(lines[i])) idxs.push(i);
								}
								if (idxs.length < 3) return raw;
								const first = idxs[0];
								const last = idxs[idxs.length - 1];
								if ((last - first) > 80) return raw; // likely not a clean option block

								const options = lines.slice(first, last + 1).join('\n').trim();
								const rest = lines.slice(0, first).concat(lines.slice(last + 1)).join('\n').trim();
								if (!options || !rest) return raw;
								return `ANSWER OPTIONS:\n${options}\n\nQUESTION / CONTEXT:\n${rest}`.trim();
							};
							const __applyPromptStructure = (text) => {
								const raw = (text || '').toString();
								if (!(optFirst || optMix)) return raw;
								const reordered = __reorderOptionsFirst(raw);
								if (reordered === raw) return raw;
								if (optMix) {
									return `${raw}\n\n---\n\n${reordered}`;
								}
								return reordered;
							};
							const __applyPromptRepetition = (text) => {
								const raw = String(text || '');
								if (prepeatN < 2) return raw;
								const q = raw.trim();
								if (!q) return raw;
								const n = Math.max(2, Math.min(5, prepeatN));
								const parts = [q];
								for (let i = 2; i <= n; i++) {
									if (prepeatVerbose) {
										if (i === 2) parts.push(`Let me repeat that:\n${q}`);
										else if (i === 3) parts.push(`Let me repeat that one more time:\n${q}`);
										else parts.push(`Let me repeat that again:\n${q}`);
									} else {
										parts.push(q);
									}
								}
								return parts.join('\n\n');
							};
							const __applyPromptPadding = (text) => {
								const raw = String(text || '');
								if (ppadN < 2) return raw;
								const q = raw.trim();
								if (!q) return raw;

								const n = Math.max(2, Math.min(5, ppadN));
								const MAX_PAD_CHARS = 80000;
								let padChars = Math.max(0, Math.min(MAX_PAD_CHARS, q.length * (n - 1)));
								if (padChars <= 0) return raw;

								const DOT80 = '................................................................................';
								const lines = [];
								while (padChars > 0) {
									const take = Math.max(1, Math.min(80, padChars));
									lines.push(DOT80.slice(0, take));
									padChars -= take;
								}
								return `${q}\n\nIgnore these periods (they are irrelevant) and answer the above question:\n${lines.join('\n')}`;
							};
							// Apply cool-down bans at round start (decrement counters and ensure tokens are present in the ban list).
							if (coolBanRounds >= 1 && __coolBans.size) {
								for (const [tok, remain] of Array.from(__coolBans.entries())) {
									const r = (Number.isFinite(remain) ? remain : 0) - 1;
									if (r <= 0) __coolBans.delete(tok);
									else __coolBans.set(tok, r);
								}
								for (const [tok] of __coolBans.entries()) {
									if (tok && tok !== 'unknown' && !bannedAnswerTokens.includes(tok)) bannedAnswerTokens.push(tok);
								}
								while (bannedAnswerTokens.length > 30) bannedAnswerTokens.shift();
							}
							const buildSolverProblem = (extraBlocks = []) => {
								const blocks = [];
								if (useHiddenState && hiddenStateSummary) blocks.push(`HIDDEN STATE SUMMARY (do not treat as extra givens; just a compression):\n${hiddenStateSummary}`);
								if (sciideaCoIContext) blocks.push(`CHAIN-OF-IDEAS CONTEXT (conceptual connections for this problem):\n${sciideaCoIContext}`);
								if (goalStackBlock) blocks.push(goalStackBlock);
								if (discourseMarkers) {
									blocks.push(`DISCOURSE MARKERS (self-check): when you doubt a step, start the sentence with "Wait," or "But," (or Korean: "Ïû†Íπê", "ÌïòÏßÄÎßå") and re-check. Use this at least twice.`);
								}
								if (optGrid) {
									blocks.push(`OPTIMIZATION GUARD:\n- State the variable domain/constraints explicitly.\n- For min/max problems: check endpoints + critical points, and justify why the best is global.\n- Avoid relying only on numerical search; if you approximate, still give a proof sketch why it is valid.`);
								}
								const banned = formatBannedTokensBlock();
								if (banned) blocks.push(banned);
								for (const b of (Array.isArray(extraBlocks) ? extraBlocks : [])) {
									const s = (b || '').toString().trim();
									if (s) blocks.push(s);
							}
							const q0 = __applyPromptStructure(String(query || ''));
							let base = q0;
							if (!prepeatFull) {
								base = (prepeatN >= 2)
									? __applyPromptRepetition(base)
									: __applyPromptPadding(base);
							} else if (prepeatN < 2) {
								base = __applyPromptPadding(base);
							}
							const merged = blocks.length ? `${base}\n\n${blocks.join('\n\n')}` : base;
							return prepeatFull ? __applyPromptRepetition(merged) : merged;
						};
						const extractAnswerTokenNorm = async (solutionXml, allowModel = false) => {
							const detailed = this.test21ExtractDetailedFromSolution(solutionXml || '');
							const rawTok = this.extractFinalAnswerTokenHeuristic(detailed) || this.extractFinalAnswerTokenHeuristic(solutionXml || '');
							if (rawTok) {
								const norm = this.normalizeAnswerToken(rawTok);
								return norm || 'unknown';
							}
							if (!allowModel) return 'unknown';
							const raw2 = await this.extractFinalAnswerToken(query, detailed || (solutionXml || ''));
							const norm2 = this.normalizeAnswerToken(raw2);
							return norm2 || 'unknown';
						};
						const computeInitialMemory = async (solutionXml) => {
							if (noMemory) return '';
							const dsol = this.test21ExtractDetailedFromSolution(solutionXml || '');
							const memUser = `User request:\n${query}\n\nCurrent solution:\n${dsol || '(empty)'}\n\nPrevious memory:\n(none)\n\nReturn updated memory summary as max 8 bullets. Keep only persistent constraints, key decisions, and critical pitfalls to avoid.`;
							return await this.callAPI(
								[
									{ role: 'system', content: 'You are the Memory Agent. Compress the current state into a short memory summary (max 8 bullets).' },
									{ role: 'user', content: memUser },
								],
								null,
								{ temperature: 0.2 }
							);
						};

						let seedText = '';
						if (seed37) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[${label}] Seed37: generating a draft seed...`);
							seedText = await this.callAPI(
								[
									{ role: 'system', content: 'You are the Main Generator. Produce an initial solution/draft for the user request.' },
									{ role: 'user', content: `User request:\n${query}\n\nProduce the initial draft.` }
								],
								null,
								{ temperature: 0.7 }
							);
						}
						const seedBlock = seedText ? `SEED DRAFT (may be imperfect):\n${seedText}` : '';

							const pickByVote = (cands) => {
								const counts = new Map();
								for (const c of cands) {
									const tok = c.answerToken || 'unknown';
									if (tok === 'unknown') continue;
									counts.set(tok, (counts.get(tok) || 0) + 1);
								}
								const best = Array.from(counts.entries()).sort((a, b) => b[1] - a[1])[0];
								if (!best) return cands[0] || null;
								const [tok] = best;
								const group = cands.filter(c => c.answerToken === tok);
								group.sort((a, b) => (b.prior - a.prior));
								return group[0] || cands[0] || null;
							};
							const pickByVoteOrDiversity = (cands) => {
								const arr = Array.isArray(cands) ? cands.filter(Boolean) : [];
								if (!arr.length) return null;
								if (!vsDivPick) return pickByVote(arr) || arr[0] || null;

								// Step 1: choose the winning answer-token group (vote), but tie-break by summed priors.
								const counts = new Map();
								const sums = new Map();
								for (const c of arr) {
									const tok = c?.answerToken || 'unknown';
									if (!tok || tok === 'unknown') continue;
									counts.set(tok, (counts.get(tok) || 0) + 1);
									const p = Number.isFinite(c?.prior) ? c.prior : 0;
									sums.set(tok, (sums.get(tok) || 0) + p);
								}
								let group = arr;
								if (counts.size) {
									const best = Array.from(counts.entries())
										.map(([tok, count]) => ({ tok, count, sum: sums.get(tok) || 0 }))
										.sort((a, b) => (b.count - a.count) || ((b.sum || 0) - (a.sum || 0)))[0];
									if (best?.tok) group = arr.filter(c => (c?.answerToken || 'unknown') === best.tok);
								}
								if (group.length <= 1) return group[0] || arr[0] || null;

								// Step 2: pick the most diverse candidate within the group.
								const texts = group.map(c => {
									const xml = (c?.solution || '').toString();
									return (this.test21ExtractDetailedFromSolution(xml) || xml).toString();
								});
								const sets = texts.map(t => this.test43WordSetForDiversity(t));
								let best = null;
								for (let i = 0; i < group.length; i++) {
									let simSum = 0;
									let cnt = 0;
									for (let j = 0; j < group.length; j++) {
										if (i === j) continue;
										simSum += this.test43JaccardSimilarity(sets[i], sets[j]);
										cnt += 1;
									}
									const avgSim = cnt ? (simSum / cnt) : 1;
									const p = Number.isFinite(group[i]?.prior) ? group[i].prior : 0;
									const score = (1 - avgSim) + (0.05 * p);
									if (!best || score > best.score) best = { idx: i, score };
								}
								return group[best?.idx ?? 0] || group[0] || arr[0] || null;
							};
							const pickByUnanimity = (cands) => {
								const arr = Array.isArray(cands) ? cands.filter(Boolean) : [];
								if (!arr.length) return null;
								const toks = arr.map(c => (c.answerToken || 'unknown'));
							if (toks.some(t => !t || t === 'unknown')) return null;
							const first = toks[0];
							if (!first || first === 'unknown') return null;
							if (!toks.every(t => t === first)) return null;
							const group = arr.filter(c => c.answerToken === first);
							group.sort((a, b) => (b.prior - a.prior));
							return group[0] || arr[0] || null;
						};
						const formatInitDisagreementBlock = (cands, title = 'INIT') => {
							const arr = Array.isArray(cands) ? cands.filter(Boolean) : [];
							if (!arr.length) return '';
							const lines = arr.slice(0, 8).map((c, i) => {
								const tok = (c.answerToken || 'unknown');
								const p = Number.isFinite(c.prior) ? c.prior : null;
								const ps = (p == null) ? '' : `; prior=${p.toFixed(2)}`;
								return `- #${i + 1}: ${tok}${ps}`;
							});
							return `${title}: Candidate branches disagreed on the final answer token.\n${lines.join('\n')}\n\nResolve the disagreement and produce the best-justified final answer.`;
						};

						const initSolveOpts = solveOptsFor(0, 'init');
						const baseTemp = Number.isFinite(initSolveOpts?.temperature) ? initSolveOpts.temperature : 0.2;
						const sampleTemp = Math.max(0.2, Math.min(0.9, baseTemp + 0.35));
						const runBaseInit = async (extraBlocks = []) => {
							const memoryForSolve = noMemory ? '' : this.test43MergeOutlierMemory(solverMemory, outlierInsights);
							const solverProblem = buildSolverProblem(extraBlocks);
							return useFreeformInit
								? await this.test40IcrSolveSolutionFreeform(solverProblem, { memory: memoryForSolve, seedText }, label, initSolveOpts)
								: await this.test40IcrSolveSolution(solverProblem, { memory: memoryForSolve, seedText }, label, initSolveOpts);
						};

						const initCandidates = [];
							if (mctsK >= 2) {
								const extra = [seedBlock, (useHiddenState && hiddenStateSummary) ? `HIDDEN STATE SUMMARY:\n${hiddenStateSummary}` : '', goalStackBlock, formatBannedTokensBlock()].filter(Boolean).join('\n\n');
								const sols = await this.test48GenerateVerbalizedSolutions(query, mctsK, extra, vsOpts);
								for (const s of sols) {
									if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
									if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) break;
									const solXml = this.test21CoerceFreeformToSolutionXml(s.text);
									const tok = await extractAnswerTokenNorm(solXml, false);
								const prior = s.probability ?? (1 / Math.max(1, sols.length));
								const verification = await this.test21VerifyMathSolution(query, solXml);
								redTeamCallsUsed += 1;
								initCandidates.push({ solution: solXml, answerToken: tok, prior, verification });
							}
								const passCands = initCandidates.filter(c => c?.verification?.isGood);
								let picked = null;
								if (passCands.length) {
									picked = pickByVoteOrDiversity(passCands) || passCands[0] || null;
									initialVerificationOverride = picked?.verification || null;
								} else if (initCandidates.length) {
									this.log(`[${label}] mcts: no passing candidates; falling back to value-net pick.`);
									const xmls = initCandidates.map(c => c.solution);
									const scores = await this.test48ScoreCandidatesValueNet(query, xmls);
								const bestIdx = scores[0]?.idx ? Math.max(0, Math.min(xmls.length - 1, scores[0].idx - 1)) : 0;
								picked = initCandidates[bestIdx] || initCandidates[0] || null;
							}
							solution = picked?.solution || '';
							solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							} else if (valuePickK >= 2) {
								const extra = [seedBlock, (useHiddenState && hiddenStateSummary) ? `HIDDEN STATE SUMMARY:\n${hiddenStateSummary}` : '', goalStackBlock, formatBannedTokensBlock()].filter(Boolean).join('\n\n');
								const sols = await this.test48GenerateVerbalizedSolutions(query, valuePickK, extra, vsOpts);
								const xmls = sols.map(s => this.test21CoerceFreeformToSolutionXml(s.text));
								const scores = await this.test48ScoreCandidatesValueNet(query, xmls);
								const bestIdx = scores[0]?.idx ? Math.max(0, Math.min(xmls.length - 1, scores[0].idx - 1)) : 0;
								solution = xmls[bestIdx] || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							} else if (rsaN >= 2 && rsaT >= 1) {
								const N = Math.max(2, Math.min(32, rsaN));
								const K = Math.max(1, Math.min(N, (rsaK || Math.min(4, N))));
								const T = Math.max(1, Math.min(10, rsaT));
								this.log(`[${label}] RSA init: generating population (N=${N}, K=${K}, T=${T})...`);

								const extraBlocks = [];
								if (seedBlock) extraBlocks.push(seedBlock);
								if (methodPlans.length) extraBlocks.push(`METHODOLOGY (use as a high-level plan, not extra givens):\n${methodPlans[0]?.text || ''}`.trim());
								if (beliefSets.length) extraBlocks.push(`BELIEF SET (assumption about missing info / interpretation):\n${beliefSets[0]?.scenario || ''}`.trim());
								const rsaProblem = buildSolverProblem(extraBlocks.filter(Boolean));

								const MAX_CAND_CHARS = 3500;
								const clipCand = (xml) => {
									const d = this.test21ExtractDetailedFromSolution(xml || '') || (xml || '');
									return __trimText(d, MAX_CAND_CHARS, 'headtail');
								};
								const sampleSubset = (arr, k) => {
									const n = arr.length;
									if (n <= k) return arr.slice();
									const idxs = Array.from({ length: n }, (_, i) => i);
									for (let i = n - 1; i > 0; i--) {
										const j = Math.floor(Math.random() * (i + 1));
										const tmp = idxs[i];
										idxs[i] = idxs[j];
										idxs[j] = tmp;
									}
									return idxs.slice(0, k).map(i => arr[i]);
								};

								// P1: generate N initial candidates using VS.
								const pop = [];
								const baseExtra = [
									seedBlock,
									(useHiddenState && hiddenStateSummary) ? `HIDDEN STATE SUMMARY:\n${hiddenStateSummary}` : '',
									goalStackBlock,
									formatBannedTokensBlock(),
									methodPlans.length ? `METHODOLOGY (use as a high-level plan, not extra givens):\n${methodPlans[0]?.text || ''}`.trim() : '',
									beliefSets.length ? `BELIEF SET (assumption about missing info / interpretation):\n${beliefSets[0]?.scenario || ''}`.trim() : '',
								].filter(Boolean).join('\n\n');
								let remaining = N;
								let guard = 0;
								while (remaining > 0 && guard < 6) {
									guard++;
									if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
									__budgetCheck(`rsa init gen ${guard}`);
									const batch = Math.min(remaining, 10);
									const sols = await this.test48GenerateVerbalizedSolutions(query, batch, baseExtra, vsOpts);
									const got = Array.isArray(sols) ? sols.filter(Boolean) : [];
									if (!got.length) break;
									for (const s of got) {
										if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
										const solXml = this.test21CoerceFreeformToSolutionXml(s.text);
										const tok = await extractAnswerTokenNorm(solXml, false);
										const prior = s.probability ?? (1 / Math.max(1, got.length));
										pop.push({ solution: solXml, answerToken: tok, prior });
										if (pop.length >= N) break;
									}
									remaining = N - pop.length;
								}

								if (!pop.length) {
									this.log(`[${label}] RSA init: failed to generate initial population; falling back to base init.`);
									const init = await runBaseInit([]);
									solution = init.solution || '';
									solverMemory = noMemory ? '' : (init.memory || '');
								} else {
									// Recursive aggregation steps.
									let current = pop.map(p => p.solution);
									for (let step = 2; step <= T; step++) {
										if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
										this.log(`[${label}] RSA step ${step}/${T}: aggregating ${current.length} candidates...`);
										const next = [];
										for (let i = 0; i < N; i++) {
											if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
											__budgetCheck(`rsa agg step${step} i${i}`);
											const subset = sampleSubset(current, K);
											const candBlock = subset.map((s, idx) => `---- Solution ${idx + 1} ----\n${clipCand(s)}`).join('\n\n');
											const user = `You are given a math problem and several candidate solutions.
Some candidates may be incorrect or incomplete.
Aggregate the useful ideas and produce a single, high-quality solution.
Reason carefully; if candidates disagree, choose the correct path.
If all are incorrect, attempt a different strategy.
End with a clear final answer.

Problem:
${rsaProblem}

Candidate solutions (may contain mistakes):
${candBlock}

Now write a single improved solution. Output ONLY <solution>...</solution>.`;
											const agg = await this.callAPI(
												[{ role: 'system', content: this.getTest21Step1PromptXML() }, { role: 'user', content: user }],
												(txt) => this.validateTest21SolutionXml(txt),
												{ temperature: Math.max(0.1, Math.min(0.35, baseTemp)) }
											);
											next.push(agg);
										}
										current = next;
									}

									// Pick final candidate by answer-token vote (optionally diversity).
									const finals = [];
									for (const s of current) {
										if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
										const tok = await extractAnswerTokenNorm(s, false);
										finals.push({ solution: s, answerToken: tok, prior: 1 / Math.max(1, current.length) });
									}
									const picked = pickByVoteOrDiversity(finals) || finals[0] || null;
									solution = picked?.solution || current[0] || '';
									solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
								}
							} else if (sotK >= 2) {
								this.log(`[${label}] SoT init: council solve (k=${sotK})...`);
								const extraBlocks = [];
								if (seedBlock) extraBlocks.push(seedBlock);
								if (methodPlans.length) extraBlocks.push(`METHODOLOGY (use as a high-level plan, not extra givens):\n${methodPlans[0]?.text || ''}`.trim());
								if (beliefSets.length) extraBlocks.push(`BELIEF SET (assumption about missing info / interpretation):\n${beliefSets[0]?.scenario || ''}`.trim());
								const solverProblem = buildSolverProblem(extraBlocks.filter(Boolean));
								const res = await this.testSoTCouncilSolveSolutionXml(solverProblem, {
									k: sotK,
									lite: sotLite,
									critique: sotCrit,
									markers: discourseMarkers,
									temperature: sampleTemp,
								});
								solution = res?.solution || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							} else if (methodPlans.length) {
								for (let i = 0; i < methodPlans.length; i++) {
									if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
									const plan = methodPlans[i];
									const problemWithPlan = buildSolverProblem([seedBlock, `METHODOLOGY (follow as a plan, do not treat as extra givens):\n${plan.text}`]);
								const sol = await this.test48SolveOnceSolutionXml(problemWithPlan, { temperature: sampleTemp });
								const tok = await extractAnswerTokenNorm(sol, false);
								initCandidates.push({ solution: sol, answerToken: tok, prior: plan.probability ?? (1 / methodPlans.length) });
							}
								const picked = initAgree ? pickByUnanimity(initCandidates) : (pickByVoteOrDiversity(initCandidates) || initCandidates[0] || null);
								if (initAgree && !picked) {
									this.log(`[${label}] initagree: methodology answers disagree; falling back to base init.`);
									const init = await runBaseInit([formatInitDisagreementBlock(initCandidates, 'INIT(method3)')].filter(Boolean));
									solution = init.solution || '';
									solverMemory = noMemory ? '' : (init.memory || '');
							} else {
								solution = picked?.solution || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							}
						} else if (beliefSets.length) {
							for (let i = 0; i < beliefSets.length; i++) {
								if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
								const b = beliefSets[i];
								const problemWithBelief = buildSolverProblem([seedBlock, `BELIEF SET (assumption about missing info / interpretation):\n${b.scenario}`]);
								const sol = await this.test48SolveOnceSolutionXml(problemWithBelief, { temperature: sampleTemp });
								const tok = await extractAnswerTokenNorm(sol, false);
								initCandidates.push({ solution: sol, answerToken: tok, prior: b.probability ?? (1 / beliefSets.length) });
							}
								const picked = initAgree ? pickByUnanimity(initCandidates) : (pickByVoteOrDiversity(initCandidates) || initCandidates[0] || null);
								if (initAgree && !picked) {
									this.log(`[${label}] initagree: belief-set answers disagree; falling back to base init.`);
									const init = await runBaseInit([formatInitDisagreementBlock(initCandidates, 'INIT(belief)')].filter(Boolean));
									solution = init.solution || '';
									solverMemory = noMemory ? '' : (init.memory || '');
							} else {
								solution = picked?.solution || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							}
							} else if (vsscK >= 2) {
								const extra = [seedBlock, (useHiddenState && hiddenStateSummary) ? `HIDDEN STATE SUMMARY:\n${hiddenStateSummary}` : '', goalStackBlock, formatBannedTokensBlock()].filter(Boolean).join('\n\n');
								const sols = await this.test48GenerateVerbalizedSolutions(query, vsscK, extra, vsOpts);
								for (const s of sols) {
									const solXml = this.test21CoerceFreeformToSolutionXml(s.text);
									const tok = await extractAnswerTokenNorm(solXml, false);
									initCandidates.push({ solution: solXml, answerToken: tok, prior: s.probability ?? (1 / sols.length) });
								}
								const picked = initAgree ? pickByUnanimity(initCandidates) : (pickByVoteOrDiversity(initCandidates) || initCandidates[0] || null);
								if (initAgree && !picked) {
									this.log(`[${label}] initagree: vssc answers disagree; falling back to base init.`);
									const init = await runBaseInit([formatInitDisagreementBlock(initCandidates, 'INIT(vssc)')].filter(Boolean));
									solution = init.solution || '';
									solverMemory = noMemory ? '' : (init.memory || '');
							} else {
								solution = picked?.solution || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							}
						} else if (scK >= 2) {
							const n = Math.max(2, Math.min(12, scK));
							for (let i = 0; i < n; i++) {
								if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
								const jitter = (i === 0) ? 0 : (Math.random() * 0.25);
								const t = Math.max(0.2, Math.min(0.95, sampleTemp + jitter));
								const hint = i === 0 ? '' : `DIVERSITY NOTE: Use a meaningfully different approach than typical.`;
								const prob = buildSolverProblem([seedBlock, hint].filter(Boolean));
								const sol = await this.test48SolveOnceSolutionXml(prob, { temperature: t });
								const tok = await extractAnswerTokenNorm(sol, false);
								initCandidates.push({ solution: sol, answerToken: tok, prior: 1 / n });
							}
								const picked = initAgree ? pickByUnanimity(initCandidates) : (pickByVoteOrDiversity(initCandidates) || initCandidates[0] || null);
								if (initAgree && !picked) {
									this.log(`[${label}] initagree: sc answers disagree; falling back to base init.`);
									const init = await runBaseInit([formatInitDisagreementBlock(initCandidates, 'INIT(sc)')].filter(Boolean));
									solution = init.solution || '';
									solverMemory = noMemory ? '' : (init.memory || '');
							} else {
								solution = picked?.solution || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							}
							} else if (pacoreK >= 2) {
								// PaCoRe-style parallel init: generate K trajectories, compact, synthesize
								this.log(`[${label}] PaCoRe init: generating ${pacoreK} parallel trajectories...`);
								const trajectories = await this.pacoreGenerateParallelTrajectories(query, pacoreK, { label, temperature: 1.0 });
								const compactedMessages = trajectories.map(t => this.pacoreExtractCompactMessage(t));
								const validMessages = compactedMessages.filter(m => m && m.length > 20);
								this.log(`[${label}] PaCoRe init: compacted ${validMessages.length}/${trajectories.length} valid messages.`);

								if (validMessages.length > 0) {
									// Synthesis: use compacted messages as references
									const refMessages = (pacoreCap > 0)
										? validMessages.map(m => __trimText(m, pacoreCap, 'headtail'))
										: validMessages;
									const synthesisPrompt = this.pacoreFormatSynthesisPrompt(query, refMessages);
									const finalSolution = await this.test40IcrSolveSolution(synthesisPrompt, {}, label, { iterations: 3 });
									solution = finalSolution.solution || '';
									solverMemory = noMemory ? '' : (finalSolution.memory || '');
								} else {
								// Fallback: use first trajectory
								this.log(`[${label}] PaCoRe init: no valid messages, using first trajectory.`);
								solution = trajectories[0] || '';
								solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							}
						} else if (useFocus) {
							// Focus: solve with active context compression
							this.log(`[${label}] Focus init: solving with context compression...`);
							solution = await this.focusSolveWithCompression(query, { maxRounds: 20, label, compressInterval: 12 });
							solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
						} else if (useSimpleMem) {
							// SimpleMem: solve with semantic compression + adaptive retrieval
							this.log(`[${label}] SimpleMem init: solving with compressed memory...`);
							solution = await this.simpleMemSolve(query, { maxRounds: 5, label });
							solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
						} else if (useAgeMem) {
							// AgeMem: solve with unified LTM/STM memory management
							this.log(`[${label}] AgeMem init: solving with memory tools...`);
							solution = await this.ageMemSolveWithMemoryTools(query, { maxRounds: 3, label });
							solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
							// Store initial solution insights to LTM
							const detailed = this.extractTag(solution, 'detailed') || '';
							if (detailed.length > 100 && !noMemory) {
								const insight = `Round ${round} approach: ${detailed.slice(0, 200).trim()}`;
								this.ageMemLtmAdd(insight, 'approach');
							}
						} else {
							const init = await runBaseInit([]);
							solution = init.solution || '';
							solverMemory = noMemory ? '' : (init.memory || '');
						}

						lastSolution = solution;

						if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
							this.log(`[${label}] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
							continue;
						}

						let verification = null;
						const runVerifier = async (solutionXml) => {
							__budgetCheck('verifier');
							let verification = await this.test21VerifyMathSolution(query, solutionXml);
							redTeamCallsUsed += 1;
							let skipCorrection = false;
							if (doubleVerifyGate && !verification.isGood && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
								__budgetCheck('verifier2');
								const verification2 = await this.test21VerifyMathSolution(query, solutionXml);
								redTeamCallsUsed += 1;
								if (verification2.isGood) {
									this.log(`[${label}] Double-verify mismatch (pass/fail); skipping correction.`);
									skipCorrection = true;
								} else if (!(await __reasonsAgree(verification.bugReport, verification2.bugReport))) {
									this.log(`[${label}] Double-verify mismatch (reason); skipping correction.`);
									skipCorrection = true;
								} else {
									const extra = verification2.bugReport ? `\n\n[Verifier2]\n${verification2.bugReport}` : '';
									verification = { ...verification, bugReport: `${verification.bugReport || ''}${extra}`.trim() };
								}
							}
							return { verification, skipCorrection };
						};

						let verifierSkipCorrection = false;
						if (initialVerificationOverride) {
							verification = initialVerificationOverride;
							verifierSkipCorrection = false;
							this.log(`[${label}] Using init verification override (mcts).`);
						} else {
							const res = await runVerifier(solution);
							verification = res.verification;
							verifierSkipCorrection = res.skipCorrection;
						}

						let grade = null;
						if (flags.useGrade || flags.useOutlier) {
							grade = await this.test31EvaluateSolution(query, solution);
							if (flags.useOutlier && grade?.verdict === 'Outlier' && grade.outlierInsight) {
								if (!outlierInsights.includes(grade.outlierInsight)) outlierInsights.push(grade.outlierInsight);
							}
							if (flags.useGrade && grade?.verdict === 'Good') {
								goodStreak += 1;
								if (goodStreak >= 2) {
									checkpoint = solution;
									this.log(`[${label}] Good twice ‚Äî checkpoint set.`);
								}
							} else if (flags.useGrade) {
								goodStreak = 0;
							}
						}

						let passStreak = verification.isGood ? 1 : 0;
						let failStreak = verification.isGood ? 0 : 1;

						for (let iter = 0; iter < ITER_HARD_CAP; iter++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							__budgetCheck(`round ${round} iter ${iter}`);
							this.log(`[${label}] Iter ${iter}: pass=${passStreak}/${PASS_STREAK_TARGET}, failStreak=${failStreak}/${FAIL_STREAK_LIMIT}, redteam=${redTeamCallsUsed}/${REDTEAM_CALL_BUDGET_PER_ROUND}`);
							let endVerifierOverride = null;
							let endVerifierSkipOverride = false;

							if (passStreak >= PASS_STREAK_TARGET) {
								let stable = true;
								let stabilityNote = '';

								if (quietPass && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
									this.log(`[${label}] Quiet-pass: running stability check...`);
									const qc = await this.test48QuietPositionCheck(query, solution);
									redTeamCallsUsed += 1;
									if (qc.unstable) {
										stable = false;
										stabilityNote = qc.note || 'Adversarial checker reported a credible flaw.';
										this.log(`[${label}] Quiet-pass: unstable -> continue.`);
									} else {
										this.log(`[${label}] Quiet-pass: stable.`);
									}
								}

										if (stable && ans2Gate) {
											const tok1 = await extractAnswerTokenNorm(solution, true);
										const altTemp = Math.max(0.2, Math.min(0.95, sampleTemp + 0.15 + Math.random() * 0.25));
										this.log(`[${label}] ans2: re-solving once for answer stability (t=${altTemp.toFixed(2)})...`);
										const alt = await this.test48SolveOnceSolutionXml(buildSolverProblem([]), { temperature: altTemp });
										const tok2 = await extractAnswerTokenNorm(alt, true);
										if (
											tok1 && tok2 &&
											tok1 !== 'unknown' && tok2 !== 'unknown' &&
											(tok1 === tok2 || await __answersAgree(tok1, tok2))
										) {
											this.log(`[${label}] ans2: stable token "${tok1}"${tok1 === tok2 ? '' : ' (equivalent)'}.`);
										} else {
											stable = false;
											stabilityNote = `Answer token unstable between two solves: "${tok1}" vs "${tok2}".`;
											this.log(`[${label}] ans2: unstable -> continue.`);
											}
										}

										if (stable && blindAnsK >= 1) {
											if (redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
												let tokMain = await extractAnswerTokenNorm(solution, false);
												if ((!tokMain || tokMain === 'unknown')) tokMain = await extractAnswerTokenNorm(solution, true);
												if (!tokMain || tokMain === 'unknown') {
													this.log(`[${label}] blindans: skipped (could not extract answer token).`);
												} else {
													const kMax = Math.max(1, Math.min(8, blindAnsK));
													const room = Math.max(0, (REDTEAM_CALL_BUDGET_PER_ROUND - redTeamCallsUsed));
													const k = Math.max(0, Math.min(kMax, room));
													if (k <= 0) {
														this.log(`[${label}] blindans: skipped (no redteam budget left).`);
													} else {
														const sys = `You are a strict answer-only solver.

Solve the problem from scratch.

Output ONLY:
<ans>FINAL_ANSWER</ans>

Rules:
- If multiple-choice, FINAL_ANSWER must be ONLY the option label (e.g., A/B/C/D/E or 1/2/3/4/5 or ‚ë†/‚ë°/‚ë¢/‚ë£/‚ë§).
- Do not include any explanation.`;
														const problemText = blindRaw ? String(query || '') : buildSolverProblem([]);
														const counts = new Map();
														const seen = [];
														this.log(`[${label}] blindans: running answer-only stability checks (k=${k})...`);
														for (let i = 0; i < k; i++) {
															if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
															__budgetCheck(`blindans ${i + 1}/${k}`);
															const user = `PROBLEM:\n${problemText}\n\nReturn the final answer now.`;
															const resp = await this.callAPI(
																[{ role: 'system', content: sys }, { role: 'user', content: user }],
																(txt) => txt.includes('<ans>') && txt.includes('</ans>'),
																{ temperature: 0.2 }
															);
															redTeamCallsUsed += 1;
															const raw = (this.extractTag(resp, 'ans') || '').toString().trim();
															const norm = this.normalizeAnswerToken(raw) || 'unknown';
															seen.push(norm);
															if (norm && norm !== 'unknown') counts.set(norm, (counts.get(norm) || 0) + 1);
														}
														const best = Array.from(counts.entries()).sort((a, b) => b[1] - a[1])[0] || null;
														const bestTok = best ? best[0] : 'unknown';
														const bestCnt = best ? best[1] : 0;
														const need = Math.floor(k / 2) + 1;
														const ok =
															bestTok && bestTok !== 'unknown'
															&& bestCnt >= need
															&& (bestTok === tokMain);
														if (ok) {
															this.log(`[${label}] blindans: stable token "${tokMain}" (majority ${bestCnt}/${k}).`);
														} else {
															stable = false;
															stabilityNote = `BlindAnswerGate mismatch: candidate "${tokMain}" vs blind majority "${bestTok}" (votes ${bestCnt}/${k}; all=${seen.join(',')}).`;
															this.log(`[${label}] blindans: unstable -> continue.`);
														}
													}
												}
											} else {
												this.log(`[${label}] blindans: skipped (no redteam budget left).`);
											}
										}

											if (stable && passVerifyGate && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
												this.log(`[${label}] pass2: verifying success one more time...`);
												const vr = await runVerifier(solution);
												if (!vr?.verification?.isGood) {
													stable = false;
												stabilityNote = `Second verifier run did not confirm success.`;
												this.log(`[${label}] pass2: mismatch -> continue.`);
											} else {
												this.log(`[${label}] pass2: confirmed.`);
											}
											} else if (stable && passVerifyGate) {
												this.log(`[${label}] pass2: skipped (no verifier budget left).`);
											}

											if (stable && refuteK >= 1) {
												if (redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
													const k = Math.max(1, Math.min(12, refuteK));
													this.log(`[${label}] refute: generating critiques (k=${k})...`);
													const notes = await this.test48GenerateVerbalizedRedTeamNotes(query, solution, k, vsOpts);
													redTeamCallsUsed += 1;
													for (const n of notes) {
														if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
														if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) break;
														const text = (n?.text || '').toString().trim();
														if (!text) continue;
														const ok = await this.test31ValidateFlaw(query, solution, __trimText(text, 1800, 'head'));
														redTeamCallsUsed += 1;
														if (ok) {
															stable = false;
															stabilityNote = `Refute gate found a credible flaw: ${text}`;
															this.log(`[${label}] refute: flaw confirmed -> continue.`);
															break;
														}
													}
													if (stable) this.log(`[${label}] refute: no validated flaw.`);
												} else {
													this.log(`[${label}] refute: skipped (no redteam budget left).`);
												}
											}

										if (stable) {
											__roundSuccess = true;
											this.state.status = 'Success';
											this.state.finalResult = solution || '';
											this.updateStatusUI('Success', 'var(--log-success)');
										const resEl = document.getElementById(`result-area-${this.uniqueId}`);
										if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}

								// Convert "unstable success" into a failure to trigger correction/regeneration.
								verification = { isGood: false, bugReport: `[StabilityCheck] ${stabilityNote}`.trim(), fullVerification: '', decisionXml: '' };
								verifierSkipCorrection = false;
								passStreak = 0;
								failStreak += 1;
							}

							if (failStreak >= FAIL_STREAK_LIMIT) {
								this.log(`[${label}] Round ended (fail-streak ${FAIL_STREAK_LIMIT}).`);
								break;
							}

							if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
								this.log(`[${label}] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
								break;
							}

							if (!verification.isGood) {
								let bugReport = verification.bugReport || '';
								let overlap = null;
								let skipCorrection = verifierSkipCorrection;

								if (banAns) {
									const tok = await extractAnswerTokenNorm(solution, false);
									if (tok && tok !== 'unknown' && !bannedAnswerTokens.includes(tok)) {
										bannedAnswerTokens.push(tok);
										while (bannedAnswerTokens.length > 30) bannedAnswerTokens.shift();
										this.log(`[${label}] banans: added "${tok}"`);
									}
								}

								if (flags.useOverlap) {
									overlap = await this.test43BuildOverlapDiagnosis(query, solution, { vsDiagK });
									if (overlap) {
										const overlapOk = useOverlapAgreement ? (await __reasonsAgree(bugReport, overlap.diagnosis)) : true;
										if (overlapOk) {
											bugReport = `${bugReport}\n\n[Overlap diagnosis]\n${overlap.diagnosis}`;
											this.log(`[${label}] Overlap diagnosis applied.`);
										} else {
											this.log(`[${label}] Overlap disagreed with verifier; ignoring overlap.`);
										}
									} else {
										if (skipCorrectionWithoutOverlap) {
											this.log(`[${label}] Overlap missing; skipping correction.`);
											skipCorrection = true;
										} else {
											this.log(`[${label}] Overlap diagnosis inconclusive; using verifier report.`);
										}
									}
								}

									if (vsRedK >= 2 && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
										this.log(`[${label}] vsred: generating critiques (k=${vsRedK})...`);
										const notes = await this.test48GenerateVerbalizedRedTeamNotes(query, solution, vsRedK, vsOpts);
										redTeamCallsUsed += 1;
										if (notes.length) {
											const top = notes[0]?.text || '';
											let second = '';
											if (notes.length >= 2) {
											const setA = this.test43WordSetForDiversity(top);
											let best = null;
											for (let i = 1; i < notes.length; i++) {
												const t = notes[i]?.text || '';
												if (!t) continue;
												const sim = this.test43JaccardSimilarity(setA, this.test43WordSetForDiversity(t));
												if (!best || sim < best.sim) best = { text: t, sim };
											}
											second = best?.text || (notes[1]?.text || '');
										}
										const block = [top, second].filter(Boolean).map(s => `- ${s}`).join('\n');
										if (block) bugReport = `${bugReport}\n\n[VS RedTeam Notes]\n${block}`.trim();
									}
								}

								if (procsup && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
									this.log(`[${label}] procsup: extracting first failing step...`);
									const ps = await this.test48ProcessSupervisorBugReport(query, solution, bugReport);
									redTeamCallsUsed += 1;
									if (ps) bugReport = `${bugReport}\n\n[Process Supervision]\n${ps}`.trim();
								}

								if (deltaSum && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
									this.log(`[${label}] deltasum: compressing bug report...`);
									const delta = await this.test48SummarizeBugReportDelta(bugReport);
									redTeamCallsUsed += 1;
									if (delta) bugReport = delta;
								}

								if (resetOnSameFailure || requireSameFailureTwice) {
									const reasonNow = String(bugReport || '').trim();
									if (reasonNow && lastFailureReason) {
										if (await __reasonsAgree(reasonNow, lastFailureReason)) {
											sameFailureStreak += 1;
										} else {
											sameFailureStreak = 1;
											lastFailureReason = reasonNow;
										}
									} else if (reasonNow) {
										sameFailureStreak = 1;
										lastFailureReason = reasonNow;
									} else {
										sameFailureStreak = 0;
										lastFailureReason = '';
									}
								}

								if (resetOnSameFailure) {
									const threshold = requireSameFailureTwice ? 3 : 2;
									if (sameFailureStreak >= threshold) {
										this.log(`[${label}] Same failure repeated; regenerating solution.`);
										const regenMemory = noMemory ? '' : this.test43MergeOutlierMemory(solverMemory, outlierInsights);
										__budgetCheck('regen: same-failure');
										const regen = freeformFull
											? await this.test40IcrSolveSolutionFreeform(buildSolverProblem([]), { memory: regenMemory }, label, solveOptsFor(failStreak))
											: await this.test40IcrSolveSolution(buildSolverProblem([]), { memory: regenMemory }, label, solveOptsFor(failStreak));
										solution = regen.solution || '';
										solverMemory = noMemory ? '' : (regen.memory || '');
										lastSolution = solution;
										correctionsThisRound += 1;
										sameFailureStreak = 0;
										lastFailureReason = '';
										passStreak = 0;
										failStreak = 0;
										skipCorrection = true;
									}
								}

								if (requireSameFailureTwice && sameFailureStreak < 2) {
									this.log(`[${label}] Waiting for same failure twice before correction.`);
									skipCorrection = true;
								}

								if (capCorrectionsPerRound && correctionsThisRound >= 1) {
									this.log(`[${label}] Correction cap reached; skipping correction.`);
									skipCorrection = true;
								}

								if (overlapStrengthGate) {
									if (!overlap || !this.test43IsOverlapStrong(overlap)) {
										this.log(`[${label}] Weak or missing overlap; regenerating solution.`);
										const regenMemory = noMemory ? '' : this.test43MergeOutlierMemory(solverMemory, outlierInsights);
										__budgetCheck('regen: weak-overlap');
										const regen = freeformFull
											? await this.test40IcrSolveSolutionFreeform(buildSolverProblem([]), { memory: regenMemory }, label, solveOptsFor(failStreak))
											: await this.test40IcrSolveSolution(buildSolverProblem([]), { memory: regenMemory }, label, solveOptsFor(failStreak));
										solution = regen.solution || '';
										solverMemory = noMemory ? '' : (regen.memory || '');
										lastSolution = solution;
										correctionsThisRound += 1;
										skipCorrection = true;
									}
								}

								if (!skipCorrection) {
									if (flags.useGrade && grade?.verdict === 'Fundamental Error') {
										this.log(`[${label}] Grade Fundamental Error ‚Äî regenerating solution.`);
										const regenMemory = noMemory ? '' : this.test43MergeOutlierMemory(solverMemory, outlierInsights);
										__budgetCheck('regen: fundamental-error');
										const regen = freeformFull
											? await this.test40IcrSolveSolutionFreeform(buildSolverProblem([]), { memory: regenMemory }, label, solveOptsFor(failStreak))
											: await this.test40IcrSolveSolution(buildSolverProblem([]), { memory: regenMemory }, label, solveOptsFor(failStreak));
										solution = regen.solution || '';
										solverMemory = noMemory ? '' : (regen.memory || '');
										lastSolution = solution;
									} else {
												if (totCorrK >= 2 && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
													this.log(`[${label}] totcorr: branching ${totCorrK} correction candidates...`);
													const extra = [seedBlock, (useHiddenState && hiddenStateSummary) ? `HIDDEN STATE SUMMARY:\n${hiddenStateSummary}` : '', formatBannedTokensBlock()].filter(Boolean).join('\n\n');
													const cands = await this.test48GenerateVerbalizedCorrections(query, solution, __trimText(bugReport || '', bugCap, 'tail'), totCorrK, extra, vsOpts);
													redTeamCallsUsed += 1;

											const candXmls = cands.map(c => this.test21CoerceFreeformToSolutionXml(c.text));
											let pickedXml = '';
											for (let i = 0; i < candXmls.length; i++) {
												if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
												if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) break;
												const candXml = candXmls[i];
												const res = await runVerifier(candXml);
												if (res.verification?.isGood) {
													pickedXml = candXml;
													endVerifierOverride = res.verification;
													endVerifierSkipOverride = res.skipCorrection;
													break;
												}
											}

											if (pickedXml) {
												solution = pickedXml;
												lastSolution = solution;
												solverMemory = noMemory ? '' : solverMemory;
											} else {
												let bestXml = candXmls[0] || '';
												if (candXmls.length >= 2 && redTeamCallsUsed < REDTEAM_CALL_BUDGET_PER_ROUND) {
													const scores = await this.test48ScoreCandidatesValueNet(query, candXmls);
													redTeamCallsUsed += 1;
													const bestIdx = scores[0]?.idx ? Math.max(0, Math.min(candXmls.length - 1, scores[0].idx - 1)) : 0;
													bestXml = candXmls[bestIdx] || bestXml;
												}
												if (bestXml) solution = bestXml;
												lastSolution = solution;
												solverMemory = noMemory ? '' : solverMemory;
											}
												} else {
													__budgetCheck('correct');
													const memForCorr = noMemory ? '' : __trimText(this.test43MergeOutlierMemory(solverMemory, outlierInsights), memCap, 'tail');
													const bugForCorr = __trimText(bugReport || '', bugCap, 'tail');
													if (sotCorr && sotK >= 2) {
														const dsol = this.test21ExtractDetailedFromSolution(solution || '');
														this.log(`[${label}] sotcorr: council correction (k=${sotK})...`);
														const corrBlocks = [
															seedBlock,
															`MEMORY SUMMARY (may be empty):\n${memForCorr || '(none)'}`,
															`CURRENT SOLUTION (detailed):\n${dsol || '(empty)'}`,
															`BUG REPORT (fix these issues):\n${bugForCorr || '(none)'}`,
														].filter(Boolean);
														const corrTemp = Number.isFinite(solveOptsFor(failStreak)?.temperature)
															? solveOptsFor(failStreak).temperature
															: 0.2;
														const corrRes = await this.testSoTCouncilSolveSolutionXml(buildSolverProblem(corrBlocks), {
															k: sotK,
															lite: sotLite,
															critique: sotCrit,
															markers: discourseMarkers,
															temperature: Math.max(0.15, Math.min(0.55, corrTemp + 0.15)),
														});
														solution = corrRes?.solution || '';
														solverMemory = noMemory ? '' : (await computeInitialMemory(solution));
														lastSolution = solution;
													} else {
														const corrected = freeformFull
															? await this.test40IcrSolveSolutionFreeform(
																buildSolverProblem([]),
																{ memory: memForCorr, solutionXml: solution, bugReport: bugForCorr },
																label,
																solveOptsFor(failStreak)
															)
															: await this.test40IcrSolveSolution(
																buildSolverProblem([]),
																{ memory: memForCorr, solutionXml: solution, bugReport: bugForCorr },
																label,
																solveOptsFor(failStreak)
															);
														solution = corrected.solution || '';
														solverMemory = noMemory ? '' : (corrected.memory || '');
														lastSolution = solution;
													}
												}
										}
										correctionsThisRound += 1;
									}
							} else if (flags.useGrade && grade?.verdict === 'Good') {
								const improved = await this.test43SelfImproveSolutionXml(
									buildSolverProblem([]),
									solution,
									noMemory ? '' : this.test43MergeOutlierMemory(solverMemory, outlierInsights)
								);
								solution = improved || solution;
								lastSolution = solution;
							}

							if (redTeamCallsUsed >= REDTEAM_CALL_BUDGET_PER_ROUND) {
								this.log(`[${label}] Round ended (redteam-budget ${REDTEAM_CALL_BUDGET_PER_ROUND}).`);
								break;
							}

							{
								if (endVerifierOverride) {
									verification = endVerifierOverride;
									verifierSkipCorrection = endVerifierSkipOverride;
								} else {
									const res = await runVerifier(solution);
									verification = res.verification;
									verifierSkipCorrection = res.skipCorrection;
								}
							}
							if (verification.isGood) {
								passStreak += 1;
								failStreak = 0;
							} else {
								passStreak = 0;
								failStreak += 1;
							}

							grade = null;
							if (flags.useGrade || flags.useOutlier) {
								grade = await this.test31EvaluateSolution(query, solution);
								if (flags.useOutlier && grade?.verdict === 'Outlier' && grade.outlierInsight) {
									if (!outlierInsights.includes(grade.outlierInsight)) outlierInsights.push(grade.outlierInsight);
								}
								if (flags.useGrade && grade?.verdict === 'Good') {
									goodStreak += 1;
									if (goodStreak >= 2) {
										checkpoint = solution;
										this.log(`[${label}] Good twice ‚Äî checkpoint set.`);
									}
								} else if (flags.useGrade) {
									goodStreak = 0;
								}
							}

								if (flags.useGrade && checkpoint && failStreak >= 2) {
									this.log(`[${label}] Restoring checkpoint after fail streak.`);
									solution = checkpoint;
									failStreak = 0;
									passStreak = 0;
								}
							}
								} catch (e) {
									const msg = (e && e.message) ? String(e.message) : '';
									if (msg.startsWith(`${__roundStopPrefix}:`)) {
										__roundAbort = msg.includes(':tok:') ? `tcap${ROUND_TOKEN_CAP}` : `rcap${ROUND_CALL_CAP}`;
										if (msg.includes(':tok:')) {
											this.log(`[${label}] Round ${round} aborted (tcap${ROUND_TOKEN_CAP}).`);
										} else {
											this.log(`[${label}] Round ${round} aborted (rcap${ROUND_CALL_CAP}).`);
										}
										continue;
									}
									throw e;
								} finally {
								// Post-round bookkeeping for escape mechanisms (only if the round didn't succeed).
								if (!__roundSuccess && (autoBanThreshold >= 2 || coolBanRounds >= 1)) {
									try {
										const tok = await extractAnswerTokenNorm(solution || lastSolution || '', false);
										if (tok && tok !== 'unknown') {
											__answerHist.set(tok, (__answerHist.get(tok) || 0) + 1);
											if (autoBanThreshold >= 2 && (__answerHist.get(tok) || 0) >= autoBanThreshold) {
												if (!bannedAnswerTokens.includes(tok)) {
													bannedAnswerTokens.push(tok);
													while (bannedAnswerTokens.length > 30) bannedAnswerTokens.shift();
													this.log(`[${label}] autoban: added "${tok}" (count=${__answerHist.get(tok)})`);
												}
											}
											if (coolBanRounds >= 1) __coolBans.set(tok, coolBanRounds);
										}
									} catch { }
								}
									// Per-round telemetry (useful for diagnosing runaway rounds / choosing rcap).
									try {
										const startCalls = (typeof this.state._roundCallStartCalls === 'number' && Number.isFinite(this.state._roundCallStartCalls))
											? this.state._roundCallStartCalls
											: (this.state.metrics.calls || 0);
										const startTok = (typeof this.state._roundTokenStartTokens === 'number' && Number.isFinite(this.state._roundTokenStartTokens))
											? this.state._roundTokenStartTokens
											: (this.state.metrics.tokens || 0);
										const usedCalls = (this.state.metrics.calls || 0) - startCalls;
										const usedTok = (this.state.metrics.tokens || 0) - startTok;
										const tag = __roundSuccess ? 'SUCCESS' : (__roundAbort ? `ABORT:${__roundAbort}` : 'END');
										this.log(`[${label}] Round ${round} summary: ${tag}; calls=${usedCalls}; tokens=${usedTok}`);
									} catch { }
									// Clear per-round cap start marker so other non-round operations aren't affected.
									this.state._roundCallCap = 0;
										this.state._roundCallStartCalls = null;
										this.state._roundTokenCap = 0;
										this.state._roundTokenStartTokens = null;
										try { saveToLocalStorage(); } catch { }
									}
								}

						this.state.status = 'Failed';
						this.state.finalResult = lastSolution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl && this.state.finalResult) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			getRoutingSignals(query) {
				const text = (query || '').toString();
				const length = text.length;
				const words = text.trim() ? text.trim().split(/\s+/).length : 0;
				const mathSymbols = (text.match(/[=+\-*/^_]/g) || []).length;
				const digits = (text.match(/\d/g) || []).length;
				const keywordHits = [
					/prove|proof|derive|show that|demonstrate/i,
					/Ï†ïÎ¶¨|Ï¶ùÎ™Ö|Ï¶ùÎ™ÖÌïò|Î≥¥Ïù¥|ÎèÑÏ∂ú|Ïú†ÎèÑ/i,
					/ÏµúÎåÄ|ÏµúÏÜå|ÏµúÏÜüÍ∞í|ÏµúÎåìÍ∞í|Ìï®Ïàò|Ï†ïÏàò|Ïã§Ïàò|Îì±Ïãù|Î∂ÄÎì±Ïãù/i,
				].reduce((acc, re) => acc + (re.test(text) ? 1 : 0), 0);
				let score = 0;
				if (length > 400) score += 1;
				if (length > 800) score += 1;
				if (words > 80) score += 1;
				if (words > 160) score += 1;
				if (mathSymbols >= 3) score += 1;
				if (mathSymbols >= 8) score += 1;
				if (digits >= 5) score += 1;
				score += keywordHits * 2;
				return { score, length, words, mathSymbols, digits, keywordHits };
			}

			normalizeAnswerToken(text) {
				let s = String(text || '').trim();
				if (!s) return '';

				// Strip common wrappers.
				s = s.replace(/^\s*(?:final\s+answer|answer|Ï†ïÎãµ)\s*[:Ôºö]\s*/i, '').trim();
				s = s.replace(/\$+/g, '');
				s = s.replace(/\\boxed\s*{([^}]*)}/gi, '$1');
				s = s.replace(/[‚Äú‚Äù"]/g, '');
				s = s.replace(/\s+/g, ' ').trim();

				// Normalize circled numerals and fullwidth digits early.
				const circled = { '‚ë†': '1', '‚ë°': '2', '‚ë¢': '3', '‚ë£': '4', '‚ë§': '5' };
				s = s.replace(/[‚ë†‚ë°‚ë¢‚ë£‚ë§]/g, (ch) => circled[ch] || ch);
				s = s.replace(/[Ôºê-Ôºô]/g, (ch) => String.fromCharCode(ch.charCodeAt(0) - 0xFF10 + 0x30));

				// If the text clearly encodes a multiple-choice label, canonicalize it.
				const direct = s.replace(/\s+/g, '').replace(/[\.„ÄÇÔºé,Ôºå;:]/g, '');
				if (/^[1-5]$/.test(direct)) return direct;
				if (/^[a-e]$/i.test(direct)) return direct.toUpperCase();

				const optionHit = s.match(/\b(?:option|choice|answer)\b\s*[:Ôºö]?\s*([1-5a-e])\b/i);
				if (optionHit && optionHit[1]) {
					const c = optionHit[1];
					return /^[a-e]$/i.test(c) ? c.toUpperCase() : c;
				}

				// LaTeX light normalization for common math-expression answers.
				let t = s;
				t = t.replace(/\\(d?frac)\s*{([^{}]+)}{([^{}]+)}/g, '($2)/($3)');
				t = t.replace(/\\left|\\right/g, '');
				t = t.replace(/\\cdot|\\times/g, '*');
				t = t.replace(/[{}]/g, '');

				return t
					.trim()
					.replace(/\s+/g, '')
					.replace(/[\.„ÄÇÔºé,Ôºå;:]/g, '')
					.toLowerCase();
			}

			extractFinalAnswerTokenHeuristic(draft) {
				const text = (draft || '').toString();
				if (!text.trim()) return '';

				const line = text.match(/(?:^|\n)\s*(?:final\s+answer|answer|Ï†ïÎãµ)\s*[:Ôºö]\s*([^\n]+)/i);
				if (line && line[1]) {
					const cand = line[1].trim();
					const circled = cand.match(/[‚ë†‚ë°‚ë¢‚ë£‚ë§]/);
					if (circled) return circled[0];
					const letter = cand.match(/\b([ABCDE])\b/i);
					if (letter) return letter[1].toUpperCase();
					const digit = cand.match(/\b([1-5])\b/);
					if (digit) return digit[1];
					return cand.split(/\s+/)[0] || cand;
				}

				const circledAll = text.match(/[‚ë†‚ë°‚ë¢‚ë£‚ë§]/g);
				if (circledAll && circledAll.length) return circledAll[circledAll.length - 1];

				const endLetter = text.trim().match(/\b([ABCDE])\b\s*$/i);
				if (endLetter) return endLetter[1].toUpperCase();

				const endDigit = text.trim().match(/\b([1-5])\b\s*$/);
				if (endDigit) return endDigit[1];

				return '';
			}

			async extractFinalAnswerToken(query, draft) {
				const prompt = `Extract the final answer ONLY from the response.

Rules:
- If multiple-choice, return ONLY the choice label (e.g., ‚ë†/‚ë°/‚ë¢/‚ë£ or A/B/C/D or 1/2/3/4).
- If numeric, return the number with unit (if any).
- If unclear, return "UNKNOWN".

Query:
${query}

Response:
${draft}`;
				return await this.callAPI(
					[
						{ role: 'system', content: 'You are an answer extractor. Output only the final answer token.' },
						{ role: 'user', content: prompt }
					],
					null,
					{ temperature: 0.1 }
				);
			}

			finalizeRoutingSuccess(result) {
				this.state.status = 'Success';
				this.state.finalResult = result || '';
				this.updateStatusUI('Success', 'var(--log-success)');
				const resEl = document.getElementById(`result-area-${this.uniqueId}`);
				if (resEl) resEl.value = this.state.finalResult;
			}

			async test37GenerateDraft(query) {
				const ITERATIONS = 3;
				let memory = '';
				let draft = '';

				draft = await this.callAPI(
					[
						{ role: 'system', content: 'You are the Main Generator. Produce an initial solution/draft for the user request.' },
						{ role: 'user', content: `User request:\n${query}\n\nProduce the initial draft.` }
					],
					null,
					{ temperature: 0.7 }
				);

				for (let i = 1; i <= ITERATIONS; i++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const suggestions = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Iterative Agent. Suggest improvements and corrections to the draft. Be concrete.' },
							{ role: 'user', content: `User request:\n${query}\n\nMemory:\n${memory || '(none)'}\n\nCurrent draft:\n${draft}\n\nProvide suggestions and identify issues.` }
						],
						null,
						{ temperature: 0.2 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					draft = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Main Generator. Apply the suggestions to revise the draft. Output the full revised draft.' },
							{ role: 'user', content: `User request:\n${query}\n\nMemory:\n${memory || '(none)'}\n\nCurrent draft:\n${draft}\n\nSuggestions:\n${suggestions}\n\nReturn the revised draft.` }
						],
						null,
						{ temperature: 0.5 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					memory = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Memory Agent. Update the memory summary (max 8 bullets) based on the new draft and suggestions.' },
							{ role: 'user', content: `User request:\n${query}\n\nRevised draft:\n${draft}\n\nSuggestions applied:\n${suggestions}\n\nPrevious memory:\n${memory || '(none)'}\n\nReturn updated memory summary.` }
						],
						null,
						{ temperature: 0.2 }
					);
				}

				return { draft, memory };
			}

			async runTest47RoutingArchitecture(query, label) {
				const signals = this.getRoutingSignals(query);
				const score = signals.score;

				const logRoute = (target, reason) => {
					this.log(`[${label}] Route -> ${target} (${reason})`);
				};

				if (label === 'test47-1') {
					if (score <= 2) {
						logRoute('test37', `score=${score} (lite-gate: easy)`);
						return await this.runTest37Architecture(query);
					}
					logRoute('test43-1-2', `score=${score} (lite-gate: hard)`);
					return await this.runTest43VariantArchitecture(query, 'test43-1-2');
				}

				if (label === 'test47-2') {
					this.updateStatusUI('Running', 'blue');
					this.startTimer();
					this.stopFlag = false;
					try {
						const { draft } = await this.test37GenerateDraft(query);
						const grade = await this.test31EvaluateSolution(query, draft);
						const verdict = grade?.verdict || 'Flaw';
						this.log(`[${label}] Graded gate verdict: ${verdict}`);
						if (verdict === 'Perfect' || verdict === 'Good' || verdict === 'Outlier') {
							this.state.status = 'Success';
							this.state.finalResult = draft || '';
							this.updateStatusUI('Success', 'var(--log-success)');
							const resEl = document.getElementById(`result-area-${this.uniqueId}`);
							if (resEl) resEl.value = this.state.finalResult;
							this.stopTimer();
							return;
						}
						this.stopTimer();
						logRoute('test43-1-2', `grade=${verdict} (escalate)`);
						return await this.runTest43VariantArchitecture(query, 'test43-1-2');
					} catch (e) {
						const msg = (e && e.message) ? String(e.message) : '';
						if (msg.startsWith(`${__budgetStopPrefix}:`)) {
							this.state.status = 'Failed';
							this.state.finalResult = lastSolution || '';
							const resEl = document.getElementById(`result-area-${this.uniqueId}`);
							if (resEl && this.state.finalResult) resEl.value = this.state.finalResult;
							this.updateStatusUI('Failed (Call Cap)', 'var(--log-error)');
						} else if (msg.startsWith(`${__roundStopPrefix}:`)) {
							// Should normally be caught per-round, but keep a safe fallback.
							this.state.status = 'Failed';
							this.state.finalResult = lastSolution || '';
							this.updateStatusUI('Failed (Round Call Cap)', 'var(--log-error)');
						} else if (msg === "Stopped" || msg === "Stopped by User") {
							this.log("Process Paused.");
							this.updateStatusUI("Paused", "orange");
						} else {
							this.log(`FATAL: ${msg || 'Unknown error'}`);
							this.updateStatusUI("Error", "red");
						}
						this.stopTimer();
					} finally {
						this.state._roundCallCap = 0;
						this.state._roundCallStartCalls = null;
					}
				}

				if (label === 'test47-3') {
					if (score <= 2) {
						logRoute('test37', `score=${score} (tier: easy)`);
						return await this.runTest37Architecture(query);
					}
					if (score <= 4) {
						logRoute('test43', `score=${score} (tier: medium)`);
						return await this.runTest43Architecture(query);
					}
					if (score <= 6) {
						logRoute('test43-1-2', `score=${score} (tier: hard)`);
						return await this.runTest43VariantArchitecture(query, 'test43-1-2');
					}
					logRoute('test43-1-2-3', `score=${score} (tier: very hard)`);
					return await this.runTest43VariantArchitecture(query, 'test43-1-2-3');
				}

				if (label === 'test47-4') {
					const budgetScore = signals.length + signals.mathSymbols * 40 + signals.keywordHits * 120;
					if (budgetScore < 400) {
						logRoute('test37', `budget=${budgetScore} (low)`);
						return await this.runTest37Architecture(query);
					}
					if (budgetScore < 900) {
						logRoute('test43', `budget=${budgetScore} (medium)`);
						return await this.runTest43Architecture(query);
					}
					if (budgetScore < 1600) {
						logRoute('test43-1-2', `budget=${budgetScore} (high)`);
						return await this.runTest43VariantArchitecture(query, 'test43-1-2');
					}
					logRoute('test43-1-2-3', `budget=${budgetScore} (very high)`);
					return await this.runTest43VariantArchitecture(query, 'test43-1-2-3');
				}

				if (label === 'test47-5') {
					this.updateStatusUI('Running', 'blue');
					this.startTimer();
					this.stopFlag = false;
					try {
						const first = await this.test37GenerateDraft(query);
						const answer1Raw = await this.extractFinalAnswerToken(query, first.draft || '');
						const answer1 = this.normalizeAnswerToken(answer1Raw);
						const second = await this.test37GenerateDraft(query);
						const answer2Raw = await this.extractFinalAnswerToken(query, second.draft || '');
						const answer2 = this.normalizeAnswerToken(answer2Raw);
						this.log(`[${label}] test37 answers: "${answer1Raw}" vs "${answer2Raw}"`);
						if (answer1 && answer2 && answer1 !== 'unknown' && answer1 === answer2) {
							this.log(`[${label}] Consistent answers ‚Üí accept test37.`);
							this.finalizeRoutingSuccess(first.draft || '');
							this.stopTimer();
							return;
						}
						this.stopTimer();
						logRoute('test43-2', 'inconsistent or UNKNOWN ‚Üí escalate');
						return await this.runTest43VariantArchitecture(query, 'test43-2');
					} catch (e) {
						const msg = (e && e.message) ? String(e.message) : '';
						if (msg.startsWith(`${__budgetStopPrefix}:`)) {
							this.state.status = 'Failed';
							this.state.finalResult = lastSolution || '';
							const resEl = document.getElementById(`result-area-${this.uniqueId}`);
							if (resEl && this.state.finalResult) resEl.value = this.state.finalResult;
							this.updateStatusUI('Failed (Call Cap)', 'var(--log-error)');
						} else if (msg.startsWith(`${__roundStopPrefix}:`)) {
							this.state.status = 'Failed';
							this.state.finalResult = lastSolution || '';
							this.updateStatusUI('Failed (Round Cap)', 'var(--log-error)');
						} else if (msg === "Stopped" || msg === "Stopped by User") {
							this.log("Process Paused.");
							this.updateStatusUI("Paused", "orange");
						} else {
							this.log(`FATAL: ${msg || 'Unknown error'}`);
							this.updateStatusUI("Error", "red");
						}
						this.stopTimer();
					} finally {
						this.state._roundCallCap = 0;
						this.state._roundCallStartCalls = null;
						this.state._roundTokenCap = 0;
						this.state._roundTokenStartTokens = null;
					}
				}

				if (label === 'test47-6') {
					this.updateStatusUI('Running', 'blue');
					this.startTimer();
					this.stopFlag = false;
					try {
						const { draft } = await this.test37GenerateDraft(query);
						const grade = await this.test31EvaluateSolution(query, draft);
						const verdict = grade?.verdict || 'Flaw';
						this.log(`[${label}] Lite gate verdict: ${verdict}`);
						if (verdict === 'Perfect' || verdict === 'Good' || verdict === 'Outlier') {
							this.finalizeRoutingSuccess(draft || '');
							this.stopTimer();
							return;
						}
						this.stopTimer();
						logRoute('test43-2', `grade=${verdict} (escalate)`);
						return await this.runTest43VariantArchitecture(query, 'test43-2');
					} catch (e) {
						if (e.message === "Stopped" || e.message === "Stopped by User") {
							this.log("Process Paused.");
							this.updateStatusUI("Paused", "orange");
						} else {
							this.log(`FATAL: ${e.message}`);
							this.updateStatusUI("Error", "red");
						}
						this.stopTimer();
					}
				}

				if (label === 'test47-7') {
					this.updateStatusUI('Running', 'blue');
					this.startTimer();
					this.stopFlag = false;
					try {
						const first = await this.test37GenerateDraft(query);
						let grade = await this.test31EvaluateSolution(query, first.draft || '');
						let verdict = grade?.verdict || 'Flaw';
						this.log(`[${label}] Gate verdict (pass1): ${verdict}`);
						if (verdict === 'Perfect' || verdict === 'Good' || verdict === 'Outlier') {
							this.finalizeRoutingSuccess(first.draft || '');
							this.stopTimer();
							return;
						}
						const second = await this.test37GenerateDraft(query);
						grade = await this.test31EvaluateSolution(query, second.draft || '');
						verdict = grade?.verdict || 'Flaw';
						this.log(`[${label}] Gate verdict (retry): ${verdict}`);
						if (verdict === 'Perfect' || verdict === 'Good' || verdict === 'Outlier') {
							this.finalizeRoutingSuccess(second.draft || '');
							this.stopTimer();
							return;
						}
						this.stopTimer();
						logRoute('test43-2', `grade=${verdict} (escalate after retry)`);
						return await this.runTest43VariantArchitecture(query, 'test43-2');
					} catch (e) {
						if (e.message === "Stopped" || e.message === "Stopped by User") {
							this.log("Process Paused.");
							this.updateStatusUI("Paused", "orange");
						} else {
							this.log(`FATAL: ${e.message}`);
							this.updateStatusUI("Error", "red");
						}
						this.stopTimer();
					}
				}
			}

			async runTest44Architecture(query) {
				return await this.runTest40LikeArchitecture(query, 30, 'test44', 3, 3, 'icr');
			}

			async runTest45Architecture(query) {
				return await this.runTest40LikeArchitecture(query, 10, 'test45', 1, 5, 'icr');
			}

			// --- test22-30 (Ïó∞ÏÜçÏã§Ìå® ÎàÑ1 ports) ---
			testNu1DetectConflictingVerdicts(response, validVerdicts) {
				const lowerResponse = (response || '').toString().toLowerCase();
				const foundVerdicts = new Set();
				for (const verdict of (validVerdicts || [])) {
					if (!verdict) continue;
					if (lowerResponse.includes(verdict.toLowerCase())) {
						foundVerdicts.add(verdict);
					}
				}
				return foundVerdicts.size > 1 ? Array.from(foundVerdicts) : null;
			}

			testNu1ExtractSingleVerdict(response, validVerdicts) {
				const conflicts = this.testNu1DetectConflictingVerdicts(response, validVerdicts);
				if (conflicts) return { verdict: null, conflicts };
				const lowerResponse = (response || '').toString().toLowerCase();
				for (const verdict of (validVerdicts || [])) {
					if (!verdict) continue;
					if (lowerResponse.includes(verdict.toLowerCase())) return { verdict, conflicts: null };
				}
				return { verdict: null, conflicts: null };
			}

			getNu1GeneralPurposeStep1Prompt() {
				return `### Core Instructions ###

*   **Comprehensiveness and Sound Reasoning are Paramount:** Your primary goal is to produce a comprehensive and well-reasoned guide or framework. Every point or recommendation must be practical, well-argued, and clearly explained. A good-sounding recommendation derived from weak or incomplete reasoning is considered a failure.
*   **Acknowledge Nuance and Trade-offs:** For topics without a single 'correct' answer, you must explore different perspectives, criteria, and potential trade-offs. If a single definitive method is not possible, your goal is to present a framework for making an informed decision.
*   **Use Clear Formatting:** Structure your response with headings, lists, and bold text to ensure it is easy to understand and follow.

### Output Format ###

Your response MUST be structured into the following sections:

**1. Summary**
Provide a concise overview of your findings with:
*   **a. Verdict:** State clearly whether you are providing a definitive guide, a comparison of different methods, or an exploratory framework for decision-making.
*   **b. Approach Overview:** Present a high-level, conceptual outline of your guide or framework.

**2. Detailed Guide**
Present the full, step-by-step guide, analysis, or framework. Each point must be justified with clear reasoning and, where appropriate, examples.`;
			}

			getNu1GeneralPurposeVerificationPrompt() {
				return `You are an expert analyst and a meticulous editor. Your primary task is to critically evaluate the provided guide for its quality, comprehensiveness, and practicality. A guide is to be judged high-quality **only if its reasoning is sound, its coverage is comprehensive, and its advice is practical.**

### Instructions ###

**1. Core Instructions**
*   Your sole task is to find and report all issues in the provided guide. You must act as a **critic**, NOT a re-writer or solver.
*   You must perform a **point-by-point** check of the entire guide's arguments and recommendations.

**2. How to Handle Issues in the Guide**
When you identify an issue, classify it as:
*   **a. Major Flaw:** Any piece of advice that is impractical, misleading, or completely overlooks a critical aspect of the topic. This includes providing a dangerously unbalanced perspective on an important issue.
*   **b. Weak Argument:** Recommendations or claims that are poorly supported, lack clear reasoning, ignore obvious counter-arguments, or are based on unsubstantiated claims.

**3. Output Format**
Your response MUST contain:
*   **Summary** with a Final Verdict on quality and a List of Findings.
*   **Detailed Critique** providing a point-by-point analysis.

**4. Decision Tag (MANDATORY)**
At the very end of your response (last line), include **exactly one** decision tag in lowercase angle brackets:
*   \`<pass>\`  ‚Üí The guide is high-quality and **does not** contain major flaws or significant weak arguments.
*   \`<fail>\`  ‚Üí Otherwise (any major flaw or significant weak argument exists).

Do not include both tags. Do not add any text after the tag.`;
			}

			validateNu1PassFailArtifact(text) {
				const src = (text || '').toString();
				const hasPass = /<\s*pass\s*>/i.test(src);
				const hasFail = /<\s*fail\s*>/i.test(src);
				if (hasPass && hasFail) return 'Conflicting decision tags (<pass> and <fail>)';
				const finalTag = this.extractFinalSingleTag(src, ['pass', 'fail']);
				if (!finalTag) return 'Missing final <pass> or <fail> tag at end';
				return true;
			}

			nu1ExtractDetailedSolution(solution) {
				const s = (solution || '').toString();
				const marker = "Detailed Guide";
				const idx = s.indexOf(marker);
				if (idx === -1) return s;
				return s.substring(idx + marker.length).trim();
			}

			async nu1GenerateInitialGuide(query) {
				return await this.callAPI([
					{ role: "system", content: this.getNu1GeneralPurposeStep1Prompt() },
					{ role: "user", content: query }
				]);
			}

			async nu1SelfImproveGuide(solution) {
				const improvePrompt = `You have an opportunity to improve your guide. Please review it carefully. Address any weak arguments and fill any gaps in your reasoning. Your new output should strictly follow the instructions in the system prompt.`;
				return await this.callAPI([
					{ role: "assistant", content: solution },
					{ role: "user", content: improvePrompt }
				]);
			}

			async nu1VerifyGuideNoHistory(query, solution) {
				const detailedSolution = this.nu1ExtractDetailedSolution(solution);
				const verifyUser = `======================================================================
### Topic ###

${query}

======================================================================
### Guide to Critique ###

${detailedSolution}

Your task is to act as a critic. Generate the **summary** and the **detailed critique** for the guide above.
Remember to end with exactly one decision tag: <pass> or <fail>.`;

				const verification = await this.callAPI(
					[
						{ role: "system", content: this.getNu1GeneralPurposeVerificationPrompt() },
						{ role: "user", content: verifyUser }
					],
					(txt) => this.validateNu1PassFailArtifact(txt),
					{ temperature: 0.2 }
				);

				const tag = this.extractFinalSingleTag(verification, ['pass', 'fail']) || 'fail';
				const isGood = (tag === 'pass');
				let bugReport = "";
				if (!isGood) {
					const idx = verification.indexOf("Detailed Critique");
					bugReport = (idx > 0) ? verification.substring(0, idx).trim() : verification;
				}
				return { isGood, bugReport, fullVerification: verification };
			}

			async nu1VerifyGuideWithHistorySimple(query, solution, history = []) {
				const detailedSolution = this.nu1ExtractDetailedSolution(solution);
				const historyContext = (Array.isArray(history) && history.length > 0)
					? `\nHere is the history of previous critiques for this topic. Use this context to ensure your critique is consistent and builds upon prior analysis.\n${history.map((h, i) =>
						`\n--- Critique of Attempt ${i + 1} ---\n### Critic's Full Output for Attempt ${i + 1} ###\n${h.fullVerification}`
					).join('\n\n')}\n\n======================================================================\n`
					: '';

				const verifyUser = `${historyContext}### Current Topic ###

${query}

======================================================================
### Current Guide to Critique ###

${detailedSolution}

Your task is to act as a critic. Generate the **summary** and the **detailed critique** for the guide above. Consider the history of critiques when making your judgment.
End your response with exactly one decision tag: <pass> or <fail>.`;

				const verification = await this.callAPI(
					[
						{ role: "system", content: this.getNu1GeneralPurposeVerificationPrompt() },
						{ role: "user", content: verifyUser }
					],
					(txt) => this.validateNu1PassFailArtifact(txt),
					{ temperature: 0.2 }
				);

				const tag = this.extractFinalSingleTag(verification, ['pass', 'fail']) || 'fail';
				const isGood = (tag === 'pass');
				let bugReport = "";
				if (!isGood) {
					const idx = verification.indexOf("Detailed Critique");
					bugReport = (idx > 0) ? verification.substring(0, idx).trim() : verification;
				}
				return { isGood, bugReport, fullVerification: verification };
			}

			async nu1VerifyGuideWithHistoryFull(query, solution, history = []) {
				const detailedSolution = this.nu1ExtractDetailedSolution(solution);
				const historyContext = (Array.isArray(history) && history.length > 0)
					? `\nHere is the history of previous critiques for this topic, including the submitted guides and the critic's full response. Use this context to ensure your critique is consistent and thorough.\n${history.map((h, i) =>
						`\n--- Critique of Attempt ${i + 1} ---\n### Guide Attempt ${i + 1} ###\n${h.solution}\n\n### Previous Critic's Full Output for Attempt ${i + 1} ###\n${h.fullVerification}`
					).join('\n\n')}\n\n======================================================================\n`
					: '';

				const verifyUser = `${historyContext}### Current Topic ###

${query}

======================================================================
### Current Guide to Critique ###

${detailedSolution}

Your task is to act as a critic. Generate the **summary** and the **detailed critique** for the guide above. Consider the full history when making your judgment.
End your response with exactly one decision tag: <pass> or <fail>.`;

				const verification = await this.callAPI(
					[
						{ role: "system", content: this.getNu1GeneralPurposeVerificationPrompt() },
						{ role: "user", content: verifyUser }
					],
					(txt) => this.validateNu1PassFailArtifact(txt),
					{ temperature: 0.2 }
				);

				const tag = this.extractFinalSingleTag(verification, ['pass', 'fail']) || 'fail';
				const isGood = (tag === 'pass');
				let bugReport = "";
				if (!isGood) {
					const idx = verification.indexOf("Detailed Critique");
					bugReport = (idx > 0) ? verification.substring(0, idx).trim() : verification;
				}
				return { isGood, bugReport, fullVerification: verification };
			}

			async nu1CorrectWithFeedback(query, solution, bugReport) {
				const correctionPrompt = `Below is a critique of your guide. If you agree with certain points, can you improve your guide to make it more comprehensive and well-reasoned? Note that the critic can misunderstand your guide and thus make mistakes. If you do not agree with certain items in the critique, please add detailed explanations to clarify your reasoning. Your new guide should strictly follow the instructions in the system prompt.

Critique:
${(bugReport || '').toString()}`;

				return await this.callAPI([
					{ role: "system", content: this.getNu1GeneralPurposeStep1Prompt() },
					{ role: "user", content: query },
					{ role: "assistant", content: solution },
					{ role: "user", content: correctionPrompt }
				]);
			}

			async nu1CorrectWithFullHistoryCritiqueOnly(query, solution, verificationHistory = []) {
				const historyContext = (Array.isArray(verificationHistory) && verificationHistory.length > 0)
					? `\nComplete Critique History:\n${verificationHistory.map((h, i) =>
						`\n=== Iteration ${i + 1} ===\nVerdict: ${h.isGood ? 'PASSED' : 'FLAWED'}\n${h.isGood ? 'Critique passed' : `Critique Summary:\n${h.bugReport}`}`
					).join('\n\n')}`
					: '';

				const latestBugReport = (Array.isArray(verificationHistory) && verificationHistory.length > 0 && !verificationHistory[verificationHistory.length - 1].isGood)
					? verificationHistory[verificationHistory.length - 1].bugReport
					: '';

				const correctionPrompt = `You have attempted to create this guide multiple times. Here is the complete history of all critiques:

${historyContext}

Latest Critique Summary:
${latestBugReport}

Learn from ALL previous attempts and feedback. Avoid repeating past mistakes and address the identified weaknesses. If you disagree with a critique, add clarifications to your reasoning. Your new guide must strictly follow the instructions in the system prompt.`;

				return await this.callAPI([
					{ role: "system", content: this.getNu1GeneralPurposeStep1Prompt() },
					{ role: "user", content: query },
					{ role: "assistant", content: solution },
					{ role: "user", content: correctionPrompt }
				]);
			}

			async nu1CorrectWithFullHistorySolutionsAndFeedback(query, solution, verificationHistory = []) {
				const historyContext = (Array.isArray(verificationHistory) && verificationHistory.length > 0)
					? `Here is the complete history of your previous attempts and the critic's feedback:\n${verificationHistory.map((h, i) =>
						`\n--- Attempt ${i + 1} ---\n### Your Guide Attempt ${i + 1} ###\n${h.solution}\n\n### Critic's Feedback on Attempt ${i + 1} ###\n${h.isGood ? 'This guide was considered high-quality by the critic.' : h.bugReport}`
					).join('\n\n')}`
					: '';

				const latestBugReport = (Array.isArray(verificationHistory) && verificationHistory.length > 0 && !verificationHistory[verificationHistory.length - 1].isGood)
					? verificationHistory[verificationHistory.length - 1].bugReport
					: '';

				const correctionPrompt = `You have attempted to create this guide multiple times. Please review the complete history of all your attempts and the critic's feedback on them:

${historyContext}

Your most recent attempt was criticized for the following:
${latestBugReport}

Learn from ALL previous attempts and feedback. Avoid repeating past mistakes. Generate a new, comprehensive, and well-reasoned guide. Your new guide must strictly follow the instructions in the system prompt.`;

				return await this.callAPI([
					{ role: "system", content: this.getNu1GeneralPurposeStep1Prompt() },
					{ role: "user", content: query },
					{ role: "assistant", content: solution },
					{ role: "user", content: correctionPrompt }
				]);
			}

			async nu1SelfImproveWithHistory(query, solution, verificationHistory = []) {
				const historyContext = (Array.isArray(verificationHistory) && verificationHistory.length > 0)
					? `\nComplete Critique History:\n${verificationHistory.map((h, i) =>
						`\n=== Iteration ${i + 1} ===\nVerdict: ${h.isGood ? 'PASSED' : 'FLAWED'}\n${h.isGood ? 'Critique passed' : `Critique Summary:\n${h.bugReport}`}`
					).join('\n\n')}`
					: '';

				const improvePrompt = `You have an opportunity to improve your guide. Here is the complete history of all critiques for context:

${historyContext}

Please review your current guide carefully. Address any weak arguments and fill any gaps in your reasoning. Your new improved guide must strictly follow the instructions in the system prompt.`;

				return await this.callAPI([
					{ role: "system", content: this.getNu1GeneralPurposeStep1Prompt() },
					{ role: "user", content: query },
					{ role: "assistant", content: solution },
					{ role: "user", content: improvePrompt }
				]);
			}

			async test22GenerateInitialSolution(query) {
				const systemPrompt = `### Core Principles ###
* **Quality is Paramount:** Produce a high-quality, comprehensive, and well-supported response.
* **Support Your Claims:** Every significant claim must be supported by clear reasoning, examples, or evidence.
* **Acknowledge Limitations:** If a topic is complex or debated, acknowledge this clearly.
* **Clarity and Structure:** Organize your response logically using headings and lists.

### Output Format ###
Your response MUST include:
1. **Summary**: Concise overview with key takeaway and outline
2. **Detailed Response**: Full step-by-step explanation or solution`;

				return await this.callAPI([
					{ role: "system", content: systemPrompt },
					{ role: "user", content: query }
				]);
			}

			async test22SelfImprove(previousAnswer) {
				const improvePrompt = `Review your response carefully against the core principles of Quality, Support, and Clarity. 
Correct errors, strengthen reasoning, and improve the overall structure.`;
				return await this.callAPI([
					{ role: "assistant", content: previousAnswer },
					{ role: "user", content: improvePrompt }
				]);
			}

			async test22VerifySolution(query, solution) {
				const verifyPrompt = `You are an expert editor and critical reviewer. Verify this response:

Query: "${query}"
Response: ${solution}

Categorize issues as:
- Factual Error (Critical)
- Support Gap/Weak Reasoning (Major) 
- Clarity/Structural Flaw (Moderate)
- Scope/Completeness Issue (Moderate)

IMPORTANT: Provide a verdict using EXACTLY ONE of these phrases:
- "Excellent" (no significant issues)
- "Good but needs revision" (minor issues)
- "Major revisions required" (significant issues)

Do not mix these verdicts. Choose the single most appropriate one based on your analysis.`;

				const validVerdicts = ["Excellent", "Good but needs revision", "Major revisions required"];
				let last = '';
				for (let attempt = 1; attempt <= 6; attempt++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const verification = await this.callAPI(
						[
							{ role: "system", content: "Act as a critical reviewer. Use ONLY one verdict phrase." },
							{ role: "user", content: verifyPrompt }
						],
						null,
						{ temperature: 0.2 }
					);
					last = verification;
					const parsed = this.testNu1ExtractSingleVerdict(verification, validVerdicts);
					if (parsed.conflicts) {
						this.log(`[test22] ‚ö† Conflicting verdicts: ${parsed.conflicts.join(', ')} (attempt ${attempt}). Retrying...`);
						continue;
					}
					if (!parsed.verdict) {
						this.log(`[test22] ‚ö† Missing verdict (attempt ${attempt}). Retrying...`);
						continue;
					}
					return { verdict: parsed.verdict, feedback: verification };
				}
				return { verdict: "Major revisions required", feedback: last || '' };
			}

			async test22CorrectWithFeedback(query, solution, feedback) {
				const correctPrompt = `Original query: "${query}"

Your previous response has issues:
${feedback}

If you agree with the feedback, improve your response accordingly. 
If not, add detailed explanation to clarify your reasoning.
Your response must follow all quality principles.`;
				return await this.callAPI([
					{ role: "assistant", content: solution },
					{ role: "user", content: correctPrompt }
				]);
			}

			async runTest22Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 20;
				const SUCCESS_STREAK_TARGET = 3;
				let excellentStreak = 0;
				let solution = '';

				try {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log('[test22] Architecture 9: Starting Advanced Verification Pipeline');

					this.log('[test22] Generating initial solution');
					solution = await this.test22GenerateInitialSolution(query);

					this.log('[test22] Applying self-improvement');
					solution = await this.test22SelfImprove(solution);

					for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test22] Iteration ${iteration + 1}/${MAX_ITERATIONS}`);

						const verification = await this.test22VerifySolution(query, solution);
						this.log(`[test22] Quality verdict: ${verification.verdict}`);

						if (verification.verdict === "Excellent") {
							excellentStreak++;
							this.log(`[test22] Excellent streak: ${excellentStreak}/${SUCCESS_STREAK_TARGET}`);
							if (excellentStreak >= SUCCESS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							excellentStreak = 0;
							this.log('[test22] Needs improvement - applying corrections');
							solution = await this.test22CorrectWithFeedback(query, solution, verification.feedback || '');
						}
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Iterations)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest23Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test23] Architecture 11: Agent Pipeline');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test23] === Round ${round}/${MAX_ROUNDS} start ===`);
						let errorCount = 0;

						this.log('[test23] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);

						this.log('[test23] Applying self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test23] Initial critique');
						let verification = await this.nu1VerifyGuideNoHistory(query, solution);
						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test23] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test23] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let iteration = 0; iteration < MAX_ITERATIONS; iteration++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test23] Iteration ${iteration + 1} (round ${round})`);

							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test23] ERROR_THRESHOLD (${ERROR_THRESHOLD}) reached ‚Äî end of round ${round}`);
									break;
								}
								this.log('[test23] Critique failed, improving with feedback');
								solution = await this.nu1CorrectWithFeedback(query, solution, verification.bugReport);
							}

							this.log('[test23] Critiquing new version');
							verification = await this.nu1VerifyGuideNoHistory(query, solution);

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test23] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test23] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test23] ERROR_THRESHOLD (${ERROR_THRESHOLD}) reached ‚Äî end of round ${round}`);
									break;
								}
							}
						}
						this.log(`[test23] === Round ${round} end ===`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					const msg = (e && e.message) ? String(e.message) : '';
					if (msg === "Stopped" || msg === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else if (msg.startsWith(__budgetStopPrefix)) {
						const where = msg.includes(':') ? msg.split(':').slice(1).join(':').trim() : '';
						const loc = where ? ` @ ${where}` : '';
						this.log(`[${label}] Stopped due to call cap (cap${MAX_TOTAL_CALLS})${loc}.`);
						this.state.status = 'Failed';
						this.state.finalResult = lastSolution || '';
						const resEl = document.getElementById(`result-area-${this.uniqueId}`);
						if (resEl && this.state.finalResult) resEl.value = this.state.finalResult;
						this.updateStatusUI('Failed (Call Cap)', 'var(--log-error)');
					} else {
						this.log(`FATAL: ${msg}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest24Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test24] Architecture 12: Agent Pipeline with Full History');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const verificationHistory = [];
						this.log(`[test24] Round ${round}/${MAX_ROUNDS}`);
						let errorCount = 0;

						this.log('[test24] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);
						this.log('[test24] Applying self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test24] Initial critique');
						let verification = await this.nu1VerifyGuideNoHistory(query, solution);
						verificationHistory.push({ iteration: 0, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test24] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test24] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let i = 0; i < MAX_ITERATIONS; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test24] Iteration ${i + 1} (round ${round})`);
							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test24] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
								this.log('[test24] Critique failed, improving with full history');
								solution = await this.nu1CorrectWithFullHistoryCritiqueOnly(query, solution, verificationHistory);
							}

							this.log('[test24] Critiquing new version');
							verification = await this.nu1VerifyGuideNoHistory(query, solution);
							verificationHistory.push({ iteration: i + 1, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test24] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test24] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test24] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
							}
						}
						this.log(`[test24] Round ${round} end`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest25Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test25] Architecture 13: Arch12 + Loop SI');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const verificationHistory = [];
						this.log(`[test25] Round ${round}/${MAX_ROUNDS}`);
						let errorCount = 0;

						this.log('[test25] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);
						this.log('[test25] Applying initial self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test25] Initial critique');
						let verification = await this.nu1VerifyGuideNoHistory(query, solution);
						verificationHistory.push({ iteration: 0, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test25] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test25] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let i = 0; i < MAX_ITERATIONS; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test25] Iteration ${i + 1} (round ${round})`);
							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test25] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
								this.log('[test25] Critique failed, improving with full history');
								solution = await this.nu1CorrectWithFullHistoryCritiqueOnly(query, solution, verificationHistory);
								this.log('[test25] Applying self-improvement with history');
								solution = await this.nu1SelfImproveWithHistory(query, solution, verificationHistory);
							}

							this.log('[test25] Critiquing new version');
							verification = await this.nu1VerifyGuideNoHistory(query, solution);
							verificationHistory.push({ iteration: i + 1, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test25] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test25] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test25] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
							}
						}
						this.log(`[test25] Round ${round} end`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest26Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test26] Architecture 14: History has Solutions');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const verificationHistory = [];
						this.log(`[test26] Round ${round}/${MAX_ROUNDS}`);
						let errorCount = 0;

						this.log('[test26] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);
						this.log('[test26] Applying self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test26] Initial critique');
						let verification = await this.nu1VerifyGuideNoHistory(query, solution);
						verificationHistory.push({ iteration: 0, solution, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test26] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test26] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let i = 0; i < MAX_ITERATIONS; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test26] Iteration ${i + 1} (round ${round})`);
							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test26] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
								this.log('[test26] Critique failed, improving with full solution history');
								solution = await this.nu1CorrectWithFullHistorySolutionsAndFeedback(query, solution, verificationHistory);
							}
							this.log('[test26] Critiquing new version');
							verification = await this.nu1VerifyGuideNoHistory(query, solution);
							verificationHistory.push({ iteration: i + 1, solution, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test26] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test26] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test26] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
							}
						}
						this.log(`[test26] Round ${round} end`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest27Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test27] Architecture 15: Verifier History');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const verificationHistory = [];
						this.log(`[test27] Round ${round}/${MAX_ROUNDS}`);
						let errorCount = 0;

						this.log('[test27] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);
						this.log('[test27] Applying self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test27] Initial critique');
						let verification = await this.nu1VerifyGuideWithHistoryFull(query, solution, verificationHistory);
						verificationHistory.push({ iteration: 0, solution, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test27] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test27] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let i = 0; i < MAX_ITERATIONS; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test27] Iteration ${i + 1} (round ${round})`);
							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test27] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
								this.log('[test27] Critique failed, improving with full solution history');
								solution = await this.nu1CorrectWithFullHistorySolutionsAndFeedback(query, solution, verificationHistory);
							}
							this.log('[test27] Critiquing new version');
							verification = await this.nu1VerifyGuideWithHistoryFull(query, solution, verificationHistory);
							verificationHistory.push({ iteration: i + 1, solution, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test27] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test27] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test27] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
							}
						}
						this.log(`[test27] Round ${round} end`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest28Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test28] Architecture 16: Verifier History (Simple)');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const verificationHistory = [];
						this.log(`[test28] Round ${round}/${MAX_ROUNDS}`);
						let errorCount = 0;

						this.log('[test28] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);
						this.log('[test28] Applying self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test28] Initial critique');
						let verification = await this.nu1VerifyGuideWithHistorySimple(query, solution, verificationHistory);
						verificationHistory.push({ iteration: 0, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test28] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test28] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let i = 0; i < MAX_ITERATIONS; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test28] Iteration ${i + 1} (round ${round})`);
							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test28] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
								this.log('[test28] Critique failed, improving with full history');
								solution = await this.nu1CorrectWithFullHistoryCritiqueOnly(query, solution, verificationHistory);
							}
							this.log('[test28] Critiquing new version');
							verification = await this.nu1VerifyGuideWithHistorySimple(query, solution, verificationHistory);
							verificationHistory.push({ iteration: i + 1, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test28] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test28] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test28] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
							}
						}
						this.log(`[test28] Round ${round} end`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async test29GetConsensusStrategy(query) {
				this.log('[test29] Phase 1.1: Generating and critiquing strategies');
				const strategiesText = await this.callAPI([
					{ role: "system", content: "You are an Architect agent. Your task is to generate 3 to 5 fundamentally distinct, high-level strategies for addressing the given query. Think non-linearly." },
					{ role: "user", content: `Core Query: "${query}"\n\nGenerate 3-5 distinct strategies.` }
				]);

				const critiquePromises = [1, 2].map(() =>
					this.callAPI([
						{ role: "system", content: `You are a Strategist-Critic. Evaluate the viability, potential blind spots, and completeness of every strategy provided.` },
						{ role: "user", content: `Critique these strategies for addressing "${query}":\n\n${strategiesText}` }
					])
				);
				const critiques = await Promise.all(critiquePromises);

				const consensusStrategy = await this.callAPI([
					{ role: "system", content: "You are a Synthesist agent. Your task is to analyze critiques from two independent critics and create a single, new, refined consensus strategy that incorporates the strengths and mitigates the weaknesses identified." },
					{ role: "user", content: `Original Strategies:\n${strategiesText}\n\nCritic 1 Analysis:\n${critiques[0]}\n\nCritic 2 Analysis:\n${critiques[1]}\n\nBased on all of this, formulate the single best consensus strategy.` }
				]);
				return consensusStrategy;
			}

			async test29RunHypothesisCouncil(hypothesis, query) {
				const [advocateResponse, skepticResponse] = await Promise.all([
					this.callAPI([
						{ role: "system", content: "You are a diligent Advocate. Your sole task is to construct a strong, well-reasoned, step-by-step argument that the following claim is true or plausible, based on the Original Query Context. If you cannot make a strong case, state that the argument is weak." },
						{ role: "user", content: `**Original Query Context:**\n\"\"\"\n${query}\n\"\"\"\n\n**Claim to Support:**\n\"\"\"\n${hypothesis}\n\"\"\"\n\n**Your Task:**\nProvide a compelling argument for the Claim.` }
					]),
					this.callAPI([
						{ role: "system", content: "You are a rigorous Skeptic and an expert in finding counter-arguments. Your sole task is to find a single, concrete counter-argument or context that shows the following claim is false or overly simplistic, based on the Original Query Context. If you cannot find a strong counter-argument, state that you were unable to find one." },
						{ role: "user", content: `**Original Query Context:**\n\"\"\"\n${query}\n\"\"\"\n\n**Claim to Challenge:**\n\"\"\"\n${hypothesis}\n\"\"\"\n\n**Your Task:**\nProvide a specific counter-argument that challenges the Claim.` }
					])
				]);

				const validVerdicts = ["PLAUSIBLE", "DOUBTFUL", "UNRESOLVED"];
				let last = '';
				for (let attempt = 1; attempt <= 6; attempt++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const arbiterResponse = await this.callAPI([
						{ role: "system", content: "You are an impartial Arbiter. You will be given a claim, an argument for it, and a counter-argument. Analyze both sides and issue a final verdict. Your response MUST begin with only ONE of these verdicts: PLAUSIBLE, DOUBTFUL, UNRESOLVED. After the verdict, provide a brief, decisive justification for your choice." },
						{ role: "user", content: `**Original Query Context:**\n\"\"\"\n${query}\n\"\"\"\n\n**Claim under review:**\n\"\"\"\n${hypothesis}\n\"\"\"\n\n**Argument from the Advocate:**\n---\n${advocateResponse}\n---\n\n**Argument from the Skeptic:**\n---\n${skepticResponse}\n---\n\n**Your Task:**\nBased on the arguments, issue your final verdict and justification.` }
					]);
					last = arbiterResponse;
					const parsed = this.testNu1ExtractSingleVerdict(arbiterResponse, validVerdicts);
					if (parsed.conflicts) {
						this.log(`[test29] ‚ö† Hypothesis council conflicting verdicts: ${parsed.conflicts.join(', ')} (attempt ${attempt}). Retrying...`);
						continue;
					}
					if (!parsed.verdict) {
						this.log(`[test29] ‚ö† Hypothesis council missing verdict (attempt ${attempt}). Retrying...`);
						continue;
					}
					return { verdict: parsed.verdict, reasoning: arbiterResponse };
				}
				return { verdict: "UNRESOLVED", reasoning: last || '' };
			}

			async test29BuildInitialWorldModel(query, dynamicWorldModelRef) {
				this.log('[test29] Phase 1.2: Formulating initial world model via Hypothesis Council');

				const hypothesisGenerationSystemPrompt = `You are a meticulous planner. Your sole task is to break down a topic into a small set of core, testable claims or questions.

**RULES:**
1.  **DO NOT** answer the query.
2.  **DO NOT** provide final recommendations or guides.
3.  Each item MUST be a declarative statement or a critical question that can be investigated.
4.  Generate a maximum of 5 core claims/questions. Focus on quality over quantity.
5.  Claims should concern the topic's underlying principles, key factors, or common misconceptions.

**EXAMPLE:**
For the query "Design the best way to choose a fig," good claims would be:
- Claim: The color of a fig is the most reliable indicator of its ripeness.
- Claim: A fig's softness to the touch is more important than its color.
- Claim: Figs from a certain region are consistently sweeter than others.`;

				const rawHypothesesText = await this.callAPI([
					{ role: "system", content: hypothesisGenerationSystemPrompt },
					{ role: "user", content: `Core Query: "${query}"\n\nProduce your list of core, testable claims.` }
				]);

				const formattedHypothesesText = await this.callAPI([
					{ role: "system", content: "You are a structural re-formatter. Your task is to extract all distinct, testable claims or questions from the provided text. You must reformat them into a delimited list. Start each item with the delimiter `### CLAIM`. Do not add commentary or change the content. Omit conversational filler." },
					{ role: "user", content: `Reformat the following text. Each distinct claim or question should be a separate item. Start each item with the delimiter \`### CLAIM\`.\n\n**Text to Reformat:**\n\"\"\"\n${rawHypothesesText}\n\"\"\"` }
				]);

				const hypotheses = formattedHypothesesText
					.split('### CLAIM')
					.map(h => h.trim())
					.filter(h => h.length > 10);

				if (hypotheses.length === 0) {
					this.log('[test29] No actionable claims were extracted.');
					return;
				}

				const validatedHypotheses = hypotheses.filter(h => h.length > 15 && !h.endsWith('?'));
				if (validatedHypotheses.length === 0) {
					this.log('[test29] No high-quality claims survived validation.');
					return;
				}

				let modelUpdate = "";
				for (const hypothesis of validatedHypotheses) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const { verdict, reasoning } = await this.test29RunHypothesisCouncil(hypothesis, query);
					modelUpdate += `Claim: ${hypothesis}\nResult: ${verdict}\nReasoning: ${(reasoning || '').replace(verdict, '').trim()}\n\n`;
				}
				dynamicWorldModelRef.value += modelUpdate;
				this.log('[test29] Initial world model built.');
			}

			async test29RunEpistemicTrackUpdate(query, solution, critiques, dynamicWorldModelRef) {
				this.log('[test29] Phase 2.B: Running Epistemic Track via Hypothesis Council');
				const rawNewHypothesesText = await this.callAPI([
					{ role: "system", content: "You are a Fact-Checker. Your job is to read a guide and critiques to generate new, critical, testable claims or questions that need to be investigated to ensure the guide's quality." },
					{ role: "user", content: `Based on the following guide and critiques, what new assumptions or claims need to be checked? List them as specific, testable claims.\n\nGuide:\n${solution}\n\nCritiques:\n${(critiques || []).join('\n---\n')}` }
				]);

				const formattedHypothesesText = await this.callAPI([
					{ role: "system", content: "You are a structural re-formatter. Extract all distinct, testable claims or questions. Start each item with the delimiter `### CLAIM`." },
					{ role: "user", content: `Reformat the following text into a list where each item starts with \`### CLAIM\`.\n\n**Text to Reformat:**\n\"\"\"\n${rawNewHypothesesText}\n\"\"\"` }
				]);

				const newHypotheses = formattedHypothesesText
					.split('### CLAIM')
					.map(h => h.trim())
					.filter(h => h.length > 10);

				if (newHypotheses.length === 0) {
					this.log('[test29] No new actionable claims generated for this iteration.');
					return;
				}

				let modelUpdate = `## Iteration Update\n\n`;
				for (const hypothesis of newHypotheses) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const { verdict, reasoning } = await this.test29RunHypothesisCouncil(hypothesis, query);
					modelUpdate += `Claim: ${hypothesis}\nResult: ${verdict}\nReasoning: ${(reasoning || '').replace(verdict, '').trim()}\n\n`;
				}
				dynamicWorldModelRef.value += modelUpdate;
				this.log('[test29] Dynamic World Model updated.');
			}

			async runTest29Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 8;
				let passCount = 0;
				let errorCount = 0;

				const dynamicWorldModelRef = { value: "## Dynamic World Model\n\n" };
				const executiveHistory = [];

				try {
					this.log('[test29] Starting Cognitive Synergy Architecture');
					const [consensusStrategy0] = await Promise.all([
						this.test29GetConsensusStrategy(query),
						this.test29BuildInitialWorldModel(query, dynamicWorldModelRef)
					]);
					let consensusStrategy = consensusStrategy0 || '';

					let currentSolution = "";

					for (let i = 0; i < MAX_ITERATIONS; i++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test29] --- Executive Track Iteration ${i + 1}/${MAX_ITERATIONS} ---`);

						const lastAttempt = executiveHistory.length > 0 ? executiveHistory[executiveHistory.length - 1] : null;
						const criticalWeakness = lastAttempt ? lastAttempt.flaw : "None. This is the first attempt.";

						const generatorSystemPrompt = `You are a meticulous guide writer. Your task is to generate a comprehensive guide by reasoning STRICTLY from the provided facts in the World Model. You are forbidden from introducing external information unless it is common knowledge. You must explicitly address the critical weakness from the last attempt.`;

						const generatorPrompt = `Core Query: "${query}"
Consensus Strategy: "${consensusStrategy}"
Dynamic World Model (Established Insights):
---
${dynamicWorldModelRef.value}
---

Your previous attempt had the following critical weakness:
---
${criticalWeakness}
---

**Your Task:**
1.  Start your response by explaining how you will avoid the previous weakness.
2.  Generate a new guide by reasoning step-by-step ONLY from the insights in the Dynamic World Model and the Consensus Strategy.`;

						currentSolution = await this.callAPI([
							{ role: "system", content: generatorSystemPrompt },
							{ role: "user", content: generatorPrompt }
						]);

						const councilPromises = [
							this.callAPI([{ role: "system", content: "You are The Logician. Check for inconsistent or contradictory advice." }, { role: "user", content: currentSolution }]),
							this.callAPI([{ role: "system", content: "You are The Pragmatist. Assess clarity, practicality, and completeness." }, { role: "user", content: currentSolution }]),
							this.callAPI([{ role: "system", content: "You are The Skeptic. Find edge cases, hidden assumptions, and overlooked alternatives." }, { role: "user", content: currentSolution }]),
						];
						const critiques = await Promise.all(councilPromises);

						const validVerdicts = ["HIGH_QUALITY", "WEAKNESS_IDENTIFIED", "FUNDAMENTAL_FLAW"];
						let arbiterResponse = '';
						let verdict = 'WEAKNESS_IDENTIFIED';
						for (let attempt = 1; attempt <= 6; attempt++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							arbiterResponse = await this.callAPI([
								{ role: "system", content: "You are an Arbiter. Synthesize feedback, identify the single most critical weakness, and issue a verdict. Respond with ONE of: HIGH_QUALITY, WEAKNESS_IDENTIFIED, FUNDAMENTAL_FLAW. Then, state the critical weakness if one exists." },
								{ role: "user", content: `Logician:\n${critiques[0]}\n\nPragmatist:\n${critiques[1]}\n\nSkeptic:\n${critiques[2]}\n\nVerdict and Critical Weakness:` }
							]);
							const parsed = this.testNu1ExtractSingleVerdict(arbiterResponse, validVerdicts);
							if (parsed.conflicts) {
								this.log(`[test29] ‚ö† Arbiter conflicting verdicts: ${parsed.conflicts.join(', ')} (attempt ${attempt}). Retrying...`);
								continue;
							}
							if (!parsed.verdict) {
								this.log(`[test29] ‚ö† Arbiter missing verdict (attempt ${attempt}). Retrying...`);
								continue;
							}
							verdict = parsed.verdict;
							break;
						}

						this.log(`[test29] Arbiter Verdict: ${verdict}`);
						executiveHistory.push({ solution: currentSolution, critiques, verdict, flaw: arbiterResponse });
						await this.test29RunEpistemicTrackUpdate(query, currentSolution, critiques, dynamicWorldModelRef);

						if (verdict === "HIGH_QUALITY") {
							passCount++;
							errorCount = 0;
							if (passCount >= 3) {
								this.log('[test29] Success (3 consecutive high-quality passes).');
								break;
							}
						} else if (verdict === "FUNDAMENTAL_FLAW") {
							errorCount++;
							passCount = 0;
							if (errorCount >= 2) {
								this.log('[test29] Failure (2 fundamental flaws).');
								break;
							}

							this.log('[test29] Fundamental Flaw detected. Engaging Strategy Review.');
							const strategyReviewPrompt = `The current strategy has led to a fundamental flaw.

**Current Strategy:**
---
${consensusStrategy}
---

**Critical Flaw Identified by Arbiter:**
---
${arbiterResponse}
---

**Current World Model (Established Insights):**
---
${dynamicWorldModelRef.value}
---

**Your Task:**
Formulate a new, revised strategy that accounts for the identified flaw and the established insights in the World Model.`;

							consensusStrategy = await this.callAPI([
								{ role: "system", content: "You are a Master Strategist. Revise the high-level plan based on new evidence and failures." },
								{ role: "user", content: strategyReviewPrompt }
							]);
						} else {
							passCount = 0;
							errorCount = 0;
						}
					}

					this.log('[test29] Phase 4: Final Synthesis');
					const successfulSolutions = executiveHistory.filter(h => h.verdict === 'HIGH_QUALITY');
					let finalCandidate = '';
					if (successfulSolutions.length > 0) {
						finalCandidate = successfulSolutions[successfulSolutions.length - 1].solution;
					} else if (executiveHistory.length > 0) {
						finalCandidate = executiveHistory[executiveHistory.length - 1].solution;
					} else {
						finalCandidate = currentSolution || '';
					}

					const finalOutput = await this.callAPI([
						{ role: "system", content: "You are the Master Communicator. Present the guide clearly, justifying key points by citing the provided world model." },
						{ role: "user", content: `Core Query: "${query}"\n\nFinal Candidate Guide:\n${finalCandidate}\n\nComplete Dynamic World Model (for justification):\n${dynamicWorldModelRef.value}\n\nProduce the final, well-reasoned output.` }
					]);

					const converged = passCount >= 3;
					this.state.status = converged ? 'Success' : 'Failed';
					this.state.finalResult = finalOutput || finalCandidate || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI(converged ? 'Success' : 'Failed (Not Converged)', converged ? 'var(--log-success)' : 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest30Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ITERATIONS = 30;
				const ERROR_THRESHOLD = 10;
				const MAX_ROUNDS = 10;
				const PASS_STREAK_TARGET = 3;

				let passStreak = 0;
				let solution = "";

				try {
					this.log('[test30] Architecture 19: Arch 15 (Loop SI) w/o History in SI');
					for (let round = 1; round <= MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const verificationHistory = [];
						this.log(`[test30] === Round ${round}/${MAX_ROUNDS} start ===`);
						let errorCount = 0;

						this.log('[test30] Generating initial guide');
						solution = await this.nu1GenerateInitialGuide(query);
						this.log('[test30] Applying initial self-improvement');
						solution = await this.nu1SelfImproveGuide(solution);

						this.log('[test30] Initial critique');
						let verification = await this.nu1VerifyGuideWithHistoryFull(query, solution, verificationHistory);
						verificationHistory.push({ iteration: 0, solution, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

						if (verification.isGood) {
							passStreak++;
							errorCount = 0;
							this.log(`[test30] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
							if (passStreak >= PASS_STREAK_TARGET) {
								this.state.status = 'Success';
								this.state.finalResult = solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
						} else {
							passStreak = 0;
							errorCount++;
							this.log(`[test30] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
						}

						for (let i = 0; i < MAX_ITERATIONS; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							this.log(`[test30] Iteration ${i + 1} (round ${round})`);
							if (!verification.isGood) {
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test30] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
								this.log('[test30] Critique failed, improving with full solution history');
								solution = await this.nu1CorrectWithFullHistorySolutionsAndFeedback(query, solution, verificationHistory);
								this.log('[test30] Applying self-improvement WITHOUT history');
								solution = await this.nu1SelfImproveGuide(solution);
							}

							this.log('[test30] Critiquing new version');
							verification = await this.nu1VerifyGuideWithHistoryFull(query, solution, verificationHistory);
							verificationHistory.push({ iteration: i + 1, solution, isGood: verification.isGood, bugReport: verification.bugReport, fullVerification: verification.fullVerification });

							if (verification.isGood) {
								passStreak++;
								errorCount = 0;
								this.log(`[test30] Guide PASSED (<pass>) | consecutive pass=${passStreak}/${PASS_STREAK_TARGET}`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = solution || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
							} else {
								passStreak = 0;
								errorCount++;
								this.log(`[test30] Guide FAILED (<fail>) | flaws=${errorCount}/${ERROR_THRESHOLD}`);
								if (errorCount >= ERROR_THRESHOLD) {
									this.log(`[test30] ERROR_THRESHOLD reached ‚Äî end of round`);
									break;
								}
							}
						}
						this.log(`[test30] === Round ${round} end ===`);
					}

					this.state.status = 'Failed';
					this.state.finalResult = solution || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			// --- test31 (ÎÇ¥ÏïÑÌÇ§ ÎßàÏßÄÎßâ Arch4 port) ---
			test31ExtractGradeLine(text, validVerdicts) {
				const src = (text || '').toString();
				const firstLine = src.split(/\r?\n/g).map(l => l.trim()).find(Boolean) || '';
				const normalized = firstLine
					.replace(/^evaluation grade\s*:\s*/i, '')
					.replace(/^grade\s*:\s*/i, '')
					.trim();
				for (const verdict of (validVerdicts || [])) {
					if (!verdict) continue;
					if (normalized.toLowerCase() === verdict.toLowerCase()) return verdict;
				}
				return null;
			}

			test31ExtractOutlierInsight(text) {
				const m = (text || '').toString().match(/Insight Summary:\s*([^\n\r]+)/i);
				if (m && m[1]) return m[1].trim();
				const lines = (text || '').toString().split('\n').map(s => s.trim()).filter(Boolean);
				const alt = lines.find(l => /insight/i.test(l));
				return (alt || lines[0] || '').slice(0, 280);
			}

			async test31EvaluateSolution(query, solution) {
				const verifyPrompt = `Evaluate the response below for quality.

You must assign exactly one "Evaluation Grade" using one of these five phrases:
- Fundamental Error
- Flaw
- Good
- Perfect
- Outlier

Start with the grade on its own line. Then briefly explain why.
If you judge "Outlier", also include a short line beginning with "Insight Summary:" that captures the gem-like insight.

Query:
${query}

Response to evaluate:
${solution}`;

				const validVerdicts = ["Fundamental Error", "Flaw", "Good", "Perfect", "Outlier"];
				let response = '';
				for (let attempt = 1; attempt <= 6; attempt++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					response = await this.callAPI(
						[
							{ role: "system", content: "Act as an exacting evaluator. Use exactly one of the five grade phrases." },
							{ role: "user", content: verifyPrompt }
						],
						null,
						{ temperature: 0.2 }
					);
					const verdict = this.test31ExtractGradeLine(response, validVerdicts);
					if (!verdict) {
						this.log(`[test31] ‚ö† Invalid grade line (attempt ${attempt}). Retrying...`);
						continue;
					}

					let outlierInsight = null;
					if (verdict === "Outlier") {
						outlierInsight = this.test31ExtractOutlierInsight(response);
						if (outlierInsight) {
							if (!window.insightDB) window.insightDB = [];
							if (!window.insightDB.find(x => (x || '').toLowerCase() === outlierInsight.toLowerCase())) {
								window.insightDB.push(outlierInsight);
							}
							this.log(`[test31] Outlier insight recorded: "${outlierInsight}"`);
						}
					}
					return { verdict, feedback: response, outlierInsight };
				}

				const fallbackVerdict = this.test31ExtractGradeLine(response, validVerdicts) || "Flaw";
				return { verdict: fallbackVerdict, feedback: response, outlierInsight: null };
			}

			async test31GenerateInitialSolution(query) {
				const sys = `You generate complete, practical, high-quality solutions with clear reasoning. Avoid fluff.`;
				const user = `Problem:
${query}

Please provide a complete, thoughtful solution with:
1) Summary (key points)
2) Detailed Guide (clear steps, trade-offs where relevant)`;
				return await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
			}

			async test31SelfImprove(query, current) {
				const sys = `You improve drafts to eliminate weaknesses and sharpen clarity.`;
				const user = `Improve the following response so it moves closer to "Perfect". Tighten reasoning, fill any gaps, and keep it practical.

Response:
${current}`;
				return await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
			}

			async test31DiagnoseFlaw(query, current) {
				const sys = `You are a flaw diagnostician. Identify precise flawed part(s) and why.`;
				const user = `Problem:
${query}

Response to diagnose (find flawed part(s) and why they are flawed; include what must be resolved):
${current}`;
				return await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
			}

			async test31FindOverlapBetweenDiagnoses(diagA, diagB) {
				const sys = `You compare two diagnoses and find overlapping flawed parts (if any).`;
				const user = `Diagnosis A:
${diagA}

Diagnosis B:
${diagB}

If there is overlapping flawed part(s) both identified, list them clearly (one per line). If there is no overlap, clearly say "No overlap".`;
				const text = await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
				if (/no overlap/i.test(text)) return [];
				const lines = (text || '').split('\n').map(s => s.trim()).filter(Boolean);
				const overlaps = lines.filter(l => !/diagnosis/i.test(l) && !/overlap/i.test(l));
				return overlaps.length ? overlaps : lines.slice(0, 3);
			}

			async test31ValidateFlaw(query, current, overlapPart) {
				const sys = `You validate whether a suspected flawed part is truly flawed in context.`;
				const user = `Problem:
${query}

Response:
${current}

Suspected flawed part:
${overlapPart}

Verdict: say "Correct" if this is truly a flaw, or "Incorrect" if it's not a real flaw. Provide one-sentence justification.`;
				const text = await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
				const t = (text || '').toLowerCase();
				if (t.includes('incorrect')) return false;
				if (t.includes('correct')) return true;
				return false;
			}

			async test31ProposeResolution(query, current, diagnosis, overlapPart, variantLabel) {
				const sys = `You propose a revised full solution that directly resolves the diagnosed flaw, keeping all other good parts.`;
				const user = `Problem:
${query}

Current response:
${current}

Diagnosis summary:
${diagnosis}

Flawed part to resolve:
${overlapPart}

${variantLabel} ‚Äî Propose a revised full response that resolves the flaw and remains comprehensive. Provide the complete improved response.`;
				return await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
			}

			async test31SelectBestResolution(query, diagnosis, candidates) {
				const sys = `You are a judge. Select the best candidate that truly resolves the diagnosis. If none fully resolve, say "None".`;
				const user = `Problem:
${query}

Diagnosis to resolve:
${diagnosis}

Candidates:
A)
${candidates[0]}

B)
${candidates[1]}

C)
${candidates[2]}

D)
${candidates[3]}

E)
${candidates[4]}

State your pick clearly as "A", "B", "C", "D", or "E". If none properly resolve, say "None". Then briefly justify.`;
				const text = await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
				const m = (text || '').match(/^\s*([ABCDE])\b/i) || (text || '').match(/\b([ABCDE])\b/);
				if (m && m[1]) return m[1].toUpperCase();
				if (/none/i.test(text)) return null;
				return null;
			}

			async test31SatisfactionCheck(query, diagnosis, chosen) {
				const sys = `You check if the chosen resolution fully addresses the diagnosis.`;
				const user = `Problem:
${query}

Diagnosis:
${diagnosis}

Chosen revised response:
${chosen}

Answer with "satisfied" if it fully resolves the diagnosis, otherwise "incomplete". Provide a brief reason.`;
				const text = await this.callAPI([{ role: "system", content: sys }, { role: "user", content: user }]);
				return /satisfied/i.test(text) ? "satisfied" : "incomplete";
			}

			async test31FlawResolutionLoop(query, current, diagA, diagB) {
				const overlaps = await this.test31FindOverlapBetweenDiagnoses(diagA, diagB);
				if (!overlaps.length) {
					this.log('[test31] No overlapping flawed parts; returning to evaluation.');
					return current;
				}

				const overlapPart = overlaps[0];
				const isRealFlaw = await this.test31ValidateFlaw(query, current, overlapPart);
				if (!isRealFlaw) {
					this.log('[test31] Overlapping part deemed NOT a real flaw; returning to evaluation.');
					return current;
				}

				this.log(`[test31] Overlapping flawed part validated: ${overlapPart}`);
				const diagnosis = `${diagA}\n\n${diagB}\n\nOverlapping focus:\n${overlapPart}`;

				let satisfiedStreak = 0;
				const labels = ['Option A', 'Option B', 'Option C', 'Option D', 'Option E'];

				for (let attempt = 0; attempt < 5; attempt++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[test31] Flaw resolution attempt #${attempt + 1}`);

					const proposals = await Promise.all(labels.map(l => this.test31ProposeResolution(query, current, diagnosis, overlapPart, l)));
					const pick = await this.test31SelectBestResolution(query, diagnosis, proposals);
					if (!pick) {
						this.log('[test31] Judge selected None; restarting flaw resolution loop.');
						continue;
					}

					const idx = ['A', 'B', 'C', 'D', 'E'].indexOf(pick);
					const chosen = proposals[idx] || proposals[0];
					const decision = await this.test31SatisfactionCheck(query, diagnosis, chosen);
					this.log(`[test31] Satisfaction check: ${decision.toUpperCase()}`);

					if (decision === 'satisfied') {
						satisfiedStreak++;
						current = chosen;
						if (satisfiedStreak >= 2) {
							this.log('[test31] Satisfied twice in a row ‚Äî exiting flaw resolution loop.');
							return current;
						}
					} else {
						satisfiedStreak = 0;
						current = chosen;
					}
				}

				return current;
			}

			async runTest31Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const MAX_ROUNDS = 30;
				let current = '';
				let feStreak = 0;
				let goodStreak = 0;
				let perfectStreak = 0;
				let checkpoint = '';

				try {
					this.log('[test31] Architecture 4: Starting Graded Evaluation & Flaw-Resolution loop');
					current = await this.test31GenerateInitialSolution(query);

					for (let round = 0; round < MAX_ROUNDS; round++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test31] ‚Äî Round ${round + 1}/${MAX_ROUNDS} ‚Äî Evaluating current solution`);
						const { verdict } = await this.test31EvaluateSolution(query, current);
						this.log(`[test31] Grade: ${verdict}`);

						if (verdict === 'Fundamental Error') {
							feStreak++;
							goodStreak = 0;
							perfectStreak = 0;
							if (feStreak >= 2) {
								this.log('[test31] Two Fundamental Errors in a row ‚Äî discarding and starting over.');
								feStreak = 0;
								current = await this.test31GenerateInitialSolution(query);
								continue;
							}
							current = await this.test31SelfImprove(query, current);
							continue;
						}

						if (verdict === 'Flaw') {
							feStreak = 0;
							goodStreak = 0;
							perfectStreak = 0;
							this.log('[test31] Running flaw diagnosis (two passes)‚Ä¶');
							const diagA = await this.test31DiagnoseFlaw(query, current);
							const diagB = await this.test31DiagnoseFlaw(query, current);
							current = await this.test31FlawResolutionLoop(query, current, diagA, diagB);
							continue;
						}

						if (verdict === 'Good') {
							feStreak = 0;
							perfectStreak = 0;
							goodStreak++;
							if (goodStreak >= 2) {
								checkpoint = current;
								this.log('[test31] Good twice ‚Äî checkpoint set. Pushing toward Perfect‚Ä¶');
							} else {
								this.log('[test31] Improving from Good toward Perfect‚Ä¶');
							}
							current = await this.test31SelfImprove(query, current);
							continue;
						}

						if (verdict === 'Perfect') {
							feStreak = 0;
							goodStreak = 0;
							perfectStreak++;
							if (perfectStreak >= 3) {
								this.log('[test31] Perfect three times in a row ‚Äî terminating.');
								this.state.status = 'Success';
								this.state.finalResult = current || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}
							this.log(`[test31] Perfect streak: ${perfectStreak}/3. Re-validating‚Ä¶`);
							continue;
						}

						if (verdict === 'Outlier') {
							feStreak = 0;
							goodStreak = 0;
							perfectStreak = 0;
							current = await this.test31SelfImprove(query, current);
						}
					}

					const final = checkpoint || current;
					this.log('[test31] Max rounds reached; returning best-known solution (checkpoint if available).');
					this.state.status = 'Failed';
					this.state.finalResult = final || '';
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.updateStatusUI('Failed (Max Rounds)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			// --- test32-38 (Iterative-Contextual-Refinements-main ports; minimal/no structured output) ---
			async runTest32Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const ITERATIONS = 3;
				let draft = '';

				try {
					this.log('[test32] ICR Refine Mode');
					draft = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Main Generator in Refine Mode. Produce the best possible initial output for the user request.' },
							{ role: 'user', content: `User request:\n${query}\n\nOutput the full content (no meta commentary).` }
						],
						null,
						{ temperature: 0.7 }
					);

					for (let i = 1; i <= ITERATIONS; i++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test32] Iteration ${i}/${ITERATIONS}: feature suggestions`);
						const suggestions = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Feature Suggestion Agent. Propose improvements that increase usefulness, correctness, and clarity. Do not rewrite; only suggest.' },
								{ role: 'user', content: `User request:\n${query}\n\nCurrent draft:\n${draft}\n\nList 5‚Äì10 actionable improvements.` }
							],
							null,
							{ temperature: 0.6 }
						);

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test32] Iteration ${i}/${ITERATIONS}: refine + bugfix`);
						draft = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Bug Fix / Refine Agent. Apply the suggested improvements, fix errors, and output the full revised content.' },
								{ role: 'user', content: `User request:\n${query}\n\nCurrent draft:\n${draft}\n\nSuggested improvements:\n${suggestions}\n\nReturn the full revised output only.` }
							],
							null,
							{ temperature: 0.4 }
						);
					}

					this.state.status = 'Success';
					this.state.finalResult = draft || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest33Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				try {
					this.log('[test33] ICR React Mode (simulated orchestrator + parallel workers)');
					const plan = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Orchestrator. Create a concrete plan to satisfy the user request. Keep it concise and actionable.' },
							{ role: 'user', content: `User request:\n${query}\n\nProvide a 6‚Äì12 step plan.` }
						],
						null,
						{ temperature: 0.3 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const [workerCore, workerEdge, workerPolish] = await Promise.all([
						this.callAPI(
							[
								{ role: 'system', content: 'You are Worker A (Core Implementer). Produce the core answer/output for the user request.' },
								{ role: 'user', content: `User request:\n${query}\n\nOrchestrator plan:\n${plan}\n\nProduce the core output.` }
							],
							null,
							{ temperature: 0.6 }
						),
						this.callAPI(
							[
								{ role: 'system', content: 'You are Worker B (Edge Cases). Identify missing requirements, edge cases, and risks; propose fixes.' },
								{ role: 'user', content: `User request:\n${query}\n\nDraft plan:\n${plan}\n\nList edge cases, pitfalls, and missing pieces.` }
							],
							null,
							{ temperature: 0.4 }
						),
						this.callAPI(
							[
								{ role: 'system', content: 'You are Worker C (Polish). Improve clarity, organization, and presentation without changing intent.' },
								{ role: 'user', content: `User request:\n${query}\n\nOrchestrator plan:\n${plan}\n\nProvide a rewrite/polish strategy (not the full rewrite).` }
							],
							null,
							{ temperature: 0.5 }
						)
					]);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const integrated = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Integrator. Combine the plan and worker outputs into one coherent final output.' },
							{ role: 'user', content: `User request:\n${query}\n\nPlan:\n${plan}\n\nWorker A (Core):\n${workerCore}\n\nWorker B (Edge Cases):\n${workerEdge}\n\nWorker C (Polish Strategy):\n${workerPolish}\n\nProduce the integrated output.` }
						],
						null,
						{ temperature: 0.5 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const validation = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Validation Manager. Find contradictions, missing requirements, and unclear parts. Be strict and concrete.' },
							{ role: 'user', content: `User request:\n${query}\n\nCandidate output:\n${integrated}\n\nList issues and required fixes.` }
						],
						null,
						{ temperature: 0.2 }
					);

					const final = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Finalizer. Apply validation fixes. Output final content only.' },
							{ role: 'user', content: `User request:\n${query}\n\nCandidate output:\n${integrated}\n\nValidation issues:\n${validation}\n\nReturn the corrected final output.` }
						],
						null,
						{ temperature: 0.4 }
					);

					this.state.status = 'Success';
					this.state.finalResult = final || integrated || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest34Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const parseNumbered = (text, min = 1) => {
					const src = (text || '').toString();
					const items = [];
					const re = /^\s*\d+[\.\)\]]\s*(.+)$/gm;
					let m;
					while ((m = re.exec(src)) !== null) {
						const item = (m[1] || '').trim();
						if (item) items.push(item);
					}
					if (items.length >= min) return items;
					const fallback = src.split(/\r?\n/g).map(l => l.trim()).filter(Boolean);
					return fallback.slice(0, Math.max(min, 3));
				};

				try {
					this.log('[test34] ICR Deepthink Mode');
					const strategiesText = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Strategy Generation Agent. Generate 3 distinct high-level strategies for solving the user request. Do not solve yet.' },
							{ role: 'user', content: `User request:\n${query}\n\nOutput 3 numbered strategies, each 1‚Äì3 sentences.` }
						],
						null,
						{ temperature: 0.7 }
					);
					const strategies = parseNumbered(strategiesText, 3).slice(0, 3);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const solutionAttempts = await Promise.all(strategies.map((strategy, idx) => {
						return this.callAPI(
							[
								{ role: 'system', content: 'You are the Solution Agent. Solve the request using the given strategy. Output the full solution.' },
								{ role: 'user', content: `User request:\n${query}\n\nStrategy S${idx + 1}:\n${strategy}\n\nProduce a complete solution.` }
							],
							null,
							{ temperature: 0.6 }
						);
					}));

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const critiques = await Promise.all(solutionAttempts.map((sol, idx) => {
						return this.callAPI(
							[
								{ role: 'system', content: 'You are the Critique Agent. Critique the solution for correctness, completeness, and clarity. Provide actionable fixes.' },
								{ role: 'user', content: `User request:\n${query}\n\nCandidate S${idx + 1}:\n${sol}\n\nCritique and list fixes.` }
							],
							null,
							{ temperature: 0.2 }
						);
					}));

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const refinedSolutions = await Promise.all(solutionAttempts.map((sol, idx) => {
						return this.callAPI(
							[
								{ role: 'system', content: 'You are the Refinement Agent. Apply the critique to produce an improved full solution.' },
								{ role: 'user', content: `User request:\n${query}\n\nOriginal candidate S${idx + 1}:\n${sol}\n\nCritique:\n${critiques[idx]}\n\nReturn the improved full solution.` }
							],
							null,
							{ temperature: 0.4 }
						);
					}));

					const redTeam = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Red Team Agent. Identify the weakest candidate and the strongest candidate, with reasons.' },
							{ role: 'user', content: `User request:\n${query}\n\nRefined candidates:\n\nS1:\n${refinedSolutions[0]}\n\nS2:\n${refinedSolutions[1]}\n\nS3:\n${refinedSolutions[2]}\n\nProvide your assessment.` }
						],
						null,
						{ temperature: 0.2 }
					);

					const final = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Final Judge. Choose the best refined candidate and output the final answer (not just a label). Use the critiques/red-team info to avoid flaws.' },
							{ role: 'user', content: `User request:\n${query}\n\nStrategies:\n${strategiesText}\n\nRefined candidates:\n\nS1:\n${refinedSolutions[0]}\n\nS2:\n${refinedSolutions[1]}\n\nS3:\n${refinedSolutions[2]}\n\nCritiques:\n\nC1:\n${critiques[0]}\n\nC2:\n${critiques[1]}\n\nC3:\n${critiques[2]}\n\nRed Team:\n${redTeam}\n\nOutput the best final answer.` }
						],
						null,
						{ temperature: 0.4 }
					);

					this.state.status = 'Success';
					this.state.finalResult = final || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest35Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				try {
					this.log('[test35] ICR Adaptive Deepthink Mode');
					const controllerPlan = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Adaptive Controller. Propose a staged reasoning plan (strategies ‚Üí hypotheses ‚Üí tests ‚Üí execution ‚Üí critique ‚Üí correction).' },
							{ role: 'user', content: `User request:\n${query}\n\nPropose the staged plan.` }
						],
						null,
						{ temperature: 0.3 }
					);

					const strategies = await this.callAPI(
						[
							{ role: 'system', content: 'Generate 2 distinct strategies for the request. Do not solve yet.' },
							{ role: 'user', content: `User request:\n${query}\n\nController plan:\n${controllerPlan}\n\nList 2 strategies.` }
						],
						null,
						{ temperature: 0.7 }
					);

					const hypotheses = await this.callAPI(
						[
							{ role: 'system', content: 'Generate 4‚Äì6 testable hypotheses/assumptions that matter for solving the request. Do not fully solve.' },
							{ role: 'user', content: `User request:\n${query}\n\nStrategies:\n${strategies}\n\nList hypotheses.` }
						],
						null,
						{ temperature: 0.6 }
					);

					const tests = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Hypothesis Tester. For each hypothesis, evaluate plausibility and implications; note any counterexamples.' },
							{ role: 'user', content: `User request:\n${query}\n\nHypotheses:\n${hypotheses}\n\nTest them and summarize actionable conclusions.` }
						],
						null,
						{ temperature: 0.2 }
					);

					const draft = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Execution Agent. Produce a complete solution using the controller plan, strategies, and tested hypotheses.' },
							{ role: 'user', content: `User request:\n${query}\n\nController plan:\n${controllerPlan}\n\nStrategies:\n${strategies}\n\nHypotheses:\n${hypotheses}\n\nHypothesis tests:\n${tests}\n\nProduce the full solution.` }
						],
						null,
						{ temperature: 0.5 }
					);

					const critique = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Solution Critique Agent. Critique for correctness/completeness and list concrete fixes.' },
							{ role: 'user', content: `User request:\n${query}\n\nDraft solution:\n${draft}\n\nCritique and list fixes.` }
						],
						null,
						{ temperature: 0.2 }
					);

					const final = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Correction Agent. Apply critique fixes and output the corrected final solution only.' },
							{ role: 'user', content: `User request:\n${query}\n\nDraft solution:\n${draft}\n\nCritique:\n${critique}\n\nReturn corrected final solution.` }
						],
						null,
						{ temperature: 0.4 }
					);

					this.state.status = 'Success';
					this.state.finalResult = final || draft || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest36Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const ITERATIONS = 3;
				let memory = '';
				let draft = '';

				try {
					this.log('[test36] ICR Agentic Mode');
					for (let i = 1; i <= ITERATIONS; i++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test36] Iteration ${i}/${ITERATIONS}: draft`);
						draft = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Agentic Refinements Agent. Use the memory summary to keep context and iteratively improve the draft. Output the revised draft only.' },
								{ role: 'user', content: `User request:\n${query}\n\nMemory summary (may be empty):\n${memory || '(none)'}\n\nCurrent draft (may be empty):\n${draft || '(none)'}\n\nRevise/produce the best next draft.` }
							],
							null,
							{ temperature: 0.6 }
						);

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test36] Iteration ${i}/${ITERATIONS}: memory compression`);
						memory = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Memory Agent. Compress the current state into a short memory summary (max 8 bullets). Keep only persistent constraints, decisions, and critical context.' },
								{ role: 'user', content: `User request:\n${query}\n\nCurrent draft:\n${draft}\n\nPrevious memory:\n${memory || '(none)'}\n\nReturn the updated memory summary.` }
							],
							null,
							{ temperature: 0.2 }
						);
					}

					this.state.status = 'Success';
					this.state.finalResult = draft || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest37Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const ITERATIONS = 3;
				let memory = '';
				let draft = '';

				try {
					this.log('[test37] ICR Contextual Mode');
					draft = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Main Generator. Produce an initial solution/draft for the user request.' },
							{ role: 'user', content: `User request:\n${query}\n\nProduce the initial draft.` }
						],
						null,
						{ temperature: 0.7 }
					);

					for (let i = 1; i <= ITERATIONS; i++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test37] Iteration ${i}/${ITERATIONS}: iterative agent suggestions`);
						const suggestions = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Iterative Agent. Suggest improvements and corrections to the draft. Be concrete.' },
								{ role: 'user', content: `User request:\n${query}\n\nMemory:\n${memory || '(none)'}\n\nCurrent draft:\n${draft}\n\nProvide suggestions and identify issues.` }
							],
							null,
							{ temperature: 0.2 }
						);

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test37] Iteration ${i}/${ITERATIONS}: main generator applies suggestions`);
						draft = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Main Generator. Apply the suggestions to revise the draft. Output the full revised draft.' },
								{ role: 'user', content: `User request:\n${query}\n\nMemory:\n${memory || '(none)'}\n\nCurrent draft:\n${draft}\n\nSuggestions:\n${suggestions}\n\nReturn the revised draft.` }
							],
							null,
							{ temperature: 0.5 }
						);

						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						this.log(`[test37] Iteration ${i}/${ITERATIONS}: memory agent update`);
						memory = await this.callAPI(
							[
								{ role: 'system', content: 'You are the Memory Agent. Update the memory summary (max 8 bullets) based on the new draft and suggestions.' },
								{ role: 'user', content: `User request:\n${query}\n\nRevised draft:\n${draft}\n\nSuggestions applied:\n${suggestions}\n\nPrevious memory:\n${memory || '(none)'}\n\nReturn updated memory summary.` }
							],
							null,
							{ temperature: 0.2 }
						);
					}

					this.state.status = 'Success';
					this.state.finalResult = draft || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest38Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				try {
					this.log('[test38] ICR Generative UI Mode');
					const uiPlan = await this.callAPI(
						[
							{ role: 'system', content: 'You are the UI Structure Generator. Propose a simple interactive UI that helps satisfy the user request.' },
							{ role: 'user', content: `User request:\n${query}\n\nDescribe UI structure, interactions, and components.` }
						],
						null,
						{ temperature: 0.7 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					let html = await this.callAPI(
						[
							{ role: 'system', content: 'You are the UI Implementer. Output a single self-contained HTML file (HTML+CSS+JS). Do not use code fences.' },
							{ role: 'user', content: `User request:\n${query}\n\nUI plan:\n${uiPlan}\n\nReturn the full HTML.` }
						],
						null,
						{ temperature: 0.6 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					const evaluation = await this.callAPI(
						[
							{ role: 'system', content: 'You are the Reward Evaluator. Score the UI 0‚Äì10 for usability, correctness, and polish, then list concrete improvements.' },
							{ role: 'user', content: `User request:\n${query}\n\nHTML:\n${html}\n\nEvaluate and list improvements.` }
						],
						null,
						{ temperature: 0.2 }
					);

					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					html = await this.callAPI(
						[
							{ role: 'system', content: 'You are the UI Refiner. Apply the evaluation improvements. Output the full updated HTML only (no fences).' },
							{ role: 'user', content: `User request:\n${query}\n\nCurrent HTML:\n${html}\n\nEvaluation:\n${evaluation}\n\nReturn updated HTML.` }
						],
						null,
						{ temperature: 0.4 }
					);

					this.state.status = 'Success';
					this.state.finalResult = html || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runPassAt1(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				try {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log('[pass@1] Single-shot solving...');

					const solution = await this.callAPI([
						{ role: 'system', content: this.getSolverPrompt() },
						{ role: 'user', content: query }
					]);

					this.state.status = 'Success';
					this.state.finalResult = solution || '';
					this.updateStatusUI('Success', 'var(--log-success)');
					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
					return;
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runExperimentalPostPassGate(originalProblemText, effectiveProblemText, candidateSolution, checklistBlock = '') {
				const exp = this.config.exp || {};
				const post = exp.postPass || {};
				if (!post || typeof post !== 'object') return { verdict: 'pass' };

				const problemOriginal = (originalProblemText || '').toString();
				const problemEffective = (effectiveProblemText || problemOriginal).toString();
				const solutionText = (candidateSolution || '').toString();

				if (post.trialV12) {
					this.log('[PostPass] Trial (Defense/Prosecutor/Judges) gate...');
					const trial = await this.runTrialV12(problemOriginal, solutionText, checklistBlock || '', 'OTHER');
					if ((trial.verdict || '').toString().toUpperCase() === 'PASS') return { verdict: 'pass' };
					return { verdict: 'fail', feedback: `Trial Rejected.\n${trial.feedback || '[No feedback]'}` };
				}

				if (post.counterexamplePersona) {
					this.log('[PostPass] Counterexample specialist gate...');
					const sys = `You are a Counterexample Specialist Verifier.
Goal: Try to find a concrete counterexample OR a fatal logical flaw in the proposed solution.

Rules:
- Attack the logic, not style.
- Try at least: (1) edge/degenerate cases, (2) quantifier/goal mismatch, (3) definition/spec mismatch, (4) internal contradiction between steps.
- If you find a real fatal flaw, explain it and then output <fail>.
- If you cannot find any fatal flaw after thorough attacks, output <pass>.

At the VERY END output EXACTLY one tag: <pass> or <fail>.`;
					const user = `ORIGINAL PROBLEM:\n${problemEffective}\n\nPROPOSED SOLUTION:\n${solutionText}`;
					const resp = await this.callAPI(
						[{ role: 'system', content: sys }, { role: 'user', content: user }],
						(txt) => txt.includes('<pass>') || txt.includes('<fail>'),
						{ temperature: 0.4 }
					);
					const isPass = resp.includes('<pass>');
					if (isPass) return { verdict: 'pass' };
					return { verdict: 'fail', feedback: resp.replace(/<\/?(pass|fail)>/g, '').trim() || 'Counterexample specialist rejected the solution.' };
				}

				if (post.counterexampleBranch) {
					const cfg = post.counterexampleBranch || {};
					const result = await this.runCounterexampleBranchGate(problemEffective, solutionText, cfg);
					if (result.verdict === 'fail') return result;
					return { verdict: 'pass' };
				}

				return { verdict: 'pass' };
			}

			async runCounterexampleBranchGate(problemText, solutionText, cfg = {}) {
				const runsPlanned = Math.max(1, Number(cfg.runs || 3));
				const runsMax = Math.max(runsPlanned, Number(cfg.maxRunsIfInconclusive || runsPlanned));
				const allowConcludeNone = cfg.allowConcludeNone !== false;
				const forbidSolverConcludeNone = !!cfg.forbidSolverConcludeNone;
				const forbidVerifierConcludeNone = !!cfg.forbidVerifierConcludeNone;

				const MAX_ITER_PER_RUN = 6;
				const MAX_FAIL_STREAK = 4;

				let lastFeedback = '';
				for (let runIdx = 1; runIdx <= runsMax; runIdx++) {
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					this.log(`[PostPass] Counterexample Branch run ${runIdx}/${runsMax}...`);

					let localFailStreak = 0;
					for (let iter = 1; iter <= MAX_ITER_PER_RUN && localFailStreak < MAX_FAIL_STREAK; iter++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						const noneRule = forbidSolverConcludeNone
							? `\n- You are FORBIDDEN to output <none/>. If you cannot find one, output <inconclusive/> instead.`
							: '';
						const sys = `You are Counterexample Finder.
Your ONLY job is to find a concrete counterexample or a fatal logical flaw in the proposed solution.

Rules:
- Be specific and checkable (name the exact step/claim that fails, or provide a concrete counterexample).
- Do NOT be vague.
- If you find a counterexample/flaw, output it as <counterexample>...</counterexample> at the very end.
- If after thorough attempts you cannot find any, output <none/> at the very end.${noneRule}

Do not output any of these tags until the end.`;

						const user = `ORIGINAL PROBLEM:\n${problemText}\n\nPROPOSED SOLUTION:\n${solutionText}\n\n${lastFeedback ? `[FEEDBACK FROM PREVIOUS INVALID ATTEMPT]\n${lastFeedback}\n\n` : ''}Find a counterexample or fatal flaw now.`;

						const finderResp = await this.callAPI(
							[{ role: 'system', content: sys }, { role: 'user', content: user }],
							(txt) => txt.includes('<counterexample>') || txt.includes('<none/>') || txt.includes('<inconclusive/>'),
							{ temperature: 0.7 }
						);

						if (finderResp.includes('<none/>')) {
							if (!allowConcludeNone || forbidVerifierConcludeNone) {
								lastFeedback = 'Refused: do NOT conclude that there are no counterexamples. Try a different attack angle.';
								localFailStreak++;
								continue;
							}
							this.log('[PostPass] Counterexample Branch concluded <none/> (accepted).');
							return { verdict: 'pass' };
						}

						if (finderResp.includes('<inconclusive/>')) {
							lastFeedback = finderResp.replace(/<\/?inconclusive\/?>/gi, '').trim() || 'Inconclusive; try again with a different angle.';
							localFailStreak++;
							continue;
						}

						const counterexample = (this.extractTag(finderResp, 'counterexample') || '').trim();
						if (!counterexample) {
							lastFeedback = 'No <counterexample> content found. Output exactly <counterexample>...</counterexample> or <none/>.';
							localFailStreak++;
							continue;
						}

						const vsys = `You are Counterexample Verifier.
Your job is to verify whether the claimed counterexample/flaw is REAL and FATAL.

If it is valid and it invalidates the solution: output <valid> at the VERY END.
If it is invalid / not demonstrated / not fatal: output <invalid> at the VERY END, and explain why briefly.`;

						const vuser = `ORIGINAL PROBLEM:\n${problemText}\n\nPROPOSED SOLUTION:\n${solutionText}\n\nCLAIMED COUNTEREXAMPLE/FATAL FLAW:\n${counterexample}\n\nIs it valid?`;

						const verifyResp = await this.callAPI(
							[{ role: 'system', content: vsys }, { role: 'user', content: vuser }],
							(txt) => txt.includes('<valid>') || txt.includes('<invalid>'),
							{ temperature: 0.2 }
						);

						if (verifyResp.includes('<valid>')) {
							return {
								verdict: 'fail',
								feedback: `Counterexample Branch found a VALID counterexample/flaw:\n${counterexample}`
							};
						}

						lastFeedback = verifyResp.replace(/<\/?(valid|invalid)>/g, '').trim() || 'Counterexample rejected; try again.';
						localFailStreak++;
					}

					// If we planned fewer runs, we still allow extra runs only when inconclusive.
					if (runIdx >= runsPlanned) {
						// After planned budget, stop early unless we explicitly extended (runsMax > runsPlanned).
						// (We keep looping up to runsMax to match "not completed within 3 runs" behavior.)
					}
				}

				this.log('[PostPass] Counterexample Branch inconclusive (budget exhausted) ‚Üí accept.');
				return { verdict: 'inconclusive' };
			}

			async runTest6Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				if (!this.state.verifiedClues) this.state.verifiedClues = [];

				const MAX_RUNS = 10;
				const PASS_STREAK_TARGET = 5;
				const MAX_FAIL_STREAK = 10;
				const MAX_ITER_PER_RUN = 30;
				const K = 3;

				const selectorSystem = `You are a Red Team Selector and Verifier.
You will be given a PROBLEM and ${K} candidate solutions.

Tasks:
1) Select the BEST candidate (the one most likely correct and complete) as <best_id>.
2) Judge whether that best candidate is fully correct and complete.

If the best candidate is correct and complete:
- Write brief reasoning (2‚Äì6 sentences).
- Output <best_id>A|B|C</best_id>
- Output <summary>...</summary> (1 sentence)
- Output <pass>

If the best candidate is NOT correct/complete:
- Write brief reasoning (2‚Äì6 sentences).
- Output <best_id>A|B|C</best_id>
- Output <summary>single most critical fix</summary>
- Output <fail>

Do not output the tags until the end.`;

				const sampleSolver = async (effectiveQuery, prevBest, feedback) => {
					const baseUser = feedback
						? `${effectiveQuery}\n\n[Previous best attempt]\n${prevBest || '[None]'}\n\n[Red Team feedback]\n${feedback}\n\nRevise and produce a corrected full solution.`
						: effectiveQuery;
					const cands = [];
					for (let i = 0; i < K; i++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						const resp = await this.callAPI([
							{ role: 'system', content: this.getSolverPrompt() },
							{ role: 'user', content: baseUser }
						]);
						cands.push({ id: String.fromCharCode(65 + i), text: resp || '' });
					}
					return cands;
				};

				const pickBest = async (effectiveQuery, candidates) => {
					const formatted = candidates.map(c => `=== Candidate ${c.id} ===\n${c.text}`).join('\n\n');
					const user = `PROBLEM:\n${effectiveQuery}\n\nCANDIDATES:\n${formatted}`;
					const resp = await this.callAPI(
						[{ role: 'system', content: selectorSystem }, { role: 'user', content: user }],
						(txt) => (txt.includes('<pass>') || txt.includes('<fail>')) && (txt.includes('<best_id>') || txt.includes('<best_id>'))
					);
					const bestId = (this.extractTag(resp, 'best_id') || '').trim().toUpperCase() || 'A';
					const best = candidates.find(c => c.id === bestId) || candidates[0];
					const isPass = resp.includes('<pass>');
					const summary = (this.extractTag(resp, 'summary') || '').trim();
					const feedback = summary || resp.replace(/<\/?(pass|fail|best_id|summary)>/g, '').trim();
					return { isPass, best, feedback };
				};

				try {
					for (let runIdx = this.state.runIdx; runIdx <= MAX_RUNS; runIdx++) {
						this.state.runIdx = runIdx;
						this.log(`=== Run ${runIdx}/${MAX_RUNS} ===`);

						const effectiveQuery = this.formatQueryWithClues(query);

						let passStreak = 0;
						let failStreak = 0;
						let totalIter = 0;

						let currentBest = null;
						let lastFeedback = '';

						while (true) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							totalIter++;

							const candidates = await sampleSolver(effectiveQuery, currentBest?.text || '', lastFeedback);
							const sel = await pickBest(effectiveQuery, candidates);
							currentBest = sel.best;

							if (sel.isPass) {
								failStreak = 0;
								passStreak++;
								this.log(`PASS (${passStreak}/${PASS_STREAK_TARGET}) [best=${currentBest.id}]`);
								if (passStreak >= PASS_STREAK_TARGET) {
									this.state.status = 'Success';
									this.state.finalResult = currentBest.text || '';
									this.updateStatusUI('Success', 'var(--log-success)');
									const resEl = document.getElementById(`result-area-${this.uniqueId}`);
									if (resEl) resEl.value = this.state.finalResult;
									this.stopTimer();
									return;
								}
								lastFeedback = '';
							} else {
								passStreak = 0;
								failStreak++;
								lastFeedback = sel.feedback || 'Red Team rejected; fix the critical issue.';
								this.log(`FAIL (${failStreak}) [best=${currentBest.id}]`);
								if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
									this.log("Run Failed (Max Streak/Iter). Next Run...");
									break;
								}
							}
							saveToLocalStorage();
						}
					}
					this.state.status = 'Failed';
					this.updateStatusUI('Failed (Max Runs)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest39Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				const toMarkdown = (wb) => {
					const provenFactsStr = (wb?.provenFacts?.length > 0)
						? wb.provenFacts.map(f => `- ${f}`).join('\n')
						: '- [None]';
					const deadEndsStr = (wb?.deadEnds?.length > 0)
						? wb.deadEnds.map(d => `- ${d}`).join('\n')
						: '- [None]';
					const principlesStr = (wb?.keyPrinciples?.length > 0)
						? wb.keyPrinciples.map(p => `- ${p}`).join('\n')
						: '- [None]';
					return `### Key Principles & Corrections
			${principlesStr}
			
			### Proven Facts
			${provenFactsStr}
			
			### Best Theory
			${wb?.bestTheory || '[Not specified]'}
			
			### Dead Ends
			${deadEndsStr}
			
			### Current Objective
			${wb?.currentObjective || '[Not specified]'}`;
				};

				const fromMarkdown = (md) => {
					const wb = {
						provenFacts: [],
						bestTheory: '',
						deadEnds: [],
						currentObjective: '',
						keyPrinciples: []
					};

					const sections = (md || '').toString().split('### ').slice(1);
					for (const section of sections) {
						const lines = section.trim().split('\n');
						const header = (lines.shift() || '').trim();
						const content = lines.join('\n').trim();

						const listItems = content.split('\n')
							.map(line => line.trim().replace(/^- /g, ''))
							.filter(line => line && line !== '[None]');

						if (header.startsWith('Key Principles')) {
							wb.keyPrinciples = listItems;
						} else if (header.startsWith('Proven Facts')) {
							wb.provenFacts = listItems;
						} else if (header.startsWith('Best Theory')) {
							wb.bestTheory = content;
						} else if (header.startsWith('Dead Ends')) {
							wb.deadEnds = listItems;
						} else if (header.startsWith('Current Objective')) {
							wb.currentObjective = content;
						}
					}
					return wb;
				};

				const getMainPrompt = (q, whiteboardMarkdown) => {
					return `### Unchanging Problem Statement ###
			${q}
			
			---
			
			### Current Whiteboard State ###
			${whiteboardMarkdown}
			
			---
			
			### Your Task ###
			Your goal is to make progress by proposing **one single, small, verifiable claim** that logically follows from the 'Proven Facts' and addresses the 'Current Objective'.
			
			1.  **Review the 'Current Objective' and 'Proven Facts'.**
			2.  **Determine the very next logical step.** This must be a small, self-contained claim, not a multi-part argument.
			3.  **Update the 'Best Theory' section** to contain a concise proof/justification for only this *single* new claim.
			4.  **Update the 'Current Objective'** to explicitly state the goal of establishing this new claim. For example: "Prove that the next step is X."
			5.  **CRITICAL: Do NOT add your proposed claim to the 'Proven Facts' list yourself.** It will be added for you automatically after it has been verified by a separate process.
			6.  **Using Symmetry / Invariance / Renaming:** If you prove a claim for a representative case and believe other cases follow by symmetry/invariance (e.g., variable renaming, permutation, rotation, role-swap), you may:
			    *   Prove the base case rigorously in the 'Best Theory' section.
			    *   In the 'Current Objective', state the full generalized claim.
			    *   Add a note in the 'Best Theory' describing the exact transformation and why it preserves all relevant assumptions.
			
			Your entire response MUST be the complete, updated whiteboard. Do not try to solve the entire problem at once. Focus only on the immediate next step.`;
				};

				const getRedTeamWithContext = (q, goldenWhiteboard, proposedFact, proposedProof) => {
					return `### Unchanging Problem Statement ###
			${q}
			
			---
			
			### Already Proven Facts (Golden Whiteboard) ###
			${goldenWhiteboard?.provenFacts?.join('\n') || '[None]'}
			
			---
			
			### New Proposal to Verify ###
			**Claim:** ${proposedFact}
			**Justification:**
			${proposedProof}
			
			---
			
			### Your Task ###
			You are a skeptical opponent. Your sole purpose is to find a single critical flaw in the "Justification" for the "Claim", assuming the "Already Proven Facts" are true.
			
			**Special Instructions for Symmetry / Invariance / Renaming Arguments:**
			If the justification proves one case and claims other cases follow "by symmetry"/"by invariance"/"by renaming", you must perform two checks:
			1.  Is the proof for the base case logically sound and rigorous?
			2.  Does the claimed transformation truly preserve the problem statement and all already-proven facts? (i.e., no hidden asymmetry)
			If both are true, the claim is valid. If either fails, you must identify the flaw.
			
			A flaw can be:
			- A logical error in the derivation of the base case.
			- A contradiction with the "Unchanging Problem Statement" or the "Already Proven Facts".
			- An invalid or improperly justified symmetry/invariance/renaming claim.
			- An unproven leap in logic within the justification.
			
			- If you find a flaw, start your response with "FLAW IDENTIFIED:" and then explain it clearly.
			- If the justification is sound and proves the claim (including any valid symmetry/invariance arguments), respond with exactly and only the text: "No critical flaws found."`;
				};

				const getFinalReviewPrompt = (q, finalWhiteboard) => {
					return `### Unchanging Problem Statement ###
			${q}
			
			---
			
			### Proposed Final Solution Whiteboard ###
			${toMarkdown(finalWhiteboard)}
			
			---
			
			### Your Task ###
			You are a final reviewer. The agent believes this whiteboard represents a complete and correct solution. Your task is to perform a holistic review of the entire argument. Check for:
			1.  **Correctness:** Is every step logically sound?
			2.  **Completeness:** Does the solution fully address all parts of the "Unchanging Problem Statement"?
			3.  **Coherence:** Does the argument flow logically from start to finish?
			
			- If you find any flaw, start with "FLAW IDENTIFIED:" and explain the final remaining issue.
			- If the solution is perfect, respond with exactly and only: "No critical flaws found."`;
				};

				const getPremiseReviewPrompt = (q, whiteboardMarkdown) => {
					return `You have failed to make progress for 3 consecutive attempts. We must pause and review your core assumptions.
			
			### Unchanging Problem Statement ###
			${q}
			
			---
			
			### Current Whiteboard State ###
			${whiteboardMarkdown}
			
			---
			
			### Your Task ###
			Based on the "Unchanging Problem Statement" and the failures listed in the "Dead Ends" of your whiteboard, list the top 1-3 core, unproven assumptions you are making. For each, provide an alternative.
			
			**Format:**
			**Assumption 1:** [Statement of assumption]
			**Alternative 1:** [A different way of thinking]
			
			**Assumption 2:** [Statement of assumption]
			**Alternative 2:** [A different way of thinking]`;
				};

				const pipelineStep1Prompt = `### Core Instructions ###
			*   **Rigor is Paramount:** Your primary goal is to produce a complete and rigorously justified solution. Every step must be logically sound.
			*   **Use Provided Facts:** Your solution MUST be built upon the provided set of "Verified Starting Facts". Assemble them, fill in the connecting logic, and produce a complete final answer.
			*   **Honesty About Completeness:** If you cannot find a complete solution even with the provided facts, you must not guess. Instead, present a partial solution and clearly state what is missing.
			*   **Use Appropriate Formalism:** Use precise language and notation; use LaTeX for mathematical expressions when helpful.
			### Output Format ###
			Your response MUST be structured into:
			**1. Summary** (Verdict: Complete/Partial, Method Sketch)
			**2. Detailed Solution**`;

				const pipelineVerificationPrompt = `You are an expert verifier and a meticulous reviewer. Your task is to rigorously verify the provided solution. A solution is correct ONLY if every critical claim is logically justified.
			### Instructions ###
			*   Your sole task is to find and report all issues. Act as a **verifier**, NOT a solver.
			*   **CRITICAL:** Your response MUST begin with the single word "CORRECT" if the solution is complete, correct, and rigorously justified. Otherwise, it MUST begin with the single word "INCORRECT".
			*   Classify issues as **Critical Error** or **Justification Gap**.
			### Output Format ###
			Your response MUST contain: **Summary** (Final Verdict, List of Findings) and **Detailed Verification Log**.`;

				const extractDetailedSolution = (solution) => {
					const marker = 'Detailed Solution';
					const idx = (solution || '').toString().indexOf(marker);
					return idx === -1 ? (solution || '') : (solution || '').toString().substring(idx + marker.length).trim();
				};

				const runPipeline = async (q, initialContextPrompt) => {
					const verificationHistory = [];
					let isSuccessful = false;
					const pipelineLog = (m) => this.log(`[PIPELINE] ${m}`);

					const generateInitialSolution = async (initialPrompt) => {
						return await this.callAPI(
							[
								{ role: 'system', content: pipelineStep1Prompt },
								{ role: 'user', content: initialPrompt }
							],
							null,
							{ temperature: 0.7 }
						);
					};

					const selfImprove = async (solution, initialCtx) => {
						const improvePrompt = `You have an opportunity to improve your solution. Please review it carefully. Correct errors and fill justification gaps. Your output must strictly follow the system prompt's instructions.`;
						return await this.callAPI(
							[
								{ role: 'system', content: pipelineStep1Prompt },
								{ role: 'user', content: initialCtx },
								{ role: 'assistant', content: solution },
								{ role: 'user', content: improvePrompt }
							],
							null,
							{ temperature: 0.7 }
						);
					};

					const verifySolution = async (problem, solution) => {
						const detailedSolution = extractDetailedSolution(solution);
						const verifyPrompt = `========================\n### Problem ###\n${problem}\n========================\n### Solution ###\n${detailedSolution}\n\nYour task is to act as a grader. Generate the summary and the step-by-step verification log for the solution above.`;
						const verification = await this.callAPI(
							[
								{ role: 'system', content: pipelineVerificationPrompt },
								{ role: 'user', content: verifyPrompt }
							],
							null,
							{ temperature: 0.1 }
						);
						const isGood = (verification || '').trim().toUpperCase().startsWith('CORRECT');
						const bugReport = isGood ? '' : (verification || '').toString().replace(/^INCORRECT\\s*:/i, '').trim();
						return { isGood, bugReport, fullVerification: verification || '' };
					};

					const correctWithFullHistory = async (problem, solution, initialCtx) => {
						const historyContext = `Complete Verification History:\n${verificationHistory.map((h, i) => `\n=== Attempt ${i + 1} ===\nVerdict: ${h.isGood ? 'PASSED' : 'FAILED'}\n${h.isGood ? '' : `Bug Report:\n${h.bugReport}`}`).join('\n')}`;
						const last = verificationHistory[verificationHistory.length - 1];
						const latestBugReport = last && !last.isGood ? last.bugReport : '';
						const correctionPrompt = `You have attempted this multiple times. Here is the complete verification history:\n\n${historyContext}\n\nLatest Bug Report:\n${latestBugReport}\n\nLearn from ALL previous attempts. Avoid repeating mistakes. Improve your solution so that it is complete and rigorous. Your new solution must follow the system prompt instructions.`;
						return await this.callAPI(
							[
								{ role: 'system', content: pipelineStep1Prompt },
								{ role: 'user', content: initialCtx },
								{ role: 'assistant', content: solution },
								{ role: 'user', content: correctionPrompt }
							],
							null,
							{ temperature: 0.7 }
						);
					};

					pipelineLog('Starting...');
					const MAX_PIPELINE_ITERS = 15;
					const SUCCESS_THRESHOLD = 3;
					let correctCount = 0;

					let solution = await generateInitialSolution(initialContextPrompt);
					if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
					pipelineLog('Applying self-improvement to initial solution.');
					solution = await selfImprove(solution, initialContextPrompt);

					for (let i = 0; i < MAX_PIPELINE_ITERS; i++) {
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
						pipelineLog(`Verification attempt ${i + 1}`);
						const verification = await verifySolution(q, solution);
						verificationHistory.push({ ...verification });

						if (verification.isGood) {
							correctCount++;
							pipelineLog(`Verification PASSED (${correctCount}/${SUCCESS_THRESHOLD})`);
							if (correctCount >= SUCCESS_THRESHOLD) {
								pipelineLog('Success threshold met. Solution is verified.');
								isSuccessful = true;
								break;
							}
						} else {
							correctCount = 0;
							pipelineLog('Verification FAILED. Correcting with full history.');
							solution = await correctWithFullHistory(q, solution, initialContextPrompt);
						}
					}

					pipelineLog('Pipeline run finished.');
					return { solution, isSuccessful, verificationHistory };
				};

				try {
					if (!this.state.test39State) {
						this.state.test39State = {
							i: 0,
							consecutiveFailures: 0,
							successfulProofCounter: 0,
							completed: false,
							whiteboard: {
								provenFacts: [],
								bestTheory: 'The solution likely involves analyzing the problem statement for key constraints and properties.',
								deadEnds: [],
								currentObjective: `Restate the user's request, \"${query}\", as a formal problem statement and devise an initial, high-level plan to solve it.`,
								keyPrinciples: []
							},
							whiteboardMarkdown: ''
						};
					}

					const s = this.state.test39State;
					if (!s.whiteboard) {
						s.whiteboard = {
							provenFacts: [],
							bestTheory: '',
							deadEnds: [],
							currentObjective: '',
							keyPrinciples: []
						};
					}
					if (!s.whiteboardMarkdown) {
						try { s.whiteboardMarkdown = toMarkdown(s.whiteboard); } catch { s.whiteboardMarkdown = ''; }
					}
					this.updateWhiteboardUI(s.whiteboardMarkdown);

					const MAX_ITERATIONS = 100;
					for (let i = s.i; i < MAX_ITERATIONS; i++) {
						s.i = i;
						if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

						const wb = s.whiteboard;
						this.log(`--- Iteration ${i + 1} / ${MAX_ITERATIONS} (Proven Facts: ${wb.provenFacts.length}, Failures: ${s.consecutiveFailures}) ---`);
						this.log(`Current Objective: ${wb.currentObjective}`);

						s.whiteboardMarkdown = toMarkdown(wb);
						this.updateWhiteboardUI(s.whiteboardMarkdown);

						if (s.consecutiveFailures >= 3) {
							this.log('Stuck state detected (3 consecutive failures). Triggering Premise Review.');
							const premiseReviewPrompt = getPremiseReviewPrompt(query, s.whiteboardMarkdown);
							const reviewResultText = await this.callAPI([{ role: 'user', content: premiseReviewPrompt }], null, { temperature: 0.4 });

							const newTheoryMatch = (reviewResultText || '').match(/Alternative 1:\\s*(.*)/);
							const newTheory = newTheoryMatch ? newTheoryMatch[1] : 'A new approach is needed based on the premise review.';
							const oldAssumptionMatch = (reviewResultText || '').match(/Assumption 1:\\s*(.*)/);
							const oldAssumption = oldAssumptionMatch ? oldAssumptionMatch[1] : (wb.bestTheory || '');

							wb.deadEnds.push(`The assumption that '${oldAssumption}' was unproductive.`);
							wb.bestTheory = newTheory;
							wb.currentObjective = `Your previous approach was flawed. Your new objective is to investigate the viability of your new theory: \"${newTheory}\".`;
							this.log(`Premise review complete. New theory: ${wb.bestTheory}`);
							s.consecutiveFailures = 0;
							s.whiteboardMarkdown = toMarkdown(wb);
							this.updateWhiteboardUI(s.whiteboardMarkdown);
							saveToLocalStorage();
							continue;
						}

						const currentMarkdown = s.whiteboardMarkdown;
						const mainPrompt = getMainPrompt(query, currentMarkdown);
						const proposalMarkdown = await this.callAPI([{ role: 'user', content: mainPrompt }], null, { temperature: 0.7 });

						let proposedWhiteboard = null;
						try {
							proposedWhiteboard = fromMarkdown(proposalMarkdown);
							if (!proposedWhiteboard.currentObjective) throw new Error("Agent failed to produce a valid whiteboard with a 'Current Objective'.");
						} catch (e) {
							this.log(`ERROR parsing agent output: ${e.message}. Adding to Dead Ends.`);
							wb.deadEnds.push(`Agent produced invalid markdown. Output: ${(proposalMarkdown || '').toString().substring(0, 200)}...`);
							s.consecutiveFailures++;
							s.whiteboardMarkdown = toMarkdown(wb);
							this.updateWhiteboardUI(s.whiteboardMarkdown);
							saveToLocalStorage();
							continue;
						}

						const objLower = (proposedWhiteboard.currentObjective || '').toString().toLowerCase();
						const isCompletionClaim = objLower.includes('solution is complete') || objLower.includes('problem is solved');
						if (isCompletionClaim) {
							this.log('Completion claimed. Initiating Finalization Protocol.');
							const finalReviewPrompt = getFinalReviewPrompt(query, proposedWhiteboard);
							const finalReviewResult = await this.callAPI([{ role: 'user', content: finalReviewPrompt }], null, { temperature: 0.2 });

							if ((finalReviewResult || '').toString().toLowerCase().includes('no critical flaws found')) {
								this.log('‚úÖ Finalization Protocol: PASS. Solution is complete and verified.');
								s.whiteboard = proposedWhiteboard;
								s.completed = true;
								s.whiteboardMarkdown = toMarkdown(s.whiteboard);
								this.updateWhiteboardUI(s.whiteboardMarkdown);
								saveToLocalStorage();
								break;
							} else {
								this.log('‚ùå Finalization Protocol: FAILED. Holistic review found a flaw.');
								const flaw = (finalReviewResult || '').toString().replace(/FLAW IDENTIFIED:/i, '').trim();
								wb.deadEnds.push(`Final solution rejected. Flaw: ${flaw}`);
								wb.keyPrinciples.push(`Final solution must address this: ${flaw}`);
								wb.currentObjective = `Your proposed final solution was rejected. Correct this final flaw: \"${flaw}\"`;
								s.consecutiveFailures++;
								s.whiteboardMarkdown = toMarkdown(wb);
								this.updateWhiteboardUI(s.whiteboardMarkdown);
								saveToLocalStorage();
								continue;
							}
						}

						const proposedFactText = (proposedWhiteboard.currentObjective || '').toString().replace(/^Prove that /i, '').trim();
						const prevFactText = (wb.currentObjective || '').toString().replace(/^Prove that /i, '').trim();
						const isNewFactProposed = proposedFactText && proposedFactText !== prevFactText && !(wb.provenFacts || []).includes(proposedFactText);

						if (isNewFactProposed) {
							this.log(`Proposing new fact for Red Team review: \"${proposedFactText}\"`);
							const redTeamPrompt = getRedTeamWithContext(query, wb, proposedFactText, proposedWhiteboard.bestTheory);
							const redTeamResult = await this.callAPI([{ role: 'user', content: redTeamPrompt }], null, { temperature: 0.2 });

							if ((redTeamResult || '').toString().toLowerCase().includes('no critical flaws found')) {
								this.log('Red Team: PASS. Adding new fact to the Golden Whiteboard.');
								wb.provenFacts.push(proposedFactText);
								wb.bestTheory = proposedWhiteboard.bestTheory;
								wb.currentObjective = 'The previous fact has been successfully proven. Determine the next logical fact to prove.';
								s.consecutiveFailures = 0;
								s.successfulProofCounter++;
							} else {
								this.log('Red Team: FLAW IDENTIFIED. Rejecting new fact.');
								const flaw = (redTeamResult || '').toString().replace(/FLAW IDENTIFIED:/i, '').trim();
								wb.deadEnds.push(`Proposed fact failed: \"${proposedFactText}\". Flaw: ${flaw}`);
								wb.keyPrinciples.push(`Correction: ${flaw}`);
								wb.currentObjective = `Your last proposal was flawed: \"${flaw}\". Re-evaluate and try again.`;
								s.consecutiveFailures++;
							}
						} else {
							this.log('Standard step progression. Updating whiteboard state.');
							s.whiteboard = proposedWhiteboard;
						}

						s.whiteboardMarkdown = toMarkdown(s.whiteboard);
						this.updateWhiteboardUI(s.whiteboardMarkdown);

						const provenFactsCount = s.whiteboard.provenFacts.length;
						if (provenFactsCount > 0 && provenFactsCount % 3 === 0 && s.successfulProofCounter > 0) {
							this.log(`--- Synthesis Checkpoint Triggered (${provenFactsCount} proven facts) ---`);
							this.log('Forking speculative answer derivation pipeline...');

							const initialPipelinePrompt = `
			${query}
			
			---
			### Verified Starting Facts ###
			You MUST use the following facts as the foundation of your solution. They have already been proven and do not need to be justified again. Your task is to assemble them, fill in the connecting logic, and produce a complete final answer.
			
			${s.whiteboard.provenFacts.map(fact => `- ${fact}`).join('\n')}
			---
			
			Please generate a complete solution based on these starting materials.
			`.trim();

							const pipeline = await runPipeline(query, initialPipelinePrompt);
							if (pipeline.isSuccessful) {
								this.log('‚úÖ Pipeline SUCCEEDED. Solution found and verified.');
								this.state.status = 'Success';
								this.state.finalResult = pipeline.solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}

							this.log('‚ùå Pipeline FAILED to produce a verified solution.');
							if (pipeline.verificationHistory.length > 0) {
								const lastFailure = pipeline.verificationHistory[pipeline.verificationHistory.length - 1];
								const feedback = `A full solution attempt failed. The final bug report was: \"${lastFailure.bugReport}\". This indicates a key piece of logic is still missing.`;
								this.log(`Feedback from pipeline: ${feedback}`);
								s.whiteboard.keyPrinciples.push(feedback);
								s.whiteboard.currentObjective = 'A full solution attempt failed. Review the new Key Principle and determine the next fact needed to overcome this block.';
								s.whiteboardMarkdown = toMarkdown(s.whiteboard);
								this.updateWhiteboardUI(s.whiteboardMarkdown);
							}
							s.successfulProofCounter = 0;
						}

						saveToLocalStorage();
					}

					const finalMarkdown = toMarkdown(this.state.test39State.whiteboard);
					this.state.finalResult = this.state.test39State.completed
						? `### FINAL WHITEBOARD STATE (Solution claimed verified) ###\n\n${finalMarkdown}`
						: `### FINAL WHITEBOARD STATE (No conclusive solution found) ###\n\n${finalMarkdown}`;

					if (this.state.test39State.completed) {
						this.state.status = 'Success';
						this.updateStatusUI('Success', 'var(--log-success)');
					} else {
						this.state.status = 'Failed';
						this.updateStatusUI('Failed (Max Iterations)', 'var(--log-error)');
					}

					const resEl = document.getElementById(`result-area-${this.uniqueId}`);
					if (resEl) resEl.value = this.state.finalResult;
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			async runTest9Architecture(query) {
				this.updateStatusUI('Running', 'blue');
				this.startTimer();
				this.stopFlag = false;

				if (!this.state.verifiedClues) this.state.verifiedClues = [];

				const MAX_RUNS = 10;
				const PASS_STREAK_TARGET = 5;
				const PRUNE_FAIL_STREAK = 3;
				const MAX_LINEAGE_CALLS = 30;

				const makeBranch = (id, seed) => ({
					id,
					solution: seed || '',
					passStreak: 0,
					consecFail: 0,
					lineageCalls: 0,
					lastFeedback: '',
					alive: true,
				});

				const callSolverOnce = async (effectiveQuery, priorSolution, feedback) => {
					let user = effectiveQuery;
					const prior = (priorSolution || '').toString().trim();
					const fb = (feedback || '').toString().trim();
					if (prior) {
						user = `${effectiveQuery}\n\n[Context from another branch]\n${prior}\n\n${fb ? `[Feedback]\n${fb}\n\n` : ''}Produce a new solution attempt.\n- You may revise the context draft OR write an alternative solution.\n- Do not merely paraphrase; aim to fix weaknesses and improve rigor.`;
					} else if (fb) {
						user = `${effectiveQuery}\n\n[Feedback]\n${fb}\n\nRevise and produce a corrected full solution.`;
					}
					return await this.callAPI([
						{ role: 'system', content: this.getSolverPrompt() },
						{ role: 'user', content: user }
					]);
				};

				try {
					for (let runIdx = this.state.runIdx; runIdx <= MAX_RUNS; runIdx++) {
						this.state.runIdx = runIdx;
						this.log(`=== Run ${runIdx}/${MAX_RUNS} ===`);
						const effectiveQuery = this.formatQueryWithClues(query);

						// Initialize 3 branches
						const branches = [];
						for (let i = 0; i < 3; i++) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
							const seed = await callSolverOnce(effectiveQuery);
							const b = makeBranch(`B${i + 1}`, seed || '');
							b.lineageCalls = 1;
							branches.push(b);
						}

						let turn = 0;
						while (true) {
							if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");

							// Success condition: any branch reaches pass streak.
							const winner = branches.find(b => b.alive && b.passStreak >= PASS_STREAK_TARGET);
							if (winner) {
								this.state.status = 'Success';
								this.state.finalResult = winner.solution || '';
								this.updateStatusUI('Success', 'var(--log-success)');
								const resEl = document.getElementById(`result-area-${this.uniqueId}`);
								if (resEl) resEl.value = this.state.finalResult;
								this.stopTimer();
								return;
							}

							const maxLineage = Math.max(...branches.filter(b => b.alive).map(b => b.lineageCalls), 0);
							if (maxLineage >= MAX_LINEAGE_CALLS) {
								this.log(`[test9] Run budget reached (lineageCalls=${maxLineage} >= ${MAX_LINEAGE_CALLS}). Next Run...`);
								break;
							}

							const alive = branches.filter(b => b.alive);
							if (alive.length === 0) {
								this.log('[test9] All branches pruned. Next Run...');
								break;
							}

							const b = alive[turn % alive.length];
							turn++;

							// Verify current branch solution.
							const verifierResp = await this.callAPI(
								[
									{ role: 'system', content: this.getVerifierPrompt(false) },
									{ role: 'user', content: `Problem:\n${effectiveQuery}\n\nSolution Attempt:\n${b.solution}\n\nReturn <pass> or <fail> at the end.` }
								],
								(txt) => txt.includes('<pass>') || txt.includes('<fail>')
							);
							b.lineageCalls += 1;

							let isPass = verifierResp.includes('<pass>');
							const feedbackContent = verifierResp.replace(/<\/?(pass|fail|summary)>/g, "").trim();

							if (isPass) {
								b.passStreak++;
								b.consecFail = 0;
								b.lastFeedback = '';
								this.log(`[test9] ${b.id}: PASS (${b.passStreak}/${PASS_STREAK_TARGET})`);
							} else {
								b.passStreak = 0;
								b.consecFail++;
								b.lastFeedback = feedbackContent || 'Verifier rejected.';
								this.log(`[test9] ${b.id}: FAIL (${b.consecFail}/${PRUNE_FAIL_STREAK})`);
							}

							// Prune if 3 fails in a row.
							if (!isPass && b.consecFail >= PRUNE_FAIL_STREAK) {
								b.alive = false;
								this.log(`[test9] ${b.id}: PRUNED (3 consecutive fails).`);

								const donors = branches.filter(x => x.alive);
								if (donors.length === 0) continue;

								// Regrow from best-performing donor (highest passStreak).
								donors.sort((a, b2) => (b2.passStreak - a.passStreak) || (b2.lineageCalls - a.lineageCalls));
								const donor = donors[0];
								const extraCalls = donor.passStreak >= 2 ? 1 : 2;
								this.log(`[test9] Regrowing from ${donor.id} (extra solver calls=${extraCalls})...`);

								let newSeed = donor.solution;
								for (let c = 0; c < extraCalls; c++) {
									if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
									newSeed = await callSolverOnce(effectiveQuery, donor.solution, donor.lastFeedback || '');
								}
								const newBranch = makeBranch(b.id, newSeed || '');
								newBranch.lineageCalls = donor.lineageCalls + extraCalls;
								const idx = branches.findIndex(x => x.id === b.id);
								if (idx >= 0) branches[idx] = newBranch;
								this.log(`[test9] ${b.id}: REPLACED (lineageCalls=${newBranch.lineageCalls}).`);
								saveToLocalStorage();
								continue;
							}

							// Otherwise, if failed, revise within the branch.
							if (!isPass) {
								const revised = await this.handleFailure(b.solution, b.lastFeedback, effectiveQuery, [], {});
								b.solution = revised || b.solution;
								b.lineageCalls += 1;
							}

							saveToLocalStorage();
						}
					}

					this.state.status = 'Failed';
					this.updateStatusUI('Failed (Max Runs)', 'var(--log-error)');
					this.stopTimer();
				} catch (e) {
					if (e.message === "Stopped" || e.message === "Stopped by User") {
						this.log("Process Paused.");
						this.updateStatusUI("Paused", "orange");
					} else {
						this.log(`FATAL: ${e.message}`);
						this.updateStatusUI("Error", "red");
					}
					this.stopTimer();
				}
			}

			// ===== Proposed architectures (wrappers) =====
			isLikelyReadingMultipleChoiceProblem(query) {
				const q = (query || '').toString();
				if (!q) return false;

				const norm = q.replace(/\s+/g, ' ').trim();
				const isLong = norm.length >= 700 || q.split('\n').length >= 14;
				if (!isLong) return false;

				const __count = (re) => (q.match(re) || []).length;
				const choiceCount =
					__count(/[‚ë†-‚ë§]/g)
					+ __count(/\b[1-5]\s*\)/g)
					+ __count(/\b[1-5]\s*\./g)
					+ __count(/\b[A-E]\s*\)/g)
					+ __count(/\b[A-E]\s*\./g);
				const hasChoices = choiceCount >= 3;

				const hasBogi = /<\s*Î≥¥Í∏∞\s*>|\[\s*Î≥¥Í∏∞\s*\]|\(\s*Î≥¥Í∏∞\s*\)|(^|\n)\s*Î≥¥Í∏∞\s*[:Ôºö]/i.test(q) || /<Î≥¥Í∏∞>/.test(q);
				const hasReadingCue = /(ÏßÄÎ¨∏|Î¨∏Îß•|ÎÇ¥Ïö©|ÏöîÏßÄ|Ï£ºÏ†ú|ÏÑúÏà†|Í∑ºÍ±∞|Ï∂îÎ°†|ÏÑ§Î™Ö|ÌïÑÏûê|Í∏ÄÏì¥Ïù¥)/.test(q);
				const hasMcqCue = /(Ï†ÅÏ†àÌïòÏßÄ ÏïäÏùÄ Í≤ÉÏùÄ|Ïò≥ÏßÄ ÏïäÏùÄ Í≤ÉÏùÄ|ÏïåÎßûÏßÄ ÏïäÏùÄ|Í∞ÄÏû• Ï†ÅÏ†à|Í∞ÄÏû• ÏïåÎßû|Í≥†Î•¥ÏãúÏò§|ÏÑ†ÌÉùÌïòÏãúÏò§)/.test(q);

				const hasMathish =
					/(\$[^$]+\$)|\\\(|\\\)|\\[a-zA-Z]+|[=<>¬±‚àë‚à´‚àö]|(probability|expected value|value of|prove|theorem)/i.test(q);

				return hasChoices && (hasBogi || hasReadingCue || hasMcqCue) && !hasMathish;
			}

			async runAdaptiveMethod3OverlapArchitecture(query) {
				const isReading = this.isLikelyReadingMultipleChoiceProblem(query);
				if (isReading) {
					this.log(`[Adaptive-Method3-Overlap] Reading/MCQ detected ‚Üí delegating to test37.`);
					return await this.runTest37Architecture(query);
				}

				const label = 'test43-2-r15-corr1-method3-ans2';
				this.log(`[Adaptive-Method3-Overlap] Math/logic path ‚Üí delegating to ${label}.`);
				return await this.runTest43VariantArchitecture(query, label);
			}

			async runBMoveArchitecture(query) {
				const isReading = this.isLikelyReadingMultipleChoiceProblem(query);
				if (isReading) {
					this.log(`[B-MOVE] Reading/MCQ detected ‚Üí delegating to test37.`);
					return await this.runTest37Architecture(query);
				}

				// Budget-oriented preset: method3 diversity + seed37, with anti-runaway caps.
				// Notes:
				// - flags: d/e/g/c = reset-on-repeat + require-same-failure-twice + adaptive temperature + cap 1 correction/round
				// - opts: nomem reduces per-round init overhead; m/r caps total rounds/verifier budget
				// - corr0 keeps corrections cheap; ans2+quietpass are final safety gates
				const label = 'test43-2degc-seed37-nomem-m4-r10-corr0-method3-ans2-quietpass';
				this.log(`[B-MOVE] Budgeted math/logic path ‚Üí delegating to ${label}.`);
				return await this.runTest43VariantArchitecture(query, label);
			}

			async run(query) {
				if (this.state.status === 'Success' || this.state.status === 'Failed') return;

				const lockedQuery = this.resolveLockedQuery(query);
				this._activeRun = true;
				try {
					if (this.config.special === 'pass@1') {
						return await this.runPassAt1(lockedQuery);
					}
					if (this.config.special === 'test6') {
						return await this.runTest6Architecture(lockedQuery);
					}
					if (this.config.special === 'test9') {
						return await this.runTest9Architecture(lockedQuery);
					}
					if (this.config.special === 'system-1.0') {
						return await this.runMainBranchArchitecture(lockedQuery);
					}
					if (this.config.special === 'system-1.1') {
						return await this.runSystem11Architecture(lockedQuery);
					}
					if (this.config.special === 'system-1.2') {
						return await this.runSystem12Architecture(lockedQuery);
					}
					if (this.config.special === 'test20') {
						return await this.runTest20Architecture(lockedQuery);
					}
					if (this.config.special === 'test21') {
						return await this.runTest21Architecture(lockedQuery);
					}
					if (this.config.special === 'test22') {
						return await this.runTest22Architecture(lockedQuery);
					}
					if (this.config.special === 'test23') {
						return await this.runTest23Architecture(lockedQuery);
					}
					if (this.config.special === 'test24') {
						return await this.runTest24Architecture(lockedQuery);
					}
					if (this.config.special === 'test25') {
						return await this.runTest25Architecture(lockedQuery);
					}
					if (this.config.special === 'test26') {
						return await this.runTest26Architecture(lockedQuery);
					}
					if (this.config.special === 'test27') {
						return await this.runTest27Architecture(lockedQuery);
					}
					if (this.config.special === 'test28') {
						return await this.runTest28Architecture(lockedQuery);
					}
					if (this.config.special === 'test29') {
						return await this.runTest29Architecture(lockedQuery);
					}
					if (this.config.special === 'test30') {
						return await this.runTest30Architecture(lockedQuery);
					}
					if (this.config.special === 'test31') {
						return await this.runTest31Architecture(lockedQuery);
					}
					if (this.config.special === 'test32') {
						return await this.runTest32Architecture(lockedQuery);
					}
					if (this.config.special === 'test33') {
						return await this.runTest33Architecture(lockedQuery);
					}
					if (this.config.special === 'test34') {
						return await this.runTest34Architecture(lockedQuery);
					}
					if (this.config.special === 'test35') {
						return await this.runTest35Architecture(lockedQuery);
					}
					if (this.config.special === 'test36') {
						return await this.runTest36Architecture(lockedQuery);
					}
					if (this.config.special === 'test37') {
						return await this.runTest37Architecture(lockedQuery);
					}
					if (this.config.special === 'adaptive-method3-overlap') {
						return await this.runAdaptiveMethod3OverlapArchitecture(lockedQuery);
					}
					if (this.config.special === 'b-move') {
						return await this.runBMoveArchitecture(lockedQuery);
					}
					if (this.config.special === 'test38') {
						return await this.runTest38Architecture(lockedQuery);
					}
					if (this.config.special === 'test39') {
						return await this.runTest39Architecture(lockedQuery);
					}
					if (this.config.special === 'test40') {
						return await this.runTest40Architecture(query);
					}
					if (this.config.special === 'test41') {
						return await this.runTest41Architecture(query);
					}
					if (this.config.special === 'test42') {
						return await this.runTest42Architecture(query);
					}
					if (this.config.special === 'agemem') {
						return await this.runAgeMemArchitecture(lockedQuery);
					}
					if (this.config.special === 'focus') {
						return await this.runFocusArchitecture(lockedQuery);
					}
					if (this.config.special === 'simplemem') {
						return await this.runSimpleMemArchitecture(lockedQuery);
					}
					if (this.config.special === 'pacore') {
						return await this.runPaCoreArchitecture(lockedQuery);
					}
					if (this.config.special === 'sciidea' || this.config.special === 'sciidea-lite') {
						return await this.runSciIdeaArchitecture(lockedQuery, this.config.special);
					}
					if (this.config.special && this.config.special.startsWith('test43-')) {
						return await this.runTest43VariantArchitecture(lockedQuery, this.config.special);
					}
					if (this.config.special === 'test43') {
						return await this.runTest43Architecture(query);
					}
					if (this.config.special === 'test44') {
						return await this.runTest44Architecture(query);
					}
					if (this.config.special === 'test45') {
						return await this.runTest45Architecture(query);
					}
					if (this.config.special && this.config.special.startsWith('test47-')) {
						return await this.runTest47RoutingArchitecture(lockedQuery, this.config.special);
					}

					this.updateStatusUI('Running', 'blue');
					this.startTimer();
					this.stopFlag = false;

					if (!this.state.verifiedClues) this.state.verifiedClues = [];
					const exp = this.config.exp || {};

					const MAX_RUNS = 10;
					const PASS_STREAK_TARGET = 5;
					const MAX_FAIL_STREAK = 10;
					const MAX_ITER_PER_RUN = 30;

					try {
						for (let runIdx = this.state.runIdx; runIdx <= MAX_RUNS; runIdx++) {
							this.state.runIdx = runIdx;
							this.log(`=== Run ${runIdx}/${MAX_RUNS} ===`);

							if (!this.config.accCross && runIdx === 1) this.state.globalMemory = [];
							let runMemory = [];
							if (exp.rrSolver || exp.rrVerifier) this.resetRoundRobinState();

							const effectiveQuery = this.formatQueryWithClues(lockedQuery);

							let methodologyText = '';
							let commitmentsText = '';
							if (exp.methodologyVote) {
								this.log('[Methodology] Selecting methodology via vote...');
								const mv = await this.runMethodologyVote(`Baseline Run ${runIdx}`, effectiveQuery, '');
								methodologyText = (mv.finalMethodology || '').trim();
								commitmentsText = (mv.finalCommitments || '').trim();
							}

							let checklistBlock = '';
							if (exp.verifierMode === 'rt2_checklist') {
								if (!this.state.expChecklistCache) this.state.expChecklistCache = {};
								const key = this.normalizeForHash(effectiveQuery).slice(0, 1800);
								if (this.state.expChecklistCache[key]) {
									checklistBlock = this.state.expChecklistCache[key];
								} else {
									checklistBlock = exp.checklistGen === 'pass@1'
										? await this.generateChecklistPassAt1(effectiveQuery)
										: await this.generateFinalChecklist(effectiveQuery);
									this.state.expChecklistCache[key] = checklistBlock;
								}
							}

							const taskType = 'OTHER';

							let solverSys = this.getSolverPrompt();
							if (exp.solverPrompt === 'v12') {
								solverSys = this.getSolverPromptWithMethodologyV12(methodologyText, commitmentsText, 'Baseline', taskType);
							} else if (exp.solverPrompt === 'v12_basis') {
								solverSys = this.getSolverPromptV12Basis(taskType);
								if (methodologyText || commitmentsText) {
									solverSys = `${solverSys}\n\n[Methodology / Commitments]\n${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}\n\nFollow these while writing your steps.`;
								}
							} else if (exp.methodologyVote && (methodologyText || commitmentsText)) {
								const injectionMode = (exp.methodologyInjection || '').toString().trim().toLowerCase();
								const mustFollow = injectionMode === 'mandatory';
								solverSys = `${solverSys}
	
	### Selected Methodology / Commitments (${mustFollow ? 'MANDATORY' : 'HIGH PRIORITY'})
	These are instructions, not output format. Do NOT output <methodology> or <commitments> tags in your final answer.
	${methodologyText ? `<methodology>\n${methodologyText.trim()}\n</methodology>\n` : ''}${commitmentsText ? `<commitments>\n${commitmentsText.trim()}\n</commitments>` : ''}
	${mustFollow ? 'You MUST follow the methodology order and honor the commitments.' : 'Follow these while solving.'}`;
							}

							if (exp.rrSolver) {
								const persona = this.nextRoundRobinPersona('solver');
								solverSys = this.applyPersonaToSystemPrompt(solverSys, persona, 'Do NOT mention the persona in your output.');
								this.log(`[Solver] Persona: ${persona.name}`);
							}

							let runWorkingMemoryEntries = [];
							let solution = '';
							if (exp.workingMemoryV12) {
								const wmDecayed = this.decrementWorkingMemoryTtl(runWorkingMemoryEntries);
								const solverResp = await this.callAPI(
									[
										{ role: 'system', content: solverSys },
										{ role: 'user', content: this.buildQueryWithWorkingMemoryV12(effectiveQuery, wmDecayed) }
									],
									(txt) => this.validateWorkingMemoryXmlBlock(txt),
									{ temperature: 0.7 }
								);
								const parsed0 = this.parseWorkingMemoryFromResponseV12(solverResp, wmDecayed);
								runWorkingMemoryEntries = this.mergeWorkingMemory(wmDecayed, parsed0.newEntries);
								if (runWorkingMemoryEntries.length > 7) {
									this.log(`[WorkingMemory] > 7 entries ‚Üí purifier...`);
									runWorkingMemoryEntries = await this.runMemoryPurifierV12(effectiveQuery, runWorkingMemoryEntries);
								}
								solution = parsed0.cleanText;
							} else {
								solution = await this.callAPI([
									{ role: 'system', content: solverSys },
									{ role: 'user', content: effectiveQuery }
								]);
							}

							let passStreak = 0;
							let failStreak = 0;
							let clueStreak = 0;
							let currentClueContent = null;
							let totalIter = 0;

							while (true) {
								if (this.stopFlag || GLOBAL_EMERGENCY_STOP) throw new Error("Stopped");
								totalIter++;

								const includeRedSummary = (this.config.who === 'red');
								const validatorFunc = (text) => text.includes('<pass>') || text.includes('<fail>') || (this.config.clueEnabled && text.includes('<clue>'));

								let verifierResp = "";
								let isClue = false;
								let isPass = false;

								if (exp.verifierMode === 'rt2_checklist') {
									const persona = { id: 'RT2-Checklist', focus: 'Grade strictly against the checklist; find fatal flaws.', temperature: 0.2, top_k: 40 };
									verifierResp = await this.runRT2ChecklistVerifierV12(effectiveQuery, checklistBlock, solution, persona);
									const finalTag = this.extractFinalSingleTag(verifierResp, ['pass', 'fail']);
									isPass = finalTag === 'pass' || verifierResp.includes('<pass>');
									isClue = false;
								} else if (exp.verifierMode === 'step_logic' || exp.verifierMode === 'step_contradiction_strict') {
									let verifierSys = this.getVerifierPromptStepLogic(includeRedSummary, { contradictionStrict: exp.verifierMode === 'step_contradiction_strict' });
									if (exp.rrVerifier) {
										const persona = this.nextRoundRobinPersona('verifier');
										verifierSys = this.applyPersonaToSystemPrompt(
											verifierSys,
											persona,
											'Judge correctness/completeness, not style. Do NOT mention the persona in your output.'
										);
										this.log(`[Verifier] Persona: ${persona.name}`);
									}
									verifierResp = await this.callAPI(
										[
											{ role: 'system', content: verifierSys },
											{ role: 'user', content: `Problem: ${effectiveQuery}\n\nSolution Attempt:\n${solution}` }
										],
										validatorFunc
									);
									isPass = verifierResp.includes('<pass>');
									isClue = this.config.clueEnabled && verifierResp.includes('<clue>');
								} else if (this.config.rtTrigger === 'T3') {
									const rtResult = await this.runRedTeamLoop(solution, this.config.rtType);
									if (rtResult.verdict === 'pass') {
										verifierResp = "<pass>" + (rtResult.feedback ? (" <summary>" + rtResult.feedback + "</summary>") : "");
									} else {
										verifierResp = "<fail>" + (rtResult.feedback ? (" <summary>" + rtResult.feedback + "</summary>") : "");
									}
									isPass = verifierResp.includes('<pass>');
									isClue = false;
								} else {
									let verifierSys = this.getVerifierPrompt(includeRedSummary);
									if (exp.rrVerifier) {
										const persona = this.nextRoundRobinPersona('verifier');
										verifierSys = this.applyPersonaToSystemPrompt(
											verifierSys,
											persona,
											'Judge correctness/completeness, not style. Do NOT mention the persona in your output.'
										);
										this.log(`[Verifier] Persona: ${persona.name}`);
									}
									verifierResp = await this.callAPI(
										[
											{ role: 'system', content: verifierSys },
											{ role: 'user', content: `Problem: ${effectiveQuery}\n\nSolution Attempt:\n${solution}` }
										],
										validatorFunc
									);
									isPass = verifierResp.includes('<pass>');
									isClue = this.config.clueEnabled && verifierResp.includes('<clue>');
								}

								if (isClue && !this.config.id.endsWith('-SUB')) {
									const extractedClue = this.extractTag(verifierResp, 'clue');
									let isValidClue = false;

									if (clueStreak === 0) {
										if (await this.validateClue(extractedClue, query)) {
											currentClueContent = extractedClue;
											clueStreak = 1;
											isValidClue = true;
											this.log(`CLUE PROPOSED (1/5): ${extractedClue}`);
										} else {
											this.log(`CLUE REJECTED (Invalid): ${extractedClue}`);
										}
									} else {
										if (extractedClue === currentClueContent) {
											clueStreak++;
											isValidClue = true;
											this.log(`CLUE VERIFIED (${clueStreak}/5)`);
										} else {
											this.log(`CLUE MISMATCH (Reset): ${extractedClue}`);
											clueStreak = 0;
											currentClueContent = null;
										}
									}

									if (isValidClue) {
										if (clueStreak >= 5) {
											const resolvedAnswer = await this.resolveClue(currentClueContent, query);
											if (resolvedAnswer) {
												this.state.verifiedClues.push({ clue: currentClueContent, answer: resolvedAnswer });
												this.log(`CLUE RESOLVED. Injecting info and restarting run...`);
												runIdx--;
												break;
											} else {
												this.log(`CLUE SOLVER FAILED.`);
												clueStreak = 0;
												currentClueContent = null;
											}
										} else {
											continue;
										}
									}
								} else {
									if (clueStreak > 0) {
										this.log("Clue Streak Broken (Verdict Changed).");
										clueStreak = 0;
										currentClueContent = null;
									}
								}
								let rawSummary = this.extractTag(verifierResp, 'summary');
								let feedbackContent = "";

								if (exp.verifierMode === 'rt2_checklist') {
									const extracted = this.extractRT2FailureFeedback(verifierResp);
									feedbackContent = (extracted.summary || '').trim();
									rawSummary = feedbackContent || rawSummary;
								} else if (this.config.fullText) {
									feedbackContent = verifierResp.replace(/<\/?(pass|fail|summary)>/g, "").trim();
								} else {
									if (this.config.who === 'red') {
										feedbackContent = rawSummary || "No summary provided.";
									} else if (this.config.who === 'mid') {
										const midResp = await this.callAPI(
											[{ role: 'user', content: this.getIntermediaryPrompt(verifierResp) }],
											(text) => text.includes('<summary>')
										);
										feedbackContent = this.extractTag(midResp, 'summary') || midResp;
										if (exp.intermediaryIncludeVerbatimVerifierFeedback) {
											const verbatim = verifierResp.replace(/<\/?(pass|fail|summary)>/g, "").trim();
											feedbackContent = `${feedbackContent}\n\n[Verbatim Red Team Feedback]\n${verbatim}`;
										}
									} else {
										feedbackContent = verifierResp.replace(/<\/?(pass|fail)>/g, "").trim();
									}
								}

								if (isPass) {
									passStreak++;
									if (this.config.rtTrigger === 'T1' && passStreak === PASS_STREAK_TARGET) {
										this.log("[RedTeam] T1 Trigger (Streak 5). Verifying...");
										const rtRes = await this.runRedTeamLoop(solution, this.config.rtType);
										if (rtRes.verdict === 'fail') {
											isPass = false;
											passStreak = 0;
											feedbackContent = "Red Team Rejected: " + (rtRes.feedback || "No Feedback");
											this.log("[RedTeam] Rejected Solution.");
										}
									} else if (this.config.rtTrigger === 'T2' && passStreak === 3) {
										this.log("[RedTeam] T2 Trigger (Streak 3). Verifying...");
										const rtRes = await this.runRedTeamLoop(solution, this.config.rtType);
										if (rtRes.verdict === 'fail') {
											isPass = false;
											passStreak = 0;
											feedbackContent = "Red Team Rejected: " + (rtRes.feedback || "No Feedback");
											this.log("[RedTeam] Rejected Solution.");
										} else {
											this.log("[RedTeam] Passed. Continuing streak...");
										}
									}
								}

								if (isPass) {
									failStreak = 0;
									this.log(`PASS (${passStreak}/${PASS_STREAK_TARGET})`);
									if (passStreak >= PASS_STREAK_TARGET) {
										const gate = await this.runExperimentalPostPassGate(query, effectiveQuery, solution, checklistBlock);
										if (gate && gate.verdict === 'fail') {
											isPass = false;
											passStreak = 0;
											feedbackContent = (gate.feedback || '').toString().trim() || 'Post-pass gate rejected the solution.';
											this.log('[PostPass] Rejected ‚Üí returning to loop.');
										} else {
											this.state.status = 'Success';
											this.state.finalResult = solution;
											this.updateStatusUI('Success', 'var(--log-success)');
											const resEl = document.getElementById(`result-area-${this.uniqueId}`);
											if (resEl) resEl.value = solution;
											this.stopTimer();
											return;
										}
									}
								}

								if (!isPass) {
									if (!this.config.rtTrigger) passStreak = 0;
									else if (isPass === false && passStreak > 0) passStreak = 0;
									failStreak++;
									this.log(`FAIL (${failStreak})`);
									if (failStreak >= MAX_FAIL_STREAK || totalIter >= MAX_ITER_PER_RUN) {
										this.log("Run Failed (Max Streak/Iter). Next Run...");
										break;
									}
									if (exp.workingMemoryV12) {
										const fixed = await this.handleFailureWithWorkingMemoryV12(
											solution,
											feedbackContent,
											verifierResp,
											effectiveQuery,
											runMemory,
											runWorkingMemoryEntries,
											{ methodologyText, commitmentsText }
										);
										solution = fixed.solution || solution;
										runWorkingMemoryEntries = fixed.workingMemory || runWorkingMemoryEntries;
									} else {
										solution = await this.handleFailure(solution, feedbackContent, effectiveQuery, runMemory, { methodologyText, commitmentsText });
									}
								}
								saveToLocalStorage();
							}
						}
						this.state.status = 'Failed';
						this.updateStatusUI('Failed (Max Runs)', 'var(--log-error)');
						this.stopTimer();
					} catch (e) {
						if (e.message === "Stopped" || e.message === "Stopped by User") {
							this.log("Process Paused.");
							this.updateStatusUI("Paused", "orange");
						} else {
							this.log(`FATAL: ${e.message}`);
							this.updateStatusUI("Error", "red");
						}
						this.stopTimer();
					}
				} finally {
					this._activeRun = false;
				}
			}
		}

		// --- QUOTA GUARD Logic ---
		function checkGlobalQuotaFailure() {
			// Disabled strict quota check to allow retry logic to work fully
		}

		// === API TELEMETRY (Stats Modal) ===
		function __getGroupForArchId(archId) {
			if (!archId) return '';
			const def = ARCH_DEFINITIONS.find(d => d && d.id === archId);
			if (def && def.group) return def.group;
			const a = (agents || []).find(x => x?.config?.id === archId);
			return a?.config?.group || '';
		}

		function setupTelemetryGroupOptions() {
			const sel = document.getElementById('stats-telemetry-group');
			if (!sel) return;
			const currentValue = sel.value || 'all';
			sel.innerHTML = '';

			const optAll = document.createElement('option');
			optAll.value = 'all';
			optAll.textContent = 'All Groups';
			sel.appendChild(optAll);

			const seen = new Set();
			(ARCH_DEFINITIONS || []).forEach(d => { if (d?.group) seen.add(d.group); });
			(agents || []).forEach(a => { if (a?.config?.group) seen.add(a.config.group); });
			[...seen].sort().forEach(g => {
				const opt = document.createElement('option');
				opt.value = g;
				opt.textContent = g;
				sel.appendChild(opt);
			});

			if ([...sel.options].some(o => o.value === currentValue)) sel.value = currentValue;
		}

		function updateTelemetryArchOptions() {
			const groupSel = document.getElementById('stats-telemetry-group');
			const archSel = document.getElementById('stats-telemetry-arch');
			if (!archSel) return;
			const groupFilter = groupSel?.value || 'all';
			const currentValue = archSel.value || 'all';
			archSel.innerHTML = '';

			const optAll = document.createElement('option');
			optAll.value = 'all';
			optAll.textContent = 'All Architectures';
			archSel.appendChild(optAll);

			const seen = new Set();
			(agents || []).forEach(a => {
				const id = a?.config?.id;
				if (!id) return;
				const g = a?.config?.group || __getGroupForArchId(id);
				if (groupFilter !== 'all' && g !== groupFilter) return;
				seen.add(id);
			});
			try {
				const entries = __apiTelemetry.getState().entries || [];
				entries.forEach(e => {
					const id = e?.archId;
					if (!id) return;
					const g = __getGroupForArchId(id);
					if (groupFilter !== 'all' && g !== groupFilter) return;
					seen.add(id);
				});
			} catch { }

			[...seen].sort().forEach(id => {
				const opt = document.createElement('option');
				opt.value = id;
				opt.textContent = id;
				archSel.appendChild(opt);
			});

			if ([...archSel.options].some(o => o.value === currentValue)) archSel.value = currentValue;
		}

		function setupTelemetryRangeOptions() {
			const scaleSel = document.getElementById('stats-telemetry-scale');
			const rangeSel = document.getElementById('stats-telemetry-range');
			if (!scaleSel || !rangeSel) return;
			const scale = scaleSel.value || 'minute';
			const current = rangeSel.value;
			const opts = scale === 'minute'
				? [{ v: '30', t: 'Last 30m' }, { v: '60', t: 'Last 60m' }, { v: '120', t: 'Last 120m' }]
				: (scale === 'day'
					? [{ v: '7', t: 'Last 7d' }, { v: '14', t: 'Last 14d' }, { v: '30', t: 'Last 30d' }]
					: [{ v: '12', t: 'Last 12h' }, { v: '24', t: 'Last 24h' }, { v: '48', t: 'Last 48h' }, { v: '96', t: 'Last 96h' }]);
			rangeSel.innerHTML = '';
			for (const o of opts) {
				const opt = document.createElement('option');
				opt.value = o.v;
				opt.textContent = o.t;
				rangeSel.appendChild(opt);
			}
			const defV = (scale === 'minute') ? '60' : (scale === 'day' ? '7' : '48');
			if ([...rangeSel.options].some(o => o.value === current)) rangeSel.value = current;
			else if ([...rangeSel.options].some(o => o.value === defV)) rangeSel.value = defV;
		}

		function __apiTelemetryFmtTime(ms) {
			if (!Number.isFinite(ms)) return '-';
			try { return new Date(ms).toTimeString().split(' ')[0]; } catch { return '-'; }
		}

		function __apiTelemetryFmtSec(ms, width = 6) {
			if (!Number.isFinite(ms)) return ' '.repeat(Math.max(0, width - 1)) + '-';
			const s = `${(ms / 1000).toFixed(1)}s`;
			return s.length >= width ? s.slice(0, width) : s.padStart(width, ' ');
		}

		function __apiTelemetryPad(s, width, right = true) {
			const v = (s ?? '').toString();
			if (v.length === width) return v;
			if (v.length > width) return v.slice(0, Math.max(0, width - 1)) + '‚Ä¶';
			return right ? v.padEnd(width, ' ') : v.padStart(width, ' ');
		}

		function __apiTelemetryCategory(e) {
			if (!e || !e.done) return 'inflight';
			if (e.ok === false) return 'fail';
			if (e.ok === true && e.validationPassed === false) return 'reject';
			if (e.ok === true) return 'success';
			return 'inflight';
		}

		function __apiTelemetryStatus(e) {
			if (!e) return 'ERR';
			if (!e.done) return 'INFLIGHT';
			if (e.ok === true && e.validationPassed === false) return 'REJECT';
			if (e.ok === true) return 'OK';
			if (e.errorType === 'http' && Number.isFinite(e.httpStatus)) return `HTTP ${e.httpStatus}`;
			if (Number.isFinite(e.httpStatus)) return `HTTP ${e.httpStatus}`;
			if (e.errorType) return e.errorType.toUpperCase();
			return 'ERR';
		}

		function __bucketFloor(ts, scale) {
			const d = new Date(ts);
			if (scale === 'minute') d.setSeconds(0, 0);
			else if (scale === 'hour') d.setMinutes(0, 0, 0);
			else d.setHours(0, 0, 0, 0);
			return d.getTime();
		}

		function __bucketAdd(ts, scale, delta) {
			const d = new Date(ts);
			if (scale === 'minute') d.setMinutes(d.getMinutes() + delta);
			else if (scale === 'hour') d.setHours(d.getHours() + delta);
			else d.setDate(d.getDate() + delta);
			return d.getTime();
		}

		function __bucketLabel(ts, scale) {
			const d = new Date(ts);
			const mm = String(d.getMonth() + 1).padStart(2, '0');
			const dd = String(d.getDate()).padStart(2, '0');
			const hh = String(d.getHours()).padStart(2, '0');
			const mi = String(d.getMinutes()).padStart(2, '0');
			if (scale === 'day') return `${d.getFullYear()}-${mm}-${dd}`;
			if (scale === 'hour') return `${mm}-${dd} ${hh}:00`;
			return `${mm}-${dd} ${hh}:${mi}`;
		}

		function drawTelemetryBucketChart(buckets, scale) {
			const canvas = document.getElementById('stats-telemetry-chart');
			if (!canvas) return;
			const ctx = canvas.getContext('2d');
			if (!ctx) return;
			const w = canvas.width || 900;
			const h = canvas.height || 220;
			ctx.clearRect(0, 0, w, h);

			const rootStyle = getComputedStyle(document.documentElement);
			const colSuccess = (rootStyle.getPropertyValue('--log-success') || '#34d399').trim();
			const colFail = (rootStyle.getPropertyValue('--log-error') || '#fb7185').trim();
			const colReject = (rootStyle.getPropertyValue('--red-grp') || '#ffb020').trim();
			const colInflight = (rootStyle.getPropertyValue('--text-3') || '#94a3b8').trim();
			const colGrid = (rootStyle.getPropertyValue('--border-light') || '#2a3558').trim();
			const colText = (rootStyle.getPropertyValue('--text-3') || '#94a3b8').trim();

			const marginL = 34;
			const marginR = 10;
			const marginT = 10;
			const marginB = 26;
			const plotW = w - marginL - marginR;
			const plotH = h - marginT - marginB;
			const maxTotal = Math.max(1, ...buckets.map(b => b.total || 0));
			const bw = plotW / Math.max(1, buckets.length);

			// grid
			ctx.strokeStyle = colGrid;
			ctx.globalAlpha = 0.6;
			ctx.beginPath();
			for (let y = 0; y <= 4; y++) {
				const yy = marginT + (plotH * y) / 4;
				ctx.moveTo(marginL, yy);
				ctx.lineTo(marginL + plotW, yy);
			}
			ctx.stroke();
			ctx.globalAlpha = 1;

			const drawStack = (x, baseY, wBar, segH, color) => {
				if (segH <= 0) return;
				ctx.fillStyle = color;
				ctx.fillRect(x, baseY - segH, wBar, segH);
			};

			for (let i = 0; i < buckets.length; i++) {
				const b = buckets[i];
				const x = Math.round(marginL + i * bw) + 1;
				const wBar = Math.max(1, Math.round(bw - 2));
				const y0 = marginT + plotH;

				const toH = (v) => Math.round((v / maxTotal) * plotH);
				let y = y0;
				// success -> reject -> fail -> inflight (top)
				const hSuccess = toH(b.success);
				drawStack(x, y, wBar, hSuccess, colSuccess); y -= hSuccess;
				const hReject = toH(b.reject);
				drawStack(x, y, wBar, hReject, colReject); y -= hReject;
				const hFail = toH(b.fail);
				drawStack(x, y, wBar, hFail, colFail); y -= hFail;
				const hInflight = toH(b.inflight);
				drawStack(x, y, wBar, hInflight, colInflight);
			}

			// x labels (sparse)
			ctx.fillStyle = colText;
			ctx.font = '10px monospace';
			const step = scale === 'minute' ? 10 : (scale === 'hour' ? 6 : 3);
			for (let i = 0; i < buckets.length; i += step) {
				const label = buckets[i]?.label || '';
				if (!label) continue;
				const x = marginL + i * bw;
				ctx.fillText(label.slice(-5), x + 2, h - 8);
			}
		}

		function updateMainRecentCalls() {
			const outEl = document.getElementById('main-recent-calls');
			if (!outEl) return;

			let st = null;
			try { st = __apiTelemetry.getState(); } catch { }
			const entriesAll = st?.entries || [];
			if (!entriesAll.length) {
				outEl.textContent = 'No calls yet.';
				return;
			}

			const limit = 50;
			const tailN = Math.max(300, limit * 10);
			const tail = entriesAll.slice(Math.max(0, entriesAll.length - tailN));
			const sorted = [...tail].sort((a, b) => {
				const ta = Number.isFinite(a?.sentAt) ? a.sentAt : a?.t0 || 0;
				const tb = Number.isFinite(b?.sentAt) ? b.sentAt : b?.t0 || 0;
				return tb - ta;
			}).slice(0, limit);

			const lines = [];
			lines.push(
				[
					__apiTelemetryPad('Sent', 8),
					__apiTelemetryPad('Resp', 8),
					__apiTelemetryPad('Key', 11),
					__apiTelemetryPad('Arch', 14),
					__apiTelemetryPad('Tok', 6, false),
					__apiTelemetryPad('Wait', 6, false),
					__apiTelemetryPad('Lat', 6, false),
					__apiTelemetryPad('Stat', 10),
					__apiTelemetryPad('Val', 6),
					'Info',
				].join(' ')
			);
			lines.push('-'.repeat(120));

			for (const e of sorted) {
				const sentTs = Number.isFinite(e?.sentAt) ? e.sentAt : e?.t0;
				const stat = __apiTelemetryStatus(e);
				const val = e?.validationPassed === true ? 'pass' : (e?.validationPassed === false ? 'reject' : '-');
				const info = (() => {
					if (!e?.done) return '';
					if (e.ok === false) return [e.errorMessage, e.errorBody].filter(Boolean).join(' | ');
					if (e.ok === true && e.validationPassed === false) return (e.validationReason || '').toString();
					return '';
				})();
				const tok = Number.isFinite(e?.estTokens) ? e.estTokens : '-';

				lines.push([
					__apiTelemetryPad(__apiTelemetryFmtTime(sentTs), 8),
					__apiTelemetryPad(__apiTelemetryFmtTime(e?.respAt), 8),
					__apiTelemetryPad(e?.key || '', 11),
					__apiTelemetryPad(`${e?.archId || '?'}#${e?.instanceId || '?'}`, 14),
					__apiTelemetryPad(tok, 6, false),
					__apiTelemetryFmtSec(e?.rateWaitMs, 6),
					__apiTelemetryFmtSec(e?.latencyMs, 6),
					__apiTelemetryPad(stat, 10),
					__apiTelemetryPad(val, 6),
					(info || '').toString().slice(0, 260),
				].join(' '));
			}

			outEl.textContent = lines.join('\n');
		}

		window.updateMainRecentCalls = updateMainRecentCalls;

		function updateGlobalCallStatsUI() {
			const __set = (id, v) => {
				const el = document.getElementById(id);
				if (el) el.innerText = `${v ?? 0}`;
			};

			let totals = { calls: 0, success: 0, reject: 0, fail: 0 };
			try { totals = __globalCallStats.getTotals(); } catch { }

			const mainEl = document.getElementById('main-global-totals');
			if (mainEl) {
				mainEl.textContent = `calls ${totals.calls} ‚Ä¢ ok ${totals.success} ‚Ä¢ reject ${totals.reject} ‚Ä¢ fail ${totals.fail}`;
			}

			__set('gs-all-calls', totals.calls);
			__set('gs-all-success', totals.success);
			__set('gs-all-reject', totals.reject);
			__set('gs-all-fail', totals.fail);

			let w1h = { calls: 0, success: 0, reject: 0, fail: 0 };
			let w24h = { calls: 0, success: 0, reject: 0, fail: 0 };
			try { w1h = __globalCallStats.getWindow(60 * 60 * 1000); } catch { }
			try { w24h = __globalCallStats.getWindow(24 * 60 * 60 * 1000); } catch { }
			__set('gs-1h-calls', w1h.calls);
			__set('gs-1h-success', w1h.success);
			__set('gs-1h-reject', w1h.reject);
			__set('gs-1h-fail', w1h.fail);
			__set('gs-24h-calls', w24h.calls);
			__set('gs-24h-success', w24h.success);
			__set('gs-24h-reject', w24h.reject);
			__set('gs-24h-fail', w24h.fail);

			const days = Math.max(0, parseInt(document.getElementById('gs-custom-days')?.value || '0', 10) || 0);
			const hours = Math.max(0, parseInt(document.getElementById('gs-custom-hours')?.value || '0', 10) || 0);
			const ms = (days * 24 + hours) * 60 * 60 * 1000;
			let w = { calls: 0, success: 0, reject: 0, fail: 0 };
			try { if (ms > 0) w = __globalCallStats.getWindow(ms); } catch { }
			__set('gs-custom-calls', w.calls);
			__set('gs-custom-success', w.success);
			__set('gs-custom-reject', w.reject);
			__set('gs-custom-fail', w.fail);
		}

		window.updateGlobalCallStatsUI = updateGlobalCallStatsUI;

		function updateApiTelemetryPanel() {
			const modal = document.getElementById('stats-modal');
			if (!modal || modal.style.display !== 'flex') return;
			const panel = document.getElementById('panel-telemetry');
			if (!panel || !panel.classList.contains('active')) return;

			const recentEl = document.getElementById('stats-telemetry-recent');
			const bucketsBody = document.getElementById('stats-telemetry-buckets-body');
			if (!recentEl || !bucketsBody) return;

			const enabledEl = document.getElementById('stats-telemetry-enabled');
			const maxEl = document.getElementById('stats-telemetry-max');
			const groupSel = document.getElementById('stats-telemetry-group');
			const archSel = document.getElementById('stats-telemetry-arch');
			const scaleSel = document.getElementById('stats-telemetry-scale');
			const rangeSel = document.getElementById('stats-telemetry-range');
			const recentLimitSel = document.getElementById('stats-telemetry-recent-limit');

			const st = __apiTelemetry.getState();
			if (enabledEl) enabledEl.checked = !!st.enabled;
			if (maxEl && Number.isFinite(st.maxEntries)) maxEl.value = st.maxEntries;

			const groupFilter = groupSel?.value || 'all';
			const archFilter = archSel?.value || 'all';
			const scale = scaleSel?.value || 'minute';
			const defaultRange = scale === 'minute' ? 60 : (scale === 'day' ? 7 : 48);
			const rangeCount = Math.max(1, parseInt(rangeSel?.value || `${defaultRange}`, 10) || defaultRange);
			const recentLimit = Math.max(1, parseInt(recentLimitSel?.value || '100', 10) || 100);

			const entriesAll = st.entries || [];
			const entries = entriesAll.filter(e => {
				if (!e) return false;
				if (archFilter !== 'all' && e.archId !== archFilter) return false;
				if (groupFilter !== 'all') {
					const g = __getGroupForArchId(e.archId);
					if (g !== groupFilter) return false;
				}
				return true;
			});

			let success = 0, fail = 0, reject = 0, inflight = 0;
			for (const e of entries) {
				const cat = __apiTelemetryCategory(e);
				if (cat === 'success') success++;
				else if (cat === 'fail') fail++;
				else if (cat === 'reject') reject++;
				else inflight++;
			}

			const avgWaitMs = (() => {
				const xs = entries.map(e => e?.rateWaitMs).filter(v => Number.isFinite(v));
				if (!xs.length) return null;
				return xs.reduce((a, b) => a + b, 0) / xs.length;
			})();
			const avgLatMs = (() => {
				const xs = entries.map(e => e?.latencyMs).filter(v => Number.isFinite(v));
				if (!xs.length) return null;
				return xs.reduce((a, b) => a + b, 0) / xs.length;
			})();

			const totalEl = document.getElementById('stats-telemetry-total');
			const successEl = document.getElementById('stats-telemetry-success');
			const failEl = document.getElementById('stats-telemetry-fail');
			const rejectEl = document.getElementById('stats-telemetry-reject');
			const inflightEl = document.getElementById('stats-telemetry-inflight');
			const avgWaitEl = document.getElementById('stats-telemetry-avgwait');
			const avgLatEl = document.getElementById('stats-telemetry-avglat');
			if (totalEl) totalEl.innerText = entries.length;
			if (successEl) successEl.innerText = success;
			if (failEl) failEl.innerText = fail;
			if (rejectEl) rejectEl.innerText = reject;
			if (inflightEl) inflightEl.innerText = inflight;
			if (avgWaitEl) avgWaitEl.innerText = Number.isFinite(avgWaitMs) ? `${(avgWaitMs / 1000).toFixed(1)}s` : '-';
			if (avgLatEl) avgLatEl.innerText = Number.isFinite(avgLatMs) ? `${(avgLatMs / 1000).toFixed(1)}s` : '-';

			// Recent calls (text)
			const sorted = [...entries].sort((a, b) => {
				const ta = Number.isFinite(a?.sentAt) ? a.sentAt : a?.t0 || 0;
				const tb = Number.isFinite(b?.sentAt) ? b.sentAt : b?.t0 || 0;
				return tb - ta;
			});

			const lines = [];
			lines.push(
				[
					__apiTelemetryPad('Sent', 8),
					__apiTelemetryPad('Resp', 8),
					__apiTelemetryPad('Key', 11),
					__apiTelemetryPad('Arch', 14),
					__apiTelemetryPad('Tok', 6, false),
					__apiTelemetryPad('Wait', 6, false),
					__apiTelemetryPad('Lat', 6, false),
					__apiTelemetryPad('Stat', 10),
					__apiTelemetryPad('Val', 6),
					'Info',
				].join(' ')
			);
			lines.push('-'.repeat(120));
			for (let i = 0; i < Math.min(recentLimit, sorted.length); i++) {
				const e = sorted[i];
				const sentTs = Number.isFinite(e?.sentAt) ? e.sentAt : e?.t0;
				const stat = __apiTelemetryStatus(e);
				const val = e?.validationPassed === true ? 'pass' : (e?.validationPassed === false ? 'reject' : '-');
				const info = (() => {
					if (!e?.done) return '';
					if (e.ok === false) return [e.errorMessage, e.errorBody].filter(Boolean).join(' | ');
					if (e.ok === true && e.validationPassed === false) return (e.validationReason || '').toString();
					return '';
				})();
				const tok = Number.isFinite(e?.estTokens) ? e.estTokens : '-';
				const line = [
					__apiTelemetryPad(__apiTelemetryFmtTime(sentTs), 8),
					__apiTelemetryPad(__apiTelemetryFmtTime(e?.respAt), 8),
					__apiTelemetryPad(e?.key || '', 11),
					__apiTelemetryPad(`${e?.archId || '?'}#${e?.instanceId || '?'}`, 14),
					__apiTelemetryPad(tok, 6, false),
					__apiTelemetryFmtSec(e?.rateWaitMs, 6),
					__apiTelemetryFmtSec(e?.latencyMs, 6),
					__apiTelemetryPad(stat, 10),
					__apiTelemetryPad(val, 6),
					(info || '').toString().slice(0, 260),
				].join(' ');
				lines.push(line);
			}
			recentEl.textContent = lines.join('\n');

			// Buckets
			const now = Date.now();
			const end = __bucketFloor(now, scale);
			const start = __bucketAdd(end, scale, -(rangeCount - 1));
			const idx = new Map(); // bucketStart -> bucket
			const buckets = [];
			for (let i = 0; i < rangeCount; i++) {
				const t = __bucketAdd(start, scale, i);
				const b = { ts: t, label: __bucketLabel(t, scale), success: 0, reject: 0, fail: 0, inflight: 0, total: 0 };
				buckets.push(b);
				idx.set(t, b);
			}

			for (const e of entries) {
				const ts = Number.isFinite(e?.sentAt) ? e.sentAt : e?.t0;
				if (!Number.isFinite(ts)) continue;
				const bt = __bucketFloor(ts, scale);
				const b = idx.get(bt);
				if (!b) continue;
				const cat = __apiTelemetryCategory(e);
				b[cat] += 1;
				b.total += 1;
			}

			bucketsBody.innerHTML = '';
			for (const b of buckets) {
				const denom = b.success + b.reject + b.fail;
				const failPct = denom ? `${((b.fail / denom) * 100).toFixed(1)}%` : '-';
				const tr = document.createElement('tr');
				tr.innerHTML = `
	                    <td>${b.label}</td>
	                    <td style="text-align:right;">${b.total}</td>
	                    <td style="text-align:right; color:var(--log-success);">${b.success}</td>
	                    <td style="text-align:right; color:var(--red-grp);">${b.reject}</td>
	                    <td style="text-align:right; color:var(--log-error);">${b.fail}</td>
	                    <td style="text-align:right; color:var(--text-3);">${b.inflight}</td>
	                    <td style="text-align:right;">${failPct}</td>
	                `;
				bucketsBody.appendChild(tr);
			}

			drawTelemetryBucketChart(buckets, scale);
		}

		window.updateApiTelemetryPanel = updateApiTelemetryPanel;

		function updateKeySchedulerPanel() {
			const outEl = document.getElementById('stats-key-sched-output');
			if (!outEl) return;
			try {
				const st = __keySchedulerLog.getState();
				const enabledEl = document.getElementById('stats-key-sched-enabled');
				if (enabledEl) enabledEl.checked = !!st.enabled;
				const maxEl = document.getElementById('stats-key-sched-max');
				if (maxEl && Number.isFinite(st.maxEntries)) maxEl.value = st.maxEntries;

				const limit = parseInt(document.getElementById('stats-key-sched-recent-limit')?.value || '100', 10) || 100;
				const entriesAll = Array.isArray(st.entries) ? st.entries : [];
				const entries = entriesAll.slice(-Math.max(0, limit));
				outEl.textContent = entries.length ? entries.map(e => JSON.stringify(e)).join('\n') : '(no entries)';
			} catch (e) {
				outEl.textContent = 'Error rendering key scheduler log.';
			}
		}

		window.updateKeySchedulerPanel = updateKeySchedulerPanel;

		function downloadKeySchedulerLog(format = 'jsonl') {
			if (format !== 'jsonl') format = 'jsonl';
			const meta = getDownloadMeta();
			const suffix = buildDownloadSuffix(meta);
			const st = __keySchedulerLog.getState();
			const entries = Array.isArray(st.entries) ? st.entries : [];
			const text = entries.map(e => JSON.stringify(e)).join('\n');
			const blob = new Blob([text], { type: 'application/x-ndjson;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `key_scheduler_${suffix}.jsonl`;
			a.click();
		}

		function downloadApiTelemetry(format = 'csv') {
			const meta = getDownloadMeta();
			const suffix = buildDownloadSuffix(meta);
			const st = __apiTelemetry.getState();
			const entriesAll = st.entries || [];

			const modal = document.getElementById('stats-modal');
			const groupFilter = (modal && modal.style.display === 'flex') ? (document.getElementById('stats-telemetry-group')?.value || 'all') : 'all';
			const archFilter = (modal && modal.style.display === 'flex') ? (document.getElementById('stats-telemetry-arch')?.value || 'all') : 'all';

			const entries = entriesAll.filter(e => {
				if (!e) return false;
				if (archFilter !== 'all' && e.archId !== archFilter) return false;
				if (groupFilter !== 'all') {
					const g = __getGroupForArchId(e.archId);
					if (g !== groupFilter) return false;
				}
				return true;
			});

			if (format === 'jsonl') {
				const text = entries.map(e => JSON.stringify({ ...e, group: __getGroupForArchId(e.archId) })).join('\n');
				const blob = new Blob([text], { type: 'application/x-ndjson;charset=utf-8' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `api_telemetry_${groupFilter}_${archFilter}_${suffix}.jsonl`;
				a.click();
				return;
			}

			const esc = (v) => {
				const s = (v ?? '').toString().replace(/\r?\n/g, '\\n');
				if (/[",\n]/.test(s)) return `"${s.replace(/"/g, '""')}"`;
				return s;
			};
			const header = [
				'id', 'seq', 'group',
				'archId', 'archName', 'instanceId', 'uniqueId',
				'apiMode', 'model', 'url', 'key',
				't0Iso', 'sentIso', 'respIso',
				'estTokens', 'rateWaitMs', 'latencyMs', 'totalMs',
				'ok', 'httpStatus', 'errorType', 'errorMessage', 'errorBody',
				'validationPassed', 'validationReason'
			].join(',');

			const lines = [header];
			for (const e of entries) {
				lines.push([
					esc(e.id), esc(e.seq), esc(__getGroupForArchId(e.archId)),
					esc(e.archId), esc(e.archName), esc(e.instanceId), esc(e.uniqueId),
					esc(e.apiMode), esc(e.model), esc(e.url), esc(e.key),
					esc(e.iso0), esc(e.sentAt ? new Date(e.sentAt).toISOString() : ''), esc(e.respAt ? new Date(e.respAt).toISOString() : ''),
					esc(e.estTokens), esc(e.rateWaitMs), esc(e.latencyMs), esc(e.totalMs),
					esc(e.ok), esc(e.httpStatus), esc(e.errorType), esc(e.errorMessage), esc(e.errorBody),
					esc(e.validationPassed), esc(e.validationReason),
				].join(','));
			}

			const blob = new Blob([lines.join('\n')], { type: 'text/csv;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `api_telemetry_${groupFilter}_${archFilter}_${suffix}.csv`;
			a.click();
		}

		// === RAW RESPONSE EXTRACTOR & ANALYSIS PANEL ===
		function extractResponsesFromChunk(chunkText) { return []; }

		function formatAllRawResponses(options = {}) {
			const { group = 'all', archId = 'all', rawOnly = true } = options;
			let fullTextParts = [];
			let totalResponses = 0;
			let finalsCount = 0;

			let targetAgents = agents;
			if (group !== 'all') targetAgents = targetAgents.filter(a => a?.config?.group === group);
			if (archId !== 'all') targetAgents = targetAgents.filter(a => a?.config?.id === archId);

			targetAgents.forEach(agent => {
				const responses = agent.state.logs.filter(l => l.includes("‚Üê API Response Received"));
				const finalResult = agent.state.finalResult;

				if (responses.length === 0 && (!finalResult || rawOnly)) return;

				const labelName = agent.config.name ? `(${agent.config.name})` : '';
				const archName = `${agent.config.id} ${labelName}`.trim();

				let block = `------ ${archName} #${agent.instanceId} ------\n`;
				block += `[Status] ${agent.state.status}\n`;
				block += `[Calls] ${agent.state.metrics.calls}  [Tokens] ${agent.state.metrics.tokens}\n\n`;

				if (agent.state.verifiedClues && agent.state.verifiedClues.length > 0) {
					block += `[Verified Clues - Resolved]\n`;
					agent.state.verifiedClues.forEach((vc, i) => {
						block += `  ${i + 1}. Q: ${vc.clue}\n     A: ${vc.answer}\n`;
					});
					block += `\n`;
				}

				if (!rawOnly && finalResult) {
					block += `[Final Solution]\n${finalResult}\n\n`;
					finalsCount++;
				}

				if (responses.length > 0) {
					block += `[Raw API Responses]\n`;
					responses.forEach((resp, idx) => {
						block += `--- Response ${idx + 1} ---\n${resp}\n\n`;
					});
				}

				fullTextParts.push(block.trimEnd());
				totalResponses += responses.length;
			});

			const text = fullTextParts.join('\n\n\n');
			return {
				text,
				agentCount: targetAgents.length,
				totalResponses,
				finalsCount
			};
		}

		function copyToClipboard(textToCopy, buttonElement, originalButtonText) {
			if (!textToCopy) { alert("Nothing to copy."); return; }
			if (!navigator.clipboard) { alert("Clipboard API not supported."); return; }
			navigator.clipboard.writeText(textToCopy).then(() => {
				if (buttonElement) {
					buttonElement.textContent = 'Copied!';
					setTimeout(() => { buttonElement.textContent = originalButtonText; }, 1500);
				}
			});
		}

		function downloadAllRawResponses() {
			const sel = document.getElementById('analysis-arch-select');
			const groupSel = document.getElementById('analysis-group-select');
			const selectedArchId = sel ? sel.value : 'all';
			const selectedGroup = groupSel ? groupSel.value : 'all';
			const { text } = formatAllRawResponses({ group: selectedGroup, archId: selectedArchId, rawOnly: true });
			if (!text) { alert("No data."); return; }

			const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			const meta = getDownloadMeta();
			const suffix = buildDownloadSuffix(meta);
			a.download = `raw_responses_${sanitizeForFilename(selectedGroup, 30)}_${sanitizeForFilename(selectedArchId, 30)}_${suffix}.txt`;
			a.click();
		}

		function formatAllApiIoLogs(options = {}) {
			const { group = 'all', archId = 'all' } = options;
			const fullTextParts = [];
			let totalBlocks = 0;

			let targetAgents = agents;
			if (group !== 'all') targetAgents = targetAgents.filter(a => a?.config?.group === group);
			if (archId !== 'all') targetAgents = targetAgents.filter(a => a?.config?.id === archId);

			targetAgents.forEach(agent => {
				const logs = Array.isArray(agent?.state?.logs) ? agent.state.logs : [];
				const apiBlocks = logs.filter(l => typeof l === 'string' && (
					l.includes('‚Üí API Request') ||
					l.includes('‚Üê API Response Received') ||
					l.includes('‚Üê API Error')
				));
				if (apiBlocks.length === 0) return;

				const labelName = agent.config?.name ? `(${agent.config.name})` : '';
				const archName = `${agent.config?.id || '?'} ${labelName}`.trim();
				let block = `------ ${archName} #${agent.instanceId} ------\n`;
				block += `[Status] ${agent.state?.status || ''}\n`;
				block += `[Calls] ${agent.state?.metrics?.calls ?? 0}  [Tokens] ${agent.state?.metrics?.tokens ?? 0}\n`;
				block += `\n[API I/O Blocks]\n`;
				block += apiBlocks.join('\n\n');
				fullTextParts.push(block.trimEnd());
				totalBlocks += apiBlocks.length;
			});

			return { text: fullTextParts.join('\n\n\n'), agentCount: targetAgents.length, totalBlocks };
		}

		function downloadAllApiIoLogs() {
			const sel = document.getElementById('analysis-arch-select');
			const groupSel = document.getElementById('analysis-group-select');
			const selectedArchId = sel ? sel.value : 'all';
			const selectedGroup = groupSel ? groupSel.value : 'all';

			// Cheap size estimate to avoid UI freeze
			let approxChars = 0;
			let targetAgents = agents;
			if (selectedGroup !== 'all') targetAgents = targetAgents.filter(a => a?.config?.group === selectedGroup);
			if (selectedArchId !== 'all') targetAgents = targetAgents.filter(a => a?.config?.id === selectedArchId);
			targetAgents.forEach(a => {
				const logs = Array.isArray(a?.state?.logs) ? a.state.logs : [];
				for (const l of logs) {
					if (typeof l !== 'string') continue;
					if (l.includes('‚Üí API Request') || l.includes('‚Üê API Response Received') || l.includes('‚Üê API Error')) {
						approxChars += l.length + 2;
					}
				}
			});
			const approxMb = approxChars / (1024 * 1024);
			if (!confirm(`Download Full API I/O blocks? (May be large: ~${approxMb.toFixed(1)} MB)`)) return;

			const { text } = formatAllApiIoLogs({ group: selectedGroup, archId: selectedArchId });
			if (!text) { alert("No data."); return; }

			const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			const meta = getDownloadMeta();
			const suffix = buildDownloadSuffix(meta);
			a.download = `api_io_${sanitizeForFilename(selectedGroup, 30)}_${sanitizeForFilename(selectedArchId, 30)}_${suffix}.txt`;
			a.click();
		}

		function updateAnalysisGroupOptions() {
			const sel = document.getElementById('analysis-group-select');
			if (!sel) return;
			const currentValue = sel.value || 'all';
			sel.innerHTML = '';
			const optAll = document.createElement('option');
			optAll.value = 'all';
			optAll.textContent = 'All Groups';
			sel.appendChild(optAll);
			const seen = new Set();
			agents.forEach(agent => { if (agent?.config?.group) seen.add(agent.config.group); });
			[...seen].sort().forEach(g => {
				const opt = document.createElement('option');
				opt.value = g;
				opt.textContent = g;
				sel.appendChild(opt);
			});
			if ([...sel.options].some(o => o.value === currentValue)) sel.value = currentValue;
		}

		function updateAnalysisArchOptions() {
			const sel = document.getElementById('analysis-arch-select');
			if (!sel) return;
			const groupSel = document.getElementById('analysis-group-select');
			const groupFilter = groupSel ? (groupSel.value || 'all') : 'all';
			const currentValue = sel.value || 'all';
			sel.innerHTML = '';
			const optAll = document.createElement('option');
			optAll.value = 'all';
			optAll.textContent = 'All Architectures';
			sel.appendChild(optAll);
			const seen = new Set();
			agents.forEach(agent => {
				if (groupFilter !== 'all' && agent?.config?.group !== groupFilter) return;
				const id = agent.config.id;
				if (seen.has(id)) return;
				seen.add(id);
				const opt = document.createElement('option');
				opt.value = id;
				opt.textContent = id;
				sel.appendChild(opt);
			});
			if ([...sel.options].some(o => o.value === currentValue)) sel.value = currentValue;
		}

		function updateAnalysisPanel() {
			const outEl = document.getElementById('log-analysis-output');
			if (!outEl) return;

			const archId = document.getElementById('analysis-arch-select')?.value || 'all';
			const group = document.getElementById('analysis-group-select')?.value || 'all';
			const { text, agentCount, totalResponses, finalsCount } = formatAllRawResponses({ group, archId, rawOnly: true });

			document.getElementById('analysis-agents').innerText = agentCount;
			document.getElementById('analysis-responses').innerText = totalResponses;
			document.getElementById('analysis-finals').innerText = finalsCount;
			outEl.innerText = text || 'No data yet.';
		}

		function setupAnalysisCard(parentId = 'stats-raw-root') {
			const host = document.getElementById(parentId);
			if (!host || document.getElementById('analysis-card')) return;

			const card = document.createElement('div');
			card.className = 'architecture-result';
			card.id = 'analysis-card';
			card.style.minHeight = "auto";

			card.innerHTML = `
	        <div class="status-header" style="color:var(--base); border-color:var(--base)">
	            <span>Raw Output Viewer</span>
	            <span></span>
	        </div>
	        <div class="metrics">
	            <div class="metric-item"><span>Agents:</span><span id="analysis-agents">0</span></div>
	            <div class="metric-item"><span>Responses:</span><span id="analysis-responses">0</span></div>
	            <div class="metric-item"><span>Finals:</span><span id="analysis-finals">0</span></div>
	        </div>
	        <div class="form-group" style="margin-bottom:8px; display:flex; gap:10px;">
	            <div style="flex:1; min-width:160px;">
	                <label class="cs-input__label" style="font-size:11px;">Group Filter</label>
	                <select id="analysis-group-select" class="cs-input" style="font-size:11px;padding:2px 4px;"></select>
	            </div>
	            <div style="flex:1; min-width:160px;">
	                <label class="cs-input__label" style="font-size:11px;">Architecture Filter</label>
	                <select id="analysis-arch-select" class="cs-input" style="font-size:11px;padding:2px 4px;"></select>
	            </div>
	        </div>
	        <div class="button-group">
	            <button id="refreshAnalysisBtn" class="cs-btn">Refresh</button>
	            <button id="copyAllResponsesBtn" class="cs-btn">Copy Raw</button>
	            <button id="downloadAllResponsesBtn" class="cs-btn">Download Raw</button>
	            <button id="downloadAllApiIoBtn" class="cs-btn">Download Full API I/O</button>
	        </div>
	        <div class="log-mini" id="log-analysis-output" style="max-height:220px; white-space:pre-wrap;">No data.</div>
	    `;

			host.appendChild(card);
			document.getElementById('refreshAnalysisBtn').addEventListener('click', updateAnalysisPanel);
			document.getElementById('copyAllResponsesBtn').addEventListener('click', (e) => copyToClipboard(document.getElementById('log-analysis-output').innerText, e.currentTarget, 'Copy Raw'));
			document.getElementById('downloadAllResponsesBtn').addEventListener('click', downloadAllRawResponses);
			document.getElementById('downloadAllApiIoBtn').addEventListener('click', downloadAllApiIoLogs);
			document.getElementById('analysis-group-select').addEventListener('change', () => { updateAnalysisArchOptions(); updateAnalysisPanel(); });
			document.getElementById('analysis-arch-select').addEventListener('change', updateAnalysisPanel);

			updateAnalysisGroupOptions();
			updateAnalysisArchOptions();
			updateAnalysisPanel();
		}

			// --- APP LOGIC ---
			function __hideApiSettingsUiForJobWindow() {
				if (!__isJobWindow) return;
				const hideGroupById = (id) => {
					try {
						const el = document.getElementById(id);
						if (!el) return;
					const group = el.closest ? el.closest('.form-group') : null;
					if (group) group.style.display = 'none';
					else el.style.display = 'none';
					} catch { }
				};

				const jobId = (__jobSessionId || '').toString();
				const isBlankBenchmarkJob = jobId.startsWith('JBLANK_');

				// In attached job windows, API settings are controlled in the main window.
				// Exception: blank benchmark jobs allow local override (collapsed by default; edits auto-detach).
				if (__useMainApiProxy() && !isBlankBenchmarkJob) {
					try {
						const det = document.getElementById('archApiSettingsDetails');
						if (det) det.style.display = 'none';
					} catch { }
					hideGroupById('mockModeChk');
				}

				if (isBlankBenchmarkJob) {
					try {
						const det = document.getElementById('archApiSettingsDetails');
						if (det) det.open = false;
					} catch { }
				}

				hideGroupById('runAllBtn');
				hideGroupById('stopAllBtn');
				try { document.getElementById('extraProblems').style.display = 'none'; } catch { }
				try { document.getElementById('addProblemBtn').style.display = 'none'; } catch { }
				try { document.getElementById('clearExtraProblemsBtn').style.display = 'none'; } catch { }
			}

			function __setupBlankBenchmarkJobApiDetachOnEdit() {
				if (!__isJobWindow) return;
				const jobId = (__jobSessionId || '').toString();
				if (!jobId.startsWith('JBLANK_')) return;
				if (window.__JOB_BLANK_API_DETACH_BOUND) return;
				window.__JOB_BLANK_API_DETACH_BOUND = true;

				const detach = () => {
					if (window.__JOB_DETACHED || window.__JOB_LOCAL_API) return;
					try { window.__JOB_LOCAL_API = true; } catch { }
					try {
						const det = document.getElementById('archApiSettingsDetails');
						const sum = det?.querySelector?.('summary');
						if (sum) {
							if (!sum.dataset.baseText) sum.dataset.baseText = (sum.textContent || '').toString();
							const base = (sum.dataset.baseText || '').toString().trim() || 'Architecture API Settings';
							sum.textContent = `${base} (local API)`;
						}
					} catch { }
					try { saveToLocalStorage(); } catch { }
				};

				const bind = (id, evt) => {
					try {
						const el = document.getElementById(id);
						if (!el) return;
						el.addEventListener(evt, detach);
					} catch { }
				};

				// Any local edit implies local ownership ‚Üí detach from main proxy.
				['apiKeyList', 'apiUrl', 'apiProxyUrl', 'modelName', 'rpmLimit', 'tpmLimit', 'maxInflightPerKey'].forEach((id) => {
					bind(id, 'input');
					bind(id, 'change');
				});
				['bypassSystemRole', 'enableRateLimit', 'expDiverseRt2Personas', 'mockModeChk'].forEach((id) => bind(id, 'change'));
			}

		let __uiInitialized = false;
		function initUI() {
			if (__uiInitialized) return;
			__uiInitialized = true;
			document.getElementById('runBtn').addEventListener('click', async () => {
				try {
					try {
						__benchmarkUpsertDatasetFromUiProblems({
							allowWhenNoDataset: true,
							syncOrigins: ['ui-sync'],
						});
					} catch { }
					const ds = __benchmarkStudio.dataset;
						const hasDataset = !!(ds && Array.isArray(ds.problems) && ds.problems.length);
						// If benchmark exists, prefer benchmark execution paths.
						// Pending spawned agents run incrementally; otherwise use full run-suite.
						const shouldRunSuite = hasDataset;
						if (shouldRunSuite) {
							const pendingSpawnTargets = __benchmarkResolvePendingSpawnRunTargets();
							if (pendingSpawnTargets.length > 0) {
								await __benchmarkRunIncrementalSpawned({ targetUniqueIds: pendingSpawnTargets });
								return;
							}
							await __benchmarkRunSuite();
							return;
						}
					await startComparison();
				} catch (e) {
					const msg = __benchmarkString(e?.message || e) || 'Unknown run error';
					try { __benchmarkLog('ERROR', 'RunBtn', `Run failed: ${msg}`); } catch { }
					alert(`Run failed: ${msg}`);
				}
			});
			document.getElementById('spawnMoreBtn')?.addEventListener('click', () => {
				try { __spawnAgentsToMatchCurrentSelection(); }
				catch (e) { alert(`Spawn failed: ${e?.message || e}`); }
			});
			document.getElementById('runAllBtn')?.addEventListener('click', __runAllWindows);
			document.getElementById('stopBtn').addEventListener('click', stopComparison);
				document.getElementById('stopAllBtn')?.addEventListener('click', __stopAllWindows);
				document.getElementById('jobRunNowBtn').addEventListener('click', () => __launchJobWindowFromUi({ autoStart: true }));
				document.getElementById('jobQueueBtn').addEventListener('click', () => __launchJobWindowFromUi({ autoStart: false }));
				document.getElementById('jobBlankBenchmarkBtn')?.addEventListener('click', async () => {
					try {
						const ok = await __openBlankBenchmarkJobWindow();
						if (!ok) alert('Failed to open blank job window (popup blocked or snapshot store failed).');
					} catch (e) {
						alert(`Open blank job failed: ${e?.message || e}`);
					}
				});
				document.getElementById('jobQueueToggleBtn').addEventListener('click', () => {
					alert('Queue mode is disabled. Each job runs in its own window.');
				});
			try {
				document.getElementById('addProblemBtn')?.addEventListener('click', () => __addExtraProblemSlot(''));
				document.getElementById('clearExtraProblemsBtn')?.addEventListener('click', () => __clearExtraProblemsUi());
				document.getElementById('extraProblems')?.addEventListener('click', (e) => {
					const btn = e?.target?.closest?.('button[data-action="remove-problem"]');
					if (!btn) return;
					const slot = btn.closest('.problem-slot');
					if (slot) slot.remove();
					__renumberExtraProblemsUi();
				});
			} catch { }
				document.getElementById('exportBtn').addEventListener('click', exportState);
				document.getElementById('importBtn').addEventListener('click', () => document.getElementById('fileInput').click());
				document.getElementById('importAsJobBtn')?.addEventListener('click', () => document.getElementById('fileInputAsJob')?.click?.());
				document.getElementById('fileInput').addEventListener('change', importState);
				document.getElementById('fileInputAsJob')?.addEventListener('change', async (e) => {
					try {
						const file = e?.target?.files?.[0];
						if (!file) return;
						const text = await file.text();
						const obj = __benchmarkTryParseJson(text);
						if (!obj || typeof obj !== 'object') throw new Error('Invalid JSON/XML payload.');
						const title = `Imported as job: ${(file?.name || 'State').toString().slice(0, 120)}`;
						const ok = await __openAnySnapshotAsJobWindow(obj, { title });
						if (!ok) alert('Failed to open job window from state.');
					} catch (err) {
						alert(`Open as job failed: ${err?.message || err}`);
					} finally {
						try { e.target.value = ''; } catch { }
					}
				});
				document.getElementById('keepSelectedBtn')?.addEventListener('click', deleteUnselectedArchitectureRuns);
				document.getElementById('clearBtn').addEventListener('click', () => { clearAllFromUi(); });
				document.getElementById('statsBtn').addEventListener('click', openStatsModal);
				document.getElementById('logsBtn').addEventListener('click', openLogsModal);
				document.getElementById('benchmarkNewBtn')?.addEventListener('click', () => {
					try {
						const existing = __benchmarkStudio.dataset;
						const existingName = __benchmarkTrim(existing?.name || '');
						const existingCount = Number(existing?.problems?.length || 0);
						if (existing && (existingName || existingCount)) {
							const label = existingName ? `${existingName} (${existingCount} problems)` : `${existingCount} problems`;
							if (!confirm(`Create a new manual benchmark and replace the current one?\n\nCurrent: ${label}`)) return;
						}
						const date = new Date();
						const iso = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
						const ds = __benchmarkPromptNewManualDataset({ defaultName: `Manual Benchmark ${iso}` });
						if (!ds) return;
						__benchmarkSetDataset(ds, 'Created manual benchmark.');
						__benchmarkStudio.lastRunRows = [];
						__benchmarkStudio.runCheckpoint = null;
						__benchmarkSetTaskCheckpoint('parse', null);
						__benchmarkSetTaskCheckpoint('grade', null);
						__benchmarkRenderGradeOutput([], document.getElementById('benchmarkGradeMode')?.value || 'answer_only');
						__benchmarkLog('SUCCESS', 'BenchmarkManual', `Created manual benchmark: ${ds.name || 'Benchmark'} (0 problems)`);
						saveToLocalStorage();
					} catch (e) {
						alert(`New manual benchmark failed: ${e?.message || e}`);
					}
				});
				document.getElementById('benchmarkConvertBtn')?.addEventListener('click', async () => {
					try { await __benchmarkConvertSourceToDataset(); }
					catch (e) { alert(`Benchmark convert failed: ${e?.message || e}`); }
				});
			document.getElementById('benchmarkConvertStopBtn')?.addEventListener('click', () => {
				try {
					__benchmarkSetTaskStopRequested('parse', true);
					__benchmarkSetProgress('Stopping benchmark conversion...');
					__benchmarkLog('WARN', 'Convert', 'Stop requested by user.');
					saveToLocalStorage();
				} catch (e) {
					alert(`Stop convert failed: ${e?.message || e}`);
				}
			});
			document.getElementById('benchmarkConvertResumeBtn')?.addEventListener('click', async () => {
				try {
					const cp = __benchmarkGetTaskCheckpoint('parse');
					if (!cp || __benchmarkTrim(cp?.status || '') !== 'paused') {
						alert('No paused conversion checkpoint to resume.');
						return;
					}
					await __benchmarkConvertSourceToDataset({ resume: true });
				} catch (e) {
					alert(`Resume convert failed: ${e?.message || e}`);
				}
			});
			document.getElementById('benchmarkLoadJsonBtn')?.addEventListener('click', () => {
				try { document.getElementById('benchmarkJsonInput')?.click(); } catch { }
			});
				document.getElementById('benchmarkJsonInput')?.addEventListener('change', async (e) => {
					try {
						const file = e?.target?.files?.[0];
						if (!file) return;
						const text = await file.text();
						__benchmarkLoadDatasetFromJsonText(text, file.name || 'Benchmark JSON');
						// Job windows hide the multi-problem query UI; don't auto-apply to avoid confusion.
						try {
							const ds = __benchmarkStudio.dataset;
							const n = Number(ds?.problems?.length || 0);
							if (!__isJobWindow) {
								__benchmarkApplyProblemsToUi();
								__benchmarkSetProgress(`Loaded + applied benchmark JSON: ${file.name || 'Benchmark JSON'} (${n} problems)`);
							} else {
								__benchmarkSetProgress(`Loaded benchmark JSON: ${file.name || 'Benchmark JSON'} (${n} problems)`);
							}
						} catch {
							__benchmarkSetProgress(`Loaded benchmark JSON: ${file.name || 'Benchmark JSON'}`);
						}
						saveToLocalStorage();
					} catch (err) {
						__benchmarkSetProgress('Benchmark JSON load failed');
						__benchmarkLog('ERROR', 'BenchmarkJSON', `Load failed: ${err?.message || err}`);
					alert(`Benchmark JSON load failed: ${err?.message || err}`);
				} finally {
					try { e.target.value = ''; } catch { }
				}
			});
				document.getElementById('benchmarkDownloadBtn')?.addEventListener('click', () => {
					const ds = __benchmarkStudio.dataset;
					if (!ds || typeof ds !== 'object') { alert('No benchmark loaded.'); return; }
					const safe = (ds.name || 'mini-artichokes-benchmark')
						.toString()
						.trim()
						.toLowerCase()
					.replace(/[^a-z0-9]+/g, '-')
					.replace(/^-+|-+$/g, '') || 'mini-artichokes-benchmark';
				__benchmarkDownloadJson(`${safe}.json`, ds);
				__benchmarkLog('INFO', 'BenchmarkJSON', `Downloaded benchmark JSON: ${safe}.json`);
			});
				document.getElementById('benchmarkApplyBtn')?.addEventListener('click', () => {
					try { __benchmarkApplyProblemsToUi(); saveToLocalStorage(); }
					catch (e) { alert(`Apply benchmark failed: ${e?.message || e}`); }
				});
				document.getElementById('benchmarkRunFilteredBtn')?.addEventListener('click', async () => {
					try { await __benchmarkRunFilteredFromUi(); }
					catch (e) { alert(`Filtered benchmark run failed: ${e?.message || e}`); }
				});
				try {
					const applyBtn = document.getElementById('benchmarkApplyBtn');
					if (applyBtn) applyBtn.style.display = 'none';
				} catch { }
			document.getElementById('benchmarkGradeBtn')?.addEventListener('click', async () => {
				try {
					const cp = __benchmarkResolveResumableGradeCheckpoint();
					if (cp) await __benchmarkGradeCurrentResults({ resume: true });
					else await __benchmarkGradeCurrentResults();
				}
				catch (e) { alert(`Benchmark grade failed: ${e?.message || e}`); }
			});
			document.getElementById('benchmarkRegradeBtn')?.addEventListener('click', async () => {
				try {
					if (!confirm('Regrade all rows? This clears previous grading results and may cost API calls.')) return;
					try { __benchmarkSetTaskCheckpoint('grade', null); } catch { }
					await __benchmarkGradeCurrentResults({ forceRegrade: true });
				}
				catch (e) { alert(`Benchmark regrade failed: ${e?.message || e}`); }
			});
			document.getElementById('benchmarkGradeStopBtn')?.addEventListener('click', () => {
				try {
					__benchmarkSetTaskStopRequested('grade', true);
					__benchmarkSetProgress('Stopping grading...');
					__benchmarkLog('WARN', 'Grade', 'Stop requested by user.');
					saveToLocalStorage();
				} catch (e) {
					alert(`Stop grade failed: ${e?.message || e}`);
				}
			});
			document.getElementById('benchmarkGradeResumeBtn')?.addEventListener('click', async () => {
				try {
					const cp = __benchmarkResolveResumableGradeCheckpoint();
					if (!cp) {
						alert('No paused grading checkpoint to resume.');
						return;
					}
					await __benchmarkGradeCurrentResults({ resume: true });
				} catch (e) {
					alert(`Resume grade failed: ${e?.message || e}`);
				}
			});
				document.getElementById('benchmarkGradeCopyBtn')?.addEventListener('click', () => {
					try { __benchmarkCopyGradeReport(); }
					catch (e) { alert(`Copy grade report failed: ${e?.message || e}`); }
				});
				document.getElementById('benchmarkResultCopyBtn')?.addEventListener('click', () => {
					try { __benchmarkCopyResultsReport(); }
					catch (e) { alert(`Copy benchmark results failed: ${e?.message || e}`); }
				});
				document.getElementById('benchmarkLogClearBtn')?.addEventListener('click', () => {
					try { __benchmarkClearLog(); } catch { }
				});
			document.getElementById('benchmarkIoCallSelect')?.addEventListener('change', () => {
				try {
					const artifacts = __benchmarkEnsureArtifacts();
					artifacts.selectedApiCallId = __benchmarkTrim(document.getElementById('benchmarkIoCallSelect')?.value || '');
					__benchmarkTouchArtifacts();
					__benchmarkRenderRawIoViewer(false);
					saveToLocalStorage();
				} catch { }
			});
			document.getElementById('benchmarkIoRefreshBtn')?.addEventListener('click', () => {
				try { __benchmarkRenderRawIoViewer(true); } catch { }
			});
			document.getElementById('benchmarkIoClearBtn')?.addEventListener('click', () => {
				try { __benchmarkClearRawIoArtifacts(); }
				catch (e) { alert(`Raw I/O clear failed: ${e?.message || e}`); }
			});
			document.getElementById('benchmarkArtifactsDownloadBtn')?.addEventListener('click', () => {
				try { __benchmarkDownloadArtifactsJson(); } catch (e) { alert(`Artifact download failed: ${e?.message || e}`); }
			});
				document.getElementById('benchmarkGradeMode')?.addEventListener('change', () => {
					try {
						const mode = document.getElementById('benchmarkGradeMode')?.value || 'answer_only';
						__benchmarkStudio.lastGradeMode = mode;
					if (Array.isArray(__benchmarkStudio.lastRunRows) && __benchmarkStudio.lastRunRows.length) {
						__benchmarkRenderGradeOutput(__benchmarkStudio.lastRunRows, mode);
					}
						saveToLocalStorage();
					} catch { }
				});
				const __benchmarkUiAutoSaveInput = () => {
					try {
						clearTimeout(__benchmarkStudio.__uiAutoSaveTimer || 0);
						__benchmarkStudio.__uiAutoSaveTimer = setTimeout(() => {
							try { saveToLocalStorage(); } catch { }
						}, 320);
					} catch {
						try { saveToLocalStorage(); } catch { }
					}
				};
				[
					'benchmarkSourceText',
					'benchmarkConvertDelimiter',
					'benchmarkAnswerKeyText',
					'benchmarkParseApiKeyList',
					'benchmarkParseApiUrl',
					'benchmarkParseApiProxyUrl',
					'benchmarkParseModelName',
					'benchmarkParseSplitTokens',
					'benchmarkParseMergeTokens',
					'benchmarkParseRpmLimit',
					'benchmarkParseTpmLimit',
					'benchmarkParseMaxInflightPerKey',
					'benchmarkGradeApiKeyList',
					'benchmarkGradeApiUrl',
					'benchmarkGradeApiProxyUrl',
					'benchmarkGradeModelName',
					'benchmarkGradeSplitTokens',
					'benchmarkGradeMergeTokens',
					'benchmarkGradeRpmLimit',
					'benchmarkGradeTpmLimit',
					'benchmarkGradeMaxInflightPerKey',
				].forEach((id) => {
					try { document.getElementById(id)?.addEventListener('input', __benchmarkUiAutoSaveInput); } catch { }
				});
				document.getElementById('benchmarkAutoGrade')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkSourceText')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkConvertDelimiter')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkAnswerKeyText')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkRunFilterEnabled')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkProblemFilter')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkParseApiKeyList')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseApiUrl')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseApiProxyUrl')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseModelName')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseBypassSystemRole')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseSplitTokens')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseMergeTokens')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseRpmLimit')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseTpmLimit')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkParseMaxInflightPerKey')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeApiKeyList')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeApiUrl')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeApiProxyUrl')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeModelName')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeBypassSystemRole')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeSplitTokens')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeMergeTokens')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeRpmLimit')?.addEventListener('change', saveToLocalStorage);
			document.getElementById('benchmarkGradeTpmLimit')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkGradeMaxInflightPerKey')?.addEventListener('change', saveToLocalStorage);
				document.getElementById('benchmarkProblemAddBtn')?.addEventListener('click', () => {
					try {
						let ds = __benchmarkStudio.dataset;
						if (!ds || typeof ds !== 'object') {
							const date = new Date();
							const iso = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
							ds = __benchmarkPromptNewManualDataset({ defaultName: `Manual Benchmark ${iso}` });
							if (!ds) return;
							__benchmarkSetDataset(ds, 'Created manual benchmark.');
							__benchmarkStudio.lastRunRows = [];
							__benchmarkRenderGradeOutput([], document.getElementById('benchmarkGradeMode')?.value || 'answer_only');
						}

						if (!Array.isArray(ds.problems)) ds.problems = [];
						const taken = new Set(
							ds.problems.map((p, idx) => __benchmarkTrim(p?.qid || `Q${idx + 1}`) || `Q${idx + 1}`)
						);
						const idx = ds.problems.length;
						const suggested = `Q${idx + 1}`;
						const qid = __benchmarkMakeUniqueQid(suggested, taken);
						ds.problems.push(__benchmarkBuildBlankProblem(qid, idx));
						ds.allow_empty_problems = true;
						if (!__benchmarkTrim(ds.origin || '')) ds.origin = 'manual';
						try { ds.updated_at = Date.now(); } catch { }
						__benchmarkStudio.appliedToUi = false;
						__benchmarkStudio.runCheckpoint = null;
						__benchmarkUpdateDatasetSummary(ds, '', { announce: false });
						__benchmarkRenderProblemEditor();
						saveToLocalStorage();
					} catch (e) {
						alert(`Add problem failed: ${e?.message || e}`);
					}
				});
				document.getElementById('benchmarkProblemRefreshBtn')?.addEventListener('click', () => {
					try { __benchmarkRenderProblemEditor(); } catch { }
				});
				document.getElementById('benchmarkProblemFilter')?.addEventListener('keydown', async (e) => {
					if ((e?.key || '') !== 'Enter') return;
					if (e?.ctrlKey || e?.metaKey) {
						try { e.preventDefault(); } catch { }
						try { await __benchmarkRunFilteredFromUi(); } catch { }
						return;
					}
					try { __benchmarkRenderProblemEditor(); } catch { }
				});
			document.getElementById('benchmarkProblemFilter')?.addEventListener('input', () => {
				try {
					clearTimeout(__benchmarkStudio.__problemFilterTimer || 0);
					__benchmarkStudio.__problemFilterTimer = setTimeout(() => {
						try { __benchmarkRenderProblemEditor(); } catch { }
					}, 120);
				} catch { }
			});
			document.getElementById('benchmarkProblemCollapseAllBtn')?.addEventListener('click', () => {
				try {
					const box = document.getElementById('benchmarkProblemEditor');
					if (!box) return;
					box.querySelectorAll('details.benchmark-problem-card').forEach(d => { d.open = false; });
				} catch { }
			});
			document.getElementById('benchmarkProblemExpandAllBtn')?.addEventListener('click', () => {
				try {
					const box = document.getElementById('benchmarkProblemEditor');
					if (!box) return;
					box.querySelectorAll('details.benchmark-problem-card').forEach(d => { d.open = true; });
				} catch { }
			});
			try { __benchmarkInitTaskApiDefaultsFromArchitecture(); } catch { }
			try { __benchmarkEnsureArtifacts(); } catch { }
			try { __benchmarkRenderLog(); } catch { }
			try { __benchmarkRenderRawIoViewer(true); } catch { }
			try { __benchmarkRenderApiCounters(); } catch { }
			try { __benchmarkSyncTaskButtons(); } catch { }
			try { __benchmarkRenderProblemEditor(); } catch { }

			initDB().then(() => {
				if (__isJobLaunchWindow) return;
				if (dbInstance) {
						const tx = dbInstance.transaction(STORE_NAME, 'readonly');
						const req = tx.objectStore(STORE_NAME).get(__dbSnapshotKey);
						req.onsuccess = (e) => {
							const snap = e?.target?.result;
							if (!snap) {
								try { __syncProxyApiInputsFromMain({ force: false, includeKeys: false }); } catch { }
								return;
							}

						// Job windows: only restore matching session snapshots (avoid cross-session bleed).
						if (__isJobWindow) {
							const sess = (snap && typeof snap === 'object') ? (snap.session || {}) : {};
							const snapKey = (sess.snapshotKey || sess.dbSnapshotKey || snap.snapshotKey || snap.dbSnapshotKey || '').toString();
							const snapSessionId = (sess.jobSessionId || sess.id || snap.jobSessionId || snap.jobSession || '').toString();
							const keyOk = !snapKey || (snapKey === (__dbSnapshotKey || '').toString());
							const idOk = !snapSessionId || (snapSessionId === (__jobSessionId || '').toString());
							if (!keyOk || !idOk) return;
						}

							const label = __isJobWindow
								? `Job session: ${(__jobSessionId || '').toString().slice(0, 80)}`
								: 'Main session';
							const autoRestore = ((__urlParams.get('autoRestore') || '').toString() === '1');
								try {
									if (autoRestore) {
										restoreFromObject(snap, { overwriteConfig: true, confirmOverwriteConfig: false, silent: true });
									} else if (confirm(`Previous session found in Database (${label}). Restore?`)) {
										restoreFromObject(snap);
									}
								} catch (e) {
									console.error('Auto restore failed:', e);
									alert(`Restore failed: ${e?.message || e}`);
								}
								try { __syncProxyApiInputsFromMain({ force: false, includeKeys: false }); } catch { }
							};
						}
					});

			setupKeyMonitorCard();
			__startAgentLiveLoop();
			__startGlobalCallStatsLoop();
			setupStatsModal();
			setupLogsModal();
			__jobManager.onInit();
				try {
						if (__isJobWindow) {
							const jp = document.getElementById('jobsPanel');
							if (jp) jp.style.display = 'none';
							__hideApiSettingsUiForJobWindow();
							__setupBlankBenchmarkJobApiDetachOnEdit();
							__syncProxyApiInputsFromMain({ force: false, includeKeys: false });
						}
					} catch { }
			try { __consumeJobLaunchPayloadIfAny(); } catch { }
			try { __registerJobWindowSelf('running'); } catch { }
		}

			async function startComparison(options = {}) {
				const benchmarkMode = !!(options && options.benchmarkMode);
				const skipPausedJobs = !!(options && options.skipPausedJobs) || benchmarkMode;
				const disableExtraProblemWindows = !!(options && options.disableExtraProblemWindows) || benchmarkMode;
				const selectionOverride = Array.isArray(options?.selectionOverride) ? options.selectionOverride : null;
				const runOnlyUniqueIds = (() => {
					if (options?.runOnlyUniqueIds instanceof Set) {
						return new Set(
							Array.from(options.runOnlyUniqueIds.values())
								.map((id) => __benchmarkTrim(id || ''))
								.filter(Boolean)
						);
					}
					if (Array.isArray(options?.runOnlyUniqueIds)) {
						return new Set(
							options.runOnlyUniqueIds
								.map((id) => __benchmarkTrim(id || ''))
								.filter(Boolean)
						);
					}
					return null;
				})();
				const query = (document.getElementById('userQuery')?.value || '').toString();
			const resArea = document.getElementById('resultsArea');
			const runBtn = document.getElementById('runBtn');
			const stopBtn = document.getElementById('stopBtn');

			const useProxy = __useMainApiProxy() && !!__apiProxyClient.request;
			const mockMode = !!document.getElementById('mockModeChk')?.checked;
			const providedKeys = getApiKeyListFromInput();
			apiKeyManager.setKeys(providedKeys);
			try { __apiKeyLive.syncFromInput(); } catch { }
			if (!mockMode && !useProxy && !providedKeys.length) {
				alert("Enter at least one API key (one per line).");
				return;
			}

			if (runBtn) runBtn.disabled = true;
			if (stopBtn) stopBtn.disabled = false;
			isRunning = true;
			try { __keepAlive.sync(true); } catch { }
			saveToLocalStorage();

				const startedJobAgentIds = new Set();
				const jobPromises = [];
				if (!skipPausedJobs) {
					try {
						const st = __jobManager?.getState?.();
						const pausedJobs = Array.isArray(st?.jobs) ? st.jobs.filter(j => j?.status === 'paused') : [];
						for (const job of pausedJobs) {
							try {
								__jobManager.startJob(job);
								if (job?.promise) jobPromises.push(job.promise);
								(job?.agents || []).forEach(a => { if (a?.uniqueId) startedJobAgentIds.add(a.uniqueId); });
							} catch { }
						}
					} catch { }
				}

			if (agents.length === 0 && jobPromises.length === 0) {
				const hasSelectionOverride = Array.isArray(selectionOverride) && selectionOverride.length > 0;
				const allowEmptyQueryBootstrap = benchmarkMode || hasSelectionOverride;
				if (!allowEmptyQueryBootstrap && !query.trim()) {
					alert("Enter a Problem Statement.");
					if (runBtn) runBtn.disabled = false;
					if (stopBtn) stopBtn.disabled = true;
					isRunning = false;
					return;
				}

				try { if (!__isJobWindow) __shared.mainPinnedQuery = query; } catch { }

					// Multi-problem: launch extra problems in job windows (Problem #2+)
						try {
							if (!disableExtraProblemWindows && !__isJobWindow) {
								const allQs = __getProblemQueriesFromUi({ includeEmpty: false });
								const extras = (allQs || []).slice(1).map(s => (s ?? '').toString()).filter(s => s.trim());
								if (extras.length) {
									const sel = __collectSelectionForJobLaunch();
									if (sel && sel.length) {
										let resumed = 0;
										let launched = 0;
										let blocked = 0;
										const reg = (() => { try { return __ensureJobWindowsRegistry(); } catch { return null; } })();
										const regItems = (() => {
											try { return Object.values(reg || {}).filter(Boolean); } catch { return []; }
										})();
										const now = Date.now();
										const resumeMsg = { type: 'BRANCHING_V12_JOB_CONTROL', cmd: 'resume' };

										for (const q2 of extras) {
											const title = __jobFirstLine(q2).slice(0, 140);
											let didResume = false;
											if (title && regItems.length) {
												const matches = regItems
													.filter((m) => (m?.title || '').toString() === title)
													.filter((m) => (m?.status || '').toString() !== 'closed')
													.filter((m) => {
														const last = Number.isFinite(m?.lastSeenAt) ? m.lastSeenAt : null;
														return last && (now - last < 60 * 1000);
													})
													.sort((a, b) => ((b?.lastSeenAt || b?.createdAt || 0) - (a?.lastSeenAt || a?.createdAt || 0)));

												for (const meta of matches) {
													const winName = (meta?.windowName || '').toString();
													if (!winName) continue;
													try {
														const w = window.open('', winName);
														if (w && !w.closed) {
															w.postMessage(resumeMsg, '*');
															didResume = true;
															break;
														}
													} catch { }
												}
											}
											if (didResume) {
												resumed += 1;
												continue;
											}

											const jobId = __launchJobWindow({ query: q2, selection: sel, autoStart: true, suppressPopupAlert: true });
											if (jobId) launched += 1;
											else blocked += 1;
										}

										// Only alert if *everything* failed to open/resume.
										if (blocked > 0 && launched === 0 && resumed === 0) {
											alert('Popup blocked. Allow popups for this site to open job windows.');
										}
									}
							}
						}
					} catch { }

				if (resArea) resArea.innerHTML = '';
				setupKeyMonitorCard();

					if (selectionOverride && selectionOverride.length) {
						for (const sel of selectionOverride) {
							const id = __benchmarkTrim(sel?.archId || '');
							if (!id) continue;
							const def = ARCH_DEFINITIONS.find(d => d && d.id === id);
							if (!def) continue;
							const rawCount = parseInt(sel?.count || '1', 10);
							const count = Number.isFinite(rawCount) ? Math.min(999, Math.max(1, rawCount)) : 1;
							for (let i = 0; i < count; i++) createAgentUI(def, i + 1);
						}
					} else {
						let selectedChecks = Array.from(document.querySelectorAll('.arch-row input[type="checkbox"]'))
							.filter(chk => !!chk?.checked);
						if (!selectedChecks.length && __benchmarkStudio?.dataset?.problems?.length) {
							// Benchmark fallback: if selection is empty, auto-select core architectures.
							const fallbackIds = (__PRIMARY_ARCH_IDS || []).filter((id) => ARCH_DEFINITIONS.some((d) => d?.id === id));
							for (const id of fallbackIds) {
								try {
									const chk = document.getElementById(`chk-${id}`);
									if (chk) chk.checked = true;
								} catch { }
							}
							selectedChecks = Array.from(document.querySelectorAll('.arch-row input[type="checkbox"]'))
								.filter(chk => !!chk?.checked);
							try {
								if (fallbackIds.length) __benchmarkLog('WARN', 'Run', `No architecture selected. Auto-selected: ${fallbackIds.join(', ')}`);
							} catch { }
						}

						selectedChecks.forEach(chk => {
							const id = chk.id.replace('chk-', '');
							const count = __getEffectiveArchCount(id);
							const def = ARCH_DEFINITIONS.find(d => d && d.id === id);
							if (!def) return;
							for (let i = 0; i < count; i++) createAgentUI(def, i + 1);
						});
					}

				try { updateAnalysisGroupOptions(); } catch { }
				try { updateAnalysisArchOptions(); } catch { }
			}

			if (agents.length === 0 && jobPromises.length === 0) {
				try {
					__benchmarkLog(
						'ERROR',
						'Run',
						`No agents created. benchmarkMode=${benchmarkMode ? 'on' : 'off'} selectionOverride=${selectionOverride?.length || 0} checked=${Array.from(document.querySelectorAll('.arch-row input[type="checkbox"]')).filter(chk => !!chk?.checked).length}`
					);
				} catch { }
				alert("Select architectures first.");
				if (runBtn) runBtn.disabled = false;
				if (stopBtn) stopBtn.disabled = true;
				isRunning = false;
				return;
			}

			const pb = document.getElementById('progress-bar');
			if (pb) pb.innerText = "Running...";

				const runnableAgents = (agents || []).filter(a => {
					if (!a) return false;
					if (startedJobAgentIds.has(a.uniqueId)) return false;
					if (runOnlyUniqueIds && !runOnlyUniqueIds.has(__benchmarkTrim(a?.uniqueId || ''))) return false;
					const st = a?.state?.status || '';
					return !(st === 'Success' || st === 'Failed');
				});
			runnableAgents.forEach(a => { if (!a.jobQuery && query.trim()) a.jobQuery = query; });
			const agentPromises = runnableAgents.map(a => a.run(a.jobQuery || query));

			try {
				await Promise.all([...jobPromises, ...agentPromises]);
			} finally {
				if (pb) pb.innerText = "All Complete / Stopped";
				if (runBtn) runBtn.disabled = false;
				if (stopBtn) stopBtn.disabled = true;
				isRunning = false;
				try { __keepAlive.sync(false); } catch { }
				saveToLocalStorage();
				try { updateAnalysisPanel(); } catch { }
			}
		}

		function stopComparison() {
			try { __jobManager.setQueueRunning(false); } catch { }
			try { __benchmarkStudio.isRunning = false; } catch { }
			agents.forEach(a => {
				a.stopFlag = true;
				if (typeof a.abortInFlight === 'function') a.abortInFlight();
				try { __apiKeyLive.freezeAgeByUniqueId?.(a?.uniqueId); } catch { }
			});
		}

			function __spawnAgentsToMatchCurrentSelection() {
				// Non-destructive: only adds new agents (never deletes).
				const ds = __benchmarkStudio?.dataset;
				if (ds && Array.isArray(ds.problems) && ds.problems.length) {
					return __benchmarkSpawnMoreForLoadedDataset();
				}

			const queryRaw = (document.getElementById('userQuery')?.value || '').toString();
			const baseQuery = queryRaw.trim() ? queryRaw : __getMainPinnedQueryText();

			const selectedChecks = Array.from(document.querySelectorAll('.arch-row input[type="checkbox"]'))
				.filter(chk => !!chk?.checked);
			if (!selectedChecks.length) {
				alert('Select architectures first (checkboxes).');
				return { spawned: 0, changes: [] };
			}

			const desired = [];
			for (const chk of selectedChecks) {
				const archId = (chk?.id || '').toString().replace('chk-', '');
				if (!archId) continue;
				const def = ARCH_DEFINITIONS.find(d => d && d.id === archId);
				if (!def) continue;
				const count = __getEffectiveArchCount(archId);
				desired.push({ archId, count, def });
			}
			if (!desired.length) {
				alert('No valid architectures selected.');
				return { spawned: 0, changes: [] };
			}

			// Existing counts + max numeric instanceId per arch.
			const existingCount = new Map();
			const maxInstance = new Map();
			for (const a of (agents || [])) {
				if (!a) continue;
				const archId = (a?.config?.id || '').toString();
				if (!archId) continue;
				existingCount.set(archId, (existingCount.get(archId) || 0) + 1);
				const n = parseInt((a?.instanceId ?? '').toString(), 10);
				if (Number.isFinite(n) && n > 0) {
					maxInstance.set(archId, Math.max(maxInstance.get(archId) || 0, n));
				}
			}

			const changes = [];
			let totalNew = 0;
			for (const item of desired) {
				const have = existingCount.get(item.archId) || 0;
				const want = Math.max(0, parseInt(item.count || '0', 10) || 0);
				if (want <= have) continue;
				const add = want - have;
				totalNew += add;
				changes.push({ archId: item.archId, have, want, add });
			}

			if (totalNew <= 0) {
				alert('No new agents needed (already at or above the selected counts).');
				return { spawned: 0, changes: [] };
			}

			const preview = changes.slice(0, 10).map(c => `${c.archId}: ${c.have} ‚Üí ${c.want} (+${c.add})`).join('\n');
			const more = changes.length > 10 ? `\n‚Ä¶(+${changes.length - 10} more)` : '';
			if (!confirm(`Spawn ${totalNew} new agent(s) to match the current architecture counts?\n\n${preview}${more}`)) {
				return { spawned: 0, changes: [] };
			}

			let spawned = 0;
			for (const item of desired) {
				const archId = item.archId;
				const want = Math.max(0, parseInt(item.count || '0', 10) || 0);
				const have = existingCount.get(archId) || 0;
				if (want <= have) continue;
				const add = want - have;
				let next = (maxInstance.get(archId) || 0) + 1;
				for (let i = 0; i < add; i++) {
					createAgentUI(item.def, next + i);
					const agent = agents[agents.length - 1];
					if (agent && baseQuery && baseQuery.trim()) {
						agent.jobQuery = baseQuery.toString();
						try { if (!agent.state.initialQuery) agent.state.initialQuery = baseQuery.toString(); } catch { }
					}
					spawned += 1;
				}
				existingCount.set(archId, have + add);
				maxInstance.set(archId, next + add - 1);
			}

			try { updateAnalysisGroupOptions(); } catch { }
			try { updateAnalysisArchOptions(); } catch { }
			try { updateAnalysisPanel(); } catch { }
			try { saveToLocalStorage(); } catch { }

			alert(`Spawned ${spawned} new agent(s). Click Run / Resume to execute them.`);
			return { spawned, changes };
		}

		function createAgentUI(def, index, options = {}) {
			const opts = (options && typeof options === 'object') ? options : {};
			const __cardEsc = (value) => {
				const s = (value ?? '').toString();
				return s.replace(/[&<>"']/g, (ch) => {
					if (ch === '&') return '&amp;';
					if (ch === '<') return '&lt;';
					if (ch === '>') return '&gt;';
					if (ch === '"') return '&quot;';
					return '&#39;';
				});
			};
			const benchmarkMeta = (opts.benchmarkMeta && typeof opts.benchmarkMeta === 'object')
				? {
					problemIndex: __benchmarkClampInt(opts.benchmarkMeta.problemIndex, { min: 0, max: 1000000, fallback: -1 }),
					problemQid: __benchmarkTrim(opts.benchmarkMeta.problemQid || ''),
					runIndex: __benchmarkClampInt(opts.benchmarkMeta.runIndex, { min: 1, max: 1000000, fallback: 1 }),
				}
				: null;
			const agent = new AgentSystem(def, index);
			try { agent.sessionId = __sessionId; } catch { }
			try { if (__isJobWindow && __jobSessionId && !agent.jobSession) agent.jobSession = __jobSessionId.toString(); } catch { }
			try { agent.benchmarkMeta = benchmarkMeta ? __benchmarkSafeClone(benchmarkMeta) : null; } catch { }
			agents.push(agent);

			const card = document.createElement('div');
			card.className = 'architecture-result';
			card.id = `agent-card-${agent.uniqueId}`;
			try { card.dataset.uniqueId = agent.uniqueId; } catch { }
			try { card.dataset.archId = def.id; } catch { }
			const problemPalette = ['#4cc9f0', '#4895ef', '#4361ee', '#3a0ca3', '#7209b7', '#f72585', '#f97316', '#22c55e'];
			let problemBadge = '';
				if (benchmarkMeta && benchmarkMeta.problemIndex >= 0 && benchmarkMeta.problemQid) {
					const accent = problemPalette[benchmarkMeta.problemIndex % problemPalette.length];
					try { card.dataset.problemIndex = `${benchmarkMeta.problemIndex}`; } catch { }
					try { card.dataset.problemQid = benchmarkMeta.problemQid; } catch { }
					try { card.style.setProperty('--problem-accent', accent); } catch { }
					const safeQid = __cardEsc(benchmarkMeta.problemQid);
					const safeRun = __cardEsc(`${benchmarkMeta.runIndex}`);
					problemBadge = `<div class="problem-badge">Problem ${safeQid} ‚Ä¢ Run ${safeRun}</div>`;
				}

				const __groupStr = (def?.group || '').toString();
				const grpColor = __groupStr.includes('Solver') ? 'var(--solver-grp)' :
					__groupStr.includes('Red') ? 'var(--red-grp)' :
						__groupStr.includes('Intermediary') ? 'var(--mid-grp)' : 'var(--base)';

			const whiteboardBlock = def.whiteboard ? `
		        <div id="whiteboard-wrap-${agent.uniqueId}" style="margin-top:6px; display:flex; flex-direction:column; min-height:0;">
		            <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:2px;">
		                <label style="font-size:11px; font-weight:bold;">Whiteboard (live):</label>
		                <button id="whiteboard-toggle-${agent.uniqueId}" class="cs-btn"
		                    style="flex:0 0 auto; font-size:10px; padding:2px 6px;"
		                    onclick="toggleWhiteboard('${agent.uniqueId}')">Hide</button>
		            </div>
		            <textarea id="whiteboard-area-${agent.uniqueId}" readonly
		                style="width:100%; min-height:90px; max-height:220px; font-size:11px; font-family:monospace; background:#0b1228; color:var(--text-1); border:1px solid var(--border-dark); resize:vertical;"
		                placeholder="Whiteboard will appear here..."></textarea>
		        </div>
		    ` : '';

			card.innerHTML = `
			${problemBadge}
	        <div class="status-header" style="color:${grpColor}; border-color:${grpColor}">
	            <span>${def.id} - ${def.name} #${index}</span>
	            <span id="status-${agent.uniqueId}">Ready</span>
	        </div>
	        <div class="metrics">
	            <div class="metric-item"><span>Time:</span><span id="time-${agent.uniqueId}">0.0s</span></div>
	            <div class="metric-item"><span>Calls:</span><span id="calls-${agent.uniqueId}">0</span></div>
	            <div class="metric-item"><span>Tokens:</span><span id="tokens-${agent.uniqueId}">0</span></div>
	        </div>

	        <div class="agent-live-row" id="agent-live-${agent.uniqueId}">
	            <span class="lbl">Key:</span><span class="val" id="agent-key-${agent.uniqueId}">-</span>
	            <span class="lbl">estTok:</span><span class="val" id="agent-esttok-${agent.uniqueId}">-</span>
	            <span class="lbl">retry:</span><span class="val" id="agent-retry-${agent.uniqueId}">-</span>
	            <span class="lbl">wait:</span><span class="val" id="agent-wait-${agent.uniqueId}">-</span>
	        </div>
	        
		        <div style="background:var(--bg); border:1px solid var(--border-dark); padding:6px; margin-bottom:6px; font-size:11px; line-height:1.25; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
		            <span style="color:var(--text-3);">Last Action:</span> 
			            <span id="last-action-${agent.uniqueId}" style="font-weight:bold;">Idle</span>
			        </div>

			        <div style="flex-grow:1; min-height:0; display:flex; flex-direction:column;">
				            <label style="font-size:11px; font-weight:bold; margin-bottom:2px;">Final Solution:</label>
				            <textarea id="result-area-${agent.uniqueId}" readonly 
				                style="width:100%; flex:1 1 140px; min-height:0; font-size:11px; font-family:monospace; background:#0f172a; color:var(--text-1); border:1px solid var(--border-dark); resize:vertical;"
				                placeholder="Waiting for completion..."></textarea>
				            ${whiteboardBlock}
				        </div>

	        <div class="button-group agent-actions">
	             <button class="cs-btn" style="font-size:10px; padding:2px;" onclick="downloadAgentLog('${agent.uniqueId}')">Download Full Log</button>
	             <button class="cs-btn" style="font-size:10px; padding:2px;" onclick="deleteAgentRun('${agent.uniqueId}')">üóë Delete</button>
	             <button class="cs-btn" style="font-size:10px; padding:2px;" onclick="deleteArchitectureRuns('${def.id}')">üßπ Delete Arch</button>
	        </div>
        
	        <div class="retry-overlay" id="retry-${agent.uniqueId}">Retry...</div>
	    `;
			document.getElementById('resultsArea').appendChild(card);
		}

		function toggleWhiteboard(uid) {
			const ta = document.getElementById(`whiteboard-area-${uid}`);
			const btn = document.getElementById(`whiteboard-toggle-${uid}`);
			if (!ta || !btn) return;
			const isHidden = ta.style.display === 'none';
			ta.style.display = isHidden ? 'block' : 'none';
			btn.textContent = isHidden ? 'Hide' : 'Show';
		}

		function sanitizeForFilename(raw, maxLen = 60) {
			const s = (raw || '').toString();
			const cleaned = s
				.replace(/[\u0000-\u001f\u007f]/g, '')
				.replace(/[<>:"/\\\\|?*]+/g, '')
				.replace(/\\s+/g, ' ')
				.trim()
				.replace(/\\s+/g, '_')
				.replace(/_+/g, '_')
				.replace(/[. ]+$/g, '');
			return (cleaned || 'untitled').slice(0, maxLen);
		}

		function __resolveDownloadQuery(preferred) {
			const pref = (preferred || '').toString().trim();
			if (pref) return pref;
			const queries = [];
			(agents || []).forEach(a => {
				const q = (a?.jobQuery || '').toString().trim();
				if (q) queries.push(q);
			});
			if (queries.length) return queries[0];
			return (document.getElementById('userQuery')?.value || '').toString();
		}

		function getDownloadMeta(options = {}) {
			const opts = (options && typeof options === 'object') ? options : {};
			const model = sanitizeForFilename(document.getElementById('modelName')?.value || 'model', 40);
			const query = __resolveDownloadQuery(opts.query);
			const firstLine = (query.split(/\\r?\\n/).find(l => l.trim()) || query).trim();
			const queryPrefix = sanitizeForFilename(firstLine, 40);
			const archId = sanitizeForFilename(opts.archId || '', 24);
			const ts = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
			return { model, queryPrefix, archId, ts };
		}

		function buildDownloadSuffix(meta) {
			const parts = [meta?.ts, meta?.queryPrefix, meta?.archId, meta?.model].filter(Boolean);
			return parts.join('_');
		}

		function __abbrevArchId(rawId) {
			const cleaned = sanitizeForFilename(rawId || '', 60);
			if (!cleaned) return '';
			const parts = cleaned.split(/[_\-\s]+/g).filter(Boolean);
			const initials = parts.map(p => p[0]).join('');
			const base = (initials.length >= 2) ? initials : cleaned.slice(0, 6);
			return base.slice(0, 6);
		}

		function __buildArchListTag(archIds, maxLen = 60) {
			const seen = new Map();
			const out = [];
			const list = Array.isArray(archIds) ? archIds.filter(Boolean) : [];
			for (const id of list) {
				const base = __abbrevArchId(id);
				if (!base) continue;
				const n = (seen.get(base) || 0) + 1;
				seen.set(base, n);
				out.push(n === 1 ? base : `${base}${n}`);
			}
			if (!out.length) return 'unknown';
			let joined = out.join('-');
			if (joined.length <= maxLen) return joined;
			// Trim entries until it fits, then append +N.
			let kept = [];
			let remaining = out.length;
			for (const item of out) {
				const next = [...kept, item].join('-');
				const extra = remaining - 1;
				const suffix = extra > 0 ? `+${extra}` : '';
				if ((next + suffix).length > maxLen) break;
				kept.push(item);
				remaining -= 1;
			}
			if (!kept.length) return out[0].slice(0, maxLen);
			const extra = remaining > 0 ? `+${remaining}` : '';
			return (kept.join('-') + extra).slice(0, maxLen);
		}

		function __buildFinalSummaryFilename(meta, archIds) {
			const ts = meta?.ts || '';
			const model = meta?.model || '';
			const archTag = __buildArchListTag(archIds, 60);
			const prefix = 'Final_';
			const suffix = `${ts}_${model}.txt`;
			const maxTotal = 180;
			const fixedLen = prefix.length + archTag.length + 2 + suffix.length;
			const qMax = Math.max(10, Math.min(120, maxTotal - fixedLen));
			const q = sanitizeForFilename(meta?.queryPrefix || 'untitled', qMax);
			return `${prefix}${archTag}_${q}_${suffix}`;
		}

		function downloadAgentLog(uid) {
			const agent = agents.find(a => a.uniqueId === uid);
			if (!agent) return;
			const text = agent.state.logs.join('\n');
			const blob = new Blob([text], { type: "text/plain" });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			const meta = getDownloadMeta({ query: agent.jobQuery || '', archId: agent.config?.id || '' });
			const suffix = buildDownloadSuffix(meta);
			a.download = `log_${suffix}_${sanitizeForFilename(agent.uniqueId, 60)}.txt`;
			a.click();
		}

		function __getAgentCardElByUniqueId(uniqueId) {
			const uid = (uniqueId || '').toString();
			if (!uid) return null;
			const byId = document.getElementById(`agent-card-${uid}`);
			if (byId) return byId;
			const statusEl = document.getElementById(`status-${uid}`);
			return statusEl?.closest?.('.architecture-result') || null;
		}

		function __deleteAgentRunByUniqueId(uniqueId, { persist = true } = {}) {
			const uid = (uniqueId || '').toString();
			if (!uid) return false;

			const idx = (agents || []).findIndex(a => (a?.uniqueId || '').toString() === uid);
			const agent = idx >= 0 ? agents[idx] : null;
			const jobId = (agent?.jobId || '').toString();

			if (agent) {
				agent.stopFlag = true;
				if (typeof agent.abortInFlight === 'function') agent.abortInFlight();
				try { __apiKeyLive.freezeAgeByUniqueId?.(agent?.uniqueId); } catch { }
			}

			if (idx >= 0) {
				try { agents.splice(idx, 1); } catch { }
			}

			try {
				const st = __jobManager?.getState?.();
				const jobs = Array.isArray(st?.jobs) ? st.jobs : [];
				for (const job of jobs) {
					if (!job) continue;
					if (Array.isArray(job.agents)) job.agents = job.agents.filter(a => (a?.uniqueId || '').toString() !== uid);
					if (Array.isArray(job.agentUniqueIds)) job.agentUniqueIds = job.agentUniqueIds.filter(x => (x || '').toString() !== uid);
				}
			} catch { }

			try { __getAgentCardElByUniqueId(uid)?.remove?.(); } catch { }

			if (jobId) {
				try {
					const stillHasAny = (agents || []).some(a => (a?.jobId || '').toString() === jobId);
					if (!stillHasAny) document.getElementById(`job-header-${jobId}`)?.remove();
				} catch { }
			}

			if (persist) {
				try { saveToLocalStorage(); } catch { }
				try { updateAnalysisPanel(); } catch { }
			}
			return true;
		}

		function deleteAgentRun(uniqueId) {
			__deleteAgentRunByUniqueId(uniqueId, { persist: true });
		}

		function deleteArchitectureRuns(archId) {
			const id = (archId || '').toString();
			if (!id) return;

			const targets = (agents || []).filter(a => (a?.config?.id || '').toString() === id);
			if (!targets.length) {
				alert(`No runs found for architecture: ${id}`);
				return;
			}

			if (!confirm(`Delete architecture "${id}"?\n\nThis stops + removes ${targets.length} run(s) in this window.\nDeleted runs will not be restored.`)) return;

			const uids = targets.map(a => (a?.uniqueId || '').toString()).filter(Boolean);
			for (const uid of uids) __deleteAgentRunByUniqueId(uid, { persist: false });

			// Remove this architecture from any local queued jobs (so it won't respawn later).
			try {
				const st = __jobManager?.getState?.();
				const jobs = Array.isArray(st?.jobs) ? st.jobs : [];
				for (const job of jobs) {
					if (!job) continue;
					if (Array.isArray(job.selection)) {
						job.selection = job.selection.filter(s => (s?.archId || '').toString() !== id);
					}
				}
			} catch { }

			// Reflect in selector (affects autosave config snapshot).
			try {
				const chk = document.getElementById(`chk-${id}`);
				if (chk) chk.checked = false;
			} catch { }

			try { saveToLocalStorage(); } catch { }
			try { updateAnalysisPanel(); } catch { }
		}

		function deleteUnselectedArchitectureRuns() {
			const keep = new Set();
			try {
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
					if (!chk?.checked) return;
					const id = (chk.id || '').replace('chk-', '').toString();
					if (id) keep.add(id);
				});
			} catch { }

			if (!keep.size) {
				alert('Select architectures to KEEP (checkboxes) first.');
				return;
			}

			const list = Array.isArray(agents) ? agents : [];
			const toDelete = list.filter(a => {
				const id = (a?.config?.id || '').toString();
				return id && !keep.has(id);
			});
			if (!toDelete.length) {
				alert('No unselected runs found to delete.');
				return;
			}

			const byArch = new Map();
			for (const a of toDelete) {
				const id = (a?.config?.id || '').toString();
				if (!id) continue;
				byArch.set(id, (byArch.get(id) || 0) + 1);
			}

			const keepPreview = Array.from(keep).slice(0, 12).join(', ');
			const keepMore = keep.size > 12 ? ` ‚Ä¶(+${keep.size - 12})` : '';
			const delList = Array.from(byArch.entries())
				.sort((a, b) => (b[1] - a[1]))
				.slice(0, 12)
				.map(([id, n]) => `${id}√ó${n}`)
				.join(', ');
			const delMore = byArch.size > 12 ? ` ‚Ä¶(+${byArch.size - 12})` : '';
			const totalRuns = toDelete.length;

			if (!confirm(
				`Keep selected architectures only?\n\n` +
				`Keep (${keep.size}): ${keepPreview}${keepMore}\n` +
				`Delete (${byArch.size} arch / ${totalRuns} runs): ${delList}${delMore}\n\n` +
				`This stops + removes runs in this window.\nDeleted runs will not be restored.`
			)) return;

			for (const a of toDelete) {
				const uid = (a?.uniqueId || '').toString();
				if (!uid) continue;
				__deleteAgentRunByUniqueId(uid, { persist: false });
			}

			// Remove deleted architectures from any local queued jobs (so they won't respawn later).
			try {
				const st = __jobManager?.getState?.();
				const jobs = Array.isArray(st?.jobs) ? st.jobs : [];
				for (const job of jobs) {
					if (!job) continue;
					if (Array.isArray(job.selection)) {
						job.selection = job.selection.filter(s => keep.has((s?.archId || '').toString()));
					}
				}
			} catch { }

			try { saveToLocalStorage(); } catch { }
			try { updateAnalysisPanel(); } catch { }
		}

		function __getAttachedJobSessionsMetaForSave() {
			if (__isJobWindow) return [];
			try {
				const reg = __ensureJobWindowsRegistry();
				const list = Object.values(reg || {}).filter(Boolean).map((r) => ({
					id: (r?.id || '').toString(),
					windowName: (r?.windowName || '').toString(),
					url: (r?.url || '').toString(),
					status: (r?.status || '').toString(),
					title: (r?.title || '').toString(),
					createdAt: Number.isFinite(r?.createdAt) ? r.createdAt : null,
					startedAt: Number.isFinite(r?.startedAt) ? r.startedAt : null,
					closedAt: Number.isFinite(r?.closedAt) ? r.closedAt : null,
					lastSeenAt: Number.isFinite(r?.lastSeenAt) ? r.lastSeenAt : null,
				})).filter(x => x.id);
				list.sort((a, b) => ((b?.createdAt || 0) - (a?.createdAt || 0)));
				return list;
			} catch { return []; }
		}

		function __sanitizeJobSnapshotForBundle(snap, jobId) {
			if (!snap || typeof snap !== 'object') return null;
			const jobSessionId = (jobId || snap?.session?.jobSessionId || snap?.jobSessionId || snap?.jobSession || '').toString();
				const out = {
					session: { ...(snap.session || {}) },
					config: { ...(snap.config || {}) },
					jobs: snap.jobs || undefined,
					benchmark: __benchmarkSafeClone(snap.benchmark || null),
					agents: Array.isArray(snap.agents)
						? snap.agents.map(a => ({
							...(a || {}),
							state: __persistSanitizeAgentStateForSave(a?.state),
					}))
					: [],
			};
			out.session.jobSessionId = jobSessionId || (out.session.jobSessionId ? out.session.jobSessionId.toString() : null);
			out.session.isJobWindow = true;
			out.session.snapshotKey = `job:${out.session.jobSessionId || jobSessionId || ''}`;
			// Keep API stats, but cap them so bundled save files don't explode.
			try {
				const KEEP = 2000;
				if (snap.apiTelemetry && typeof snap.apiTelemetry === 'object') {
					const t = snap.apiTelemetry;
					const entries = Array.isArray(t.entries) ? t.entries : [];
					out.apiTelemetry = { ...t, entries: entries.slice(-KEEP), maxEntries: Math.min(KEEP, Number(t.maxEntries) || KEEP) };
				}
				if (snap.keySchedulerLog && typeof snap.keySchedulerLog === 'object') {
					const k = snap.keySchedulerLog;
					const entries = Array.isArray(k.entries) ? k.entries : [];
					out.keySchedulerLog = { ...k, entries: entries.slice(-KEEP), maxEntries: Math.min(KEEP, Number(k.maxEntries) || KEEP) };
				}
			} catch { }
			return out;
		}

		async function __collectJobBundleForExport(baseState) {
			if (!baseState || typeof baseState !== 'object') return null;
			if (baseState?.session?.isJobWindow) return null;
			const attached = Array.isArray(baseState?.session?.attachedJobSessions)
				? baseState.session.attachedJobSessions
				: __getAttachedJobSessionsMetaForSave();
			const ids = [...new Set(attached.map(x => (x?.id || '').toString()).filter(Boolean))];
			const bundled = [];
			for (const id of ids) {
				const snap = await __idbGetSnapshot(`job:${id}`);
				if (!snap) continue;
				const meta = attached.find(x => (x?.id || '').toString() === id) || { id };
				const slim = __sanitizeJobSnapshotForBundle(snap, id);
				if (!slim) continue;
				bundled.push({ id, meta, snapshot: slim });
			}
			return {
				version: 1,
				generatedAt: Date.now(),
				jobs: bundled,
			};
		}

			function __extractJobSessionIdFromSnapshot(obj) {
				try {
					const snap = (obj && typeof obj === 'object') ? obj : null;
					if (!snap) return null;

					const key = (
						snap?.session?.snapshotKey ||
						snap?.session?.dbSnapshotKey ||
						snap?.snapshotKey ||
						snap?.dbSnapshotKey ||
						''
					).toString().trim();
					if (key.startsWith('job:')) {
						const fromKey = key.slice(4).trim();
						if (fromKey && fromKey !== 'latest') return fromKey;
					}

					const id =
						snap?.session?.jobSessionId ??
						snap?.session?.id ??
						snap?.jobSessionId ??
						snap?.jobSession ??
						null;
					let s = (id ?? '').toString().trim();
					if (!s) return null;
					if (s === 'latest' || s === 'null' || s === 'undefined') return null;
					if (s.startsWith('job:')) s = s.slice(4).trim();
					if (!s) return null;
					if (s === 'latest' || s === 'null' || s === 'undefined') return null;
					return s;
				} catch {
					return null;
				}
			}

			function __sanitizeSnapshotForIdbImport(snapshot, jobId) {
				if (!snapshot || typeof snapshot !== 'object') return null;
				const out = { ...(snapshot || {}) };
				out.session = { ...(out.session || {}) };
				if (jobId) out.session.jobSessionId = jobId.toString();
			out.session.isJobWindow = true;
			if (out.session.jobSessionId) out.session.snapshotKey = `job:${out.session.jobSessionId}`;
			if (Array.isArray(out.agents)) {
				out.agents = out.agents.map(a => ({
					...(a || {}),
					state: __persistSanitizeAgentStateForSave(a?.state),
				}));
			}
			// Avoid recursive bundles inside job snapshots.
				try { delete out.jobBundle; } catch { }
				return out;
			}

			function __normalizeApiKeyListForCompare(raw) {
				try {
					const keys = __parseApiKeyList(__coerceApiKeyListTextareaValue(raw));
					return keys.map(k => (k || '').toString().trim()).filter(Boolean).join('\n');
				} catch {
					return __coerceApiKeyListTextareaValue(raw).trim();
				}
			}

				function __jobShouldDetachFromMainProxy(snapshot) {
					// Only matters when opening job windows from an existing window.
					try {
						const snap = (snapshot && typeof snapshot === 'object') ? snapshot : null;
						if (!snap) return false;
						// Local API (job-owned config) should still remain attached for save-bundling.
						if (snap?.session?.jobLocalApi === true) return false;
						const cur = getAppState();
						const mainCfg = (cur && typeof cur === 'object') ? (cur.config || {}) : {};
						const snapCfg = (snap && typeof snap === 'object') ? (snap.config || {}) : {};

					const sameStr = (a, b) => (a ?? '').toString().trim() === (b ?? '').toString().trim();
					const sameNum = (a, b) => {
						const na = Number.isFinite(a) ? Number(a) : parseInt(a ?? '0', 10) || 0;
						const nb = Number.isFinite(b) ? Number(b) : parseInt(b ?? '0', 10) || 0;
						return na === nb;
					};
					const sameBool = (a, b) => (!!a) === (!!b);

					if (!sameStr(mainCfg.apiUrl, snapCfg.apiUrl)) return true;
					if (!sameStr(mainCfg.apiProxyUrl, snapCfg.apiProxyUrl)) return true;
					if (!sameStr(mainCfg.model, snapCfg.model)) return true;
					if (!sameBool(mainCfg.bypassSystemRole, snapCfg.bypassSystemRole)) return true;
					if (!sameBool(mainCfg.enableRateLimit, snapCfg.enableRateLimit)) return true;
					if (!sameNum(mainCfg.rpmLimit, snapCfg.rpmLimit)) return true;
					if (!sameNum(mainCfg.tpmLimit, snapCfg.tpmLimit)) return true;
					if (!sameNum(mainCfg.maxInflightPerKey, snapCfg.maxInflightPerKey)) return true;

					const mainKeys = __normalizeApiKeyListForCompare(mainCfg.apiKeyList);
					const snapKeys = __normalizeApiKeyListForCompare(snapCfg.apiKeyList);
					if (mainKeys !== snapKeys) return true;

					return false;
				} catch {
					return true;
				}
			}

			async function __openAnySnapshotAsJobWindow(snapshot, meta = {}) {
				const snapObj = (snapshot && typeof snapshot === 'object') ? snapshot : null;
				if (!snapObj) return false;
				const detached = (typeof meta?.detached === 'boolean') ? meta.detached : __jobShouldDetachFromMainProxy(snapObj);
				const existingJobId = __extractJobSessionIdFromSnapshot(snapObj);
				if (existingJobId) {
					return await __openJobWindowFromSnapshot(snapObj, { ...(meta || {}), detached });
				}

				const jobId = `JSTATE_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
				const snap = __sanitizeSnapshotForIdbImport(snapObj, jobId);
				if (!snap) return false;
				const title = (meta?.title || __jobFirstLine(snap?.config?.query || snap?.config?.queryText || '') || jobId).toString();
				const windowName = (meta?.windowName || `_job_${jobId}`).toString();
				const regMeta = { ...(meta || {}), title, windowName, id: jobId };
				await __idbPutSnapshot(`job:${jobId}`, snap);
					__openJobWindow(jobId, regMeta, { autoRestore: true, detached });
					return true;
				}

				function __buildBlankBenchmarkSeedFromState(baseState) {
					try {
						const src = (baseState?.benchmark && typeof baseState.benchmark === 'object') ? baseState.benchmark : null;
						const ui = (src?.ui && typeof src.ui === 'object') ? src.ui : null;
						if (!ui) return null;
						const gradeMode = (__benchmarkTrim(ui?.gradeMode || src?.lastGradeMode || '') || 'answer_only').toString();
						const clampTok = (v) => __benchmarkClampInt(v, { min: 500, max: 200000, fallback: 12000 });
							return {
								dataset: null,
								lastRunRows: [],
								lastGradeMode: gradeMode,
								manualSpawnMode: false,
								pendingSpawnUniqueIds: [],
								logLines: [],
								runCheckpoint: null,
							parseCheckpoint: null,
							gradeCheckpoint: null,
							artifacts: null,
							apiCounters: null,
							ui: {
								sourceText: (ui?.sourceText || '').toString(),
								convertDelimiter: (ui?.convertDelimiter || '').toString(),
								answerKeyText: (ui?.answerKeyText || '').toString(),
								appliedToUi: false,
								runFilterEnabled: !!ui?.runFilterEnabled,
								problemFilterText: (ui?.problemFilterText || '').toString(),
								gradeMode,
								autoGrade: (typeof ui?.autoGrade === 'boolean') ? ui.autoGrade : true,
								parseApiKeyList: __coerceApiKeyListTextareaValue(ui?.parseApiKeyList || ''),
								parseApiUrl: (ui?.parseApiUrl || '').toString(),
								parseApiProxyUrl: (ui?.parseApiProxyUrl || '').toString(),
								parseModelName: (ui?.parseModelName || '').toString(),
								parseBypassSystemRole: !!ui?.parseBypassSystemRole,
								parseSplitTokens: clampTok(ui?.parseSplitTokens),
								parseMergeTokens: clampTok(ui?.parseMergeTokens),
								parseRpmLimit: __normalizeRateLimit(ui?.parseRpmLimit),
								parseTpmLimit: __normalizeRateLimit(ui?.parseTpmLimit),
								parseMaxInflightPerKey: __normalizeInflightLimit(ui?.parseMaxInflightPerKey),
								gradeApiKeyList: __coerceApiKeyListTextareaValue(ui?.gradeApiKeyList || ''),
								gradeApiUrl: (ui?.gradeApiUrl || '').toString(),
								gradeApiProxyUrl: (ui?.gradeApiProxyUrl || '').toString(),
								gradeModelName: (ui?.gradeModelName || '').toString(),
								gradeBypassSystemRole: !!ui?.gradeBypassSystemRole,
								gradeSplitTokens: clampTok(ui?.gradeSplitTokens),
								gradeMergeTokens: clampTok(ui?.gradeMergeTokens),
								gradeRpmLimit: __normalizeRateLimit(ui?.gradeRpmLimit),
								gradeTpmLimit: __normalizeRateLimit(ui?.gradeTpmLimit),
								gradeMaxInflightPerKey: __normalizeInflightLimit(ui?.gradeMaxInflightPerKey),
							},
						};
					} catch {
						return null;
					}
				}

				async function __openBlankBenchmarkJobWindow() {
					const jobId = `JBLANK_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
					const base = getAppState();
					const cfg = { ...(base?.config || {}) };
					try { cfg.query = ''; } catch { }
					try { cfg.queries = []; } catch { }
					const blankBenchmark = __buildBlankBenchmarkSeedFromState(base);
					const snap = __sanitizeSnapshotForIdbImport({
						session: {
							jobSessionId: jobId,
							isJobWindow: true,
							snapshotKey: `job:${jobId}`,
						},
						config: cfg,
						agents: [],
						benchmark: blankBenchmark,
					}, jobId);
				if (!snap) return false;
				const ok = await __idbPutSnapshot(`job:${jobId}`, snap);
				if (!ok) return false;
				const meta = { id: jobId, title: 'Blank Benchmark Job', windowName: `_job_${jobId}` };
				__openJobWindow(jobId, meta, { autoRestore: true, detached: false });
				return true;
			}

			function __buildJobWindowUrl(jobId, { autoRestore = true, detached = false } = {}) {
				const id = (jobId || '').toString();
				if (!id) return '';
				try {
					const u = new URL(window.location.href);
					u.searchParams.delete('jobLaunch');
					u.searchParams.set('jobSession', id);
					if (autoRestore) u.searchParams.set('autoRestore', '1');
					else u.searchParams.delete('autoRestore');
					if (detached) u.searchParams.set('detached', '1');
					else u.searchParams.delete('detached');
					return u.toString();
				} catch {
					const base = (window.location.href || '').split('#')[0];
					const [path, qs = ''] = base.split('?');
					const p = new URLSearchParams(qs);
					p.delete('jobLaunch');
					p.set('jobSession', id);
					if (autoRestore) p.set('autoRestore', '1');
					else p.delete('autoRestore');
					if (detached) p.set('detached', '1');
					else p.delete('detached');
					const q = p.toString();
					return q ? `${path}?${q}` : path;
				}
			}

		function __registerJobWindowForOpen(jobId, meta = {}, urlStr = '') {
			try {
				const reg = __ensureJobWindowsRegistry();
				const id = (jobId || '').toString();
				if (!id) return;
				try {
					const ban = __ensureJobWindowsBanList();
					if (ban && ban[id]) delete ban[id];
				} catch { }
				const now = Date.now();
				const prev = reg[id] || {};
				const windowName = (meta?.windowName || prev.windowName || `_job_${id}`).toString();
				const title = (meta?.title || prev.title || id).toString().slice(0, 140);
				reg[id] = {
					...prev,
					id,
					createdAt: Number.isFinite(prev.createdAt) ? prev.createdAt : (Number.isFinite(meta?.createdAt) ? meta.createdAt : now),
					startedAt: Number.isFinite(prev.startedAt) ? prev.startedAt : null,
					closedAt: null,
					status: 'opening', // opening | running | blocked | closed
					title,
					url: (urlStr || prev.url || '').toString(),
					windowName,
					lastSeenAt: Number.isFinite(prev.lastSeenAt) ? prev.lastSeenAt : null,
				};
			} catch { }
		}

			function __openJobWindow(jobId, meta = {}, { autoRestore = true, detached = false } = {}) {
				const id = (jobId || '').toString();
				if (!id) return null;
				const urlStr = __buildJobWindowUrl(id, { autoRestore, detached });
				const windowName = (meta?.windowName || `_job_${id}`).toString();
				try { __registerJobWindowForOpen(id, meta, urlStr); } catch { }
				try { window.__jobManager?.onInit?.(); } catch { }

			let w = null;
			try { w = window.open(urlStr, windowName); } catch { w = null; }
			if (!w) {
				try {
					const reg = __ensureJobWindowsRegistry();
					if (reg?.[id]) reg[id].status = 'blocked';
				} catch { }
				try { window.__jobManager?.onInit?.(); } catch { }
				return null;
			}
			try { __jobWindowRefs?.set?.(id, w); } catch { }
			try { __bindProxyHostForJobWindowRef(w); } catch { }
			try { w.focus(); } catch { }
			return w;
		}

			async function __openJobWindowFromSnapshot(snapshot, meta = {}) {
				const jobId = __extractJobSessionIdFromSnapshot(snapshot);
				if (!jobId) return false;
				const snap = __sanitizeSnapshotForIdbImport(snapshot, jobId);
				if (!snap) return false;
				const title = (meta?.title || __jobFirstLine(snap?.config?.query || snap?.config?.queryText || '') || jobId).toString();
				const windowName = (meta?.windowName || `_job_${jobId}`).toString();
				const detached = !!meta?.detached;
				const regMeta = { ...(meta || {}), title, windowName };
				const urlStr = __buildJobWindowUrl(jobId, { autoRestore: true, detached });

					// Restore/import flows often happen after async work (file reads/IDB), which can trip popup blockers.
					// Workaround: pre-open/reacquire first, then always force navigation to the target URL after IDB write.
					let preopened = null;
					try {
						const ref = __jobWindowRefs?.get?.(jobId);
						if (ref && !ref.closed) preopened = ref;
					} catch { }
					if (!preopened) {
						try {
							const maybe = window.open('', windowName);
							if (maybe && !maybe.closed) preopened = maybe;
						} catch { preopened = null; }
					}

					// Persist snapshot first so job window auto-restore can pick it up.
					await __idbPutSnapshot(`job:${jobId}`, snap);

					let w = null;
					try {
						const maybe = window.open(urlStr, windowName);
						if (maybe && !maybe.closed) w = maybe;
					} catch { w = null; }
					if (!w && preopened && !preopened.closed) {
						w = preopened;
						try { w.location.replace(urlStr); }
						catch {
							try { w.location.href = urlStr; }
							catch { w = null; }
						}
					}

					if (w && !w.closed) {
						try { __jobWindowRefs?.set?.(jobId, w); } catch { }
						try { __bindProxyHostForJobWindowRef(w); } catch { }
						try { w.focus(); } catch { }
						try { __registerJobWindowForOpen(jobId, regMeta, urlStr); } catch { }
						try { window.__jobManager?.onInit?.(); } catch { }
						return true;
					}

					// Final fallback: normal open path (may still be blocked).
					return !!__openJobWindow(jobId, regMeta, { autoRestore: true, detached });
				}

		async function __restoreJobSessionsAfterMainRestore(data) {
			if (__isJobWindow) return;
			if (!data || typeof data !== 'object') return;

			const memo = (() => {
				try {
					if (!window.__JOB_AUTO_REOPEN_BY_RESTORE_SIG_V1 || typeof window.__JOB_AUTO_REOPEN_BY_RESTORE_SIG_V1 !== 'object') {
						window.__JOB_AUTO_REOPEN_BY_RESTORE_SIG_V1 = Object.create(null);
					}
					const bySig = window.__JOB_AUTO_REOPEN_BY_RESTORE_SIG_V1;
					const sess = (data && typeof data === 'object') ? (data.session || {}) : {};
					const key = (sess?.snapshotKey || sess?.dbSnapshotKey || data?.snapshotKey || data?.dbSnapshotKey || '').toString();
					const savedAt = Number.isFinite(sess?.savedAt) ? sess.savedAt : (Number.isFinite(data?.savedAt) ? data.savedAt : null);
					const jobId = (sess?.jobSessionId || data?.jobSessionId || data?.jobSession || '').toString();
					const sig = `${key}|${jobId}|${savedAt || 0}`;
					if (!bySig[sig] || typeof bySig[sig] !== 'object') bySig[sig] = Object.create(null);
					return bySig[sig];
				} catch { return Object.create(null); }
			})();

			const opened = new Set();
			const bundleJobs = Array.isArray(data?.jobBundle?.jobs) ? data.jobBundle.jobs : [];
			for (const j of bundleJobs) {
				const id = (j?.id || '').toString();
				const snap = j?.snapshot;
				if (!id || !snap) continue;
				if (memo[id]) continue;
				memo[id] = Date.now();
				opened.add(id);
				await __openJobWindowFromSnapshot(snap, j?.meta || { id });
			}

			const attached = Array.isArray(data?.session?.attachedJobSessions) ? data.session.attachedJobSessions : [];
			// IMPORTANT: Don't auto-open attached job windows on restore.
			// - They may have been explicitly closed, but still exist in the last autosaved snapshot.
			// - Auto-opening can "resurrect" closed sessions after refresh.
			// Instead, rehydrate the Jobs list registry only; users can manually open windows.
			try {
				const reg = __ensureJobWindowsRegistry();
				const now = Date.now();
				for (const meta of attached) {
					const id = (meta?.id || '').toString();
					if (!id || opened.has(id)) continue;
					if (memo[id]) continue;
					memo[id] = Date.now();
					opened.add(id);

					const prev = (reg && reg[id] && typeof reg[id] === 'object') ? reg[id] : {};
					reg[id] = {
						...prev,
						...(meta || {}),
						id,
						windowName: (meta?.windowName || prev.windowName || `_job_${id}`).toString(),
						title: (meta?.title || prev.title || id).toString().slice(0, 140),
						url: (meta?.url || prev.url || '').toString(),
						status: (meta?.status || prev.status || 'closed').toString(),
						createdAt: Number.isFinite(meta?.createdAt) ? meta.createdAt : (Number.isFinite(prev.createdAt) ? prev.createdAt : now),
						startedAt: Number.isFinite(meta?.startedAt) ? meta.startedAt : (Number.isFinite(prev.startedAt) ? prev.startedAt : null),
						closedAt: Number.isFinite(meta?.closedAt) ? meta.closedAt : (Number.isFinite(prev.closedAt) ? prev.closedAt : null),
						lastSeenAt: Number.isFinite(meta?.lastSeenAt) ? meta.lastSeenAt : (Number.isFinite(prev.lastSeenAt) ? prev.lastSeenAt : null),
					};
				}
			} catch { }

			try { window.__jobManager?.onInit?.(); } catch { }
		}

		function getAppState() {
			return {
					session: {
						jobSessionId: __jobSessionId ? __jobSessionId.toString() : null,
						snapshotKey: (__dbSnapshotKey || '').toString(),
						isJobWindow: !!__isJobWindow,
						jobLocalApi: !!window.__JOB_LOCAL_API,
						attachedJobSessions: __getAttachedJobSessionsMetaForSave(),
						savedAt: Date.now(),
						url: (window.location && window.location.href) ? window.location.href.toString() : '',
					},
				config: {
					apiKeyList: document.getElementById('apiKeyList').value,
					apiUrl: document.getElementById('apiUrl').value,
					apiProxyUrl: document.getElementById('apiProxyUrl').value,
					model: document.getElementById('modelName').value,
					query: document.getElementById('userQuery').value,
					queries: __getProblemQueriesFromUi({ includeEmpty: false }),
					globalArchCount: parseInt(document.getElementById('globalArchCount')?.value || '1', 10) || 1,
					archSelection: (() => {
						try {
							const out = [];
							document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => {
								if (!chk?.checked) return;
								const id = (chk.id || '').replace('chk-', '');
								if (!id) return;
								if (!ARCH_DEFINITIONS.some(d => d?.id === id)) return;
								const cntEl = document.getElementById(`cnt-${id}`);
								const cntRaw = parseInt(cntEl?.value || '1', 10);
								const cnt = Number.isFinite(cntRaw) ? Math.min(999, Math.max(1, cntRaw)) : 1;
								out.push({ archId: id, cnt });
							});
							return out;
						} catch {
							return [];
						}
					})(),
					bypassSystemRole: !!document.getElementById('bypassSystemRole')?.checked,
					enableRateLimit: !!document.getElementById('enableRateLimit')?.checked,
					rpmLimit: parseInt(document.getElementById('rpmLimit')?.value || '30', 10),
					tpmLimit: parseInt(document.getElementById('tpmLimit')?.value || '15000', 10),
					maxInflightPerKey: parseInt(document.getElementById('maxInflightPerKey')?.value || '0', 10) || 0,
					expDiverseRt2Personas: !!document.getElementById('expDiverseRt2Personas')?.checked,
					mockMode: !!document.getElementById('mockModeChk')?.checked,
				},
				apiTelemetry: __apiTelemetry.exportState(),
				keySchedulerLog: __keySchedulerLog.exportState(),
				jobs: __jobManager.exportState(),
				benchmark: __benchmarkExportState(),
				agents: agents.map(a => ({
					config: a.config,
					instanceId: a.instanceId,
					state: __persistSanitizeAgentStateForSave(a.state),
					jobId: a.jobId || null,
					jobQuery: a.jobQuery || null,
					jobSession: a.jobSession || null,
					sessionId: a.sessionId || null,
					benchmarkMeta: __benchmarkSafeClone(a.benchmarkMeta || null),
				}))
			};
		}

			window.addEventListener('beforeunload', () => { saveToLocalStorage(); });

			const __STATE_CHUNK_EXPORT_MAX_BYTES = 95 * 1024 * 1024; // < 100 MiB (GitHub hard file limit)
			const __STATE_CHUNK_MANIFEST_FORMAT = 'branching_state_chunks_v1';
			const __STATE_CHUNK_MANIFEST_VERSION = 1;

			function __stateLooksLikeChunkPartFileName(name) {
				const n = (name || '').toString().trim();
				if (!n) return false;
				return /\.part\d+\.(?:bin|chunk|part)$/i.test(n);
			}

			function __stateIsChunkManifestObject(obj) {
				if (!obj || typeof obj !== 'object') return false;
				if ((obj?.format || '').toString() !== __STATE_CHUNK_MANIFEST_FORMAT) return false;
				return Array.isArray(obj?.parts) && obj.parts.length > 0;
			}

			function __stateDownloadBlob(blob, fileName) {
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = (fileName || 'download.bin').toString();
				a.click();
				try { setTimeout(() => URL.revokeObjectURL(url), 4000); } catch { }
			}

			async function exportState() {
				const state = getAppState();
				try {
					const bundle = await __collectJobBundleForExport(state);
					if (bundle && Array.isArray(bundle.jobs) && bundle.jobs.length) state.jobBundle = bundle;
				} catch { }
				const dataStr = JSON.stringify(state, null, 2);
				const meta = getDownloadMeta();
				const suffix = buildDownloadSuffix(meta);
				const baseName = `exp_backup_${suffix}`;
				const blob = new Blob([dataStr], { type: "application/json" });
				if (blob.size <= __STATE_CHUNK_EXPORT_MAX_BYTES) {
					__stateDownloadBlob(blob, `${baseName}.json`);
					return;
				}

				const partCount = Math.ceil(blob.size / __STATE_CHUNK_EXPORT_MAX_BYTES);
				const mb = (n) => (Number(n || 0) / (1024 * 1024)).toFixed(1);
				const splitExport = confirm(
					`State size is ${mb(blob.size)} MiB.\n\n` +
					`Split export into ${partCount} chunk file(s) + 1 manifest file under ~95 MiB each?\n` +
					`(Recommended for GitHub's 100MB per-file limit)\n\n` +
					`[OK] Split export\n` +
					`[Cancel] Single large .json export`
				);
				if (!splitExport) {
					__stateDownloadBlob(blob, `${baseName}.json`);
					try {
						__benchmarkSetProgress(`State export complete: single large file (${mb(blob.size)} MiB)`);
						__benchmarkLog('WARN', 'StateExport', `Exported single large state file (${mb(blob.size)} MiB).`);
					} catch { }
					return;
				}

				const pad = Math.max(3, `${partCount}`.length);
				const parts = [];
				for (let i = 0; i < partCount; i++) {
					const start = i * __STATE_CHUNK_EXPORT_MAX_BYTES;
					const end = Math.min(blob.size, start + __STATE_CHUNK_EXPORT_MAX_BYTES);
					const partBlob = blob.slice(start, end, 'application/octet-stream');
					const partName = `${baseName}.part${String(i + 1).padStart(pad, '0')}.bin`;
					parts.push({
						index: i + 1,
						file: partName,
						size: partBlob.size,
					});
					__stateDownloadBlob(partBlob, partName);
				}

				const manifest = {
					format: __STATE_CHUNK_MANIFEST_FORMAT,
					version: __STATE_CHUNK_MANIFEST_VERSION,
					generatedAt: Date.now(),
					sourceFile: `${baseName}.json`,
					totalBytes: blob.size,
					maxPartBytes: __STATE_CHUNK_EXPORT_MAX_BYTES,
					partCount,
					parts,
				};
				__stateDownloadBlob(
					new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' }),
					`${baseName}.parts.json`
				);
				try {
					__benchmarkSetProgress(`State export split complete: ${partCount} part(s) + manifest`);
					__benchmarkLog('INFO', 'StateExport', `Exported chunked state (${mb(blob.size)} MiB): ${partCount} parts + manifest`);
				} catch { }
			}

			async function importState(e) {
				const files = Array.from(e?.target?.files || []);
				try { e.target.value = ''; } catch { }
				if (!files.length) return;

				const __setProgress = (msg) => {
					try { __benchmarkSetProgress((msg || '').toString()); } catch { }
				};
				const __yieldToUi = () => new Promise((resolve) => {
					try { (window.requestAnimationFrame || window.setTimeout)(() => resolve(), 0); }
					catch { try { setTimeout(() => resolve(), 0); } catch { resolve(); } }
				});

					const __readText = (file) => new Promise((resolve) => {
						const reader = new FileReader();
						reader.onload = (ev) => resolve({ file, text: (ev?.target?.result || '').toString() });
						reader.onerror = () => resolve({ file, text: '' });
						reader.readAsText(file);
					});

					const __readArrayBuffer = (file) => new Promise((resolve) => {
						const reader = new FileReader();
						reader.onload = (ev) => resolve({ file, buffer: ev?.target?.result || null });
						reader.onerror = () => resolve({ file, buffer: null });
						reader.readAsArrayBuffer(file);
					});

				const __makeJsonParseWorker = () => {
					try {
						const code = [
							"self.onmessage = function(e) {",
							"  var d = (e && e.data) ? e.data : {};",
							"  var id = d.id;",
							"  var text = (d.text || '');",
							"  try {",
							"    var obj = JSON.parse(text);",
							"    self.postMessage({ id: id, ok: true, obj: obj });",
							"  } catch (err) {",
							"    self.postMessage({ id: id, ok: false, error: (err && err.message) ? err.message : String(err) });",
							"  }",
							"};"
						].join('\n');
						const blob = new Blob([code], { type: 'text/javascript' });
						const url = URL.createObjectURL(blob);
						const worker = new Worker(url);
						return { worker, url };
					} catch {
						return { worker: null, url: null };
					}
				};

				let __jsonWorker = null;
				let __jsonWorkerUrl = null;
				let __jsonWorkerNextId = 1;
				const __parseLargeJsonInWorker = (text) => new Promise((resolve) => {
					if (!__jsonWorker) {
						const built = __makeJsonParseWorker();
						__jsonWorker = built.worker;
						__jsonWorkerUrl = built.url;
					}
					if (!__jsonWorker) { resolve(null); return; }

					const reqId = __jsonWorkerNextId++;
					const onMessage = (ev) => {
						const d = ev?.data || {};
						if (d.id !== reqId) return;
						try { __jsonWorker.removeEventListener('message', onMessage); } catch { }
						resolve((d.ok && d.obj && typeof d.obj === 'object') ? d.obj : null);
					};
					const onError = () => {
						try { __jsonWorker.removeEventListener('message', onMessage); } catch { }
						try { __jsonWorker.removeEventListener('error', onError); } catch { }
						resolve(null);
					};
					__jsonWorker.addEventListener('message', onMessage);
					__jsonWorker.addEventListener('error', onError, { once: true });
					try {
						__jsonWorker.postMessage({ id: reqId, text });
					} catch {
						try { __jsonWorker.removeEventListener('message', onMessage); } catch { }
						try { __jsonWorker.removeEventListener('error', onError); } catch { }
						resolve(null);
					}
				});
					const __cleanupJsonWorker = () => {
						try { if (__jsonWorker) __jsonWorker.terminate(); } catch { }
						__jsonWorker = null;
						try { if (__jsonWorkerUrl) URL.revokeObjectURL(__jsonWorkerUrl); } catch { }
						__jsonWorkerUrl = null;
					};
					const __tryParseSnapshotText = async (text) => {
						const raw = (text || '').toString().replace(/^\uFEFF/, '');
						const head = raw.trimStart();
						const looksJson = head.startsWith('{') || head.startsWith('[');
						if (looksJson && raw.length >= 700000) {
							const parsedByWorker = await __parseLargeJsonInWorker(raw);
							if (parsedByWorker && typeof parsedByWorker === 'object') return parsedByWorker;
						}
						return __benchmarkTryParseJson(raw);
					};

					const __collectChunkedSnapshots = async (allFiles) => {
						const snapshots = [];
						const consumed = new Set();
						const issues = [];
						const fileByName = new Map();
						for (const file of allFiles) {
							const name = (file?.name || '').toString();
							if (!name) continue;
							if (!fileByName.has(name)) fileByName.set(name, file);
						}

						for (let idx = 0; idx < allFiles.length; idx++) {
							const manifestFile = allFiles[idx];
							if (!manifestFile || consumed.has(manifestFile)) continue;
							const manifestName = (manifestFile?.name || '').toString();
							if (!manifestName) continue;

							const maybeManifestByName = /\.parts\.json$/i.test(manifestName);
							const maybeManifestBySize = Number(manifestFile?.size || 0) > 0 && Number(manifestFile?.size || 0) <= (2 * 1024 * 1024);
							if (!maybeManifestByName && !maybeManifestBySize) continue;

							__setProgress(`Reading chunk manifest candidate ${idx + 1}/${allFiles.length}: ${manifestName}`);
							const { text } = await __readText(manifestFile);
							if (!text) continue;
							const manifestObj = __benchmarkTryParseJson(text);
							if (!__stateIsChunkManifestObject(manifestObj)) continue;

							const partsRaw = Array.isArray(manifestObj?.parts) ? manifestObj.parts : [];
							const parts = partsRaw
								.map((p, i) => ({
									index: __benchmarkClampInt(p?.index, { min: 1, max: 1000000, fallback: i + 1 }),
									file: __benchmarkTrim(p?.file || ''),
								}))
								.filter((p) => !!p.file)
								.sort((a, b) => a.index - b.index);
							if (!parts.length) {
								issues.push(`${manifestName} (manifest has no valid parts)`);
								consumed.add(manifestFile);
								continue;
							}

							const chunks = [];
							const partFiles = [];
							const missing = [];
							let totalBytes = 0;
							for (let i = 0; i < parts.length; i++) {
								const p = parts[i];
								const partFile = fileByName.get(p.file);
								if (!partFile) {
									missing.push(p.file);
									continue;
								}
								__setProgress(`Reading chunk ${i + 1}/${parts.length}: ${p.file}`);
								const { buffer } = await __readArrayBuffer(partFile);
								if (!(buffer instanceof ArrayBuffer)) {
									missing.push(p.file);
									continue;
								}
								const bytes = new Uint8Array(buffer);
								chunks.push(bytes);
								partFiles.push(partFile);
								totalBytes += bytes.byteLength;
								if ((i % 4) === 3) await __yieldToUi();
							}

							consumed.add(manifestFile);
							for (const pf of partFiles) consumed.add(pf);

							if (missing.length) {
								const preview = missing.slice(0, 6).join(', ');
								const more = missing.length > 6 ? ` ... +${missing.length - 6}` : '';
								issues.push(`${manifestName} (missing chunk file(s): ${preview}${more})`);
								continue;
							}
							if (!chunks.length || totalBytes <= 0) {
								issues.push(`${manifestName} (chunk files are empty)`);
								continue;
							}

							let merged = null;
							try {
								merged = new Uint8Array(totalBytes);
							} catch {
								issues.push(`${manifestName} (failed to allocate ${totalBytes} bytes for reassembly)`);
								continue;
							}
							let offset = 0;
							for (const bytes of chunks) {
								merged.set(bytes, offset);
								offset += bytes.byteLength;
							}

							let combinedText = '';
							try {
								combinedText = new TextDecoder('utf-8').decode(merged);
							} catch {
								issues.push(`${manifestName} (UTF-8 decode failed)`);
								continue;
							}

							__setProgress(`Parsing chunked snapshot: ${manifestName}`);
							const parsedData = await __tryParseSnapshotText(combinedText);
							if (parsedData && typeof parsedData === 'object') {
								const virtualName = __benchmarkTrim(
									manifestObj?.sourceFile ||
									manifestName.replace(/\.parts\.json$/i, '.json') ||
									manifestName
								) || manifestName;
								snapshots.push({ file: { name: virtualName }, data: parsedData });
							} else {
								issues.push(`${manifestName} (reassembled snapshot parse failed)`);
							}
							await __yieldToUi();
						}

						return { snapshots, consumed, issues };
					};

				__setProgress(`Importing ${files.length} file(s)...`);
				await __yieldToUi();

					const parsed = [];
					const failed = [];
					const consumedFiles = new Set();
					let orphanChunkPartCount = 0;
					try {
						const chunked = await __collectChunkedSnapshots(files);
						for (const item of (chunked?.snapshots || [])) parsed.push(item);
						for (const issue of (chunked?.issues || [])) failed.push(issue);
						for (const cf of (chunked?.consumed || [])) consumedFiles.add(cf);

						for (let idx = 0; idx < files.length; idx++) {
							const file = files[idx];
							if (!file || consumedFiles.has(file)) continue;
							const label = (file?.name || '(unknown)').toString();
							if (__stateLooksLikeChunkPartFileName(label)) {
								orphanChunkPartCount += 1;
								consumedFiles.add(file);
								continue;
							}
							__setProgress(`Reading ${idx + 1}/${files.length}: ${label}`);
							const { text } = await __readText(file);
							if (!text) { failed.push(label); continue; }

						__setProgress(`Parsing ${idx + 1}/${files.length}: ${label}`);
						const parsedData = await __tryParseSnapshotText(text);
						if (parsedData && typeof parsedData === 'object') parsed.push({ file, data: parsedData });
						else failed.push(label);

						await __yieldToUi();
					}
					} finally {
						__cleanupJsonWorker();
					}

					if (orphanChunkPartCount > 0) {
						failed.push(`Chunk part files selected without a matching manifest (.parts.json): ${orphanChunkPartCount}`);
					}
					if (failed.length) {
						alert(`Parse/Read error:\n- ${failed.join('\n- ')}`);
					}
					if (!parsed.length) {
						__setProgress('Import aborted (no valid files).');
						return;
					}

				__setProgress(`Restoring ${parsed.length} snapshot(s)...`);
				await __yieldToUi();

				const mains = [];
				const jobs = [];
				for (const p of parsed) {
					const sess = (p?.data && typeof p.data === 'object') ? (p.data.session || {}) : {};
					const key = (
						sess?.snapshotKey ||
						sess?.dbSnapshotKey ||
						p?.data?.snapshotKey ||
						p?.data?.dbSnapshotKey ||
						''
					).toString().trim();
					const isJobish = (sess?.isJobWindow === true) || key.startsWith('job:');
					const jobId = isJobish ? __extractJobSessionIdFromSnapshot(p.data) : null;
					if (jobId) jobs.push({ ...p, jobId });
					else mains.push(p);
				}

				const main = mains.length ? mains[0].data : null;
				const bundledIds = new Set(
					(main?.jobBundle?.jobs || []).map(j => (j?.id || '').toString()).filter(Boolean)
				);

				if (main) {
					try {
						__setProgress('Applying main snapshot...');
						await __yieldToUi();
						restoreFromObject(main);
					} catch (err) {
						__setProgress('Restore failed.');
						alert(`Restore failed: ${err?.message || err}`);
						return;
					}
				}

				let blockedOpenCount = 0;
				let openErrorCount = 0;
				for (let idx = 0; idx < jobs.length; idx++) {
					const j = jobs[idx];
					if (bundledIds.has(j.jobId)) continue;

					__setProgress(`Opening job window ${idx + 1}/${jobs.length}: ${j.jobId}`);
					await __yieldToUi();

					// If importing into the same job window, restore in-place.
					if (__isJobWindow && (__jobSessionId || '').toString() === j.jobId) {
						try { restoreFromObject(j.data); }
						catch (err) { alert(`Restore job failed: ${err?.message || err}`); }
						continue;
					}
					try {
						const ok = await __openJobWindowFromSnapshot(j.data, { title: `Imported: ${(j.file?.name || j.jobId).toString()}` });
						if (!ok) blockedOpenCount += 1;
					} catch (err) {
						openErrorCount += 1;
						console.warn('Open job from snapshot failed:', err);
					}
				}
				if (blockedOpenCount > 0) {
					alert(`Imported ${blockedOpenCount} job snapshot(s), but opening job windows was blocked by the browser.\n\nUse the Jobs panel -> Open (or allow popups).`);
				}
				if (openErrorCount > 0) {
					alert(`Imported job snapshot(s) but ${openErrorCount} window(s) failed to open due to an error.\n\nCheck the console for details.`);
				}

				__setProgress('Import complete.');
				try { setTimeout(() => __setProgress(''), 1200); } catch { }
			}

		function __mergeApiTelemetryState(incoming) {
			try {
				if (!incoming || typeof incoming !== 'object') return;
				const cur = __apiTelemetry.exportState();
				const curEntries = Array.isArray(cur?.entries) ? cur.entries : [];
				const inEntries = Array.isArray(incoming?.entries) ? incoming.entries : [];

				const sig = (e) => {
					const t0 = Number.isFinite(e?.t0) ? e.t0 : (Number.isFinite(e?.sentAt) ? e.sentAt : 0);
					const archId = (e?.archId || '').toString();
					const instanceId = (e?.instanceId || '').toString();
					const uniqueId = (e?.uniqueId || '').toString();
					const model = (e?.model || '').toString();
					const url = (e?.url || '').toString();
					const key = (e?.key || '').toString();
					const ok = (e?.ok == null) ? '' : String(!!e.ok);
					const http = (e?.httpStatus == null) ? '' : String(e.httpStatus);
					const err = (e?.errorType || '').toString();
					const val = (e?.validationPassed == null) ? '' : String(!!e.validationPassed);
					return `${t0}|${archId}|${instanceId}|${uniqueId}|${model}|${url}|${key}|${ok}|${http}|${err}|${val}`;
				};

				const seen = new Set();
				const merged = [];
				const push = (e) => {
					if (!e || typeof e !== 'object') return;
					const s = sig(e);
					if (seen.has(s)) return;
					seen.add(s);
					merged.push({ ...(e || {}) });
				};
				curEntries.forEach(push);
				inEntries.forEach(push);

				merged.sort((a, b) => ((a?.t0 || a?.sentAt || 0) - (b?.t0 || b?.sentAt || 0)));

				const max = Number.isFinite(cur?.maxEntries) ? cur.maxEntries : 20000;
				const trimmed = merged.length > max ? merged.slice(merged.length - max) : merged;
				const rebuilt = trimmed.map((e, i) => ({ ...e, id: i + 1, done: true }));

				__apiTelemetry.importState({
					version: cur?.version || 1,
					enabled: (typeof cur?.enabled === 'boolean') ? cur.enabled : true,
					maxEntries: max,
					nextId: rebuilt.length + 1,
					entries: rebuilt,
				});
			} catch { }
		}

		function __mergeKeySchedulerLogState(incoming) {
			try {
				if (!incoming || typeof incoming !== 'object') return;
				const cur = __keySchedulerLog.exportState();
				const curEntries = Array.isArray(cur?.entries) ? cur.entries : [];
				const inEntries = Array.isArray(incoming?.entries) ? incoming.entries : [];

				const sig = (e) => {
					const ts = Number.isFinite(e?.ts) ? e.ts : 0;
					const type = (e?.type || '').toString();
					const uniqueId = (e?.uniqueId || '').toString();
					const archId = (e?.archId || '').toString();
					const instanceId = (e?.instanceId || '').toString();
					const key = (e?.chosenKey || e?.bestKey || e?.key || '').toString();
					const est = (e?.estTokens == null) ? '' : String(e.estTokens);
					return `${ts}|${type}|${uniqueId}|${archId}|${instanceId}|${key}|${est}`;
				};

				const seen = new Set();
				const merged = [];
				const push = (e) => {
					if (!e || typeof e !== 'object') return;
					const s = sig(e);
					if (seen.has(s)) return;
					seen.add(s);
					merged.push({ ...(e || {}) });
				};
				curEntries.forEach(push);
				inEntries.forEach(push);

				merged.sort((a, b) => ((a?.ts || 0) - (b?.ts || 0)));

				const max = Number.isFinite(cur?.maxEntries) ? cur.maxEntries : 5000;
				const trimmed = merged.length > max ? merged.slice(merged.length - max) : merged;
				const rebuilt = trimmed.map((e, i) => ({ ...e, id: i + 1 }));

				__keySchedulerLog.importState({
					version: cur?.version || 1,
					enabled: (typeof cur?.enabled === 'boolean') ? cur.enabled : true,
					maxEntries: max,
					nextId: rebuilt.length + 1,
					entries: rebuilt,
				});
			} catch { }
		}

			function restoreFromObject(data, opts = {}) {
				const options = (opts && typeof opts === 'object') ? opts : {};
				try {
					// Job windows can opt out of main-window API proxy while still being bundled in saves.
					if (__isJobWindow) {
						const isLocalApi = !!(data?.session?.jobLocalApi);
						window.__JOB_LOCAL_API = isLocalApi;
						const det = document.getElementById('archApiSettingsDetails');
						const sum = det?.querySelector?.('summary');
						if (sum) {
							if (!sum.dataset.baseText) sum.dataset.baseText = (sum.textContent || '').toString();
							const base = (sum.dataset.baseText || '').toString().trim() || 'Architecture API Settings';
							sum.textContent = isLocalApi ? `${base} (local API)` : base;
						}
					}
				} catch { }
				const shouldOverwriteConfig = (typeof options.overwriteConfig === 'boolean')
					? options.overwriteConfig
					: (options.confirmOverwriteConfig === false
						? false
					: confirm(
						"Overwrite current configuration (API Key, URL) with file data?\n\n" +
						"[OK] = Overwrite (Restore exact state)\n" +
						"[Cancel] = Keep current input (Use new keys/settings)"
					)
				);

				if (shouldOverwriteConfig) {
				if (data?.config?.apiKey && !data?.config?.apiKeyList) {
					document.getElementById('apiKeyList').value = __coerceApiKeyListTextareaValue(data.config.apiKey);
				} else {
					document.getElementById('apiKeyList').value = __coerceApiKeyListTextareaValue(data?.config?.apiKeyList || "");
				}
				document.getElementById('apiUrl').value = data?.config?.apiUrl || '';
				document.getElementById('apiProxyUrl').value = data?.config?.apiProxyUrl || '';
				document.getElementById('modelName').value = data?.config?.model || '';
				try {
					const qs = Array.isArray(data?.config?.queries) ? data.config.queries : null;
					if (qs && qs.length) __setProblemQueriesInUi(qs);
					else __setProblemQueriesInUi([(data?.config?.query || '').toString()]);
				} catch {
					document.getElementById('userQuery').value = data?.config?.query || '';
				}
				if (Number.isFinite(data?.config?.globalArchCount)) document.getElementById('globalArchCount').value = `${data.config.globalArchCount}`;

				if (typeof data?.config?.bypassSystemRole === 'boolean') document.getElementById('bypassSystemRole').checked = data.config.bypassSystemRole;
				if (typeof data?.config?.enableRateLimit === 'boolean') document.getElementById('enableRateLimit').checked = data.config.enableRateLimit;
				if (Number.isFinite(data?.config?.rpmLimit)) document.getElementById('rpmLimit').value = data.config.rpmLimit;
				if (Number.isFinite(data?.config?.tpmLimit)) document.getElementById('tpmLimit').value = data.config.tpmLimit;
				if (Number.isFinite(data?.config?.maxInflightPerKey) && data.config.maxInflightPerKey > 0) document.getElementById('maxInflightPerKey').value = `${data.config.maxInflightPerKey}`;
				else document.getElementById('maxInflightPerKey').value = '';
					if (typeof data?.config?.expDiverseRt2Personas === 'boolean') document.getElementById('expDiverseRt2Personas').checked = data.config.expDiverseRt2Personas;
					if (typeof data?.config?.mockMode === 'boolean') document.getElementById('mockModeChk').checked = data.config.mockMode;
				}
				try {
					// If this job is still attached to the main-window proxy, avoid blank API fields.
					// We only fill missing values here; local overrides remain untouched.
					__syncProxyApiInputsFromMain({ force: false, includeKeys: false });
				} catch { }

				// Restore architecture checkbox selection + per-arch counts (so you can see what was chosen at a glance).
			try {
				const applySelection = (selection) => {
					try { document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => { chk.checked = false; }); } catch { }
					if (!Array.isArray(selection) || !selection.length) return;
					for (const s of selection) {
						const id = (s?.archId || s?.id || '').toString();
						if (!id) continue;
						const chk = document.getElementById(`chk-${id}`);
						const cntEl = document.getElementById(`cnt-${id}`);
						if (chk) chk.checked = true;
						const cntRaw = parseInt(s?.cnt ?? s?.count ?? '1', 10);
						const cnt = Number.isFinite(cntRaw) ? Math.min(999, Math.max(1, cntRaw)) : 1;
						if (cntEl) cntEl.value = `${cnt}`;
					}
				};

				const selectionFromConfig = Array.isArray(data?.config?.archSelection) ? data.config.archSelection : [];
				if (selectionFromConfig.length) {
					applySelection(selectionFromConfig);
				} else {
					// Back-compat: infer selection from agents in old snapshots.
					const counts = new Map();
					for (const a of (Array.isArray(data?.agents) ? data.agents : [])) {
						const id = (a?.config?.id || '').toString();
						if (!id) continue;
						counts.set(id, (counts.get(id) || 0) + 1);
					}
					const inferred = [];
					for (const [id, n] of counts.entries()) {
						const global = Number.isFinite(data?.config?.globalArchCount) ? data.config.globalArchCount : null;
						const shouldUseGlobal = (Number.isFinite(global) && global > 1 && n === global);
						const cnt = shouldUseGlobal ? 1 : Math.min(999, Math.max(1, n));
						inferred.push({ archId: id, cnt });
					}
					applySelection(inferred);
				}
			} catch { }

			apiKeyManager.keys = [];
			apiKeyManager.idx = 0;

				clearAll(false);
				try { if (data?.jobs) __jobManager.importState(data.jobs); } catch (e) { console.warn("Jobs restore failed:", e); }
				try { if (data?.apiTelemetry) __mergeApiTelemetryState(data.apiTelemetry); } catch (e) { console.warn("API Telemetry restore failed:", e); }
				try { if (data?.keySchedulerLog) __mergeKeySchedulerLogState(data.keySchedulerLog); } catch (e) { console.warn("Key Scheduler log restore failed:", e); }
				const agentList = Array.isArray(data?.agents) ? data.agents : [];
				for (const aData of agentList) {
					try {
						const cfgIn = (aData && typeof aData === 'object') ? aData.config : null;
						const archId = (cfgIn?.id || '').toString().trim();
						if (!archId) {
							console.warn('Skipping agent restore (missing config.id):', aData);
							continue;
						}
						const baseDef = ARCH_DEFINITIONS.find(d => (d?.id || '').toString() === archId) || null;
						const cfg = baseDef ? { ...(baseDef || {}), ...(cfgIn || {}), id: archId } : { ...(cfgIn || {}), id: archId };
						try { cfg.group = (cfg.group || baseDef?.group || '').toString(); } catch { }
						try { cfg.name = (cfg.name || baseDef?.name || archId).toString(); } catch { }

						const instRaw = aData?.instanceId;
						const instanceId = (() => {
							if (typeof instRaw === 'number' && Number.isFinite(instRaw)) return instRaw;
							const txt = (instRaw ?? '').toString().trim();
							return txt || 1;
						})();

						createAgentUI(cfg, instanceId, {
							benchmarkMeta: (aData?.benchmarkMeta && typeof aData.benchmarkMeta === 'object') ? aData.benchmarkMeta : null,
						});

						const a = agents[agents.length - 1];
						if (!a) continue;
						try {
							if (aData.jobId != null) a.jobId = aData.jobId;
							if (aData.jobQuery != null) {
								a.jobQuery = aData.jobQuery;
							} else if (!(aData?.state?.initialQuery) && data?.config?.query) {
								a.jobQuery = (data.config.query || '').toString();
							}
							if (aData.jobSession != null) a.jobSession = aData.jobSession;
							if (aData.sessionId != null) a.sessionId = aData.sessionId;
							if (aData.benchmarkMeta && typeof aData.benchmarkMeta === 'object') {
								a.benchmarkMeta = __benchmarkSafeClone(aData.benchmarkMeta);
							}
						} catch { }

						const stRaw = (aData?.state && typeof aData.state === 'object') ? aData.state : {};
						try { a.restore(__persistSanitizeAgentStateForSave(stRaw)); } catch (e) { console.warn('Agent state restore failed:', e); }
					} catch (e) {
						console.warn('Agent restore failed:', e, aData);
					}
				}
				try { __jobManager.attachAgents(); } catch { }
				try { __benchmarkRestoreState(data?.benchmark); } catch (e) { console.warn("Benchmark restore failed:", e); }

			updateAnalysisArchOptions();
			updateAnalysisPanel();

			try { Promise.resolve(__restoreJobSessionsAfterMainRestore(data)).catch(() => { }); } catch { }
			if (!options.silent) {
				let msg = "State restored. Click 'Run/Resume' to continue.";
				try {
					const agentCount = Array.isArray(data?.agents) ? data.agents.length : 0;
					const bundleCount = Array.isArray(data?.jobBundle?.jobs) ? data.jobBundle.jobs.length : 0;
					const attachedCount = Array.isArray(data?.session?.attachedJobSessions) ? data.session.attachedJobSessions.length : 0;
					const jobCount = Math.max(bundleCount, attachedCount);
					if (agentCount === 0 && jobCount > 0) {
						msg =
							`State restored.\n\n` +
							`This save contains ${jobCount} job session(s), but this window has 0 agents.\n` +
							`Use the Jobs panel ‚Üí Open to view restored job sessions.`;
					}
				} catch { }
				alert(msg);
			}
		}

		async function __clearAllJobWindowsAndSnapshotsForMainClear({ closeWindows = true, deleteSnapshots = true } = {}) {
			if (__isJobWindow) return;
			const reg = (() => { try { return __ensureJobWindowsRegistry(); } catch { return null; } })();
			const ban = (() => { try { return __ensureJobWindowsBanList(); } catch { return null; } })();
			const list = (() => {
				try {
					if (!reg || typeof reg !== 'object') return [];
					return Object.values(reg).filter(Boolean);
				} catch { return []; }
			})();
			const now = Date.now();
			const ids = [...new Set(list.map(r => (r?.id || '').toString()).filter(Boolean))];

			for (const id of ids) {
				const meta = (reg && reg[id]) ? reg[id] : {};
				const windowName = (meta?.windowName || `_job_${id}`).toString();
				const status = (meta?.status || '').toString();
				const lastSeenAt = Number.isFinite(meta?.lastSeenAt) ? meta.lastSeenAt : null;

				try { if (ban) ban[id] = true; } catch { }

				if (closeWindows) {
					let w = null;
					try {
						const r0 = __jobWindowRefs.get(id);
						if (r0 && !r0.closed) w = r0;
					} catch { }

					// If we lost refs (main window reload), re-acquire by windowName only if the job was seen recently.
					if (!w && lastSeenAt && (now - lastSeenAt < 15000) && status !== 'closed') {
						try {
							const maybe = window.open('', windowName);
							if (maybe && !maybe.closed) w = maybe;
						} catch { }
					}

					if (w && !w.closed) {
						try { __jobWindowRefs.set(id, w); } catch { }
						try { w.postMessage({ type: 'BRANCHING_V12_JOB_CONTROL', cmd: 'clear_and_close' }, '*'); } catch { }
						try { w.close(); } catch { }
					}
				}

				if (deleteSnapshots) {
					try { await __idbDeleteSnapshot(`job:${id}`); } catch { }
				}

				try { localStorage.removeItem(`${__JOB_PAYLOAD_LS_PREFIX}${id}`); } catch { }
				try { if (reg && reg[id]) delete reg[id]; } catch { }
				try { __jobWindowRefs.delete(id); } catch { }
			}

			if (deleteSnapshots) {
				// Also wipe any leftover job:* snapshots (stale entries).
				try { await __idbDeleteSnapshotsByPrefix('job:'); } catch { }
			}

			// Clear any undelivered payloads (defensive; avoids accidental restore/queue).
			try {
				if (__shared?.jobLaunchPayloads && typeof __shared.jobLaunchPayloads === 'object') {
					for (const k of Object.keys(__shared.jobLaunchPayloads)) delete __shared.jobLaunchPayloads[k];
				}
			} catch { }

			try { if (__shared && typeof __shared === 'object') __shared.jobWindows = {}; } catch { }
			try { if (__shared && typeof __shared === 'object') __shared.jobWindowsBan = ban || {}; } catch { }
			try { window.__JOB_AUTO_REOPEN_BY_RESTORE_SIG_V1 = Object.create(null); } catch { }
		}

		function __resetArchitectureSelectionUiForClear() {
			try {
				const globalCountEl = document.getElementById('globalArchCount');
				if (globalCountEl) globalCountEl.value = '1';
			} catch { }
			try {
				document.querySelectorAll('.arch-row input[type="checkbox"]').forEach(chk => { chk.checked = false; });
			} catch { }
			try {
				document.querySelectorAll('.arch-row input[id^="cnt-"]').forEach(inp => { inp.value = '1'; });
			} catch { }
		}

			function __benchmarkResetStudioForClear({ preserveApiConfig = true } = {}) {
				__benchmarkSetDataset(null);
				__benchmarkStudio.lastRunRows = [];
				__benchmarkStudio.lastGradeMode = 'answer_only';
				__benchmarkStudio.manualSpawnMode = false;
				__benchmarkStudio.pendingSpawnUniqueIds = [];
				__benchmarkStudio.isRunning = false;
			__benchmarkSetTaskRunning('parse', false);
			__benchmarkSetTaskRunning('grade', false);
			__benchmarkSetTaskStopRequested('parse', false);
			__benchmarkSetTaskStopRequested('grade', false);
			__benchmarkSetTaskCheckpoint('parse', null);
			__benchmarkSetTaskCheckpoint('grade', null);
			__benchmarkStudio.taskRateState = { parse: new Map(), grade: new Map() };
			__benchmarkStudio.taskInflightState = { parse: new Map(), grade: new Map() };
			__benchmarkStudio.apiKeyCursor = { parse: 0, grade: 0 };
			__benchmarkStudio.appliedToUi = false;
			__benchmarkStudio.runCheckpoint = null;
			__benchmarkStudio.artifacts = __benchmarkCreateArtifactsState();
			__benchmarkStudio.apiCounters = __benchmarkCreateApiCountersState();

			try {
				const sourceTextEl = document.getElementById('benchmarkSourceText');
				if (sourceTextEl) sourceTextEl.value = '';
			} catch { }
			try {
				const gradeModeEl = document.getElementById('benchmarkGradeMode');
				if (gradeModeEl) gradeModeEl.value = 'answer_only';
			} catch { }
			try {
				const autoGradeEl = document.getElementById('benchmarkAutoGrade');
				if (autoGradeEl) autoGradeEl.checked = true;
			} catch { }
			try {
				const parseSplitEl = document.getElementById('benchmarkParseSplitTokens');
				if (parseSplitEl) parseSplitEl.value = '12000';
			} catch { }
			try {
				const parseMergeEl = document.getElementById('benchmarkParseMergeTokens');
				if (parseMergeEl) parseMergeEl.value = '12000';
			} catch { }
			try {
				const gradeSplitEl = document.getElementById('benchmarkGradeSplitTokens');
				if (gradeSplitEl) gradeSplitEl.value = '12000';
			} catch { }
			try {
				const gradeMergeEl = document.getElementById('benchmarkGradeMergeTokens');
				if (gradeMergeEl) gradeMergeEl.value = '12000';
			} catch { }
			try {
				const el = document.getElementById('benchmarkParseRpmLimit');
				if (el) el.value = '30';
			} catch { }
			try {
				const el = document.getElementById('benchmarkParseTpmLimit');
				if (el) el.value = '15000';
			} catch { }
			try {
				const el = document.getElementById('benchmarkParseMaxInflightPerKey');
				if (el) el.value = '';
			} catch { }
			try {
				const el = document.getElementById('benchmarkGradeRpmLimit');
				if (el) el.value = '30';
			} catch { }
			try {
				const el = document.getElementById('benchmarkGradeTpmLimit');
				if (el) el.value = '15000';
			} catch { }
			try {
				const el = document.getElementById('benchmarkGradeMaxInflightPerKey');
				if (el) el.value = '';
			} catch { }

			if (!preserveApiConfig) {
				try { const el = document.getElementById('benchmarkParseApiKeyList'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkParseApiUrl'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkParseApiProxyUrl'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkParseModelName'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkParseBypassSystemRole'); if (el) el.checked = false; } catch { }
				try { const el = document.getElementById('benchmarkGradeApiKeyList'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkGradeApiUrl'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkGradeApiProxyUrl'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkGradeModelName'); if (el) el.value = ''; } catch { }
				try { const el = document.getElementById('benchmarkGradeBypassSystemRole'); if (el) el.checked = false; } catch { }
			}

			__benchmarkRenderGradeOutput([], 'answer_only');
			__benchmarkRenderLog();
			__benchmarkRenderRawIoViewer(true);
			__benchmarkRenderApiCounters();
			__benchmarkSetProgress('No benchmark loaded');
		}

		async function clearAllFromUi() {
			const msg = __isJobWindow
				? 'Clear this job window? (API stats are preserved.)'
				: 'Clear current session?\n\nThis will:\n- Stop running agents\n- Clear all results in this window\n- Close job windows and delete their autosave snapshots\n\n(API stats are preserved.)';
			if (!confirm(msg)) return;

			const runBtn = document.getElementById('runBtn');
			const clearBtn = document.getElementById('clearBtn');
			try { if (runBtn) runBtn.disabled = true; } catch { }
			try { if (clearBtn) clearBtn.disabled = true; } catch { }

			try {
				try { stopComparison(); } catch { }
				clearAll(true);
				__setProblemQueriesInUi(['']);
				__resetArchitectureSelectionUiForClear();
				try { __shared.mainPinnedQuery = ''; } catch { }
				try { __benchmarkResetStudioForClear({ preserveApiConfig: true }); } catch { }
				try { updateAnalysisGroupOptions(); } catch { }
				try { updateAnalysisArchOptions(); } catch { }

				if (!__isJobWindow) {
					try { await __clearAllJobWindowsAndSnapshotsForMainClear({ closeWindows: true, deleteSnapshots: true }); } catch { }
				}

				// Persist cleared state so stale architecture selections and jobs do not revive.
				try { await performSave(); } catch { }
				try { __jobManager.onInit(); } catch { }
				try { updateAnalysisPanel(); } catch { }
				try { __logsRenderPanel({ refreshOptions: true }); } catch { }
			} finally {
				try { if (clearBtn) clearBtn.disabled = false; } catch { }
				try { if (runBtn) runBtn.disabled = false; } catch { }
			}
		}

		function clearAll(resetGlobal = true) {
			try { __jobManager.clear(); } catch { }
			try {
				if (!__isJobWindow) {
					const reg = __ensureJobWindowsRegistry();
					if (reg && typeof reg === 'object') {
						for (const k of Object.keys(reg)) delete reg[k];
					}
					const ban = __ensureJobWindowsBanList();
					if (ban && typeof ban === 'object') {
						for (const k of Object.keys(ban)) delete ban[k];
					}
					window.__JOB_AUTO_REOPEN_BY_RESTORE_SIG_V1 = Object.create(null);
				}
			} catch { }
			agents = [];
			isRunning = false;
			if (resetGlobal) GLOBAL_EMERGENCY_STOP = false;
			const resArea = document.getElementById('resultsArea');
			if (resArea) resArea.innerHTML = '';
			setupKeyMonitorCard();
		}

		function showFinalSummary() {
			let fullText = "=== FINAL RESULTS SUMMARY ===\n\n";
			let count = 0;
			const archIds = [];

			const sessionFilter = (__isJobWindow && __jobSessionId) ? __jobSessionId.toString() : null;
			const list = sessionFilter
				? (agents || []).filter(a => ((a?.jobSession || a?.sessionId || '') + '') === sessionFilter)
				: (agents || []);

			list.forEach(agent => {
				if (agent.state.finalResult) {
					if (agent?.config?.id) archIds.push(agent.config.id.toString());
					fullText += `--------------------------------------------------\n`;
					fullText += `ARCHITECTURE: ${agent.config.id} (${agent.config.name}) #${agent.instanceId}\n`;
					fullText += `METRICS: ${agent.state.metrics.calls} Calls, ${agent.state.metrics.tokens} Tokens\n`;
					fullText += `--------------------------------------------------\n`;
					fullText += `${agent.state.finalResult}\n\n\n`;
					count++;
				}
			});

			if (count === 0) { alert("No final results available yet."); return; }

			const blob = new Blob([fullText], { type: "text/plain;charset=utf-8" });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			const meta = getDownloadMeta();
			a.download = __buildFinalSummaryFilename(meta, archIds);
			a.click();
		}

		initUI();
	</script>
</body>

</html>
